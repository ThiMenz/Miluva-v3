public class SNAPSHOT_V01_00_000 : IBoardManager  { public int TEXEL_PARAMS { get; } = 778; private const int BESTMOVE_SORT_VAL = -2_000_000_000; private const int CAPTURE_SORT_VAL = -1_000_000_000; private const int KILLERMOVE_SORT_VAL = -1000; private readonly int[,] MVVLVA_TABLE = new int[7, 7] { { 0, 0, 0, 0, 0, 0, 0 }, { 0, 1500, 1400, 1300, 1200, 1100, 1000 }, { 0, 3500, 3400, 3300, 3200, 3100, 3000 }, { 0, 4500, 4400, 4300, 4200, 4100, 4000 }, { 0, 5500, 5400, 5300, 5200, 5100, 5000 }, { 0, 9500, 9400, 9300, 9200, 9100, 9000 }, { 0, 0, 0, 0, 0, 0, 0 }}; private int BOARD_MANAGER_ID = -1; private bool debugSearchDepthResults = false; private bool debugSortResults = false; private RookMovement rookMovement; private BishopMovement bishopMovement; private QueenMovement queenMovement; private KnightMovement knightMovement; private KingMovement kingMovement; private WhitePawnMovement whitePawnMovement; private BlackPawnMovement blackPawnMovement; private Rays rays; public List<Move> moveOptionList { get; set; } private int[] pieceTypeArray = new int[64]; public ulong whitePieceBitboard, blackPieceBitboard, allPieceBitboard; private ulong zobristKey; private int whiteKingSquare, blackKingSquare, enPassantSquare = 65, happenedHalfMoves = 0, fiftyMoveRuleCounter = 0; private bool whiteCastleRightKingSide, whiteCastleRightQueenSide, blackCastleRightKingSide, blackCastleRightQueenSide; private bool isWhiteToMove; private const ulong WHITE_KING_ROCHADE = 96, WHITE_QUEEN_ROCHADE = 14, BLACK_KING_ROCHADE = 6917529027641081856, BLACK_QUEEN_ROCHADE = 1008806316530991104, WHITE_QUEEN_ATTK_ROCHADE = 12, BLACK_QUEEN_ATTK_ROCHADE = 864691128455135232; private readonly Move mWHITE_KING_ROCHADE = new Move(4, 6, 7, 5), mWHITE_QUEEN_ROCHADE = new Move(4, 2, 0, 3), mBLACK_KING_ROCHADE = new Move(60, 62, 63, 61), mBLACK_QUEEN_ROCHADE = new Move(60, 58, 56, 59); private ulong[] knightSquareBitboards = new ulong[64]; private ulong[] whitePawnAttackSquareBitboards = new ulong[64]; private ulong[] blackPawnAttackSquareBitboards = new ulong[64]; private ulong[] kingSquareBitboards = new ulong[64]; private bool[,] pieceTypeAbilities = new bool[7, 3] { { false, false, false }, { false, false, false }, { false, false, false }, { false, false, true }, { false, true, false }, { false, true, true }, { false, false, false } }; private List<int> moveHashList = new List<int>(); private ulong[] curSearchZobristKeyLine = Array.Empty<ulong>(); private Stopwatch globalTimer = Stopwatch.StartNew(); private Move lastMadeMove; private int depths, searches; private Random globalRandom = new Random(); public SNAPSHOT_V01_00_000(string fen) { Setup(fen); } public void Setup(string pFen) { Stopwatch setupStopwatch = Stopwatch.StartNew(); BOARD_MANAGER_ID = BOT_MAIN.curBoardManagerID; for (int i = 0; i < 33; i++) for (int j = 0; j < 14; j++) piecePositionEvals[i, j] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; for (int i = 0; i < 33; i++) for (int j = 0; j < 14; j++) texelTuningRuntimeVals[i, j] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; for (int i = 0; i < 3; i++) for (int j = 0; j < 6; j++) texelTuningVals[i, j] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; for (int i = 0; i < 14; i++) { texelTuningRuntimePositionalValsV2EG[i] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; texelTuningRuntimePositionalValsV2LG[i] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; } PrecalculateMultipliers(); GetLowNoisePositionalEvaluation(globalRandom); MinimaxRoot(1L); SetupConsoleWrite("[PRECALCS] Zobrist Hashing"); InitZobrist(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Knight Movement"); knightMovement = new KnightMovement(this); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Square Connectives"); SquareConnectivesPrecalculations(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Pawn Attack Bitboards"); PawnAttackBitboards(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Rays"); rays = new Rays(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); queenMovement = new QueenMovement(this); SetupConsoleWrite("[PRECALCS] Rook Movement"); rookMovement = new RookMovement(this, queenMovement); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Bishop Movement"); bishopMovement = new BishopMovement(this, queenMovement); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] King Movement"); kingMovement = new KingMovement(this); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Pawn Movement"); whitePawnMovement = new WhitePawnMovement(this); blackPawnMovement = new BlackPawnMovement(this); PrecalculateEnPassantMoves(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWriteLine("[DONE]\n\n"); LoadFenString(pFen); LoadBestTexelParamsIn(); setupStopwatch.Stop(); } private void SetupConsoleWriteLine(string pStr) { if (BOT_MAIN.isFirstBoardManagerInitialized) return; SNAPSHOT_WRITLINE_REPLACEMENT(pStr); } private void SetupConsoleWrite(string pStr) { if (BOT_MAIN.isFirstBoardManagerInitialized) return; SNAPSHOT_WRITLINE_REPLACEMENT(pStr); } public void GetLowNoisePositionalEvaluation(System.Random rng) { int[,][] digitArray = new int[3, 6][]; for (int i = 0; i < 3; i++) for (int j = 0; j < 6; j++) digitArray[i, j] = GetRand64IntArray(rng, -5, 6); lowNoisePositionEvals1 = GetInterpolatedProcessedValues(digitArray); int[,][] digitArray2 = new int[3, 6][]; for (int i = 0; i < 3; i++) for (int j = 0; j < 6; j++) digitArray2[i, j] = GetRand64IntArray(rng, -5, 6); lowNoisePositionEvals2 = GetInterpolatedProcessedValues(digitArray2); } private int[] GetRand64IntArray(System.Random rng, int pMin, int pMax) { return new int[64] { rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax) }; } private string GetAIArrayValuesStringRepresentation(int[,][] pArr) { string r = "int[,][] ReLe_AI_RESULT_VALS = new int[3, 6][] {"; for (int i = 0; i < 3; i++) { r += "{"; for (int j = 0; j < 5; j++) { r += GetIntArray64LStringRepresentation(pArr[i, j]) + ","; } r += GetIntArray64LStringRepresentation(pArr[i, 5]) + "},"; } return r.Substring(0, r.Length - 1) + "};"; } private string GetIntArray64LStringRepresentation(int[] p64LArr) { if (p64LArr == null) return ""; string r = "new int[64]{"; for (int i = 0; i < 63; i++) { r += p64LArr[i] + ","; } return r + p64LArr[63] + "}"; } public void TempStuff() { PlayGameOnConsoleAgainstHuman("B4k2/8/4Q3/5K2/8/8/2P5/8 w ha - 5 11", true, 30_000_000L); } private string[] gameResultStrings = new string[5] { "Black Has Won!", "Draw!", "White Has Won!", "Non Existant Result!", "Game is Ongoing!"}; private int[,][] lowNoisePositionEvals1, lowNoisePositionEvals2; public void ThreadSelfPlay(object obj) { PlayGameAgainstItself(obj); } public void PlayGameAgainstItself(object obj, string pStartFEN = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1", long tickLimitForEngine = ENGINE_VALS.SELF_PLAY_THINK_TIME) { int ttGState; while (BOT_MAIN.goalGameCount > BOT_MAIN.gamesPlayed) { try { string tGameStr; GetLowNoisePositionalEvaluation(globalRandom); LoadFenString(tGameStr = pStartFEN); tGameStr += ";"; int tGState = 3, tmc = 0; bool lowNoiceDecider = globalRandom.NextDouble() < 0.5d; while (tGState == 3) { piecePositionEvals = lowNoiceDecider ? lowNoisePositionEvals1 : lowNoisePositionEvals2; MinimaxRoot(tickLimitForEngine); Move tM = transpositionTable[zobristKey].bestMove; PlainMakeMove(tM); tGameStr += NuCRe.GetNuCRe(tM.moveHash) + ","; BOT_MAIN.movesPlayed++; tGState = GameState(isWhiteToMove); lowNoiceDecider = !lowNoiceDecider; tmc++; } ttGState = tGState; tGameStr += ttGState + 1; SNAPSHOT_WRITLINE_REPLACEMENT(tGameStr); BOT_MAIN.gamesPlayedResultArray[ttGState + 1]++; BOT_MAIN.gamesPlayed++; BOT_MAIN.selfPlayGameStrings.Add(tGameStr); } catch (Exception tE) { SNAPSHOT_WRITLINE_REPLACEMENT(tE.ToString()); } } } public void PlayGameOnConsoleAgainstHuman(string pStartFEN = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1", bool pHumanPlaysWhite = true, long tickLimitForEngine = 10_000_000L) { debugSearchDepthResults = true; LoadFenString(pStartFEN); if (!(pHumanPlaysWhite ^ isWhiteToMove)) { var pVS = Console.ReadLine(); if (pVS == null) return; Move tm = GetMoveOfString(pVS.ToString()); SNAPSHOT_WRITLINE_REPLACEMENT(tm); PlainMakeMove(tm); } int tGState = 3; while (tGState == 3) { MinimaxRoot(tickLimitForEngine); PlayThroughZobristTree(); Move tM = transpositionTable[zobristKey].bestMove; SNAPSHOT_WRITLINE_REPLACEMENT(tM); SNAPSHOT_WRITLINE_REPLACEMENT(CreateFenString()); PlainMakeMove(tM); tGState = GameState(isWhiteToMove); if (tGState != 3 || tM == NULL_MOVE) break; var pV = ""; tM = NULL_MOVE; do { pV = Console.ReadLine(); if (pV == null) continue; tM = GetMoveOfString(pV.ToString()); SNAPSHOT_WRITLINE_REPLACEMENT(tM); } while (tM == NULL_MOVE); PlainMakeMove(tM); tGState = GameState(isWhiteToMove); } } private void PlayThroughZobristTree() { SetJumpState(); SNAPSHOT_WRITLINE_REPLACEMENT("\n- - - - - - - - - - - - -"); int tC = 1; Dictionary<ulong, bool> usedULs = new Dictionary<ulong, bool>(); while (transpositionTable.TryGetValue(zobristKey, out TranspositionEntry tM)) { if (usedULs.ContainsKey(zobristKey)) { SNAPSHOT_WRITLINE_REPLACEMENT(tC + ": AT LEAST ONE REPETION; REST NOT VISIBLE"); break; } SNAPSHOT_WRITLINE_REPLACEMENT(tC + ": "+ tM.bestMove + " > "); usedULs.Add(zobristKey, true); PlainMakeMove(tM.bestMove); tC++; } SNAPSHOT_WRITLINE_REPLACEMENT("- - - - - - - - - - - - -\n"); LoadJumpState(); } public Move? ReturnNextMove(Move? lastMove, long pThinkingTime) { if (lastMove != null) PlainMakeMove(lastMove); if (GameState(isWhiteToMove) != 3) return null; MinimaxRoot(pThinkingTime); if (!transpositionTable.ContainsKey(zobristKey)) return null; Move tm = transpositionTable[zobristKey].bestMove; PlainMakeMove(tm); return tm; } private int[] jmpSt_pieceTypeArray; private ulong jmpSt_whitePieceBitboard, jmpSt_blackPieceBitboard; private ulong jmpSt_zobristKey; private int jmpSt_whiteKingSquare, jmpSt_blackKingSquare, jmpSt_enPassantSquare, jmpSt_happenedHalfMoves, jmpSt_fiftyMoveRuleCounter; private bool jmpSt_whiteCastleRightKingSide, jmpSt_whiteCastleRightQueenSide, jmpSt_blackCastleRightKingSide, jmpSt_blackCastleRightQueenSide; private bool jmpSt_isWhiteToMove; private ulong[] jmpSt_curSearchZobristKeyLine; private int[] jmpSt_moveHashList; public void LoadJumpState() { pieceTypeArray = (int[])jmpSt_pieceTypeArray.Clone(); whitePieceBitboard = jmpSt_whitePieceBitboard; blackPieceBitboard = jmpSt_blackPieceBitboard; zobristKey = jmpSt_zobristKey; whiteKingSquare = jmpSt_whiteKingSquare; blackKingSquare = jmpSt_blackKingSquare; enPassantSquare = jmpSt_enPassantSquare; happenedHalfMoves = jmpSt_happenedHalfMoves; fiftyMoveRuleCounter = jmpSt_fiftyMoveRuleCounter; whiteCastleRightKingSide = jmpSt_whiteCastleRightKingSide; whiteCastleRightQueenSide = jmpSt_whiteCastleRightQueenSide; blackCastleRightKingSide = jmpSt_blackCastleRightKingSide; blackCastleRightQueenSide = jmpSt_blackCastleRightQueenSide; isWhiteToMove = jmpSt_isWhiteToMove; curSearchZobristKeyLine = (ulong[])jmpSt_curSearchZobristKeyLine.Clone(); allPieceBitboard = blackPieceBitboard | whitePieceBitboard; moveHashList = jmpSt_moveHashList.ToList(); } public void SetJumpState() { jmpSt_pieceTypeArray = (int[])pieceTypeArray.Clone(); jmpSt_whitePieceBitboard = whitePieceBitboard; jmpSt_blackPieceBitboard = blackPieceBitboard; jmpSt_zobristKey = zobristKey; jmpSt_whiteKingSquare = whiteKingSquare; jmpSt_blackKingSquare = blackKingSquare; jmpSt_enPassantSquare = enPassantSquare; jmpSt_happenedHalfMoves = happenedHalfMoves; jmpSt_fiftyMoveRuleCounter = fiftyMoveRuleCounter; jmpSt_whiteCastleRightKingSide = whiteCastleRightKingSide; jmpSt_whiteCastleRightQueenSide = whiteCastleRightQueenSide; jmpSt_blackCastleRightKingSide = blackCastleRightKingSide; jmpSt_blackCastleRightQueenSide = blackCastleRightQueenSide; jmpSt_isWhiteToMove = isWhiteToMove; jmpSt_curSearchZobristKeyLine = (ulong[])curSearchZobristKeyLine.Clone(); jmpSt_moveHashList = moveHashList.ToArray(); } private int PreMinimaxCheckCheckWhite() { ulong bitShiftedKingPos = 1ul << whiteKingSquare; int curR = -1; for (int p = 0; p < 64; p++) { if (ULONG_OPERATIONS.IsBitZero(blackPieceBitboard, p)) continue; int tPT; switch (tPT = pieceTypeArray[p]) { case 1: if ((bitShiftedKingPos & blackPawnAttackSquareBitboards[p]) != 0ul) return p; break; case 2: if ((bitShiftedKingPos & knightSquareBitboards[p]) != 0ul) return p; break; case 6: break; default: if ((squareConnectivesPrecalculationLineArray[whiteKingSquare << 6 | p] & allPieceBitboard) == (1ul << p) && pieceTypeAbilities[tPT, squareConnectivesPrecalculationArray[whiteKingSquare << 6 | p]]) { if (curR != -1) return -779; curR = p; } break; } } return curR; } private int PreMinimaxCheckCheckBlack() { ulong bitShiftedKingPos = 1ul << blackKingSquare; int curR = -1; for (int p = 0; p < 64; p++) { if (ULONG_OPERATIONS.IsBitZero(whitePieceBitboard, p)) continue; int tPT; switch (tPT = pieceTypeArray[p]) { case 1: if ((bitShiftedKingPos & whitePawnAttackSquareBitboards[p]) != 0ul) return p; break; case 2: if ((bitShiftedKingPos & knightSquareBitboards[p]) != 0ul) return p; break; case 6: break; default: if ((squareConnectivesPrecalculationLineArray[blackKingSquare << 6 | p] & allPieceBitboard) == (1ul << p) && pieceTypeAbilities[tPT, squareConnectivesPrecalculationArray[blackKingSquare << 6 | p]]) { if (curR != -1) return -779; curR = p; } break; } } return curR; } private int LecacyLeafCheckingPieceCheckWhite(int pStartPos, int pEndPos, int pPieceType) { int tI, tPossibleAttackPiece; if (pPieceType == 1) { if (ULONG_OPERATIONS.IsBitOne(blackPawnAttackSquareBitboards[pEndPos], whiteKingSquare)) return pEndPos; } else if (pPieceType == 2) { if (ULONG_OPERATIONS.IsBitOne(knightSquareBitboards[pEndPos], whiteKingSquare)) return pEndPos; } else if (pPieceType != 6) { tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | pEndPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; } tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | pStartPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; return -1; } private int LecacyLeafCheckingPieceCheckBlack(int pStartPos, int pEndPos, int pPieceType) { int tI, tPossibleAttackPiece; if (pPieceType == 1) { if (ULONG_OPERATIONS.IsBitOne(whitePawnAttackSquareBitboards[pEndPos], blackKingSquare)) return pEndPos; } else if (pPieceType == 2) { if (ULONG_OPERATIONS.IsBitOne(knightSquareBitboards[pEndPos], blackKingSquare)) return pEndPos; } else if (pPieceType != 6) { tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | pEndPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; } tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | pStartPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; return -1; } public void GetLegalMoves(ref List<Move> pMoveList) { int attk; if (isWhiteToMove) { attk = PreMinimaxCheckCheckWhite(); if (attk == -779) GetLegalWhiteMovesSpecialDoubleCheckCase(ref pMoveList); else GetLegalWhiteMoves(attk, ref pMoveList); } else { attk = PreMinimaxCheckCheckBlack(); if (attk == -779) GetLegalBlackMovesSpecialDoubleCheckCase(ref pMoveList); else GetLegalBlackMoves(attk, ref pMoveList); } } private void GetLegalWhiteMoves(int pCheckingPieceSquare, ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= blackPawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, whiteKingSquare); if (curCheckCount == 0) { if (whiteCastleRightKingSide && ((allPieceBitboard | oppAttkBitboard) & WHITE_KING_ROCHADE) == 0ul) pMoveList.Add(mWHITE_KING_ROCHADE); if (whiteCastleRightQueenSide && (allPieceBitboard & WHITE_QUEEN_ROCHADE | oppAttkBitboard & WHITE_QUEEN_ATTK_ROCHADE) == 0ul) pMoveList.Add(mWHITE_QUEEN_ROCHADE); if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, whitePieceBitboard, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[whiteKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare + 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, whitePieceBitboard, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveList(whiteKingSquare, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalWhiteCaptures(int pCheckingPieceSquare, ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= blackPawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, whiteKingSquare); if (curCheckCount == 0) { if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & blackPieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[whiteKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare + 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & blackPieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveListOnlyCaptures(whiteKingSquare, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalWhiteMovesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= blackPawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveList(whiteKingSquare, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalWhiteCapturesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= blackPawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveListOnlyCaptures(whiteKingSquare, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalBlackMoves(int pCheckingPieceSquare, ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= whitePawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, blackKingSquare); if (curCheckCount == 0) { if (blackCastleRightKingSide && ((allPieceBitboard | oppAttkBitboard) & BLACK_KING_ROCHADE) == 0ul) pMoveList.Add(mBLACK_KING_ROCHADE); if (blackCastleRightQueenSide && (allPieceBitboard & BLACK_QUEEN_ROCHADE | oppAttkBitboard & BLACK_QUEEN_ATTK_ROCHADE) == 0ul) pMoveList.Add(mBLACK_QUEEN_ROCHADE); if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveList(p, blackKingSquare, blackPieceBitboard, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[blackKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare - 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveList(p, blackKingSquare, blackPieceBitboard, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveList(blackKingSquare, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); } private void GetLegalBlackCaptures(int pCheckingPieceSquare, ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= whitePawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, blackKingSquare); if (curCheckCount == 0) { if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & whitePieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[blackKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare - 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & whitePieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveListOnlyCaptures(blackKingSquare, ~oppAttkBitboard & whitePieceBitboard); } private void GetLegalBlackMovesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= whitePawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveList(blackKingSquare, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); } private void GetLegalBlackCapturesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= whitePawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveListOnlyCaptures(blackKingSquare, ~oppAttkBitboard & whitePieceBitboard); } public Move GetMoveOfString(string pMove) { int tSP, tEP; string[] tSpl = pMove.Split(','); if (Char.IsNumber(pMove[0])) { tSP = Convert.ToInt32(tSpl[0]); tEP = Convert.ToInt32(tSpl[1]); } else { tSP = SQUARES.NumberNotation(tSpl[0]); tEP = SQUARES.NumberNotation(tSpl[1]); } int tPT = pieceTypeArray[tSP]; bool tIC = ULONG_OPERATIONS.IsBitOne(allPieceBitboard, tEP), tIEP = enPassantSquare == tEP && tPT == 1; if (tSpl.Length == 3) return new Move(tSP, tEP, tPT, Convert.ToInt32(tSpl[2]), tIC); if (tIEP) return new Move(true, tSP, tEP, isWhiteToMove ? tEP - 8 : tEP + 8); if (tPT == 1 && Math.Abs(tSP - tEP) > 11) return new Move(tSP, tEP, 1, false, isWhiteToMove ? tSP + 8 : tSP - 8); if (tPT == 6 && (Math.Abs(tSP - tEP) == 2 || Math.Abs(tSP - tEP) == 3)) { if (isWhiteToMove) return tEP == 6 ? mWHITE_KING_ROCHADE : mWHITE_QUEEN_ROCHADE; return tEP == 62 ? mBLACK_KING_ROCHADE : mBLACK_QUEEN_ROCHADE; } return new Move(tSP, tEP, tPT, tIC); } public void PlainMakeMove(string pMoveName) { PlainMakeMove(GetMoveOfString(pMoveName)); } public void PlainMakeMove(Move pMove) { lastMadeMove = pMove; if (isWhiteToMove) WhiteMakeMove(pMove); else BlackMakeMove(pMove); } public void WhiteMakeMove(Move pMove) { int tEndPos = pMove.endPos, tStartPos = pMove.startPos, tPieceType = pMove.pieceType, tPTI = pieceTypeArray[tEndPos]; fiftyMoveRuleCounter++; whitePieceBitboard ^= pMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey ^= blackTurnHash ^ enPassantSquareHashes[enPassantSquare] ^ pieceHashesWhite[tStartPos, tPieceType] ^ pieceHashesWhite[tEndPos, tPieceType]; enPassantSquare = 65; isWhiteToMove = false; switch (pMove.moveTypeID) { case 0: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 1: fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 2: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 3: whiteKingSquare = tEndPos; if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 4: if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 5: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 6: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 7: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[whiteKingSquare = tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 8: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 9: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = pMove.enPassantOption]; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 11: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; whiteKingSquare = tEndPos; pieceTypeArray[pMove.rochadeEndPos] = 4; pieceTypeArray[pMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesWhite[pMove.rochadeStartPos, 4] ^ pieceHashesWhite[pMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 12: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[pMove.enPassantOption] = 0; zobristKey ^= pieceHashesBlack[pMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 13: fiftyMoveRuleCounter = 0; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; zobristKey ^= pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, pMove.promotionType]; break; case 14: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, tPTI] ^ pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, pMove.promotionType]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; } moveHashList.Add(pMove.moveHash); if (pMove.isCapture || tPieceType == 1) { curSearchZobristKeyLine = Array.Empty<ulong>(); return; } ulong[] u = new ulong[(tPTI = curSearchZobristKeyLine.Length) + 1]; for (int i = tPTI; i-- > 0;) u[i] = curSearchZobristKeyLine[i]; u[tPTI] = zobristKey; curSearchZobristKeyLine = u; } public void BlackMakeMove(Move pMove) { int tEndPos = pMove.endPos, tStartPos = pMove.startPos, tPieceType = pMove.pieceType, tPTI = pieceTypeArray[tEndPos]; fiftyMoveRuleCounter++; blackPieceBitboard ^= pMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey ^= blackTurnHash ^ enPassantSquareHashes[enPassantSquare] ^ pieceHashesBlack[tStartPos, tPieceType] ^ pieceHashesBlack[tEndPos, tPieceType]; enPassantSquare = 65; isWhiteToMove = true; switch (pMove.moveTypeID) { case 0: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 1: fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 2: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 3: blackKingSquare = tEndPos; if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 4: if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 5: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 6: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 7: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[blackKingSquare = tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 8: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 9: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = pMove.enPassantOption]; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 11: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; blackKingSquare = tEndPos; pieceTypeArray[pMove.rochadeEndPos] = 4; pieceTypeArray[pMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesBlack[pMove.rochadeStartPos, 4] ^ pieceHashesBlack[pMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 12: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[pMove.enPassantOption] = 0; zobristKey ^= pieceHashesWhite[pMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 13: fiftyMoveRuleCounter = 0; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, pMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 14: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } zobristKey ^= pieceHashesWhite[tEndPos, tPTI] ^ pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, pMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; } moveHashList.Add(pMove.moveHash); if (pMove.isCapture || tPieceType == 1) { curSearchZobristKeyLine = Array.Empty<ulong>(); return; } ulong[] u = new ulong[(tPTI = curSearchZobristKeyLine.Length) + 1]; for (int i = tPTI; i-- > 0;) u[i] = curSearchZobristKeyLine[i]; u[tPTI] = zobristKey; curSearchZobristKeyLine = u; } public void WhiteUndoMove(Move pMove) { } private const int WHITE_CHECKMATE_VAL = 100000, BLACK_CHECKMATE_VAL = -100000, CHECK_EXTENSION_LENGTH = -12, MAX_QUIESCENCE_TOTAL_LENGTH = -32; private readonly Move NULL_MOVE = new Move(0, 0, 0); private int curSearchDepth = 0, curSubSearchDepth = -1; public int MinimaxRoot(long pTime) { evalCount = 0; searches++; int baseLineLen = 0; long tTimestamp = globalTimer.ElapsedTicks + pTime; ClearHeuristics(); transpositionTable.Clear(); ulong[] tZobristKeyLine = Array.Empty<ulong>(); if (curSearchZobristKeyLine != null) { baseLineLen = curSearchZobristKeyLine.Length; tZobristKeyLine = new ulong[baseLineLen]; Array.Copy(curSearchZobristKeyLine, tZobristKeyLine, baseLineLen); } int perftScore, tattk = isWhiteToMove ? PreMinimaxCheckCheckWhite() : PreMinimaxCheckCheckBlack(), pDepth = 1; (string, int) bookMoveTuple = TLMDatabase.SearchForNextBookMove(moveHashList); if (bookMoveTuple.Item2 != 0) { int actualMoveHash = NuCRe.GetNumber(bookMoveTuple.Item1); List<Move> tMoves = new List<Move>(); GetLegalMoves(ref tMoves); int tL = tMoves.Count; for (int i = 0; i < tL; i++) { if (tMoves[i].moveHash == actualMoveHash) { if (debugSearchDepthResults) { SNAPSHOT_WRITLINE_REPLACEMENT("TLM_DB_Count: " + bookMoveTuple.Item2); SNAPSHOT_WRITLINE_REPLACEMENT(">> " + tMoves[i]); } transpositionTable.Add(zobristKey, new TranspositionEntry(tMoves[i], Array.Empty<int>())); return 0; } } } do { curSearchDepth = pDepth; curSubSearchDepth = pDepth - 1; ulong[] completeZobristHistory = new ulong[baseLineLen + pDepth - CHECK_EXTENSION_LENGTH + 1]; for (int i = 0; i < baseLineLen; i++) completeZobristHistory[i] = curSearchZobristKeyLine[i]; curSearchZobristKeyLine = completeZobristHistory; if (isWhiteToMove) { if (tattk == -1) perftScore = MinimaxWhite(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); else perftScore = MinimaxWhite(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); } else { if (tattk == -1) perftScore = MinimaxBlack(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); else perftScore = MinimaxBlack(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); } if (debugSearchDepthResults && pTime != 1L) { int tNpS = Convert.ToInt32((double)evalCount * 10_000_000d /(double)(pTime - tTimestamp + globalTimer.ElapsedTicks)); int tSearchEval = perftScore; int timeForSearchSoFar = (int)((pTime - tTimestamp + globalTimer.ElapsedTicks) /10000d); Move tBestMove = transpositionTable[zobristKey].bestMove; SNAPSHOT_WRITLINE_REPLACEMENT((tSearchEval >= 0 ? "+": "") + tSearchEval); SNAPSHOT_WRITLINE_REPLACEMENT(" " + tBestMove + "  ["); SNAPSHOT_WRITLINE_REPLACEMENT("Depth = " + pDepth + ", "); SNAPSHOT_WRITLINE_REPLACEMENT("Evals = " + GetThreeDigitSeperatedInteger(evalCount) + ", "); SNAPSHOT_WRITLINE_REPLACEMENT("Time = " + GetThreeDigitSeperatedInteger(timeForSearchSoFar) + "ms, "); SNAPSHOT_WRITLINE_REPLACEMENT("NpS = " + GetThreeDigitSeperatedInteger(tNpS) + "]"); } pDepth++; } while (globalTimer.ElapsedTicks < tTimestamp && pDepth < 179); depths += pDepth - 1; BOT_MAIN.depthsSearched += pDepth - 1; BOT_MAIN.searchesFinished++; BOT_MAIN.evaluationsMade += evalCount; curSearchZobristKeyLine = tZobristKeyLine; return perftScore; } private int MinimaxWhite(int pPly, int pAlpha, int pBeta, int pDepth, int pRepetitionHistoryPly, int pCheckingSquare, Move pLastMove) { if (IsDrawByRepetition(pRepetitionHistoryPly - 4)) return 0; if ((pDepth <= 0 && pCheckingSquare == -1) || pDepth < CHECK_EXTENSION_LENGTH) return QuiescenceWhite(pPly, pAlpha, pBeta, pDepth - 1, pCheckingSquare, pLastMove); List<Move> moveOptionList = new List<Move>(); Move bestMove = NULL_MOVE; if (pLastMove.isPromotion && pLastMove.isCapture && pLastMove.startPos % 8 == pCheckingSquare % 8 && pLastMove.startPos == whiteKingSquare + 8 && (pLastMove.promotionType == 4 || pLastMove.promotionType == 5)) GetLegalWhiteMovesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalWhiteMoves(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tWhiteKingSquare = whiteKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1, curEval = BLACK_CHECKMATE_VAL - pDepth; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = true; double[] moveSortingArray = new double[molc]; int[] moveSortingArrayIndexes = new int[molc], thisSearchMoveSortingArrayForTransposEntry = new int[molc]; transpositionTable.TryGetValue(zobristKey, out TranspositionEntry transposEntry); if (transposEntry == null) { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; } } else { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove == transposEntry.bestMove) moveSortingArray[m] = BESTMOVE_SORT_VAL; else if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; if (transposEntry.moveGenOrderedEvalLength > m) moveSortingArray[m] -= transposEntry.moveGenOrderedEvals[m]; } } Array.Sort(moveSortingArray, moveSortingArrayIndexes); for (int m = 0; m < molc; m++) { int tActualIndex = moveSortingArrayIndexes[m]; Move curMove = moveOptionList[tActualIndex]; if (debugSortResults && pDepth == curSubSearchDepth) { SNAPSHOT_WRITLINE_REPLACEMENT(moveSortingArray[m] + " | "+ curMove); } int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; whitePieceBitboard = tWPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesWhite[tStartPos, tPieceType] ^ pieceHashesWhite[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 0: blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 1: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 2: blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 3: whiteKingSquare = tEndPos; if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 4: blackPieceBitboard = tBPB; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 5: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[whiteKingSquare = tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = curMove.enPassantOption]; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 11: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; whiteKingSquare = tEndPos; blackPieceBitboard = tBPB; pieceTypeArray[curMove.rochadeEndPos] = 4; pieceTypeArray[curMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesWhite[curMove.rochadeStartPos, 4] ^ pieceHashesWhite[curMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | curMove.rochadeEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << curMove.rochadeEndPos)) tCheckPos = curMove.rochadeEndPos; break; case 12: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesBlack[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 13: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; zobristKey ^= pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, curMove.promotionType]; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; case 14: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, tPTI] ^ pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, curMove.promotionType]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } curSearchZobristKeyLine[pRepetitionHistoryPly] = zobristKey; int tEval = MinimaxBlack(pPly + 1, pAlpha, pBeta, pDepth - 1, pRepetitionHistoryPly + 1, tCheckPos, curMove); thisSearchMoveSortingArrayForTransposEntry[tActualIndex] = tEval; pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 3: whiteKingSquare = tWhiteKingSquare; break; case 7: whiteKingSquare = tWhiteKingSquare; break; case 10: enPassantSquare = 65; break; case 11: whiteKingSquare = tWhiteKingSquare; pieceTypeArray[curMove.rochadeStartPos] = 4; pieceTypeArray[curMove.rochadeEndPos] = 0; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 13: pieceTypeArray[tStartPos] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval > curEval) { bestMove = curMove; curEval = tEval; } if (pAlpha < curEval) pAlpha = curEval; if (curEval >= pBeta) { if (!curMove.isCapture) { killerMoveHeuristic[curMove.moveHash] = true; if (pDepth > 0) historyHeuristic[curMove.moveHash] += pDepth * pDepth; } break; } } isWhiteToMove = true; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; if (molc == 0 && pCheckingSquare == 0) curEval = 0; if (!transpositionTable.ContainsKey(zobristKey)) transpositionTable.Add(zobristKey, new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry)); else transpositionTable[zobristKey] = new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry); return curEval; } private int QuiescenceWhite(int pPly, int pAlpha, int pBeta, int pDepth, int pCheckingSquare, Move pLastMove) { int standPat = TexelEvaluate(); if (standPat >= pBeta || pDepth < MAX_QUIESCENCE_TOTAL_LENGTH) return pBeta; if (standPat > pAlpha) pAlpha = standPat; List<Move> moveOptionList = new List<Move>(); if (pLastMove.isPromotion && pLastMove.isCapture && pLastMove.startPos % 8 == pCheckingSquare % 8 && pLastMove.startPos == whiteKingSquare + 8 && (pLastMove.promotionType == 4 || pLastMove.promotionType == 5)) GetLegalWhiteCapturesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalWhiteCaptures(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tWhiteKingSquare = whiteKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = true; for (int m = 0; m < molc; m++) { Move curMove = moveOptionList[m]; int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; whitePieceBitboard = tWPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesWhite[tStartPos, tPieceType] ^ pieceHashesWhite[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 5: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[whiteKingSquare = tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 12: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesBlack[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 14: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, tPTI] ^ pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, curMove.promotionType]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } int tEval = QuiescenceBlack(pPly + 1, pAlpha, pBeta, pDepth - 1, tCheckPos, curMove); pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 7: whiteKingSquare = tWhiteKingSquare; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval >= pBeta) return pBeta; if (pAlpha < tEval) pAlpha = tEval; } isWhiteToMove = true; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; return pAlpha; } private int MinimaxBlack(int pPly, int pAlpha, int pBeta, int pDepth, int pRepetitionHistoryPly, int pCheckingSquare, Move pLastMove) { if (IsDrawByRepetition(pRepetitionHistoryPly - 4)) return 0; if ((pDepth <= 0 && pCheckingSquare == -1) || pDepth < CHECK_EXTENSION_LENGTH) return QuiescenceBlack(pPly, pAlpha, pBeta, pDepth - 1, pCheckingSquare, pLastMove); List<Move> moveOptionList = new List<Move>(); Move bestMove = NULL_MOVE; if (pLastMove.isPromotion && pLastMove.isCapture && pLastMove.startPos % 8 == pCheckingSquare % 8 && pLastMove.startPos == blackKingSquare - 8 && (pLastMove.promotionType == 4 || pLastMove.promotionType == 5)) GetLegalBlackMovesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalBlackMoves(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tBlackKingSquare = blackKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1, curEval = WHITE_CHECKMATE_VAL + pDepth; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = false; double[] moveSortingArray = new double[molc]; int[] moveSortingArrayIndexes = new int[molc], thisSearchMoveSortingArrayForTransposEntry = new int[molc]; transpositionTable.TryGetValue(zobristKey, out TranspositionEntry transposEntry); if (transposEntry == null) { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; } } else { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove == transposEntry.bestMove) moveSortingArray[m] = BESTMOVE_SORT_VAL; else if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; if (transposEntry.moveGenOrderedEvalLength > m) moveSortingArray[m] -= transposEntry.moveGenOrderedEvals[m]; } } Array.Sort(moveSortingArray, moveSortingArrayIndexes); for (int m = 0; m < molc; m++) { int tActualIndex = moveSortingArrayIndexes[m]; Move curMove = moveOptionList[tActualIndex]; if (debugSortResults && pDepth == curSearchDepth) { SNAPSHOT_WRITLINE_REPLACEMENT("=== " + moveSortingArray[m] + " | "+ curMove); } int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; blackPieceBitboard = tBPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesBlack[tStartPos, tPieceType] ^ pieceHashesBlack[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 0: whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 1: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 2: whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 3: blackKingSquare = tEndPos; if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 4: whitePieceBitboard = tWPB; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 5: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[blackKingSquare = tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = curMove.enPassantOption]; whitePieceBitboard = tWPB; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 11: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; blackKingSquare = tEndPos; whitePieceBitboard = tWPB; pieceTypeArray[curMove.rochadeEndPos] = 4; pieceTypeArray[curMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesBlack[curMove.rochadeStartPos, 4] ^ pieceHashesBlack[curMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | curMove.rochadeEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << curMove.rochadeEndPos)) tCheckPos = curMove.rochadeEndPos; break; case 12: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesWhite[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 13: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, curMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; case 14: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } zobristKey ^= pieceHashesWhite[tEndPos, tPTI] ^ pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, curMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } curSearchZobristKeyLine[pRepetitionHistoryPly] = zobristKey; int tEval = MinimaxWhite(pPly + 1, pAlpha, pBeta, pDepth - 1, pRepetitionHistoryPly + 1, tCheckPos, curMove); thisSearchMoveSortingArrayForTransposEntry[tActualIndex] = tEval; pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 3: blackKingSquare = tBlackKingSquare; break; case 7: blackKingSquare = tBlackKingSquare; break; case 10: enPassantSquare = 65; break; case 11: blackKingSquare = tBlackKingSquare; pieceTypeArray[curMove.rochadeStartPos] = 4; pieceTypeArray[curMove.rochadeEndPos] = 0; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 13: pieceTypeArray[tStartPos] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval < curEval) { bestMove = curMove; curEval = tEval; } if (pBeta > curEval) pBeta = curEval; if (curEval <= pAlpha) { if (!curMove.isCapture) { killerMoveHeuristic[curMove.moveHash] = true; if (pDepth > 0) historyHeuristic[curMove.moveHash] += pDepth * pDepth; } break; } } isWhiteToMove = false; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; if (molc == 0 && pCheckingSquare == 0) curEval = 0; if (!transpositionTable.ContainsKey(zobristKey)) transpositionTable.Add(zobristKey, new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry)); else transpositionTable[zobristKey] = new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry); return curEval; } private int QuiescenceBlack(int pPly, int pAlpha, int pBeta, int pDepth, int pCheckingSquare, Move pLastMove) { int standPat = TexelEvaluate(); if (standPat <= pAlpha || pDepth < MAX_QUIESCENCE_TOTAL_LENGTH) return pAlpha; if (standPat < pBeta) pBeta = standPat; List<Move> moveOptionList = new List<Move>(); if (pLastMove.isPromotion && pLastMove.isCapture && pLastMove.startPos % 8 == pCheckingSquare % 8 && pLastMove.startPos == blackKingSquare - 8 && (pLastMove.promotionType == 4 || pLastMove.promotionType == 5)) GetLegalBlackCapturesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalBlackCaptures(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tBlackKingSquare = blackKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = false; for (int m = 0; m < molc; m++) { Move curMove = moveOptionList[m]; int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; blackPieceBitboard = tBPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesBlack[tStartPos, tPieceType] ^ pieceHashesBlack[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 5: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[blackKingSquare = tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 12: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesWhite[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 14: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } zobristKey ^= pieceHashesWhite[tEndPos, tPTI] ^ pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, curMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } int tEval = QuiescenceWhite(pPly + 1, pAlpha, pBeta, pDepth - 1, tCheckPos, curMove); pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 7: blackKingSquare = tBlackKingSquare; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval <= pAlpha) return pAlpha; if (pBeta > tEval) pBeta = tEval; } isWhiteToMove = false; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; return pBeta; } private bool[] killerMoveHeuristic = new bool[262_144]; private int[] historyHeuristic = new int[262_144]; public void ClearHeuristics() { for (int i = 0; i < 262_144; i++) { killerMoveHeuristic[i] = false; historyHeuristic[i] = 0; } } private Dictionary<ulong, TranspositionEntry> transpositionTable = new Dictionary<ulong, TranspositionEntry>(); private int[] pieceEvals = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[,][] piecePositionEvals = new int[33, 14][]; private int evalCount = 0; private int Evaluate() { evalCount++; if (fiftyMoveRuleCounter > 99) return 0; int tEval = 0, tPT, pieceCount = ULONG_OPERATIONS.CountBits(allPieceBitboard); for (int p = 0; p < 64; p++) tEval += pieceEvals[tPT = pieceTypeArray[p] + 7 * ((int)(blackPieceBitboard >> p) & 1)] + piecePositionEvals[pieceCount, tPT][p]; return tEval; } public int GameState(bool pWhiteKingCouldBeAttacked) { if (IsDrawByRepetition(curSearchZobristKeyLine.Length - 5) || fiftyMoveRuleCounter > 99) return 0; int t; List<Move> tMoves = new List<Move>(); GetLegalMoves(ref tMoves); if (pWhiteKingCouldBeAttacked) { t = PreMinimaxCheckCheckWhite(); if (t == -1) return tMoves.Count == 0 ? 0 : 3; else if (tMoves.Count == 0) return -1; } else { t = PreMinimaxCheckCheckBlack(); if (t == -1) return tMoves.Count == 0 ? 0 : 3; else if (tMoves.Count == 0) return 1; } return 3; } private bool IsDrawByRepetition(int pPlyOfFirstPossibleRepeatedPosition) { int tC = 0; for (int i = pPlyOfFirstPossibleRepeatedPosition; i >= 0; i -= 2) { if (curSearchZobristKeyLine[i] == zobristKey) if (++tC == 2) return true; } return false; } private const int RELE_MAX_MOVE_COUNT_PER_GAME = 500; public double ReLePlayGame(int[,][] pEvalPositionValuesWhite, int[,][] pEvalPositionValuesBlack, long thinkingTimePerMove) { int[,][] processedValuesWhite = InitReLeAgent(pEvalPositionValuesWhite), processedValuesBlack = InitReLeAgent(pEvalPositionValuesBlack); int tGS, mc = 0; do { if (IsDrawByRepetition(curSearchZobristKeyLine.Length - 5)) return 0d; piecePositionEvals = isWhiteToMove ? processedValuesWhite : processedValuesBlack; MinimaxRoot(thinkingTimePerMove); if (transpositionTable.Count == 0) { SNAPSHOT_WRITLINE_REPLACEMENT("?!"); return 0d; } PlainMakeMove(transpositionTable[zobristKey].bestMove); tGS = GameState(isWhiteToMove); transpositionTable.Clear(); if (tGS != 3) break; } while (mc++ < RELE_MAX_MOVE_COUNT_PER_GAME); if (tGS == 3 || tGS == 0) return 0d; else if (tGS == 1) return 0.1d * (double)(RELE_MAX_MOVE_COUNT_PER_GAME - mc); return 0.1d * (double)(-RELE_MAX_MOVE_COUNT_PER_GAME + mc); } public int[,][] InitReLeAgent(int[,][] pEvalPositionValues) { return GetInterpolatedProcessedValues(pEvalPositionValues); } private int[,][] GetInterpolatedProcessedValues(int[,][] pEvalPositionValues) { int[,][] processedValues = new int[33, 14][]; for (int i = 0; i < 32; i++) { int ip1 = i + 1; processedValues[ip1, 7] = processedValues[ip1, 0] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; processedValues[ip1, 8] = SwapArrayViewingSide(processedValues[ip1, 1] = MultiplyArraysWithVal(pEvalPositionValues[0, 0], pEvalPositionValues[1, 0], pEvalPositionValues[2, 0], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 9] = SwapArrayViewingSide(processedValues[ip1, 2] = MultiplyArraysWithVal(pEvalPositionValues[0, 1], pEvalPositionValues[1, 1], pEvalPositionValues[2, 1], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 10] = SwapArrayViewingSide(processedValues[ip1, 3] = MultiplyArraysWithVal(pEvalPositionValues[0, 2], pEvalPositionValues[1, 2], pEvalPositionValues[2, 2], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 11] = SwapArrayViewingSide(processedValues[ip1, 4] = MultiplyArraysWithVal(pEvalPositionValues[0, 3], pEvalPositionValues[1, 3], pEvalPositionValues[2, 3], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 12] = SwapArrayViewingSide(processedValues[ip1, 5] = MultiplyArraysWithVal(pEvalPositionValues[0, 4], pEvalPositionValues[1, 4], pEvalPositionValues[2, 4], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 13] = SwapArrayViewingSide(processedValues[ip1, 6] = MultiplyArraysWithVal(pEvalPositionValues[0, 5], pEvalPositionValues[1, 5], pEvalPositionValues[2, 5], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); } return processedValues; } private double[,][] GetInterpolatedProcessedValues(double[,][] pEvalPositionValues) { double[,][] processedValues = new double[33, 14][]; for (int i = 0; i < 32; i++) { int ip1 = i + 1; processedValues[ip1, 7] = processedValues[ip1, 0] = new double[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; processedValues[ip1, 8] = SwapArrayViewingSide(processedValues[ip1, 1] = MultiplyArraysWithVal(pEvalPositionValues[0, 0], pEvalPositionValues[1, 0], pEvalPositionValues[2, 0], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 9] = SwapArrayViewingSide(processedValues[ip1, 2] = MultiplyArraysWithVal(pEvalPositionValues[0, 1], pEvalPositionValues[1, 1], pEvalPositionValues[2, 1], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 10] = SwapArrayViewingSide(processedValues[ip1, 3] = MultiplyArraysWithVal(pEvalPositionValues[0, 2], pEvalPositionValues[1, 2], pEvalPositionValues[2, 2], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 11] = SwapArrayViewingSide(processedValues[ip1, 4] = MultiplyArraysWithVal(pEvalPositionValues[0, 3], pEvalPositionValues[1, 3], pEvalPositionValues[2, 3], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 12] = SwapArrayViewingSide(processedValues[ip1, 5] = MultiplyArraysWithVal(pEvalPositionValues[0, 4], pEvalPositionValues[1, 4], pEvalPositionValues[2, 4], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 13] = SwapArrayViewingSide(processedValues[ip1, 6] = MultiplyArraysWithVal(pEvalPositionValues[0, 5], pEvalPositionValues[1, 5], pEvalPositionValues[2, 5], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); } return processedValues; } private double[] MultiplyArraysWithVal(double[] pArr1, double[] pArr2, double[] pArr3, double pVal1, double pVal2, double pVal3) { int tL = pArr1.Length; double[] rArr = new double[tL]; for (int i = 0; i < tL; i++) { rArr[i] = pArr1[i] * pVal1 + pArr2[i] * pVal2 + pArr3[i] * pVal3; } return rArr; } private int[] MultiplyArraysWithVal(int[] pArr1, int[] pArr2, int[] pArr3, double pVal1, double pVal2, double pVal3) { int tL = pArr1.Length; int[] rArr = new int[tL]; for (int i = 0; i < tL; i++) { rArr[i] = (int)(pArr1[i] * pVal1 + pArr2[i] * pVal2 + pArr3[i] * pVal3); } return rArr; } private int[] SwapArrayViewingSide(int[] pArr) { return new int[64] { pArr[56], pArr[57], pArr[58], pArr[59], pArr[60], pArr[61], pArr[62], pArr[63], pArr[48], pArr[49], pArr[50], pArr[51], pArr[52], pArr[53], pArr[54], pArr[55], pArr[40], pArr[41], pArr[42], pArr[43], pArr[44], pArr[45], pArr[46], pArr[47], pArr[32], pArr[33], pArr[34], pArr[35], pArr[36], pArr[37], pArr[38], pArr[39], pArr[24], pArr[25], pArr[26], pArr[27], pArr[28], pArr[29], pArr[30], pArr[31], pArr[16], pArr[17], pArr[18], pArr[19], pArr[20], pArr[21], pArr[22], pArr[23], pArr[8], pArr[9], pArr[10], pArr[11], pArr[12], pArr[13], pArr[14], pArr[15], pArr[0], pArr[1], pArr[2], pArr[3], pArr[4], pArr[5], pArr[6], pArr[7] }; } private double[] SwapArrayViewingSide(double[] pArr) { return new double[64] { pArr[56], pArr[57], pArr[58], pArr[59], pArr[60], pArr[61], pArr[62], pArr[63], pArr[48], pArr[49], pArr[50], pArr[51], pArr[52], pArr[53], pArr[54], pArr[55], pArr[40], pArr[41], pArr[42], pArr[43], pArr[44], pArr[45], pArr[46], pArr[47], pArr[32], pArr[33], pArr[34], pArr[35], pArr[36], pArr[37], pArr[38], pArr[39], pArr[24], pArr[25], pArr[26], pArr[27], pArr[28], pArr[29], pArr[30], pArr[31], pArr[16], pArr[17], pArr[18], pArr[19], pArr[20], pArr[21], pArr[22], pArr[23], pArr[8], pArr[9], pArr[10], pArr[11], pArr[12], pArr[13], pArr[14], pArr[15], pArr[0], pArr[1], pArr[2], pArr[3], pArr[4], pArr[5], pArr[6], pArr[7] }; } private int[,][] texelTuningRuntimeVals = new int[33, 14][]; private int[,][] texelTuningVals = new int[3, 6][]; private int[,] texelTuningAdjustIterations = new int[6, 64]; private int[][] texelTuningRuntimePositionalValsV2EG = new int[14][]; private int[][] texelTuningRuntimePositionalValsV2LG = new int[14][]; private int[] texelPieceEvaluationsV2EG = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[] texelPieceEvaluationsV2LG = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[] texelPieceEvaluations = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[] blackSidedSquares = new int[64] { 56, 57, 58, 59, 60, 61, 62, 63, 48, 49, 50, 51, 52, 53, 54, 55, 40, 41, 42, 43, 44, 45, 46, 47, 32, 33, 34, 35, 36, 37, 38, 39, 24, 25, 26, 27, 28, 29, 30, 31, 16, 17, 18, 19, 20, 21, 22, 23, 08, 09, 10, 11, 12, 13, 14, 15, 00, 01, 02, 03, 04, 05, 06, 07 }; private int[,] T_Pawns = new int[3, 64] { { 0, 0, 0, 0, 0, 0, 0, 0, 98, 134, 61, 95, 68, 126, 34, -11, -6, 7, 26, 31, 65, 56, 25, -20, -14, 13, 6, 21, 23, 12, 17, -23, -27, -2, -5, 12, 17, 6, 10, -25, -26, -4, -4, -10, 3, 3, 33, -12, -35, -1, -20, -23, -15, 24, 38, -22, 0, 0, 0, 0, 0, 0, 0, 0, } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { 0, 0, 0, 0, 0, 0, 0, 0, 178, 173, 158, 134, 147, 132, 165, 187, 94, 100, 85, 67, 56, 53, 82, 84, 32, 24, 13, 5, -2, 4, 17, 17, 13, 9, -3, -7, -7, -8, 3, -1, 4, 7, -6, 1, 0, -5, -1, -8, 13, 8, 8, 10, 13, 0, 2, -7, 0, 0, 0, 0, 0, 0, 0, 0, } }; private int[,] T_Knights = new int[3, 64] { { -167, -89, -34, -49, 61, -97, -15, -107, -73, -41, 72, 36, 23, 62, 7, -17, -47, 60, 37, 65, 84, 129, 73, 44, -9, 17, 19, 53, 37, 69, 18, 22, -13, 4, 16, 13, 28, 19, 21, -8, -23, -9, 12, 10, 19, 17, 25, -16, -29, -53, -12, -3, -1, 18, -14, -19, -105, -21, -58, -33, -17, -28, -19, -23 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -58, -38, -13, -28, -31, -27, -63, -99, -25, -8, -25, -2, -9, -25, -24, -52, -24, -20, 10, 9, -1, -9, -19, -41, -17, 3, 22, 22, 22, 11, 8, -18, -18, -6, 16, 25, 16, 17, 4, -18, -23, -3, -1, 15, 10, -3, -20, -22, -42, -20, -10, -5, -2, -20, -23, -44, -29, -51, -23, -15, -22, -18, -50, -64 } }; private int[,] T_Bishops = new int[3, 64] { { -29, 4, -82, -37, -25, -42, 7, -8, -26, 16, -18, -13, 30, 59, 18, -47, -16, 37, 43, 40, 35, 50, 37, -2, -4, 5, 19, 50, 37, 37, 7, -2, -6, 13, 13, 26, 34, 12, 10, 4, 0, 15, 15, 15, 14, 27, 18, 10, 4, 15, 16, 0, 7, 21, 33, 1, -33, -3, -14, -21, -13, -12, -39, -21 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -14, -21, -11, -8, -7, -9, -17, -24, -8, -4, 7, -12, -3, -13, -4, -14, 2, -8, 0, -1, -2, 6, 0, 4, -3, 9, 12, 9, 14, 10, 3, 2, -6, 3, 13, 19, 7, 10, -3, -9, -12, -3, 8, 10, 13, 3, -7, -15, -14, -18, -7, -1, 4, -9, -15, -27, -23, -9, -23, -5, -9, -16, -5, -17 } }; private int[,] T_Rooks = new int[3, 64] { { 32, 42, 32, 51, 63, 9, 31, 43, 27, 32, 58, 62, 80, 67, 26, 44, -5, 19, 26, 36, 17, 45, 61, 16, -24, -11, 7, 26, 24, 35, -8, -20, -36, -26, -12, -1, 9, -7, 6, -23, -45, -25, -16, -17, 3, 0, -5, -33, -44, -16, -20, -9, -1, 11, -6, -71, -19, -13, 1, 17, 16, 7, -37, -26 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { 13, 10, 18, 15, 12, 12, 8, 5, 11, 13, 13, 11, -3, 3, 8, 3, 7, 7, 7, 5, 4, -3, -5, -3, 4, 3, 13, 1, 2, 1, -1, 2, 3, 5, 8, 4, -5, -6, -8, -11, -4, 0, -5, -1, -7, -12, -8, -16, -6, -6, 0, 2, -9, -9, -11, -3, -9, 2, 3, -1, -5, -13, 4, -20 } }; private int[,] T_Queens = new int[3, 64] { { -28, 0, 29, 12, 59, 44, 43, 45, -24, -39, -5, 1, -16, 57, 28, 54, -13, -17, 7, 8, 29, 56, 47, 57, -27, -27, -16, -16, -1, 17, -2, 1, -9, -26, -9, -10, -2, -4, 3, -3, -14, 2, -11, -2, -5, 2, 14, 5, -35, -8, 11, 2, 8, 15, -3, 1, -1, -18, -9, 10, -15, -25, -31, -50 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -9, 22, 22, 27, 27, 19, 10, 20, -17, 20, 32, 41, 58, 25, 30, 0, -20, 6, 9, 49, 47, 35, 19, 9, 3, 22, 24, 45, 57, 40, 57, 36, -18, 28, 19, 47, 31, 34, 39, 23, -16, -27, 15, 6, 9, 17, 10, 5, -22, -23, -30, -16, -16, -23, -36, -32, -33, -28, -22, -43, -5, -32, -20, -41 } }; private int[,] T_Kings = new int[3, 64] { { -65, 23, 16, -15, -56, -34, 2, 13, 29, -1, -20, -7, -8, -4, -38, -29, -9, 24, 2, -16, -20, 6, 22, -22, -17, -20, -12, -27, -30, -25, -14, -36, -49, -1, -27, -39, -46, -44, -33, -51, -14, -14, -22, -46, -44, -30, -15, -27, 1, 7, -8, -64, -43, -16, 9, 8, -15, 36, 12, -54, 8, -28, 24, 14 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -74, -35, -18, -18, -11, 15, 4, -17, -12, 17, 14, 17, 17, 38, 23, 11, 10, 17, 23, 15, 20, 45, 44, 13, -8, 22, 24, 27, 26, 33, 26, 3, -18, -4, 21, 24, 27, 23, 9, -11, -19, -3, 11, 21, 23, 16, 7, -9, -27, -11, 4, 13, 14, 4, -5, -17, -53, -34, -21, -11, -28, -14, -24, -43 } }; private int[] paramsLowerLimits = new int[5] { -10000, -10000, -10000, -10000, -10000 }; private int[] paramsUpperLimits = new int[5] { 10000, 10000, 10000, 10000, 10000 }; private List<TLM_ChessGame> threadDataset; private int threadFrom, threadTo; private int[] threadParams; private int customThreadID = 0; private ulong ulAllThreadIDsUnfinished = 0; private double lastCostVal = 0d; private double sumCostVals = 0d; private int costCalculations = 0; private readonly string[] TEXELPRINT_GAMEPARTS = new string[3] { "Early Game: ", "Mid Game: ", "Late Game: "}; private readonly string[] TEXELPRINT_PIECES = new string[6] { "Bauer: ", "Springer: ", "Lufer: ", "Turm: ", "Dame: ", "Knig: "}; private double[] earlyGameMultipliers = new double[33]; private double[] middleGameMultipliers = new double[33]; private double[] lateGameMultipliers = new double[33]; private int[] pieceTypeGameProgressImpact = new int[14] { 0, 0, 1, 1, 2, 4, 0, 0, 0, 1, 1, 2, 4, 0 }; private void PrecalculateMultipliers() { if (BOARD_MANAGER_ID == ENGINE_VALS.PARALLEL_BOARDS - 1) SNAPSHOT_WRITLINE_REPLACEMENT(); for (int i = 0; i < 25; i++) { earlyGameMultipliers[i] = EGMultiplierFunction(i); lateGameMultipliers[i] = LGMultiplierFunction(i); if (BOARD_MANAGER_ID == ENGINE_VALS.PARALLEL_BOARDS - 1) SNAPSHOT_WRITLINE_REPLACEMENT("[" + i + "] "+ earlyGameMultipliers[i] + " | "+ middleGameMultipliers[i] + " | "+ lateGameMultipliers[i]); } } private double MultiplierFunction(double pVal, double pXShift) { double d = Math.Exp(1d /6d * (pVal - pXShift)); return 5 * (d /Math.Pow(d + 1, 2d)); } private double EGMultiplierFunction(double pVal) { return Math.Clamp(1 /16d * (pVal - 4d), 0d, 1d); } private double LGMultiplierFunction(double pVal) { return Math.Clamp(1 /-16d * (pVal - 4d) + 1d, 0d, 1d); } private double EGMultiplierFunction2(double pVal) { return Math.Clamp(1 /32d * pVal, 0d, 1d); } private double LGMultiplierFunction2(double pVal) { return Math.Clamp(1 /-32d * pVal + 1d, 0d, 1d); } private void TuneWithTxtFile(string pTXTName) { List<TLM_ChessGame> gameDataset = new List<TLM_ChessGame>(); string tPath = PathManager.GetTXTPath(pTXTName); string[] tStrs = File.ReadAllLines(tPath); List<string> tGames = new List<string>(); foreach (string s in tStrs) if (s.Contains(';') && s.Replace(" ", "") != "") tGames.Add(s); foreach (string s in tGames) { TLM_ChessGame tGame = CGFF.GetGame(s); LoadFenString(tGame.startFen); foreach (int hMove in tGame.hashedMoves) { List<Move> moveOptionList = new List<Move>(); GetLegalMoves(ref moveOptionList); int tL = moveOptionList.Count; for (int j = 0; j < tL; j++) { Move tMove = moveOptionList[j]; if (tMove.moveHash == hMove) { tGame.actualMoves.Add(tMove); PlainMakeMove(tMove); tL = -1; break; } } if (tL != -1) break; } gameDataset.Add(tGame); } SNAPSHOT_WRITLINE_REPLACEMENT("[TLM TEXEL TUNER] " + tGames.Count + " Games Loaded In!"); BOT_MAIN.ParallelTexelTuning(gameDataset); } private void LoadBestTexelParamsIn() { int[] ttt = new int[778] { 82, 341, 416, 470, 1106, 102, 302, 304, 518, 960, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, -46, 0, -20, 0, 64, -21, -71, 37, 29, 6, 98, 13, 44, 0, -26, -14, -36, -20, 94, 16, 60, 10, -62, -19, -38, -8, -28, 14, -26, -4, -32, -28, -52, 30, 56, -40, -72, -22, 100, 4, -98, -34, 6, -49, 32, -10, 72, 20, 84, -56, -60, -112, 128, -28, 152, 34, 26, -52, 200, -56, 76, 44, -56, -113, -156, 188, -39, 28, 200, -90, -60, -86, 100, -178, -119, -200, 200, 200, -20, -22, -78, -158, -200, 196, 200, -200, -200, -200, 104, 200, 138, -122, 200, 200, 124, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 200, 156, -37, -68, -148, -200, 200, -70, 72, 76, -31, -200, -21, 178, -200, 200, 200, -200, 123, -188, -6, 164, -74, 24, -28, -8, 71, -50, -112, -200, -8, -44, 27, -23, -50, 19, 19, 41, 150, 152, 4, -98, -36, -34, 174, -106, -16, 17, 141, -48, -108, 162, 6, -112, -52, 76, 68, 8, -86, 68, -176, 189, 81, 162, -200, 152, -41, 128, 172, -173, -144, 56, 22, 94, -28, 32, 16, -63, 36, -200, -200, -200, -22, 56, -116, 76, -36, -30, 100, 52, -166, -114, 142, -52, -44, -200, -18, -72, 60, 200, -160, 96, 46, -200, -28, -32, -44, 132, 60, -200, -137, -200, -176, 200, -200, -200, 4, 200, -200, 72, 200, -78, 200, 160, -105, 200, 96, -114, 200, 200, -88, -24, 11, -34, 184, 26, 83, -140, 10, -16, -72, -200, 12, -200, 46, -200, 11, 82, 66, -102, 22, -184, 32, 114, 140, -26, -18, -36, 66, 100, 25, -24, 133, -96, 50, 2, 80, 184, 43, -136, 44, 124, -148, 180, 69, -126, -200, 6, 78, -96, 89, -68, 200, -116, 114, 158, 5, -154, 115, 200, -152, -171, 41, -80, -23, 137, 98, -80, 40, -42, 200, 52, 146, 200, 6, -112, 32, 200, 132, 4, 90, -200, -200, 104, 67, -56, 186, 124, 140, 97, -144, 200, -4, -160, -117, -200, 24, -80, 200, 28, -46, -24, -52, -200, -200, 72, 20, 34, 200, -16, 88, 56, 200, -146, 120, 174, 200, -200, -86, 125, 172, -70, 4, 124, -72, 0, -2, 70, -14, 48, -32, 200, 80, 24, -132, 74, -44, 184, -4, -136, 0, -16, 20, -18, -32, 96, 92, 56, 2, 174, 196, -200, -56, -116, 88, 200, -8, 168, -13, 74, -106, 200, -182, 80, 82, -128, -16, 90, -200, 66, -88, 58, -16, 80, -34, 96, -95, -96, -200, 76, 26, -72, 32, -27, -108, 164, 200, -36, -93, -10, -56, 22, 36, 74, -200, -96, 200, 88, -88, 156, -92, 96, -200, 200, 191, -8, 62, -8, -100, 136, -72, -36, 200, -64, -114, 153, -110, 174, 46, 108, 142, 121, -200, 108, -200, 74, -4, 104, -200, 116, 82, 200, -76, 176, -200, 76, -8, 200, 46, 29, -86, 12, -24, -80, -12, 200, 124, -16, 54, 104, 200, -94, 140, 36, 32, -64, 24, -178, 15, -200, 0, -200, 4, -32, -124, 148, 176, 192, 90, 164, -91, 200, 172, -200, 64, 34, 40, -200, 0, -200, 12, -124, 48, -200, -56, 184, -8, -184, 0, 200, -16, 200, -8, 180, -18, -20, 24, -200, -58, 174, -200, 40, -4, -200, -24, 200, 54, 200, -24, -32, 37, 192, 48, 44, 26, 200, -22, 200, -145, -200, 30, 86, 54, 200, -102, -34, 94, -98, 92, -200, -76, 196, -18, -200, -180, 16, 186, -92, -200, -200, 164, -200, 62, 192, 159, -112, -12, -70, 184, 104, 200, -200, -148, -4, 86, -144, 200, -100, 200, 200, -104, 114, 132, -168, 12, 56, -10, 82, 200, -200, -200, -196, -6, 52, -200, 84, 200, -192, 128, 200, -200, -200, 200, 88, 168, -32, -84, 172, 52, -172, 0, -40, 68, -186, 42, 96, -200, -198, 200, -56, -176, 88, 0, 86, 16, -124, -46, 40, -16, -4, 54, -184, 200, 58, -200, 77, -200, -44, 102, 0, -50, -10, -92, 100, -86, 8, 20, -20, -200, 38, -200, -49, -4, 2, -200, 78, 0, -40, -92, 32, 0, -164, -88, -38, -138, -118, 29, -34, -200, -200, -200, -71, -200, 200, -200, -108, -200, 0, 192, -24, 104, -200, 200, 190, -28, -200, -200, -200, 128, -96, 200, 200, 200, 200, -200, -200, 177, -24, 200, 132, 200, -190, 200, -130, 200, 148, 200, 200, -200, -100, 200, -196, -200, 90, 200, -200, 200, 200, -200, -200, -200, -200, -200, 118, -200, 85, -200, 166, 199, -200 }; SetupTexelEvaluationParams(ttt); } private void SetupTexelEvaluationParams(int[] pParams) { texelPieceEvaluationsV2EG[8] = -(texelPieceEvaluationsV2EG[1] = pParams[0]); texelPieceEvaluationsV2EG[9] = -(texelPieceEvaluationsV2EG[2] = pParams[1]); texelPieceEvaluationsV2EG[10] = -(texelPieceEvaluationsV2EG[3] = pParams[2]); texelPieceEvaluationsV2EG[11] = -(texelPieceEvaluationsV2EG[4] = pParams[3]); texelPieceEvaluationsV2EG[12] = -(texelPieceEvaluationsV2EG[5] = pParams[4]); texelPieceEvaluationsV2LG[8] = -(texelPieceEvaluationsV2LG[1] = pParams[5]); texelPieceEvaluationsV2LG[9] = -(texelPieceEvaluationsV2LG[2] = pParams[6]); texelPieceEvaluationsV2LG[10] = -(texelPieceEvaluationsV2LG[3] = pParams[7]); texelPieceEvaluationsV2LG[11] = -(texelPieceEvaluationsV2LG[4] = pParams[8]); texelPieceEvaluationsV2LG[12] = -(texelPieceEvaluationsV2LG[5] = pParams[9]); int c = 10; for (int p = 1; p < 7; p++) { for (int s = 0; s < 64; s++) { texelTuningRuntimePositionalValsV2EG[p + 7][blackSidedSquares[s]] = texelTuningRuntimePositionalValsV2EG[p][s] = pParams[c++]; texelTuningRuntimePositionalValsV2LG[p + 7][blackSidedSquares[s]] = texelTuningRuntimePositionalValsV2LG[p][s] = pParams[c++]; } } } private void PrintDefinedTexelParams(int[] pParams) { int c = 0; for (int t = 0; t < 3; t++) { SNAPSHOT_WRITLINE_REPLACEMENT(TEXELPRINT_GAMEPARTS[t]); for (int p = 0; p < 6; p++) { SNAPSHOT_WRITLINE_REPLACEMENT(TEXELPRINT_PIECES[p]); texelTuningVals[t, p] = new int[64]; for (int s = 0; s < 64; s++) { if (s % 8 == 0 && s != 0) SNAPSHOT_WRITLINE_REPLACEMENT(); SNAPSHOT_WRITLINE_REPLACEMENT((texelTuningVals[t, p][s] = pParams[c++]) + ", "); } SNAPSHOT_WRITLINE_REPLACEMENT(); } } piecePositionEvals = GetInterpolatedProcessedValues(texelTuningVals); } public void TLMTuning(List<TLM_ChessGame> pDataset) { int tGameDataSetLen = pDataset.Count; int[,][] tRatio = new int[33, 6][]; int[,][] tTotalMoves = new int[33, 6][]; double[,][] tSummedRatios = new double[33, 6][]; double[,][] tSummedDataAmount = new double[33, 6][]; double[,][] tTuningResults = new double[33, 6][]; for (int t = 1; t < 33; t++) { for (int p = 0; p < 6; p++) { tRatio[t, p] = new int[64]; tTotalMoves[t, p] = new int[64]; tSummedRatios[t, p] = new double[64]; tSummedDataAmount[t, p] = new double[64]; tTuningResults[t, p] = new double[64]; } } for (int j = 0; j < tGameDataSetLen; j++) { TLM_ChessGame tGame = pDataset[j]; int tGR = tGame.gameResult - 1; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count - 5; for (int i = 0; i < tL; i++) { if (tGame.isMoveNonTactical[i]) { int tPieceAmount = ULONG_OPERATIONS.CountBits(allPieceBitboard); for (int s = 0; s < 64; s++) { int tPT = pieceTypeArray[s] - 1; if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, s)) { tTotalMoves[tPieceAmount, tPT][s]++; tRatio[tPieceAmount, tPT][s] += tGR; } else if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, s)) { int b = blackSidedSquares[s]; tTotalMoves[tPieceAmount, tPT][b]++; tRatio[tPieceAmount, tPT][b] += tGR; } } } PlainMakeMove(tGame.actualMoves[i]); } } double[,] allMultipliers = new double[33, 33]; for (int sh = 0; sh < 33; sh++) { for (int i = 0; i < 33; i++) { allMultipliers[sh, i] = MultiplierFunction(i, sh); } } for (int t = 1; t < 33; t++) { for (int p = 0; p < 6; p++) { for (int s = 0; s < 64; s++) { for (int t2 = 1; t2 < 33; t2++) { double cmult = allMultipliers[t, t2]; tSummedRatios[t, p][s] += tRatio[t2, p][s] * cmult; tSummedDataAmount[t, p][s] += tTotalMoves[t2, p][s] * cmult; } tTuningResults[t, p][s] = TTT(tSummedRatios[t, p][s], tSummedDataAmount[t, p][s]); } } } int c = 0; int[] tparams = new int[1152]; for (int t = 1; t < 33; t += 15) { if (t == 31) t = 32; SNAPSHOT_WRITLINE_REPLACEMENT("PieceCount = " + t + ": "); for (int p = 0; p < 6; p++) { SNAPSHOT_WRITLINE_REPLACEMENT(TEXELPRINT_PIECES[p]); for (int s = 0; s < 64; s++) { if (s % 8 == 0 && s != 0) SNAPSHOT_WRITLINE_REPLACEMENT(); SNAPSHOT_WRITLINE_REPLACEMENT((tparams[c++] = (int)(tTuningResults[t, p][s] * 100)).ToString().Replace(",", ".") + "("+ (int)tSummedDataAmount[t, p][s] + ")"+ ", "); } SNAPSHOT_WRITLINE_REPLACEMENT(); } } string tS = "PARAMS: {"; for (int i = 0; i < tparams.Length; i++) tS += tparams[i] + ","; tS = tS.Substring(0, tS.Length - 1) + "}\n"; SNAPSHOT_WRITLINE_REPLACEMENT(tS); TexelTuning(pDataset, tparams); } private double TTT(double d1, double d2) { if (d2 == 0) return 0; return d1 /d2; } public void TexelTuning(List<TLM_ChessGame> pDataset, int[] pCurBestParams) { Stopwatch sw = Stopwatch.StartNew(); string tPath = PathManager.GetTXTPath("OTHER/TEXEL_TUNING"); int paramCount = pCurBestParams.Length; double bestAvrgCost = CalculateAverageTexelCost(pDataset, pCurBestParams); SNAPSHOT_WRITLINE_REPLACEMENT("CUR PARAMS COST: " + bestAvrgCost); int packetSize = Math.Clamp(paramCount /ENGINE_VALS.CPU_CORES, 1, 100000); paramsLowerLimits = new int[paramCount]; paramsUpperLimits = new int[paramCount]; for (int i = 0; i < paramCount; i++) { int lim = i < 10 ? 100000 : 200; paramsLowerLimits[i] = -lim; paramsUpperLimits[i] = lim; } SNAPSHOT_WRITLINE_REPLACEMENT("PARAM-COUNT: " + paramCount); SNAPSHOT_WRITLINE_REPLACEMENT("PACKET-SIZE: " + packetSize); while (packetSize <= paramCount) { BOT_MAIN.TEXELfinished = 0; int lM = 0, tC = 0; ulong tUL = 0ul; for (int m = packetSize; lM < paramCount; m += packetSize) { if (m > paramCount) m = paramCount; tUL = ULONG_OPERATIONS.SetBitToOne(tUL, ++tC); lM = m; } tC = lM = 0; for (int m = packetSize; lM < paramCount; m += packetSize) { if (m > paramCount) m = paramCount; tC++; BOT_MAIN.boardManagers[tC].SetPlayTexelVals(pDataset, lM, m, pCurBestParams, paramsLowerLimits, paramsUpperLimits, tC, tUL); ThreadPool.QueueUserWorkItem(new WaitCallback(BOT_MAIN.boardManagers[tC].TexelTuningThreadedPackage)); lM = m; } packetSize = paramCount + 1; int tmod = 0; while (tC != BOT_MAIN.TEXELfinished) { if (++tmod % 20 == 0) { WriteTexelParamsToTXT(tPath, BOT_MAIN.curTEXELPARAMS); SNAPSHOT_WRITLINE_REPLACEMENT(CalculateAverageTexelCost(pDataset, BOT_MAIN.curTEXELPARAMS) + " | "+ BOT_MAIN.TEXELadjustmentsmade); SNAPSHOT_WRITLINE_REPLACEMENT(ULONG_OPERATIONS.GetBitVisualization(BOT_MAIN.TEXELfinishedwithoutimpovement)); } Thread.Sleep(100); } SNAPSHOT_WRITLINE_REPLACEMENT("One Thread Generation FINISHED! :) :) :)"); pCurBestParams = BOT_MAIN.curTEXELPARAMS; } sw.Stop(); WriteTexelParamsToTXT(tPath, BOT_MAIN.curTEXELPARAMS); SNAPSHOT_WRITLINE_REPLACEMENT("END COST: " + CalculateAverageTexelCost(pDataset, BOT_MAIN.curTEXELPARAMS)); SNAPSHOT_WRITLINE_REPLACEMENT(BOT_MAIN.TEXELadjustmentsmade); SNAPSHOT_WRITLINE_REPLACEMENT(sw.ElapsedMilliseconds); } public void TexelTuningThreadedPackage(object obj) { SNAPSHOT_WRITLINE_REPLACEMENT("Started CThreadID [" + customThreadID + "] which is handling Params ["+ threadFrom + "] - ["+ threadTo + "]"); bool firstIter = true; do { double bestAvrgCost = CalculateAverageTexelCost(threadDataset, threadParams); int adjust_val = firstIter ? 512 : 8; do { adjust_val /= 2; bool improvedAvrgCost = true; while (improvedAvrgCost) { improvedAvrgCost = false; for (int i = threadFrom; i < threadTo; i++) { bool improvedWithThisParam = true; int tadjustval = adjust_val; bool lastTimeMaximized = false, lastTimeMinimized = false; while (improvedWithThisParam) { improvedWithThisParam = false; int[] curParams = (int[])threadParams.Clone(); int paramBefore = curParams[i]; curParams[i] = Math.Clamp(paramBefore + adjust_val, paramsLowerLimits[i], paramsUpperLimits[i]); double curAvrgCost = CalculateAverageTexelCost(threadDataset, curParams); if (curAvrgCost < bestAvrgCost) { improvedAvrgCost = true; improvedWithThisParam = true; SNAPSHOT_WRITLINE_REPLACEMENT("Improved Param [" + i + "] at CThreadID ["+ customThreadID + "]: +"+ adjust_val + " ("+ GetDoublePrecentageString(bestAvrgCost - curAvrgCost) + ")"); bestAvrgCost = curAvrgCost; threadParams = curParams; BOT_MAIN.TEXELadjustmentsmade++; BOT_MAIN.TEXELfinishedwithoutimpovement = ulAllThreadIDsUnfinished; if (lastTimeMaximized) { adjust_val *= 4; lastTimeMaximized = false; } else lastTimeMaximized = true; lastTimeMinimized = false; } else { curParams[i] = Math.Clamp(paramBefore - adjust_val, paramsLowerLimits[i], paramsUpperLimits[i]); curAvrgCost = CalculateAverageTexelCost(threadDataset, curParams); if (curAvrgCost < bestAvrgCost) { improvedAvrgCost = true; improvedWithThisParam = true; SNAPSHOT_WRITLINE_REPLACEMENT("Improved Param [" + i + "] at CThreadID ["+ customThreadID + "]: -"+ adjust_val + " ("+ GetDoublePrecentageString(bestAvrgCost - curAvrgCost) + ")"); bestAvrgCost = curAvrgCost; threadParams = curParams; BOT_MAIN.TEXELadjustmentsmade++; BOT_MAIN.TEXELfinishedwithoutimpovement = ulAllThreadIDsUnfinished; if (lastTimeMinimized) { adjust_val *= 4; lastTimeMinimized = false; } else lastTimeMinimized = true; lastTimeMaximized = false; } } if (adjust_val != 1) adjust_val /= 2; for (int j = threadFrom; j < threadTo; j++) { BOT_MAIN.curTEXELPARAMS[j] = threadParams[j]; } threadParams = (int[])BOT_MAIN.curTEXELPARAMS.Clone(); bestAvrgCost = CalculateAverageTexelCost(threadDataset, threadParams); } adjust_val = tadjustval; } } } while (adjust_val != 1); BOT_MAIN.TEXELfinishedwithoutimpovement = ULONG_OPERATIONS.SetBitToZero(BOT_MAIN.TEXELfinishedwithoutimpovement, customThreadID); SNAPSHOT_WRITLINE_REPLACEMENT("FULLY FINISHED " + customThreadID + ". IMPROVEMENT THREAD PACKAGE CYCLE"); firstIter = false; } while (BOT_MAIN.TEXELfinishedwithoutimpovement != 0); BOT_MAIN.TEXELfinished++; } private void WriteTexelParamsToTXT(string pPath, int[] pParams) { try { string tS = "PARAMS: {"; for (int i = 0; i < pParams.Length; i++) tS += pParams[i] + ","; tS = tS.Substring(0, tS.Length - 1) + "}\n"; File.AppendAllText(pPath, tS); } catch { SNAPSHOT_WRITLINE_REPLACEMENT("Mal wieder TXT zu lange gebraucht um zu aktualisieren."); } } private double costSum = 0d; private int texelCostMovesEvaluated = 0; private double CalculateAverageTexelCost(List<TLM_ChessGame> tDataset, int[] pParams, bool pFullCost = true) { costSum = 0d; texelCostMovesEvaluated = 0; SetupTexelEvaluationParams(pParams); int tGameDataSetLen = tDataset.Count; int start = 0, end = tGameDataSetLen; if (!pFullCost) { end = (start = globalRandom.Next(0, end - 256)) + 256; } for (int j = start; j < end; j++) { TLM_ChessGame tGame = tDataset[j]; double tGR = tGame.gameResult; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count - 5; texelCostMovesEvaluated += tL; for (int i = 0; i < tL; i++) { costSum += TexelCost(tGR - TexelTuningSigmoid(TexelEvaluate())); PlainMakeMove(tGame.actualMoves[i]); } } return costSum /texelCostMovesEvaluated; } private double CalculateAverageTexelCostThreadedVersionLEGACYDOESNTWORK(List<TLM_ChessGame> tDataset, int[] pParams) { Stopwatch sw = Stopwatch.StartNew(); BOT_MAIN.TEXELcostSum = 0d; BOT_MAIN.TEXELfinished = 0; BOT_MAIN.TEXELcostMovesEvaluated = 0; int tGameDataSetLen = tDataset.Count; int gamesPerThread = tGameDataSetLen /ENGINE_VALS.CPU_CORES; for (int i = 0; i < ENGINE_VALS.CPU_CORES - 1; i++) { } for (int i = 0; i < ENGINE_VALS.CPU_CORES - 1; i++) { } while (BOT_MAIN.TEXELfinished != ENGINE_VALS.CPU_CORES) Thread.Sleep(1); sw.Stop(); return BOT_MAIN.TEXELcostSum /BOT_MAIN.TEXELcostMovesEvaluated; } public void SetPlayThroughVals(List<TLM_ChessGame> pDataset, int pFrom, int pTo) { threadDataset = pDataset; threadFrom = pFrom; threadTo = pTo; } public void SetPlayTexelVals(List<TLM_ChessGame> pDataset, int pFrom, int pTo, int[] pTexelParams, int[] pLowerLimits, int[] pUpperLimits, int pThreadID, ulong pUL) { threadDataset = pDataset; threadFrom = pFrom; threadTo = pTo; threadParams = pTexelParams; paramsLowerLimits = pLowerLimits; paramsUpperLimits = pUpperLimits; customThreadID = pThreadID; ulAllThreadIDsUnfinished = pUL; } public void PlayThroughSetOfGames(object obj) { SNAPSHOT_WRITLINE_REPLACEMENT(threadFrom + "->"+ threadTo); int sortedOut = 0; for (int j = threadFrom; j < threadTo; j++) { TLM_ChessGame tGame = threadDataset[j]; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count; for (int i = 0; i < tL; i++) { int tQuietEval = isWhiteToMove ? QuiescenceWhite(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, 0, PreMinimaxCheckCheckWhite(), NULL_MOVE) : QuiescenceBlack(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, 0, PreMinimaxCheckCheckBlack(), NULL_MOVE); bool tB; tGame.isMoveNonTactical.Add(tB = (Evaluate() == tQuietEval && i > 4)); if (!tB) sortedOut++; PlainMakeMove(tGame.actualMoves[i]); } } BOT_MAIN.TEXELsortedout += sortedOut; BOT_MAIN.TEXELfinished++; } public void CalculateAverageTexelCostThreadFunction(object obj) { SetupTexelEvaluationParams(threadParams); double d = 0d; for (int j = threadFrom; j < threadTo; j++) { TLM_ChessGame tGame = threadDataset[j]; double tGR = tGame.gameResult; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count - 5; BOT_MAIN.TEXELcostMovesEvaluated += tL; for (int i = 0; i < tL; i++) { d += TexelCost(tGR - TexelTuningSigmoid(TexelEvaluate())); PlainMakeMove(tGame.actualMoves[i]); } } BOT_MAIN.TEXELcostSum += d; BOT_MAIN.TEXELfinished++; } private void ConsoleWriteLineTuneArray<T>(T[,][] pArr) { for (int j = 0; j < 3; j++) { SNAPSHOT_WRITLINE_REPLACEMENT("{"); for (int k = 0; k < 6; k++) { SNAPSHOT_WRITLINE_REPLACEMENT("{"); for (int s = 0; s < 64; s++) SNAPSHOT_WRITLINE_REPLACEMENT(pArr[j, k][s] + ", "); SNAPSHOT_WRITLINE_REPLACEMENT("\n}"); } SNAPSHOT_WRITLINE_REPLACEMENT("}"); } } private void Tune(string pGameCGFF, double pLearningRate) { TLM_ChessGame tGame = CGFF.GetGame(pGameCGFF); LoadFenString(tGame.startFen); double tDGameResult = tGame.gameResult; foreach (int hMove in tGame.hashedMoves) { Tune(tDGameResult, pLearningRate); List<Move> moveOptionList = new List<Move>(); GetLegalMoves(ref moveOptionList); int tL = moveOptionList.Count; for (int i = 0; i < tL; i++) { Move tMove = moveOptionList[i]; if (tMove.moveHash == hMove) { PlainMakeMove(tMove); tL = -1; break; } } if (tL != -1) break; } } private void Tune(double pGameResult, double pLearningRate) { int tPC = ULONG_OPERATIONS.CountBits(allPieceBitboard); double oneThroughPieceCount = 1d /tPC; double egMult = earlyGameMultipliers[tPC], mgMult = middleGameMultipliers[tPC], lgMult = lateGameMultipliers[tPC]; double tTexelResult = TexelEvaluateF(); double tSigmoidedTexelResult = TexelSigmoid(tTexelResult); double tDif = tSigmoidedTexelResult - pGameResult; double tM = oneThroughPieceCount * TexelCostDerivative(tDif) * TexelSigmoidDerivative(tTexelResult) * pLearningRate; sumCostVals += lastCostVal = TexelCost(tDif); costCalculations++; for (int i = 0; i < 64; i++) { if (ULONG_OPERATIONS.IsBitZero(allPieceBitboard, i)) continue; int tPT = pieceTypeArray[i] - 1, tI = i; if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, i)) tI = blackSidedSquares[i]; texelTuningAdjustIterations[tPT, tI]++; } } private double TexelEvaluateF() { texelTuningRuntimeVals = GetInterpolatedProcessedValues(texelTuningVals); return TexelEvaluate(); } private int TexelEvaluate() { int tEvalEG = 0, tEvalLG = 0, tProgress = 0; for (int p = 0; p < 64; p++) { if (((int)(allPieceBitboard >> p) & 1) == 0) continue; int tPT = pieceTypeArray[p] + 7 * ((int)(blackPieceBitboard >> p) & 1); tEvalEG += texelTuningRuntimePositionalValsV2EG[tPT][p] + texelPieceEvaluationsV2EG[tPT]; tEvalLG += texelTuningRuntimePositionalValsV2LG[tPT][p] + texelPieceEvaluationsV2LG[tPT]; tProgress += pieceTypeGameProgressImpact[tPT]; } if (tProgress > 24) { tProgress = 24; } return (int)(earlyGameMultipliers[tProgress] * tEvalEG + lateGameMultipliers[tProgress] * tEvalLG); } private const double TexelK = 0.2; private double TexelTuningSigmoid(double pVal) { return 2d /(1 + Math.Pow(10, -TexelK * pVal /400)); } private double TexelSigmoid(double pVal) { return 2d /(Math.Exp(-0.04d * pVal) + 1d); } private double TexelSigmoidDerivative(double pVal) { double d = Math.Exp(-0.04d * pVal); return 2d * d /(25d * (d + 1d) * (d + 1d)); } private double TexelCost(double pVal) { return pVal * pVal; } private double TexelCostDerivative(double pVal) { return 2 * pVal; } private char[] fenPieces = new char[7] { 'z', 'p', 'n', 'b', 'r', 'q', 'k' }; private string[] squareNames = new string[64] { "a1", "b1", "c1", "d1", "e1", "f1", "g1", "h1", "a2", "b2", "c2", "d2", "e2", "f2", "g2", "h2", "a3", "b3", "c3", "d3", "e3", "f3", "g3", "h3", "a4", "b4", "c4", "d4", "e4", "f4", "g4", "h4", "a5", "b5", "c5", "d5", "e5", "f5", "g5", "h5", "a6", "b6", "c6", "d6", "e6", "f6", "g6", "h6", "a7", "b7", "c7", "d7", "e7", "f7", "g7", "h7", "a8", "b8", "c8", "d8", "e8", "f8", "g8", "h8"}; public string CreateFenString() { string rFEN = ""; for (int i = 7; i >= 0; i--) { int t = 0; for (int j = 0; j < 8; j++) { int sq = i * 8 + j; if (pieceTypeArray[sq] != 0) { if (t != 0) rFEN += t; t = 0; } if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, sq)) { switch (pieceTypeArray[sq]) { case 0: t++; SNAPSHOT_WRITLINE_REPLACEMENT("???"); break; case 1: rFEN += 'P'; break; case 2: rFEN += 'N'; break; case 3: rFEN += 'B'; break; case 4: rFEN += 'R'; break; case 5: rFEN += 'Q'; break; case 6: rFEN += 'K'; break; } } else { switch (pieceTypeArray[sq]) { case 0: t++; break; case 1: rFEN += 'p'; break; case 2: rFEN += 'n'; break; case 3: rFEN += 'b'; break; case 4: rFEN += 'r'; break; case 5: rFEN += 'q'; break; case 6: rFEN += 'k'; break; } } } if (t != 0) rFEN += t; if (i != 0) rFEN += "/"; } rFEN += (isWhiteToMove ? " w": " b"); rFEN += (whiteCastleRightKingSide ? " K": " "); rFEN += (whiteCastleRightQueenSide ? "Q": ""); rFEN += (blackCastleRightKingSide ? "k": ""); rFEN += (blackCastleRightQueenSide ? "q": ""); if (!whiteCastleRightKingSide && !whiteCastleRightQueenSide && !blackCastleRightKingSide && !blackCastleRightQueenSide) rFEN += "-"; if (enPassantSquare < 64) rFEN += " "+ squareNames[enPassantSquare] + " "; else rFEN += " - "; return rFEN + fiftyMoveRuleCounter + " "+ ((happenedHalfMoves - happenedHalfMoves % 2) /2); } public void LoadFenString(string fenStr) { lastMadeMove = NULL_MOVE; zobristKey = 0ul; whitePieceBitboard = blackPieceBitboard = allPieceBitboard = 0ul; for (int i = 0; i < 64; i++) pieceTypeArray[i] = 0; string[] spaceSpl = fenStr.Split(' '); string[] rowSpl = spaceSpl[0].Split('/'); string epstr = spaceSpl[3]; if (epstr == "-") enPassantSquare = 65; else enPassantSquare = (epstr[0] - 'a') + 8 * (epstr[1] - '1'); isWhiteToMove = true; if (spaceSpl[1] == "b") isWhiteToMove = false; if (!isWhiteToMove) zobristKey ^= blackTurnHash; string crstr = spaceSpl[2]; whiteCastleRightKingSide = whiteCastleRightQueenSide = blackCastleRightKingSide = blackCastleRightQueenSide = false; int crStrL = crstr.Length; for (int i = 0; i < crStrL; i++) { switch (crstr[i]) { case 'K': whiteCastleRightKingSide = true; break; case 'Q': whiteCastleRightQueenSide = true; break; case 'k': blackCastleRightKingSide = true; break; case 'q': blackCastleRightQueenSide = true; break; } } fiftyMoveRuleCounter = Convert.ToInt32(spaceSpl[4]); happenedHalfMoves = Convert.ToInt32(spaceSpl[5]) * 2; if (!isWhiteToMove) happenedHalfMoves++; int tSq = 0; for (int i = rowSpl.Length; i-- > 0;) { string tStr = rowSpl[i]; int tStrLen = tStr.Length; for (int c = 0; c < tStrLen; c++) { char tChar = tStr[c]; if (Char.IsDigit(tChar)) tSq += tChar - '0'; else { bool tCol = Char.IsLower(tChar); if (tCol) blackPieceBitboard = ULONG_OPERATIONS.SetBitToOne(blackPieceBitboard, tSq); else whitePieceBitboard = ULONG_OPERATIONS.SetBitToOne(whitePieceBitboard, tSq); if (tChar == 'k') blackKingSquare = tSq; else if (tChar == 'K') whiteKingSquare = tSq; pieceTypeArray[tSq] = Array.IndexOf(fenPieces, Char.ToLower(tChar)); if (tCol) zobristKey ^= pieceHashesBlack[tSq, pieceTypeArray[tSq]]; else zobristKey ^= pieceHashesWhite[tSq, pieceTypeArray[tSq]]; tSq++; } } } if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; zobristKey ^= enPassantSquareHashes[enPassantSquare]; allPieceBitboard = whitePieceBitboard | blackPieceBitboard; if (zobristKey == 16260251586586513106) moveHashList.Clear(); else { moveHashList.Clear(); moveHashList.Add(1); moveHashList.Add(2); moveHashList.Add(3); } } private ulong[,] pieceHashesWhite = new ulong[64, 7], pieceHashesBlack = new ulong[64, 7]; private ulong blackTurnHash, whiteKingSideRochadeRightHash, whiteQueenSideRochadeRightHash, blackKingSideRochadeRightHash, blackQueenSideRochadeRightHash; private ulong[] enPassantSquareHashes = new ulong[66]; private void InitZobrist() { Random rng = new Random(31415926); for (int sq = 0; sq < 64; sq++) { enPassantSquareHashes[sq] = ULONG_OPERATIONS.GetRandomULONG(rng); for (int it = 1; it < 7; it++) { pieceHashesWhite[sq, it] = ULONG_OPERATIONS.GetRandomULONG(rng); pieceHashesBlack[sq, it] = ULONG_OPERATIONS.GetRandomULONG(rng); } } blackTurnHash = ULONG_OPERATIONS.GetRandomULONG(rng); whiteKingSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); whiteQueenSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); blackKingSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); blackQueenSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); } public void SetKnightMasks(ulong[] uls) { knightSquareBitboards = uls; } public void SetKingMasks(ulong[] uls) { kingSquareBitboards = uls; } private Move[,] whiteEnPassantMoves = new Move[64, 64]; private Move[,] blackEnPassantMoves = new Move[64, 64]; private bool[] epValidationArray = new bool[64] { false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true , true , true , true , true , true , true , true, true , true , true , true , true , true , true , true, true , true , true , true , true , true , true , true, true , true , true , true , true , true , true , true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false }; private void PrecalculateEnPassantMoves() { for (int i = 0; i < 64; i++) { if (!epValidationArray[i]) continue; for (int j = 0; j < 64; j++) { if (i == j) continue; if (Math.Abs(i - j) > 9) continue; if (!epValidationArray[j]) continue; whiteEnPassantMoves[i, j] = new Move(false, i, j, j - 8); blackEnPassantMoves[i, j] = new Move(false, i, j, j + 8); } } } private void PawnAttackBitboards() { for (int sq = 0; sq < 64; sq++) { ulong u = 0ul; if (sq % 8 != 0) u = ULONG_OPERATIONS.SetBitToOne(u, sq + 7); if (sq % 8 != 7) u = ULONG_OPERATIONS.SetBitToOne(u, sq + 9); whitePawnAttackSquareBitboards[sq] = u; u = 0ul; if (sq % 8 != 0 && sq - 9 > -1) u = ULONG_OPERATIONS.SetBitToOne(u, sq - 9); if (sq % 8 != 7 && sq - 7 > -1) u = ULONG_OPERATIONS.SetBitToOne(u, sq - 7); blackPawnAttackSquareBitboards[sq] = u; } } private int[] squareConnectivesPrecalculationArray = new int[4096]; public int[] squareConnectivesCrossDirsPrecalculationArray { get; set; } = new int[4096]; private ulong[] squareConnectivesPrecalculationRayArray = new ulong[4096]; private ulong[] squareConnectivesPrecalculationLineArray = new ulong[4096]; private List<Dictionary<ulong, int>> rayCollidingSquareCalculations = new List<Dictionary<ulong, int>>(); private readonly int[] maxIntWithSpecifiedBitcount = new int[8] { 0, 0b1, 0b11, 0b111, 0b1111, 0b11111, 0b111111, 0b1111111 }; private List<ulong> differentRays = new List<ulong>(); private void SquareConnectivesPrecalculations() { for (int square = 0; square < 64; square++) { rayCollidingSquareCalculations.Add(new Dictionary<ulong, int>()); rayCollidingSquareCalculations[square].Add(0ul, square); for (int square2 = 0; square2 < 64; square2++) { if (square == square2) continue; int t = 0, t2 = 0, difSign = Math.Sign(square2 - square), itSq = square, g = 0; ulong tRay = 0ul, tExclRay = 0ul; List<int> tRayInts = new List<int>(); if (difSign == -1) g = 7; if (square % 8 == square2 % 8) { t2 = t = 1; while ((itSq += difSign * 8) < 64 && itSq > -1) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } } else if ((square - square % 8) == (square2 - square2 % 8)) { t = 1; t2 = -1; while ((itSq += difSign) % 8 != g && itSq > -1 && itSq < 64) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } } else { int dif = Math.Abs(square2 - square); if (dif % 7 == 0) { t = 2; t2 = 2; g = (difSign == 1) ? 7 : 0; while ((itSq += difSign * 7) % 8 != g && itSq < 64 && itSq > -1) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } if (ULONG_OPERATIONS.IsBitZero(tRay, square2)) { t2 = t = 0; tRay = 0ul; } } else if (dif % 9 == 0) { t = 2; t2 = -2; if (square == 0 && square2 == 63 || square == 63 && square2 == 0) SNAPSHOT_WRITLINE_REPLACEMENT("!"); while ((itSq += difSign * 9) % 8 != g && itSq < 64 && itSq > -1) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } if (ULONG_OPERATIONS.IsBitZero(tRay, square2)) { t2 = t = 0; tRay = 0ul; } } } if (square == 0 && square2 == 63) { t2 = t = 2; tRayInts.Clear(); tExclRay = tRay = ULONG_OPERATIONS.SetBitsToOne(0ul, 9, 18, 27, 36, 45, 54, 63); tRayInts = new List<int>() { 9, 18, 27, 36, 45, 54, 63 }; } else if (square2 == 0 && square == 63) { t = 2; tRayInts.Clear(); t2 = -2; tExclRay = tRay = ULONG_OPERATIONS.SetBitsToOne(0ul, 0, 9, 18, 27, 36, 45, 54); tRayInts = new List<int>() { 54, 45, 36, 27, 18, 9, 0 }; } if (tRay != 0ul && !differentRays.Contains(tRay)) { differentRays.Add(tRay); int ccount, combI = maxIntWithSpecifiedBitcount[ccount = ULONG_OPERATIONS.CountBits(tRay)]; do { ulong curAllPieceBitboard = 0ul; int solution = square; for (int j = 0; j < ccount; j++) { if (((combI >> j) & 1) == 1) { curAllPieceBitboard = ULONG_OPERATIONS.SetBitToOne(curAllPieceBitboard, tRayInts[j]); if (solution == square) solution = tRayInts[j]; } } rayCollidingSquareCalculations[square].Add(curAllPieceBitboard, solution); } while (--combI != 0); } squareConnectivesPrecalculationArray[square << 6 | square2] = t; squareConnectivesPrecalculationRayArray[square << 6 | square2] = tRay; squareConnectivesCrossDirsPrecalculationArray[square << 6 | square2] = t2; if (t != 0) squareConnectivesPrecalculationLineArray[square << 6 | square2] = (square == 0 && square2 == 63 || square2 == 0 && square == 63) ? tExclRay : ULONG_OPERATIONS.SetBitToOne(tExclRay, square2); if (squareConnectivesPrecalculationLineArray[square << 6 | square2] == 0ul && ULONG_OPERATIONS.IsBitOne(knightSquareBitboards[square], square2)) squareConnectivesPrecalculationLineArray[square << 6 | square2] = 1ul << square2; } differentRays.Clear(); } } public void SNAPSHOT_WRITLINE_REPLACEMENT() { } public void SNAPSHOT_WRITLINE_REPLACEMENT(object pStr) { } private string GetDoublePrecentageString(double pVal) { return ((int)(pVal * 1_000_000) /10_000d) + "%"; } private string ReplaceAllULONGIsBitOne(string pCode) { const string METHOD_NAME = "ULONG_OPERATIONS.IsBitOne"; int METHOD_NAME_LEN = METHOD_NAME.Length, iterations = 0; int pIndex = pCode.IndexOf(METHOD_NAME); while (pIndex != -1 && ++iterations < 10_000) { List<int> paramIndexes = new List<int>(); int openedBracketCount = 1, closedBracketCount = 0, a = METHOD_NAME_LEN + pIndex; string tpCode = pCode.Substring(0, pIndex); paramIndexes.Add(a + 1); while (++a < pCode.Length) { switch (pCode[a]) { case '(': openedBracketCount++; break; case ')': if (++closedBracketCount == openedBracketCount) { pIndex = a; a = int.MaxValue - 5; } break; case ',': if (openedBracketCount - closedBracketCount == 1) paramIndexes.Add(a + 1); break; } } if (openedBracketCount == closedBracketCount && paramIndexes.Count == 2) { tpCode += "((int)("+ pCode.Substring(paramIndexes[0], paramIndexes[1] - paramIndexes[0] - 1) + (pCode[paramIndexes[1]] == ' ' ? " >> (": " >> (") + pCode.Substring(paramIndexes[1], pIndex - paramIndexes[1]) + ")) & 1) == 1"+ pCode.Substring(pIndex + 1, pCode.Length - pIndex - 1); } pIndex = (pCode = tpCode).IndexOf(METHOD_NAME); } SNAPSHOT_WRITLINE_REPLACEMENT(iterations + " ITERATIONS"); return pCode; } private string ReplaceAllULONGIsBitZero(string pCode) { const string METHOD_NAME = "ULONG_OPERATIONS.IsBitZero"; int METHOD_NAME_LEN = METHOD_NAME.Length, iterations = 0; int pIndex = pCode.IndexOf(METHOD_NAME); while (pIndex != -1 && ++iterations < 10_000) { List<int> paramIndexes = new List<int>(); int openedBracketCount = 1, closedBracketCount = 0, a = METHOD_NAME_LEN + pIndex; string tpCode = pCode.Substring(0, pIndex); paramIndexes.Add(a + 1); while (++a < pCode.Length) { switch (pCode[a]) { case '(': openedBracketCount++; break; case ')': if (++closedBracketCount == openedBracketCount) { pIndex = a; a = int.MaxValue - 5; } break; case ',': if (openedBracketCount - closedBracketCount == 1) paramIndexes.Add(a + 1); break; } } if (openedBracketCount == closedBracketCount && paramIndexes.Count == 2) { tpCode += "((int)("+ pCode.Substring(paramIndexes[0], paramIndexes[1] - paramIndexes[0] - 1) + (pCode[paramIndexes[1]] == ' ' ? " >>": " >> ") + pCode.Substring(paramIndexes[1], pIndex - paramIndexes[1]) + ") & 1) == 0"+ pCode.Substring(pIndex + 1, pCode.Length - pIndex - 1); } pIndex = (pCode = tpCode).IndexOf(METHOD_NAME); } SNAPSHOT_WRITLINE_REPLACEMENT(iterations + " ITERATIONS"); return pCode; } private string GetThreeDigitSeperatedInteger(int pInt) { string s = pInt.ToString(), r = s[0].ToString(); int t = s.Length % 3; for (int i = 1; i < s.Length; i++) { if (i % 3 == t) r += "."; r += s[i]; } s = ""; for (int i = 0; i < r.Length; i++) s += r[i]; return s; } public double GetAverageDepth() { return (double)depths /(double)searches; } }
public class SNAPSHOT_V01_00_001 : IBoardManager  { public int TEXEL_PARAMS { get; } = 778; private const int BESTMOVE_SORT_VAL = -2_000_000_000; private const int CAPTURE_SORT_VAL = -1_000_000_000; private const int KILLERMOVE_SORT_VAL = -1000; private readonly int[,] MVVLVA_TABLE = new int[7, 7] { { 0, 0, 0, 0, 0, 0, 0 }, { 0, 1500, 1400, 1300, 1200, 1100, 1000 }, { 0, 3500, 3400, 3300, 3200, 3100, 3000 }, { 0, 4500, 4400, 4300, 4200, 4100, 4000 }, { 0, 5500, 5400, 5300, 5200, 5100, 5000 }, { 0, 9500, 9400, 9300, 9200, 9100, 9000 }, { 0, 0, 0, 0, 0, 0, 0 }}; private int BOARD_MANAGER_ID = -1; private bool debugSearchDepthResults = false; private bool debugSortResults = false; private RookMovement rookMovement; private BishopMovement bishopMovement; private QueenMovement queenMovement; private KnightMovement knightMovement; private KingMovement kingMovement; private WhitePawnMovement whitePawnMovement; private BlackPawnMovement blackPawnMovement; private Rays rays; public List<Move> moveOptionList { get; set; } private int[] pieceTypeArray = new int[64]; public ulong whitePieceBitboard, blackPieceBitboard, allPieceBitboard; private ulong zobristKey; private int whiteKingSquare, blackKingSquare, enPassantSquare = 65, happenedHalfMoves = 0, fiftyMoveRuleCounter = 0; private bool whiteCastleRightKingSide, whiteCastleRightQueenSide, blackCastleRightKingSide, blackCastleRightQueenSide; private bool isWhiteToMove; private const ulong WHITE_KING_ROCHADE = 96, WHITE_QUEEN_ROCHADE = 14, BLACK_KING_ROCHADE = 6917529027641081856, BLACK_QUEEN_ROCHADE = 1008806316530991104, WHITE_QUEEN_ATTK_ROCHADE = 12, BLACK_QUEEN_ATTK_ROCHADE = 864691128455135232; private readonly Move mWHITE_KING_ROCHADE = new Move(4, 6, 7, 5), mWHITE_QUEEN_ROCHADE = new Move(4, 2, 0, 3), mBLACK_KING_ROCHADE = new Move(60, 62, 63, 61), mBLACK_QUEEN_ROCHADE = new Move(60, 58, 56, 59); private ulong[] knightSquareBitboards = new ulong[64]; private ulong[] whitePawnAttackSquareBitboards = new ulong[64]; private ulong[] blackPawnAttackSquareBitboards = new ulong[64]; private ulong[] kingSquareBitboards = new ulong[64]; private bool[,] pieceTypeAbilities = new bool[7, 3] { { false, false, false }, { false, false, false }, { false, false, false }, { false, false, true }, { false, true, false }, { false, true, true }, { false, false, false } }; private List<int> moveHashList = new List<int>(); private ulong[] curSearchZobristKeyLine = Array.Empty<ulong>(); private Stopwatch globalTimer = Stopwatch.StartNew(); private Move lastMadeMove; private int depths, searches; private Random globalRandom = new Random(); public SNAPSHOT_V01_00_001(string fen) { Setup(fen); } public void Setup(string pFen) { Stopwatch setupStopwatch = Stopwatch.StartNew(); BOARD_MANAGER_ID = BOT_MAIN.curBoardManagerID; for (int i = 0; i < 33; i++) for (int j = 0; j < 14; j++) piecePositionEvals[i, j] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; for (int i = 0; i < 33; i++) for (int j = 0; j < 14; j++) texelTuningRuntimeVals[i, j] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; for (int i = 0; i < 3; i++) for (int j = 0; j < 6; j++) texelTuningVals[i, j] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; for (int i = 0; i < 14; i++) { texelTuningRuntimePositionalValsV2EG[i] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; texelTuningRuntimePositionalValsV2LG[i] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; } PrecalculateKingSafetyBitboards(); PrecalculateMultipliers(); GetLowNoisePositionalEvaluation(globalRandom); MinimaxRoot(1L); SetupConsoleWrite("[PRECALCS] Zobrist Hashing"); InitZobrist(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Knight Movement"); knightMovement = new KnightMovement(this); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Square Connectives"); SquareConnectivesPrecalculations(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Pawn Attack Bitboards"); PawnAttackBitboards(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Rays"); rays = new Rays(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); queenMovement = new QueenMovement(this); SetupConsoleWrite("[PRECALCS] Rook Movement"); rookMovement = new RookMovement(this, queenMovement); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Bishop Movement"); bishopMovement = new BishopMovement(this, queenMovement); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] King Movement"); kingMovement = new KingMovement(this); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Pawn Movement"); whitePawnMovement = new WhitePawnMovement(this); blackPawnMovement = new BlackPawnMovement(this); PrecalculateEnPassantMoves(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWriteLine("[DONE]\n\n"); LoadFenString(pFen); LoadBestTexelParamsIn(); setupStopwatch.Stop(); } private void SetupConsoleWriteLine(string pStr) { if (BOT_MAIN.isFirstBoardManagerInitialized) return; SNAPSHOT_WRITLINE_REPLACEMENT(pStr); } private void SetupConsoleWrite(string pStr) { if (BOT_MAIN.isFirstBoardManagerInitialized) return; SNAPSHOT_WRITLINE_REPLACEMENT(pStr); } public void GetLowNoisePositionalEvaluation(System.Random rng) { int[,][] digitArray = new int[3, 6][]; for (int i = 0; i < 3; i++) for (int j = 0; j < 6; j++) digitArray[i, j] = GetRand64IntArray(rng, -5, 6); lowNoisePositionEvals1 = GetInterpolatedProcessedValues(digitArray); int[,][] digitArray2 = new int[3, 6][]; for (int i = 0; i < 3; i++) for (int j = 0; j < 6; j++) digitArray2[i, j] = GetRand64IntArray(rng, -5, 6); lowNoisePositionEvals2 = GetInterpolatedProcessedValues(digitArray2); } private int[] GetRand64IntArray(System.Random rng, int pMin, int pMax) { return new int[64] { rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax) }; } private string GetAIArrayValuesStringRepresentation(int[,][] pArr) { string r = "int[,][] ReLe_AI_RESULT_VALS = new int[3, 6][] {"; for (int i = 0; i < 3; i++) { r += "{"; for (int j = 0; j < 5; j++) { r += GetIntArray64LStringRepresentation(pArr[i, j]) + ","; } r += GetIntArray64LStringRepresentation(pArr[i, 5]) + "},"; } return r.Substring(0, r.Length - 1) + "};"; } private string GetIntArray64LStringRepresentation(int[] p64LArr) { if (p64LArr == null) return ""; string r = "new int[64]{"; for (int i = 0; i < 63; i++) { r += p64LArr[i] + ","; } return r + p64LArr[63] + "}"; } public void TempStuff() { } private string[] gameResultStrings = new string[5] { "Black Has Won!", "Draw!", "White Has Won!", "Non Existant Result!", "Game is Ongoing!"}; private int[,][] lowNoisePositionEvals1, lowNoisePositionEvals2; public void ThreadSelfPlay(object obj) { PlayGameAgainstItself(obj); } public void PlayGameAgainstItself(object obj, string pStartFEN = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1", long tickLimitForEngine = ENGINE_VALS.SELF_PLAY_THINK_TIME) { int ttGState; while (BOT_MAIN.goalGameCount > BOT_MAIN.gamesPlayed) { try { string tGameStr; GetLowNoisePositionalEvaluation(globalRandom); LoadFenString(tGameStr = pStartFEN); tGameStr += ";"; int tGState = 3, tmc = 0; bool lowNoiceDecider = globalRandom.NextDouble() < 0.5d; while (tGState == 3) { piecePositionEvals = lowNoiceDecider ? lowNoisePositionEvals1 : lowNoisePositionEvals2; MinimaxRoot(tickLimitForEngine); Move tM = transpositionTable[zobristKey].bestMove; PlainMakeMove(tM); tGameStr += NuCRe.GetNuCRe(tM.moveHash) + ","; BOT_MAIN.movesPlayed++; tGState = GameState(isWhiteToMove); lowNoiceDecider = !lowNoiceDecider; tmc++; } ttGState = tGState; tGameStr += ttGState + 1; SNAPSHOT_WRITLINE_REPLACEMENT(tGameStr); BOT_MAIN.gamesPlayedResultArray[ttGState + 1]++; BOT_MAIN.gamesPlayed++; BOT_MAIN.selfPlayGameStrings.Add(tGameStr); } catch (Exception tE) { SNAPSHOT_WRITLINE_REPLACEMENT(tE.ToString()); } } } public void PlayGameOnConsoleAgainstHuman(string pStartFEN = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1", bool pHumanPlaysWhite = true, long tickLimitForEngine = 10_000_000L) { debugSearchDepthResults = true; LoadFenString(pStartFEN); if (!(pHumanPlaysWhite ^ isWhiteToMove)) { var pVS = Console.ReadLine(); if (pVS == null) return; Move tm = GetMoveOfString(pVS.ToString()); SNAPSHOT_WRITLINE_REPLACEMENT(tm); PlainMakeMove(tm); } int tGState = 3; while (tGState == 3) { MinimaxRoot(tickLimitForEngine); PlayThroughZobristTree(); Move tM = transpositionTable[zobristKey].bestMove; SNAPSHOT_WRITLINE_REPLACEMENT(tM); SNAPSHOT_WRITLINE_REPLACEMENT(CreateFenString()); PlainMakeMove(tM); tGState = GameState(isWhiteToMove); if (tGState != 3 || tM == NULL_MOVE) break; var pV = ""; tM = NULL_MOVE; do { pV = Console.ReadLine(); if (pV == null) continue; tM = GetMoveOfString(pV.ToString()); SNAPSHOT_WRITLINE_REPLACEMENT(tM); } while (tM == NULL_MOVE); PlainMakeMove(tM); tGState = GameState(isWhiteToMove); } } private void PlayThroughZobristTree() { SetJumpState(); SNAPSHOT_WRITLINE_REPLACEMENT("\n- - - - - - - - - - - - -"); int tC = 1; Dictionary<ulong, bool> usedULs = new Dictionary<ulong, bool>(); while (transpositionTable.TryGetValue(zobristKey, out TranspositionEntry tM)) { if (usedULs.ContainsKey(zobristKey)) { SNAPSHOT_WRITLINE_REPLACEMENT(tC + ": AT LEAST ONE REPETION; REST NOT VISIBLE"); break; } SNAPSHOT_WRITLINE_REPLACEMENT(tC + ": "+ tM.bestMove + " > "); usedULs.Add(zobristKey, true); PlainMakeMove(tM.bestMove); tC++; } SNAPSHOT_WRITLINE_REPLACEMENT("- - - - - - - - - - - - -\n"); LoadJumpState(); } public Move? ReturnNextMove(Move? lastMove, long pThinkingTime) { if (lastMove != null) PlainMakeMove(lastMove); if (GameState(isWhiteToMove) != 3) return null; MinimaxRoot(pThinkingTime); if (!transpositionTable.ContainsKey(zobristKey)) return null; Move tm = transpositionTable[zobristKey].bestMove; PlainMakeMove(tm); return tm; } private int[] jmpSt_pieceTypeArray; private ulong jmpSt_whitePieceBitboard, jmpSt_blackPieceBitboard; private ulong jmpSt_zobristKey; private int jmpSt_whiteKingSquare, jmpSt_blackKingSquare, jmpSt_enPassantSquare, jmpSt_happenedHalfMoves, jmpSt_fiftyMoveRuleCounter; private bool jmpSt_whiteCastleRightKingSide, jmpSt_whiteCastleRightQueenSide, jmpSt_blackCastleRightKingSide, jmpSt_blackCastleRightQueenSide; private bool jmpSt_isWhiteToMove; private ulong[] jmpSt_curSearchZobristKeyLine; private int[] jmpSt_moveHashList; public void LoadJumpState() { pieceTypeArray = (int[])jmpSt_pieceTypeArray.Clone(); whitePieceBitboard = jmpSt_whitePieceBitboard; blackPieceBitboard = jmpSt_blackPieceBitboard; zobristKey = jmpSt_zobristKey; whiteKingSquare = jmpSt_whiteKingSquare; blackKingSquare = jmpSt_blackKingSquare; enPassantSquare = jmpSt_enPassantSquare; happenedHalfMoves = jmpSt_happenedHalfMoves; fiftyMoveRuleCounter = jmpSt_fiftyMoveRuleCounter; whiteCastleRightKingSide = jmpSt_whiteCastleRightKingSide; whiteCastleRightQueenSide = jmpSt_whiteCastleRightQueenSide; blackCastleRightKingSide = jmpSt_blackCastleRightKingSide; blackCastleRightQueenSide = jmpSt_blackCastleRightQueenSide; isWhiteToMove = jmpSt_isWhiteToMove; curSearchZobristKeyLine = (ulong[])jmpSt_curSearchZobristKeyLine.Clone(); allPieceBitboard = blackPieceBitboard | whitePieceBitboard; moveHashList = jmpSt_moveHashList.ToList(); } public void SetJumpState() { jmpSt_pieceTypeArray = (int[])pieceTypeArray.Clone(); jmpSt_whitePieceBitboard = whitePieceBitboard; jmpSt_blackPieceBitboard = blackPieceBitboard; jmpSt_zobristKey = zobristKey; jmpSt_whiteKingSquare = whiteKingSquare; jmpSt_blackKingSquare = blackKingSquare; jmpSt_enPassantSquare = enPassantSquare; jmpSt_happenedHalfMoves = happenedHalfMoves; jmpSt_fiftyMoveRuleCounter = fiftyMoveRuleCounter; jmpSt_whiteCastleRightKingSide = whiteCastleRightKingSide; jmpSt_whiteCastleRightQueenSide = whiteCastleRightQueenSide; jmpSt_blackCastleRightKingSide = blackCastleRightKingSide; jmpSt_blackCastleRightQueenSide = blackCastleRightQueenSide; jmpSt_isWhiteToMove = isWhiteToMove; jmpSt_curSearchZobristKeyLine = (ulong[])curSearchZobristKeyLine.Clone(); jmpSt_moveHashList = moveHashList.ToArray(); } private int PreMinimaxCheckCheckWhite() { ulong bitShiftedKingPos = 1ul << whiteKingSquare; int curR = -1; for (int p = 0; p < 64; p++) { if (ULONG_OPERATIONS.IsBitZero(blackPieceBitboard, p)) continue; int tPT; switch (tPT = pieceTypeArray[p]) { case 1: if ((bitShiftedKingPos & blackPawnAttackSquareBitboards[p]) != 0ul) return p; break; case 2: if ((bitShiftedKingPos & knightSquareBitboards[p]) != 0ul) return p; break; case 6: break; default: if ((squareConnectivesPrecalculationLineArray[whiteKingSquare << 6 | p] & allPieceBitboard) == (1ul << p) && pieceTypeAbilities[tPT, squareConnectivesPrecalculationArray[whiteKingSquare << 6 | p]]) { if (curR != -1) return -779; curR = p; } break; } } return curR; } private int PreMinimaxCheckCheckBlack() { ulong bitShiftedKingPos = 1ul << blackKingSquare; int curR = -1; for (int p = 0; p < 64; p++) { if (ULONG_OPERATIONS.IsBitZero(whitePieceBitboard, p)) continue; int tPT; switch (tPT = pieceTypeArray[p]) { case 1: if ((bitShiftedKingPos & whitePawnAttackSquareBitboards[p]) != 0ul) return p; break; case 2: if ((bitShiftedKingPos & knightSquareBitboards[p]) != 0ul) return p; break; case 6: break; default: if ((squareConnectivesPrecalculationLineArray[blackKingSquare << 6 | p] & allPieceBitboard) == (1ul << p) && pieceTypeAbilities[tPT, squareConnectivesPrecalculationArray[blackKingSquare << 6 | p]]) { if (curR != -1) return -779; curR = p; } break; } } return curR; } private int LecacyLeafCheckingPieceCheckWhite(int pStartPos, int pEndPos, int pPieceType) { int tI, tPossibleAttackPiece; if (pPieceType == 1) { if (ULONG_OPERATIONS.IsBitOne(blackPawnAttackSquareBitboards[pEndPos], whiteKingSquare)) return pEndPos; } else if (pPieceType == 2) { if (ULONG_OPERATIONS.IsBitOne(knightSquareBitboards[pEndPos], whiteKingSquare)) return pEndPos; } else if (pPieceType != 6) { tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | pEndPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; } tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | pStartPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; return -1; } private int LecacyLeafCheckingPieceCheckBlack(int pStartPos, int pEndPos, int pPieceType) { int tI, tPossibleAttackPiece; if (pPieceType == 1) { if (ULONG_OPERATIONS.IsBitOne(whitePawnAttackSquareBitboards[pEndPos], blackKingSquare)) return pEndPos; } else if (pPieceType == 2) { if (ULONG_OPERATIONS.IsBitOne(knightSquareBitboards[pEndPos], blackKingSquare)) return pEndPos; } else if (pPieceType != 6) { tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | pEndPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; } tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | pStartPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; return -1; } public void GetLegalMoves(ref List<Move> pMoveList) { int attk; if (isWhiteToMove) { attk = PreMinimaxCheckCheckWhite(); if (attk == -779) GetLegalWhiteMovesSpecialDoubleCheckCase(ref pMoveList); else GetLegalWhiteMoves(attk, ref pMoveList); } else { attk = PreMinimaxCheckCheckBlack(); if (attk == -779) GetLegalBlackMovesSpecialDoubleCheckCase(ref pMoveList); else GetLegalBlackMoves(attk, ref pMoveList); } } private void GetLegalWhiteMoves(int pCheckingPieceSquare, ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= blackPawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, whiteKingSquare); if (curCheckCount == 0) { if (whiteCastleRightKingSide && ((allPieceBitboard | oppAttkBitboard) & WHITE_KING_ROCHADE) == 0ul) pMoveList.Add(mWHITE_KING_ROCHADE); if (whiteCastleRightQueenSide && (allPieceBitboard & WHITE_QUEEN_ROCHADE | oppAttkBitboard & WHITE_QUEEN_ATTK_ROCHADE) == 0ul) pMoveList.Add(mWHITE_QUEEN_ROCHADE); if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, whitePieceBitboard, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[whiteKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare + 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, whitePieceBitboard, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveList(whiteKingSquare, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalWhiteCaptures(int pCheckingPieceSquare, ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= blackPawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, whiteKingSquare); if (curCheckCount == 0) { if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & blackPieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[whiteKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare + 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & blackPieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveListOnlyCaptures(whiteKingSquare, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalWhiteMovesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= blackPawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveList(whiteKingSquare, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalWhiteCapturesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= blackPawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveListOnlyCaptures(whiteKingSquare, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalBlackMoves(int pCheckingPieceSquare, ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= whitePawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, blackKingSquare); if (curCheckCount == 0) { if (blackCastleRightKingSide && ((allPieceBitboard | oppAttkBitboard) & BLACK_KING_ROCHADE) == 0ul) pMoveList.Add(mBLACK_KING_ROCHADE); if (blackCastleRightQueenSide && (allPieceBitboard & BLACK_QUEEN_ROCHADE | oppAttkBitboard & BLACK_QUEEN_ATTK_ROCHADE) == 0ul) pMoveList.Add(mBLACK_QUEEN_ROCHADE); if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveList(p, blackKingSquare, blackPieceBitboard, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[blackKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare - 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveList(p, blackKingSquare, blackPieceBitboard, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveList(blackKingSquare, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); } private void GetLegalBlackCaptures(int pCheckingPieceSquare, ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= whitePawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, blackKingSquare); if (curCheckCount == 0) { if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & whitePieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[blackKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare - 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & whitePieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveListOnlyCaptures(blackKingSquare, ~oppAttkBitboard & whitePieceBitboard); } private void GetLegalBlackMovesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= whitePawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveList(blackKingSquare, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); } private void GetLegalBlackCapturesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= whitePawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveListOnlyCaptures(blackKingSquare, ~oppAttkBitboard & whitePieceBitboard); } public Move GetMoveOfString(string pMove) { int tSP, tEP; string[] tSpl = pMove.Split(','); if (Char.IsNumber(pMove[0])) { tSP = Convert.ToInt32(tSpl[0]); tEP = Convert.ToInt32(tSpl[1]); } else { tSP = SQUARES.NumberNotation(tSpl[0]); tEP = SQUARES.NumberNotation(tSpl[1]); } int tPT = pieceTypeArray[tSP]; bool tIC = ULONG_OPERATIONS.IsBitOne(allPieceBitboard, tEP), tIEP = enPassantSquare == tEP && tPT == 1; if (tSpl.Length == 3) return new Move(tSP, tEP, tPT, Convert.ToInt32(tSpl[2]), tIC); if (tIEP) return new Move(true, tSP, tEP, isWhiteToMove ? tEP - 8 : tEP + 8); if (tPT == 1 && Math.Abs(tSP - tEP) > 11) return new Move(tSP, tEP, 1, false, isWhiteToMove ? tSP + 8 : tSP - 8); if (tPT == 6 && (Math.Abs(tSP - tEP) == 2 || Math.Abs(tSP - tEP) == 3)) { if (isWhiteToMove) return tEP == 6 ? mWHITE_KING_ROCHADE : mWHITE_QUEEN_ROCHADE; return tEP == 62 ? mBLACK_KING_ROCHADE : mBLACK_QUEEN_ROCHADE; } return new Move(tSP, tEP, tPT, tIC); } public void PlainMakeMove(string pMoveName) { PlainMakeMove(GetMoveOfString(pMoveName)); } public void PlainMakeMove(Move pMove) { lastMadeMove = pMove; if (isWhiteToMove) WhiteMakeMove(pMove); else BlackMakeMove(pMove); } public void WhiteMakeMove(Move pMove) { int tEndPos = pMove.endPos, tStartPos = pMove.startPos, tPieceType = pMove.pieceType, tPTI = pieceTypeArray[tEndPos]; fiftyMoveRuleCounter++; whitePieceBitboard ^= pMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey ^= blackTurnHash ^ enPassantSquareHashes[enPassantSquare] ^ pieceHashesWhite[tStartPos, tPieceType] ^ pieceHashesWhite[tEndPos, tPieceType]; enPassantSquare = 65; isWhiteToMove = false; switch (pMove.moveTypeID) { case 0: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 1: fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 2: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 3: whiteKingSquare = tEndPos; if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 4: if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 5: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 6: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 7: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[whiteKingSquare = tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 8: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 9: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = pMove.enPassantOption]; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 11: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; whiteKingSquare = tEndPos; pieceTypeArray[pMove.rochadeEndPos] = 4; pieceTypeArray[pMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesWhite[pMove.rochadeStartPos, 4] ^ pieceHashesWhite[pMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 12: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[pMove.enPassantOption] = 0; zobristKey ^= pieceHashesBlack[pMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 13: fiftyMoveRuleCounter = 0; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; zobristKey ^= pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, pMove.promotionType]; break; case 14: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, tPTI] ^ pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, pMove.promotionType]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; } moveHashList.Add(pMove.moveHash); if (pMove.isCapture || tPieceType == 1) { curSearchZobristKeyLine = Array.Empty<ulong>(); return; } ulong[] u = new ulong[(tPTI = curSearchZobristKeyLine.Length) + 1]; for (int i = tPTI; i-- > 0;) u[i] = curSearchZobristKeyLine[i]; u[tPTI] = zobristKey; curSearchZobristKeyLine = u; } public void BlackMakeMove(Move pMove) { int tEndPos = pMove.endPos, tStartPos = pMove.startPos, tPieceType = pMove.pieceType, tPTI = pieceTypeArray[tEndPos]; fiftyMoveRuleCounter++; blackPieceBitboard ^= pMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey ^= blackTurnHash ^ enPassantSquareHashes[enPassantSquare] ^ pieceHashesBlack[tStartPos, tPieceType] ^ pieceHashesBlack[tEndPos, tPieceType]; enPassantSquare = 65; isWhiteToMove = true; switch (pMove.moveTypeID) { case 0: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 1: fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 2: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 3: blackKingSquare = tEndPos; if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 4: if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 5: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 6: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 7: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[blackKingSquare = tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 8: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 9: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = pMove.enPassantOption]; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 11: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; blackKingSquare = tEndPos; pieceTypeArray[pMove.rochadeEndPos] = 4; pieceTypeArray[pMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesBlack[pMove.rochadeStartPos, 4] ^ pieceHashesBlack[pMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 12: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[pMove.enPassantOption] = 0; zobristKey ^= pieceHashesWhite[pMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 13: fiftyMoveRuleCounter = 0; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, pMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 14: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } zobristKey ^= pieceHashesWhite[tEndPos, tPTI] ^ pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, pMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; } moveHashList.Add(pMove.moveHash); if (pMove.isCapture || tPieceType == 1) { curSearchZobristKeyLine = Array.Empty<ulong>(); return; } ulong[] u = new ulong[(tPTI = curSearchZobristKeyLine.Length) + 1]; for (int i = tPTI; i-- > 0;) u[i] = curSearchZobristKeyLine[i]; u[tPTI] = zobristKey; curSearchZobristKeyLine = u; } public void WhiteUndoMove(Move pMove) { } private const int WHITE_CHECKMATE_VAL = 100000, BLACK_CHECKMATE_VAL = -100000, CHECK_EXTENSION_LENGTH = -12, MAX_QUIESCENCE_TOTAL_LENGTH = -32; private readonly Move NULL_MOVE = new Move(0, 0, 0); private int curSearchDepth = 0, curSubSearchDepth = -1; public int MinimaxRoot(long pTime) { evalCount = 0; searches++; int baseLineLen = 0; long tTimestamp = globalTimer.ElapsedTicks + pTime; ClearHeuristics(); transpositionTable.Clear(); ulong[] tZobristKeyLine = Array.Empty<ulong>(); if (curSearchZobristKeyLine != null) { baseLineLen = curSearchZobristKeyLine.Length; tZobristKeyLine = new ulong[baseLineLen]; Array.Copy(curSearchZobristKeyLine, tZobristKeyLine, baseLineLen); } int perftScore, tattk = isWhiteToMove ? PreMinimaxCheckCheckWhite() : PreMinimaxCheckCheckBlack(), pDepth = 1; (string, int) bookMoveTuple = TLMDatabase.SearchForNextBookMove(moveHashList); if (bookMoveTuple.Item2 != 0) { int actualMoveHash = NuCRe.GetNumber(bookMoveTuple.Item1); List<Move> tMoves = new List<Move>(); GetLegalMoves(ref tMoves); int tL = tMoves.Count; for (int i = 0; i < tL; i++) { if (tMoves[i].moveHash == actualMoveHash) { if (debugSearchDepthResults) { SNAPSHOT_WRITLINE_REPLACEMENT("TLM_DB_Count: " + bookMoveTuple.Item2); SNAPSHOT_WRITLINE_REPLACEMENT(">> " + tMoves[i]); } transpositionTable.Add(zobristKey, new TranspositionEntry(tMoves[i], Array.Empty<int>())); return 0; } } } do { curSearchDepth = pDepth; curSubSearchDepth = pDepth - 1; ulong[] completeZobristHistory = new ulong[baseLineLen + pDepth - CHECK_EXTENSION_LENGTH + 1]; for (int i = 0; i < baseLineLen; i++) completeZobristHistory[i] = curSearchZobristKeyLine[i]; curSearchZobristKeyLine = completeZobristHistory; if (isWhiteToMove) { if (tattk == -1) perftScore = MinimaxWhite(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); else perftScore = MinimaxWhite(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); } else { if (tattk == -1) perftScore = MinimaxBlack(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); else perftScore = MinimaxBlack(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); } if (debugSearchDepthResults && pTime != 1L) { int tNpS = Convert.ToInt32((double)evalCount * 10_000_000d /(double)(pTime - tTimestamp + globalTimer.ElapsedTicks)); int tSearchEval = perftScore; int timeForSearchSoFar = (int)((pTime - tTimestamp + globalTimer.ElapsedTicks) /10000d); Move tBestMove = transpositionTable[zobristKey].bestMove; SNAPSHOT_WRITLINE_REPLACEMENT((tSearchEval >= 0 ? "+": "") + tSearchEval); SNAPSHOT_WRITLINE_REPLACEMENT(" " + tBestMove + "  ["); SNAPSHOT_WRITLINE_REPLACEMENT("Depth = " + pDepth + ", "); SNAPSHOT_WRITLINE_REPLACEMENT("Evals = " + GetThreeDigitSeperatedInteger(evalCount) + ", "); SNAPSHOT_WRITLINE_REPLACEMENT("Time = " + GetThreeDigitSeperatedInteger(timeForSearchSoFar) + "ms, "); SNAPSHOT_WRITLINE_REPLACEMENT("NpS = " + GetThreeDigitSeperatedInteger(tNpS) + "]"); } pDepth++; } while (globalTimer.ElapsedTicks < tTimestamp && pDepth < 179); depths += pDepth - 1; BOT_MAIN.depthsSearched += pDepth - 1; BOT_MAIN.searchesFinished++; BOT_MAIN.evaluationsMade += evalCount; curSearchZobristKeyLine = tZobristKeyLine; return perftScore; } private int MinimaxWhite(int pPly, int pAlpha, int pBeta, int pDepth, int pRepetitionHistoryPly, int pCheckingSquare, Move pLastMove) { if (IsDrawByRepetition(pRepetitionHistoryPly - 4)) return 0; if ((pDepth <= 0 && pCheckingSquare == -1) || pDepth < CHECK_EXTENSION_LENGTH) return QuiescenceWhite(pPly, pAlpha, pBeta, pDepth - 1, pCheckingSquare, pLastMove); List<Move> moveOptionList = new List<Move>(); Move bestMove = NULL_MOVE; if (pLastMove.isPromotion && pLastMove.isCapture && pLastMove.startPos % 8 == pCheckingSquare % 8 && pLastMove.startPos == whiteKingSquare + 8 && (pLastMove.promotionType == 4 || pLastMove.promotionType == 5)) GetLegalWhiteMovesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalWhiteMoves(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tWhiteKingSquare = whiteKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1, curEval = BLACK_CHECKMATE_VAL - pDepth; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = true; double[] moveSortingArray = new double[molc]; int[] moveSortingArrayIndexes = new int[molc], thisSearchMoveSortingArrayForTransposEntry = new int[molc]; transpositionTable.TryGetValue(zobristKey, out TranspositionEntry transposEntry); if (transposEntry == null) { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; } } else { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove == transposEntry.bestMove) moveSortingArray[m] = BESTMOVE_SORT_VAL; else if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; if (transposEntry.moveGenOrderedEvalLength > m) moveSortingArray[m] -= transposEntry.moveGenOrderedEvals[m]; } } Array.Sort(moveSortingArray, moveSortingArrayIndexes); for (int m = 0; m < molc; m++) { int tActualIndex = moveSortingArrayIndexes[m]; Move curMove = moveOptionList[tActualIndex]; if (debugSortResults && pDepth == curSubSearchDepth) { SNAPSHOT_WRITLINE_REPLACEMENT(moveSortingArray[m] + " | "+ curMove); } int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; whitePieceBitboard = tWPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesWhite[tStartPos, tPieceType] ^ pieceHashesWhite[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 0: blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 1: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 2: blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 3: whiteKingSquare = tEndPos; if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 4: blackPieceBitboard = tBPB; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 5: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[whiteKingSquare = tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = curMove.enPassantOption]; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 11: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; whiteKingSquare = tEndPos; blackPieceBitboard = tBPB; pieceTypeArray[curMove.rochadeEndPos] = 4; pieceTypeArray[curMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesWhite[curMove.rochadeStartPos, 4] ^ pieceHashesWhite[curMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | curMove.rochadeEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << curMove.rochadeEndPos)) tCheckPos = curMove.rochadeEndPos; break; case 12: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesBlack[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 13: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; zobristKey ^= pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, curMove.promotionType]; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; case 14: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, tPTI] ^ pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, curMove.promotionType]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } curSearchZobristKeyLine[pRepetitionHistoryPly] = zobristKey; int tEval = MinimaxBlack(pPly + 1, pAlpha, pBeta, pDepth - 1, pRepetitionHistoryPly + 1, tCheckPos, curMove); thisSearchMoveSortingArrayForTransposEntry[tActualIndex] = tEval; pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 3: whiteKingSquare = tWhiteKingSquare; break; case 7: whiteKingSquare = tWhiteKingSquare; break; case 10: enPassantSquare = 65; break; case 11: whiteKingSquare = tWhiteKingSquare; pieceTypeArray[curMove.rochadeStartPos] = 4; pieceTypeArray[curMove.rochadeEndPos] = 0; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 13: pieceTypeArray[tStartPos] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval > curEval) { bestMove = curMove; curEval = tEval; } if (pAlpha < curEval) pAlpha = curEval; if (curEval >= pBeta) { if (!curMove.isCapture) { killerMoveHeuristic[curMove.moveHash] = true; if (pDepth > 0) historyHeuristic[curMove.moveHash] += pDepth * pDepth; } break; } } isWhiteToMove = true; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; if (molc == 0 && pCheckingSquare == 0) curEval = 0; if (!transpositionTable.ContainsKey(zobristKey)) transpositionTable.Add(zobristKey, new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry)); else transpositionTable[zobristKey] = new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry); return curEval; } private int QuiescenceWhite(int pPly, int pAlpha, int pBeta, int pDepth, int pCheckingSquare, Move pLastMove) { int standPat = TexelEvaluate(); if (standPat >= pBeta || pDepth < MAX_QUIESCENCE_TOTAL_LENGTH) return pBeta; if (standPat > pAlpha) pAlpha = standPat; List<Move> moveOptionList = new List<Move>(); if (pLastMove.isPromotion && pLastMove.isCapture && pLastMove.startPos % 8 == pCheckingSquare % 8 && pLastMove.startPos == whiteKingSquare + 8 && (pLastMove.promotionType == 4 || pLastMove.promotionType == 5)) GetLegalWhiteCapturesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalWhiteCaptures(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tWhiteKingSquare = whiteKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = true; for (int m = 0; m < molc; m++) { Move curMove = moveOptionList[m]; int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; whitePieceBitboard = tWPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesWhite[tStartPos, tPieceType] ^ pieceHashesWhite[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 5: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[whiteKingSquare = tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 12: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesBlack[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 14: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, tPTI] ^ pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, curMove.promotionType]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } int tEval = QuiescenceBlack(pPly + 1, pAlpha, pBeta, pDepth - 1, tCheckPos, curMove); pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 7: whiteKingSquare = tWhiteKingSquare; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval >= pBeta) return pBeta; if (pAlpha < tEval) pAlpha = tEval; } isWhiteToMove = true; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; return pAlpha; } private int MinimaxBlack(int pPly, int pAlpha, int pBeta, int pDepth, int pRepetitionHistoryPly, int pCheckingSquare, Move pLastMove) { if (IsDrawByRepetition(pRepetitionHistoryPly - 4)) return 0; if ((pDepth <= 0 && pCheckingSquare == -1) || pDepth < CHECK_EXTENSION_LENGTH) return QuiescenceBlack(pPly, pAlpha, pBeta, pDepth - 1, pCheckingSquare, pLastMove); List<Move> moveOptionList = new List<Move>(); Move bestMove = NULL_MOVE; if (pLastMove.isPromotion && pLastMove.isCapture && pLastMove.startPos % 8 == pCheckingSquare % 8 && pLastMove.startPos == blackKingSquare - 8 && (pLastMove.promotionType == 4 || pLastMove.promotionType == 5)) GetLegalBlackMovesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalBlackMoves(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tBlackKingSquare = blackKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1, curEval = WHITE_CHECKMATE_VAL + pDepth; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = false; double[] moveSortingArray = new double[molc]; int[] moveSortingArrayIndexes = new int[molc], thisSearchMoveSortingArrayForTransposEntry = new int[molc]; transpositionTable.TryGetValue(zobristKey, out TranspositionEntry transposEntry); if (transposEntry == null) { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; } } else { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove == transposEntry.bestMove) moveSortingArray[m] = BESTMOVE_SORT_VAL; else if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; if (transposEntry.moveGenOrderedEvalLength > m) moveSortingArray[m] -= transposEntry.moveGenOrderedEvals[m]; } } Array.Sort(moveSortingArray, moveSortingArrayIndexes); for (int m = 0; m < molc; m++) { int tActualIndex = moveSortingArrayIndexes[m]; Move curMove = moveOptionList[tActualIndex]; if (debugSortResults && pDepth == curSearchDepth) { SNAPSHOT_WRITLINE_REPLACEMENT("=== " + moveSortingArray[m] + " | "+ curMove); } int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; blackPieceBitboard = tBPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesBlack[tStartPos, tPieceType] ^ pieceHashesBlack[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 0: whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 1: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 2: whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 3: blackKingSquare = tEndPos; if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 4: whitePieceBitboard = tWPB; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 5: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[blackKingSquare = tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = curMove.enPassantOption]; whitePieceBitboard = tWPB; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 11: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; blackKingSquare = tEndPos; whitePieceBitboard = tWPB; pieceTypeArray[curMove.rochadeEndPos] = 4; pieceTypeArray[curMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesBlack[curMove.rochadeStartPos, 4] ^ pieceHashesBlack[curMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | curMove.rochadeEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << curMove.rochadeEndPos)) tCheckPos = curMove.rochadeEndPos; break; case 12: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesWhite[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 13: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, curMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; case 14: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } zobristKey ^= pieceHashesWhite[tEndPos, tPTI] ^ pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, curMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } curSearchZobristKeyLine[pRepetitionHistoryPly] = zobristKey; int tEval = MinimaxWhite(pPly + 1, pAlpha, pBeta, pDepth - 1, pRepetitionHistoryPly + 1, tCheckPos, curMove); thisSearchMoveSortingArrayForTransposEntry[tActualIndex] = tEval; pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 3: blackKingSquare = tBlackKingSquare; break; case 7: blackKingSquare = tBlackKingSquare; break; case 10: enPassantSquare = 65; break; case 11: blackKingSquare = tBlackKingSquare; pieceTypeArray[curMove.rochadeStartPos] = 4; pieceTypeArray[curMove.rochadeEndPos] = 0; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 13: pieceTypeArray[tStartPos] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval < curEval) { bestMove = curMove; curEval = tEval; } if (pBeta > curEval) pBeta = curEval; if (curEval <= pAlpha) { if (!curMove.isCapture) { killerMoveHeuristic[curMove.moveHash] = true; if (pDepth > 0) historyHeuristic[curMove.moveHash] += pDepth * pDepth; } break; } } isWhiteToMove = false; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; if (molc == 0 && pCheckingSquare == 0) curEval = 0; if (!transpositionTable.ContainsKey(zobristKey)) transpositionTable.Add(zobristKey, new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry)); else transpositionTable[zobristKey] = new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry); return curEval; } private int QuiescenceBlack(int pPly, int pAlpha, int pBeta, int pDepth, int pCheckingSquare, Move pLastMove) { int standPat = TexelEvaluate(); if (standPat <= pAlpha || pDepth < MAX_QUIESCENCE_TOTAL_LENGTH) return pAlpha; if (standPat < pBeta) pBeta = standPat; List<Move> moveOptionList = new List<Move>(); if (pLastMove.isPromotion && pLastMove.isCapture && pLastMove.startPos % 8 == pCheckingSquare % 8 && pLastMove.startPos == blackKingSquare - 8 && (pLastMove.promotionType == 4 || pLastMove.promotionType == 5)) GetLegalBlackCapturesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalBlackCaptures(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tBlackKingSquare = blackKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = false; for (int m = 0; m < molc; m++) { Move curMove = moveOptionList[m]; int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; blackPieceBitboard = tBPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesBlack[tStartPos, tPieceType] ^ pieceHashesBlack[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 5: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[blackKingSquare = tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 12: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesWhite[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 14: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } zobristKey ^= pieceHashesWhite[tEndPos, tPTI] ^ pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, curMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } int tEval = QuiescenceWhite(pPly + 1, pAlpha, pBeta, pDepth - 1, tCheckPos, curMove); pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 7: blackKingSquare = tBlackKingSquare; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval <= pAlpha) return pAlpha; if (pBeta > tEval) pBeta = tEval; } isWhiteToMove = false; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; return pBeta; } private bool[] killerMoveHeuristic = new bool[262_144]; private int[] historyHeuristic = new int[262_144]; public void ClearHeuristics() { for (int i = 0; i < 262_144; i++) { killerMoveHeuristic[i] = false; historyHeuristic[i] = 0; } } private Dictionary<ulong, TranspositionEntry> transpositionTable = new Dictionary<ulong, TranspositionEntry>(); private int[] pieceEvals = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[,][] piecePositionEvals = new int[33, 14][]; private int evalCount = 0; private int Evaluate() { evalCount++; if (fiftyMoveRuleCounter > 99) return 0; int tEval = 0, tPT, pieceCount = ULONG_OPERATIONS.CountBits(allPieceBitboard); for (int p = 0; p < 64; p++) tEval += pieceEvals[tPT = pieceTypeArray[p] + 7 * ((int)(blackPieceBitboard >> p) & 1)] + piecePositionEvals[pieceCount, tPT][p]; return tEval; } public int GameState(bool pWhiteKingCouldBeAttacked) { if (IsDrawByRepetition(curSearchZobristKeyLine.Length - 5) || fiftyMoveRuleCounter > 99) return 0; int t; List<Move> tMoves = new List<Move>(); GetLegalMoves(ref tMoves); if (pWhiteKingCouldBeAttacked) { t = PreMinimaxCheckCheckWhite(); if (t == -1) return tMoves.Count == 0 ? 0 : 3; else if (tMoves.Count == 0) return -1; } else { t = PreMinimaxCheckCheckBlack(); if (t == -1) return tMoves.Count == 0 ? 0 : 3; else if (tMoves.Count == 0) return 1; } return 3; } private bool IsDrawByRepetition(int pPlyOfFirstPossibleRepeatedPosition) { int tC = 0; for (int i = pPlyOfFirstPossibleRepeatedPosition; i >= 0; i -= 2) { if (curSearchZobristKeyLine[i] == zobristKey) if (++tC == 2) return true; } return false; } private const int RELE_MAX_MOVE_COUNT_PER_GAME = 500; public double ReLePlayGame(int[,][] pEvalPositionValuesWhite, int[,][] pEvalPositionValuesBlack, long thinkingTimePerMove) { int[,][] processedValuesWhite = InitReLeAgent(pEvalPositionValuesWhite), processedValuesBlack = InitReLeAgent(pEvalPositionValuesBlack); int tGS, mc = 0; do { if (IsDrawByRepetition(curSearchZobristKeyLine.Length - 5)) return 0d; piecePositionEvals = isWhiteToMove ? processedValuesWhite : processedValuesBlack; MinimaxRoot(thinkingTimePerMove); if (transpositionTable.Count == 0) { SNAPSHOT_WRITLINE_REPLACEMENT("?!"); return 0d; } PlainMakeMove(transpositionTable[zobristKey].bestMove); tGS = GameState(isWhiteToMove); transpositionTable.Clear(); if (tGS != 3) break; } while (mc++ < RELE_MAX_MOVE_COUNT_PER_GAME); if (tGS == 3 || tGS == 0) return 0d; else if (tGS == 1) return 0.1d * (double)(RELE_MAX_MOVE_COUNT_PER_GAME - mc); return 0.1d * (double)(-RELE_MAX_MOVE_COUNT_PER_GAME + mc); } public int[,][] InitReLeAgent(int[,][] pEvalPositionValues) { return GetInterpolatedProcessedValues(pEvalPositionValues); } private int[,][] GetInterpolatedProcessedValues(int[,][] pEvalPositionValues) { int[,][] processedValues = new int[33, 14][]; for (int i = 0; i < 32; i++) { int ip1 = i + 1; processedValues[ip1, 7] = processedValues[ip1, 0] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; processedValues[ip1, 8] = SwapArrayViewingSide(processedValues[ip1, 1] = MultiplyArraysWithVal(pEvalPositionValues[0, 0], pEvalPositionValues[1, 0], pEvalPositionValues[2, 0], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 9] = SwapArrayViewingSide(processedValues[ip1, 2] = MultiplyArraysWithVal(pEvalPositionValues[0, 1], pEvalPositionValues[1, 1], pEvalPositionValues[2, 1], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 10] = SwapArrayViewingSide(processedValues[ip1, 3] = MultiplyArraysWithVal(pEvalPositionValues[0, 2], pEvalPositionValues[1, 2], pEvalPositionValues[2, 2], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 11] = SwapArrayViewingSide(processedValues[ip1, 4] = MultiplyArraysWithVal(pEvalPositionValues[0, 3], pEvalPositionValues[1, 3], pEvalPositionValues[2, 3], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 12] = SwapArrayViewingSide(processedValues[ip1, 5] = MultiplyArraysWithVal(pEvalPositionValues[0, 4], pEvalPositionValues[1, 4], pEvalPositionValues[2, 4], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 13] = SwapArrayViewingSide(processedValues[ip1, 6] = MultiplyArraysWithVal(pEvalPositionValues[0, 5], pEvalPositionValues[1, 5], pEvalPositionValues[2, 5], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); } return processedValues; } private double[,][] GetInterpolatedProcessedValues(double[,][] pEvalPositionValues) { double[,][] processedValues = new double[33, 14][]; for (int i = 0; i < 32; i++) { int ip1 = i + 1; processedValues[ip1, 7] = processedValues[ip1, 0] = new double[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; processedValues[ip1, 8] = SwapArrayViewingSide(processedValues[ip1, 1] = MultiplyArraysWithVal(pEvalPositionValues[0, 0], pEvalPositionValues[1, 0], pEvalPositionValues[2, 0], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 9] = SwapArrayViewingSide(processedValues[ip1, 2] = MultiplyArraysWithVal(pEvalPositionValues[0, 1], pEvalPositionValues[1, 1], pEvalPositionValues[2, 1], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 10] = SwapArrayViewingSide(processedValues[ip1, 3] = MultiplyArraysWithVal(pEvalPositionValues[0, 2], pEvalPositionValues[1, 2], pEvalPositionValues[2, 2], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 11] = SwapArrayViewingSide(processedValues[ip1, 4] = MultiplyArraysWithVal(pEvalPositionValues[0, 3], pEvalPositionValues[1, 3], pEvalPositionValues[2, 3], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 12] = SwapArrayViewingSide(processedValues[ip1, 5] = MultiplyArraysWithVal(pEvalPositionValues[0, 4], pEvalPositionValues[1, 4], pEvalPositionValues[2, 4], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 13] = SwapArrayViewingSide(processedValues[ip1, 6] = MultiplyArraysWithVal(pEvalPositionValues[0, 5], pEvalPositionValues[1, 5], pEvalPositionValues[2, 5], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); } return processedValues; } private double[] MultiplyArraysWithVal(double[] pArr1, double[] pArr2, double[] pArr3, double pVal1, double pVal2, double pVal3) { int tL = pArr1.Length; double[] rArr = new double[tL]; for (int i = 0; i < tL; i++) { rArr[i] = pArr1[i] * pVal1 + pArr2[i] * pVal2 + pArr3[i] * pVal3; } return rArr; } private int[] MultiplyArraysWithVal(int[] pArr1, int[] pArr2, int[] pArr3, double pVal1, double pVal2, double pVal3) { int tL = pArr1.Length; int[] rArr = new int[tL]; for (int i = 0; i < tL; i++) { rArr[i] = (int)(pArr1[i] * pVal1 + pArr2[i] * pVal2 + pArr3[i] * pVal3); } return rArr; } private int[] SwapArrayViewingSideAndNegate(int[] pArr) { return new int[64] { -pArr[56], -pArr[57], -pArr[58], -pArr[59], -pArr[60], -pArr[61], -pArr[62], -pArr[63], -pArr[48], -pArr[49], -pArr[50], -pArr[51], -pArr[52], -pArr[53], -pArr[54], -pArr[55], -pArr[40], -pArr[41], -pArr[42], -pArr[43], -pArr[44], -pArr[45], -pArr[46], -pArr[47], -pArr[32], -pArr[33], -pArr[34], -pArr[35], -pArr[36], -pArr[37], -pArr[38], -pArr[39], -pArr[24], -pArr[25], -pArr[26], -pArr[27], -pArr[28], -pArr[29], -pArr[30], -pArr[31], -pArr[16], -pArr[17], -pArr[18], -pArr[19], -pArr[20], -pArr[21], -pArr[22], -pArr[23], -pArr[8], -pArr[9], -pArr[10], -pArr[11], -pArr[12], -pArr[13], -pArr[14], -pArr[15], -pArr[0], -pArr[1], -pArr[2], -pArr[3], -pArr[4], -pArr[5], -pArr[6], -pArr[7] }; } private int[] SwapArrayViewingSide(int[] pArr) { return new int[64] { pArr[56], pArr[57], pArr[58], pArr[59], pArr[60], pArr[61], pArr[62], pArr[63], pArr[48], pArr[49], pArr[50], pArr[51], pArr[52], pArr[53], pArr[54], pArr[55], pArr[40], pArr[41], pArr[42], pArr[43], pArr[44], pArr[45], pArr[46], pArr[47], pArr[32], pArr[33], pArr[34], pArr[35], pArr[36], pArr[37], pArr[38], pArr[39], pArr[24], pArr[25], pArr[26], pArr[27], pArr[28], pArr[29], pArr[30], pArr[31], pArr[16], pArr[17], pArr[18], pArr[19], pArr[20], pArr[21], pArr[22], pArr[23], pArr[8], pArr[9], pArr[10], pArr[11], pArr[12], pArr[13], pArr[14], pArr[15], pArr[0], pArr[1], pArr[2], pArr[3], pArr[4], pArr[5], pArr[6], pArr[7] }; } private double[] SwapArrayViewingSide(double[] pArr) { return new double[64] { pArr[56], pArr[57], pArr[58], pArr[59], pArr[60], pArr[61], pArr[62], pArr[63], pArr[48], pArr[49], pArr[50], pArr[51], pArr[52], pArr[53], pArr[54], pArr[55], pArr[40], pArr[41], pArr[42], pArr[43], pArr[44], pArr[45], pArr[46], pArr[47], pArr[32], pArr[33], pArr[34], pArr[35], pArr[36], pArr[37], pArr[38], pArr[39], pArr[24], pArr[25], pArr[26], pArr[27], pArr[28], pArr[29], pArr[30], pArr[31], pArr[16], pArr[17], pArr[18], pArr[19], pArr[20], pArr[21], pArr[22], pArr[23], pArr[8], pArr[9], pArr[10], pArr[11], pArr[12], pArr[13], pArr[14], pArr[15], pArr[0], pArr[1], pArr[2], pArr[3], pArr[4], pArr[5], pArr[6], pArr[7] }; } private int[,][] texelTuningRuntimeVals = new int[33, 14][]; private int[,][] texelTuningVals = new int[3, 6][]; private int[,] texelTuningAdjustIterations = new int[6, 64]; private int[][] texelTuningRuntimePositionalValsV2EG = new int[14][]; private int[][] texelTuningRuntimePositionalValsV2LG = new int[14][]; private int[] texelPieceEvaluationsV2EG = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[] texelPieceEvaluationsV2LG = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[] texelKingSafetyR1EvaluationsEG = new int[9]; private int[] texelKingSafetyR2EvaluationsEG = new int[17]; private int[] texelKingSafetyR1EvaluationsLG = new int[9]; private int[] texelKingSafetyR2EvaluationsLG = new int[17]; private int[] texelKingSafetySREvaluationsPT1EG = new int[12]; private int[] texelKingSafetySREvaluationsPT2EG = new int[12]; private int[] texelKingSafetySREvaluationsPT3EG = new int[12]; private int[] texelKingSafetySREvaluationsPT4EG = new int[12]; private int[] texelKingSafetySREvaluationsPT5EG = new int[12]; private int[] texelKingSafetySREvaluationsPT6EG = new int[12]; private int[] texelKingSafetySREvaluationsPT1LG = new int[12]; private int[] texelKingSafetySREvaluationsPT2LG = new int[12]; private int[] texelKingSafetySREvaluationsPT3LG = new int[12]; private int[] texelKingSafetySREvaluationsPT4LG = new int[12]; private int[] texelKingSafetySREvaluationsPT5LG = new int[12]; private int[] texelKingSafetySREvaluationsPT6LG = new int[12]; private int[,] texelMobilityStraightEG = new int[14, 15], texelMobilityStraightLG = new int[14, 15]; private int[,] texelMobilityDiagonalEG = new int[14, 14], texelMobilityDiagonalLG = new int[14, 14]; private int[] texelPieceEvaluations = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[] blackSidedSquares = new int[64] { 56, 57, 58, 59, 60, 61, 62, 63, 48, 49, 50, 51, 52, 53, 54, 55, 40, 41, 42, 43, 44, 45, 46, 47, 32, 33, 34, 35, 36, 37, 38, 39, 24, 25, 26, 27, 28, 29, 30, 31, 16, 17, 18, 19, 20, 21, 22, 23, 08, 09, 10, 11, 12, 13, 14, 15, 00, 01, 02, 03, 04, 05, 06, 07 }; private int[,] T_Pawns = new int[3, 64] { { 0, 0, 0, 0, 0, 0, 0, 0, 98, 134, 61, 95, 68, 126, 34, -11, -6, 7, 26, 31, 65, 56, 25, -20, -14, 13, 6, 21, 23, 12, 17, -23, -27, -2, -5, 12, 17, 6, 10, -25, -26, -4, -4, -10, 3, 3, 33, -12, -35, -1, -20, -23, -15, 24, 38, -22, 0, 0, 0, 0, 0, 0, 0, 0, } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { 0, 0, 0, 0, 0, 0, 0, 0, 178, 173, 158, 134, 147, 132, 165, 187, 94, 100, 85, 67, 56, 53, 82, 84, 32, 24, 13, 5, -2, 4, 17, 17, 13, 9, -3, -7, -7, -8, 3, -1, 4, 7, -6, 1, 0, -5, -1, -8, 13, 8, 8, 10, 13, 0, 2, -7, 0, 0, 0, 0, 0, 0, 0, 0, } }; private int[,] T_Knights = new int[3, 64] { { -167, -89, -34, -49, 61, -97, -15, -107, -73, -41, 72, 36, 23, 62, 7, -17, -47, 60, 37, 65, 84, 129, 73, 44, -9, 17, 19, 53, 37, 69, 18, 22, -13, 4, 16, 13, 28, 19, 21, -8, -23, -9, 12, 10, 19, 17, 25, -16, -29, -53, -12, -3, -1, 18, -14, -19, -105, -21, -58, -33, -17, -28, -19, -23 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -58, -38, -13, -28, -31, -27, -63, -99, -25, -8, -25, -2, -9, -25, -24, -52, -24, -20, 10, 9, -1, -9, -19, -41, -17, 3, 22, 22, 22, 11, 8, -18, -18, -6, 16, 25, 16, 17, 4, -18, -23, -3, -1, 15, 10, -3, -20, -22, -42, -20, -10, -5, -2, -20, -23, -44, -29, -51, -23, -15, -22, -18, -50, -64 } }; private int[,] T_Bishops = new int[3, 64] { { -29, 4, -82, -37, -25, -42, 7, -8, -26, 16, -18, -13, 30, 59, 18, -47, -16, 37, 43, 40, 35, 50, 37, -2, -4, 5, 19, 50, 37, 37, 7, -2, -6, 13, 13, 26, 34, 12, 10, 4, 0, 15, 15, 15, 14, 27, 18, 10, 4, 15, 16, 0, 7, 21, 33, 1, -33, -3, -14, -21, -13, -12, -39, -21 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -14, -21, -11, -8, -7, -9, -17, -24, -8, -4, 7, -12, -3, -13, -4, -14, 2, -8, 0, -1, -2, 6, 0, 4, -3, 9, 12, 9, 14, 10, 3, 2, -6, 3, 13, 19, 7, 10, -3, -9, -12, -3, 8, 10, 13, 3, -7, -15, -14, -18, -7, -1, 4, -9, -15, -27, -23, -9, -23, -5, -9, -16, -5, -17 } }; private int[,] T_Rooks = new int[3, 64] { { 32, 42, 32, 51, 63, 9, 31, 43, 27, 32, 58, 62, 80, 67, 26, 44, -5, 19, 26, 36, 17, 45, 61, 16, -24, -11, 7, 26, 24, 35, -8, -20, -36, -26, -12, -1, 9, -7, 6, -23, -45, -25, -16, -17, 3, 0, -5, -33, -44, -16, -20, -9, -1, 11, -6, -71, -19, -13, 1, 17, 16, 7, -37, -26 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { 13, 10, 18, 15, 12, 12, 8, 5, 11, 13, 13, 11, -3, 3, 8, 3, 7, 7, 7, 5, 4, -3, -5, -3, 4, 3, 13, 1, 2, 1, -1, 2, 3, 5, 8, 4, -5, -6, -8, -11, -4, 0, -5, -1, -7, -12, -8, -16, -6, -6, 0, 2, -9, -9, -11, -3, -9, 2, 3, -1, -5, -13, 4, -20 } }; private int[,] T_Queens = new int[3, 64] { { -28, 0, 29, 12, 59, 44, 43, 45, -24, -39, -5, 1, -16, 57, 28, 54, -13, -17, 7, 8, 29, 56, 47, 57, -27, -27, -16, -16, -1, 17, -2, 1, -9, -26, -9, -10, -2, -4, 3, -3, -14, 2, -11, -2, -5, 2, 14, 5, -35, -8, 11, 2, 8, 15, -3, 1, -1, -18, -9, 10, -15, -25, -31, -50 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -9, 22, 22, 27, 27, 19, 10, 20, -17, 20, 32, 41, 58, 25, 30, 0, -20, 6, 9, 49, 47, 35, 19, 9, 3, 22, 24, 45, 57, 40, 57, 36, -18, 28, 19, 47, 31, 34, 39, 23, -16, -27, 15, 6, 9, 17, 10, 5, -22, -23, -30, -16, -16, -23, -36, -32, -33, -28, -22, -43, -5, -32, -20, -41 } }; private int[,] T_Kings = new int[3, 64] { { -65, 23, 16, -15, -56, -34, 2, 13, 29, -1, -20, -7, -8, -4, -38, -29, -9, 24, 2, -16, -20, 6, 22, -22, -17, -20, -12, -27, -30, -25, -14, -36, -49, -1, -27, -39, -46, -44, -33, -51, -14, -14, -22, -46, -44, -30, -15, -27, 1, 7, -8, -64, -43, -16, 9, 8, -15, 36, 12, -54, 8, -28, 24, 14 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -74, -35, -18, -18, -11, 15, 4, -17, -12, 17, 14, 17, 17, 38, 23, 11, 10, 17, 23, 15, 20, 45, 44, 13, -8, 22, 24, 27, 26, 33, 26, 3, -18, -4, 21, 24, 27, 23, 9, -11, -19, -3, 11, 21, 23, 16, 7, -9, -27, -11, 4, 13, 14, 4, -5, -17, -53, -34, -21, -11, -28, -14, -24, -43 } }; private int[] paramsLowerLimits = new int[5] { -10000, -10000, -10000, -10000, -10000 }; private int[] paramsUpperLimits = new int[5] { 10000, 10000, 10000, 10000, 10000 }; private List<TLM_ChessGame> threadDataset; private int threadFrom, threadTo; private int[] threadParams; private int customThreadID = 0; private ulong ulAllThreadIDsUnfinished = 0; private double lastCostVal = 0d; private double sumCostVals = 0d; private int costCalculations = 0; private readonly string[] TEXELPRINT_GAMEPARTS = new string[3] { "Early Game: ", "Mid Game: ", "Late Game: "}; private readonly string[] TEXELPRINT_PIECES = new string[6] { "Bauer: ", "Springer: ", "Lufer: ", "Turm: ", "Dame: ", "Knig: "}; private double[] earlyGameMultipliers = new double[33]; private double[] middleGameMultipliers = new double[33]; private double[] lateGameMultipliers = new double[33]; private int[] pieceTypeGameProgressImpact = new int[14] { 0, 0, 1, 1, 2, 4, 0, 0, 0, 1, 1, 2, 4, 0 }; private void PrecalculateMultipliers() { if (BOARD_MANAGER_ID == ENGINE_VALS.PARALLEL_BOARDS - 1) SNAPSHOT_WRITLINE_REPLACEMENT(); for (int i = 0; i < 25; i++) { earlyGameMultipliers[i] = EGMultiplierFunction(i); lateGameMultipliers[i] = LGMultiplierFunction(i); if (BOARD_MANAGER_ID == ENGINE_VALS.PARALLEL_BOARDS - 1) SNAPSHOT_WRITLINE_REPLACEMENT("[" + i + "] "+ earlyGameMultipliers[i] + " | "+ middleGameMultipliers[i] + " | "+ lateGameMultipliers[i]); } } private double MultiplierFunction(double pVal, double pXShift) { double d = Math.Exp(1d /6d * (pVal - pXShift)); return 5 * (d /Math.Pow(d + 1, 2d)); } private double EGMultiplierFunction(double pVal) { return Math.Clamp(1 /16d * (pVal - 4d), 0d, 1d); } private double LGMultiplierFunction(double pVal) { return Math.Clamp(1 /-16d * (pVal - 4d) + 1d, 0d, 1d); } private double EGMultiplierFunction2(double pVal) { return Math.Clamp(1 /32d * pVal, 0d, 1d); } private double LGMultiplierFunction2(double pVal) { return Math.Clamp(1 /-32d * pVal + 1d, 0d, 1d); } private void TuneWithTxtFile(string pTXTName) { List<TLM_ChessGame> gameDataset = new List<TLM_ChessGame>(); string tPath = PathManager.GetTXTPath(pTXTName); string[] tStrs = File.ReadAllLines(tPath); List<string> tGames = new List<string>(); foreach (string s in tStrs) if (s.Contains(';') && s.Replace(" ", "") != "") tGames.Add(s); foreach (string s in tGames) { TLM_ChessGame tGame = CGFF.GetGame(s); LoadFenString(tGame.startFen); foreach (int hMove in tGame.hashedMoves) { List<Move> moveOptionList = new List<Move>(); GetLegalMoves(ref moveOptionList); int tL = moveOptionList.Count; for (int j = 0; j < tL; j++) { Move tMove = moveOptionList[j]; if (tMove.moveHash == hMove) { tGame.actualMoves.Add(tMove); PlainMakeMove(tMove); tL = -1; break; } } if (tL != -1) break; } gameDataset.Add(tGame); } SNAPSHOT_WRITLINE_REPLACEMENT("[TLM TEXEL TUNER] " + tGames.Count + " Games Loaded In!"); BOT_MAIN.curTEXELPARAMS = new int[TEXEL_PARAMS]; BOT_MAIN.ParallelTexelTuning(gameDataset); } private void LoadBestTexelParamsIn() { int[] ttt = new int[778] { 72, 300, 484, 528, 904, 128, 272, 280, 504, 720, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -56, 88, -92, -200, 56, -40, -48, -148, -100, 96, -32, -100, 8, -28, -8, 32, -64, -200, 44, -184, 12, -8, 96, -200, -16, -104, -40, 40, 24, -134, -136, -8, -16, 80, -8, -32, 136, -120, -12, -136, -16, 20, -136, 68, 32, -200, 0, 88, -176, 128, -72, 128, 88, -200, 104, -200, 124, 40, 64, 84, 8, -124, -48, 128, 100, -36, -32, -32, -64, 200, -200, 200, 200, -200, 8, 156, -20, 76, 72, 200, 196, 200, 200, 200, -66, 8, 200, 200, -200, 200, -200, 200, 56, 200, -200, 200, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -200, -200, -28, 200, -200, -22, 200, 192, 172, 200, 12, 120, 12, -200, -200, 200, 18, -194, 200, -200, 46, -168, 52, 200, 176, 56, -56, 200, -40, 32, 8, 200, 70, -176, -112, 200, 168, -48, 192, 76, 192, -72, 136, 46, 64, -200, -24, -200, 172, -200, -200, 88, 24, 200, 112, -68, 200, 200, 168, -120, 200, -88, -12, 200, 76, 40, 56, 200, 200, 200, 64, -200, 138, -56, 200, -16, 96, 136, 200, -112, 200, 200, 200, 200, 101, -200, 176, 200, -200, 200, 120, -200, 54, -128, 200, -24, -200, 200, 200, -72, 200, 200, 200, 200, -200, -200, 176, -200, 80, 176, 200, -24, 112, -200, 200, 200, -200, -200, -200, 128, -200, 112, -200, -200, 200, -200, 16, -200, 16, -80, -200, 184, -8, 200, -32, -200, -176, -200, -56, 200, 56, 200, -104, -152, -200, 200, 32, 200, 112, 8, -24, 160, 92, -76, -120, -200, 64, -200, 200, -200, 32, 136, -140, -144, 24, 8, 16, 200, 132, 24, 40, -24, -62, -200, 200, -15, -8, -116, 148, 200, -76, 200, 200, -200, 96, -200, 8, 200, -148, -200, -200, 188, 200, 86, 64, 80, -180, -200, 64, 200, 200, 200, -200, -132, 184, -184, 200, -156, -136, -200, 200, -104, -184, 60, -200, -184, -32, 0, -169, 96, 200, 200, 200, 200, 200, 200, -200, -200, 200, -200, -200, 68, -200, -200, 200, 200, -200, 176, -200, 200, -56, 200, -200, 152, -200, -168, -46, -200, 200, -200, -200, 192, -200, 68, -200, -200, -16, 16, 4, 200, -168, 112, 176, -200, 92, -128, -200, 16, 34, 144, -68, 24, -40, -200, -64, 40, -128, 152, 48, -24, -200, -35, 200, -56, -88, 4, -96, 128, 200, -200, 200, -100, 200, -80, 32, -172, 200, -200, -40, -200, -78, 200, 96, -24, -26, 200, 80, -32, 200, -76, 200, 48, 200, -200, 16, -148, -200, -64, 32, -72, 120, -180, 200, 84, 200, 136, 200, 200, 200, 200, -52, 200, 72, 200, 200, -200, -64, 200, 200, -144, -136, 40, 200, -104, -8, 200, 88, -200, -173, -112, 200, -88, -40, 200, 32, -200, -200, 72, 200, 68, 200, -156, -200, -40, 128, 4, 144, -88, -200, 200, 174, -136, 200, -200, 184, -176, 200, -56, -200, 200, -200, -152, -200, 160, 200, -171, -96, -200, 88, 200, -62, 72, -200, -200, -200, 200, 194, -200, -200, -200, -140, 200, -32, 56, 88, 200, 200, 200, -53, -200, -38, -200, 84, -200, -200, 200, -8, 100, 3, -140, 38, 172, -48, 200, -20, -160, 80, -200, 200, -200, -200, 200, -200, -200, -56, -52, -72, -124, 80, 80, 88, -8, 104, -88, 104, 200, -24, -200, -8, -200, -80, 22, 164, 200, 152, 80, 104, -200, 88, -104, 200, 200, 25, 200, -112, -200, 56, -200, 200, 200, 100, -80, 176, 200, 200, 104, 200, 200, -200, -200, 24, 200, 200, 200, 200, -200, -200, -30, 200, 200, 200, 48, 200, 200, -76, -200, 200, -184, 200, 200, -200, -200, 174, 200, 108, 192, 128, 200, 80, 200, 200, 40, -200, -200, -48, -84, -88, 64, -24, -200, 8, -16, 160, -200, 176, -100, 200, 200, -200, -174, 48, -112, 72, 44, -136, -84, 44, -104, 64, -16, -96, 200, 64, -200, -200, 200, -200, 80, -200, 144, -200, 144, -192, 152, -104, 24, -200, 200, -200, -136, -8, -112, -200, -200, 200, 112, -200, 200, 48, 0, -200, 144, -200, -136, -48, 200, 200, -134, -200, -56, -200, -28, -192, -200, 200, 92, -200, 200, 134, 200, 200, 144, 200, -94, 200, 120, 200, 200, 200, 200, -200, -200, -200, 200, -200, 200, 200, -200, 200, 200, -197, 200, -200, 200, 197, 200, 200, 200, 0, 0, 200, -200, 200, 200, -200, -200, -200, 200, -200, -200, -200, 128, -200, -200, -200, -200, 0, -200, -200, -200 }; SetupTexelEvaluationParams(ttt); } private void SetupTexelEvaluationParams(int[] pParams) { texelPieceEvaluationsV2EG[8] = -(texelPieceEvaluationsV2EG[1] = pParams[0]); texelPieceEvaluationsV2EG[9] = -(texelPieceEvaluationsV2EG[2] = pParams[1]); texelPieceEvaluationsV2EG[10] = -(texelPieceEvaluationsV2EG[3] = pParams[2]); texelPieceEvaluationsV2EG[11] = -(texelPieceEvaluationsV2EG[4] = pParams[3]); texelPieceEvaluationsV2EG[12] = -(texelPieceEvaluationsV2EG[5] = pParams[4]); texelPieceEvaluationsV2LG[8] = -(texelPieceEvaluationsV2LG[1] = pParams[5]); texelPieceEvaluationsV2LG[9] = -(texelPieceEvaluationsV2LG[2] = pParams[6]); texelPieceEvaluationsV2LG[10] = -(texelPieceEvaluationsV2LG[3] = pParams[7]); texelPieceEvaluationsV2LG[11] = -(texelPieceEvaluationsV2LG[4] = pParams[8]); texelPieceEvaluationsV2LG[12] = -(texelPieceEvaluationsV2LG[5] = pParams[9]); int c = 10; for (int p = 1; p < 7; p++) { for (int s = 0; s < 64; s++) { texelTuningRuntimePositionalValsV2EG[p + 7][blackSidedSquares[s]] = -(texelTuningRuntimePositionalValsV2EG[p][s] = pParams[c++]); texelTuningRuntimePositionalValsV2LG[p + 7][blackSidedSquares[s]] = -(texelTuningRuntimePositionalValsV2LG[p][s] = pParams[c++]); } } return; for (int p = 2; p < 7; p++) { for (int a = 0; a < 15; a++) { if (a != 14) { texelMobilityDiagonalEG[p + 7, a] = -(texelMobilityDiagonalEG[p, a] = pParams[c++]); texelMobilityDiagonalLG[p + 7, a] = -(texelMobilityDiagonalLG[p, a] = pParams[c++]); } texelMobilityStraightEG[p + 7, a] = -(texelMobilityStraightEG[p, a] = pParams[c++]); texelMobilityStraightLG[p + 7, a] = -(texelMobilityStraightLG[p, a] = pParams[c++]); } } for (int i = 0; i < 12; i++) { texelKingSafetySREvaluationsPT1EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT2EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT3EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT4EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT5EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT6EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT1LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT2LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT3LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT4LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT5LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT6LG[i] = pParams[c++]; } } private void PrintDefinedTexelParams(int[] pParams) { int c = 0; for (int t = 0; t < 3; t++) { SNAPSHOT_WRITLINE_REPLACEMENT(TEXELPRINT_GAMEPARTS[t]); for (int p = 0; p < 6; p++) { SNAPSHOT_WRITLINE_REPLACEMENT(TEXELPRINT_PIECES[p]); texelTuningVals[t, p] = new int[64]; for (int s = 0; s < 64; s++) { if (s % 8 == 0 && s != 0) SNAPSHOT_WRITLINE_REPLACEMENT(); SNAPSHOT_WRITLINE_REPLACEMENT((texelTuningVals[t, p][s] = pParams[c++]) + ", "); } SNAPSHOT_WRITLINE_REPLACEMENT(); } } piecePositionEvals = GetInterpolatedProcessedValues(texelTuningVals); } public void TLMTuning(List<TLM_ChessGame> pDataset) { int tGameDataSetLen = pDataset.Count; int[,][] tRatio = new int[33, 6][]; int[,][] tTotalMoves = new int[33, 6][]; double[,][] tSummedRatios = new double[33, 6][]; double[,][] tSummedDataAmount = new double[33, 6][]; double[,][] tTuningResults = new double[33, 6][]; for (int t = 1; t < 33; t++) { for (int p = 0; p < 6; p++) { tRatio[t, p] = new int[64]; tTotalMoves[t, p] = new int[64]; tSummedRatios[t, p] = new double[64]; tSummedDataAmount[t, p] = new double[64]; tTuningResults[t, p] = new double[64]; } } for (int j = 0; j < tGameDataSetLen; j++) { TLM_ChessGame tGame = pDataset[j]; int tGR = tGame.gameResult - 1; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count - 5; for (int i = 0; i < tL; i++) { if (tGame.isMoveNonTactical[i]) { int tPieceAmount = ULONG_OPERATIONS.CountBits(allPieceBitboard); for (int s = 0; s < 64; s++) { int tPT = pieceTypeArray[s] - 1; if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, s)) { tTotalMoves[tPieceAmount, tPT][s]++; tRatio[tPieceAmount, tPT][s] += tGR; } else if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, s)) { int b = blackSidedSquares[s]; tTotalMoves[tPieceAmount, tPT][b]++; tRatio[tPieceAmount, tPT][b] += tGR; } } } PlainMakeMove(tGame.actualMoves[i]); } } double[,] allMultipliers = new double[33, 33]; for (int sh = 0; sh < 33; sh++) { for (int i = 0; i < 33; i++) { allMultipliers[sh, i] = MultiplierFunction(i, sh); } } for (int t = 1; t < 33; t++) { for (int p = 0; p < 6; p++) { for (int s = 0; s < 64; s++) { for (int t2 = 1; t2 < 33; t2++) { double cmult = allMultipliers[t, t2]; tSummedRatios[t, p][s] += tRatio[t2, p][s] * cmult; tSummedDataAmount[t, p][s] += tTotalMoves[t2, p][s] * cmult; } tTuningResults[t, p][s] = TTT(tSummedRatios[t, p][s], tSummedDataAmount[t, p][s]); } } } int c = 0; int[] tparams = new int[1152]; for (int t = 1; t < 33; t += 15) { if (t == 31) t = 32; SNAPSHOT_WRITLINE_REPLACEMENT("PieceCount = " + t + ": "); for (int p = 0; p < 6; p++) { SNAPSHOT_WRITLINE_REPLACEMENT(TEXELPRINT_PIECES[p]); for (int s = 0; s < 64; s++) { if (s % 8 == 0 && s != 0) SNAPSHOT_WRITLINE_REPLACEMENT(); SNAPSHOT_WRITLINE_REPLACEMENT((tparams[c++] = (int)(tTuningResults[t, p][s] * 100)).ToString().Replace(",", ".") + "("+ (int)tSummedDataAmount[t, p][s] + ")"+ ", "); } SNAPSHOT_WRITLINE_REPLACEMENT(); } } string tS = "PARAMS: {"; for (int i = 0; i < tparams.Length; i++) tS += tparams[i] + ","; tS = tS.Substring(0, tS.Length - 1) + "}\n"; SNAPSHOT_WRITLINE_REPLACEMENT(tS); TexelTuning(pDataset, tparams); } private double TTT(double d1, double d2) { if (d2 == 0) return 0; return d1 /d2; } public void TexelTuning(List<TLM_ChessGame> pDataset, int[] pCurBestParams) { Stopwatch sw = Stopwatch.StartNew(); string tPath = PathManager.GetTXTPath("OTHER/TEXEL_TUNING"); int paramCount = pCurBestParams.Length; double bestAvrgCost = CalculateAverageTexelCost(pDataset, pCurBestParams); SNAPSHOT_WRITLINE_REPLACEMENT("CUR PARAMS COST: " + bestAvrgCost); int packetSize = Math.Clamp(paramCount /ENGINE_VALS.CPU_CORES, 1, 100000); paramsLowerLimits = new int[paramCount]; paramsUpperLimits = new int[paramCount]; for (int i = 0; i < paramCount; i++) { int lim = i < 10 ? 100000 : 200; paramsLowerLimits[i] = -lim; paramsUpperLimits[i] = lim; } SNAPSHOT_WRITLINE_REPLACEMENT("PARAM-COUNT: " + paramCount); SNAPSHOT_WRITLINE_REPLACEMENT("PACKET-SIZE: " + packetSize); while (packetSize <= paramCount) { BOT_MAIN.TEXELfinished = 0; int lM = 0, tC = 0; ulong tUL = 0ul; for (int m = packetSize; lM < paramCount; m += packetSize) { if (m > paramCount) m = paramCount; tUL = ULONG_OPERATIONS.SetBitToOne(tUL, ++tC); lM = m; } tC = lM = 0; for (int m = packetSize; lM < paramCount; m += packetSize) { if (m > paramCount) m = paramCount; tC++; BOT_MAIN.boardManagers[tC].SetPlayTexelVals(pDataset, lM, m, pCurBestParams, paramsLowerLimits, paramsUpperLimits, tC, tUL); ThreadPool.QueueUserWorkItem(new WaitCallback(BOT_MAIN.boardManagers[tC].TexelTuningThreadedPackage)); lM = m; } packetSize = paramCount + 1; int tmod = 0; while (tC != BOT_MAIN.TEXELfinished) { if (++tmod % 20 == 0) { WriteTexelParamsToTXT(tPath, BOT_MAIN.curTEXELPARAMS); SNAPSHOT_WRITLINE_REPLACEMENT(CalculateAverageTexelCost(pDataset, BOT_MAIN.curTEXELPARAMS) + " | "+ BOT_MAIN.TEXELadjustmentsmade); SNAPSHOT_WRITLINE_REPLACEMENT(ULONG_OPERATIONS.GetBitVisualization(BOT_MAIN.TEXELfinishedwithoutimpovement)); } Thread.Sleep(100); } SNAPSHOT_WRITLINE_REPLACEMENT("One Thread Generation FINISHED! :) :) :)"); pCurBestParams = BOT_MAIN.curTEXELPARAMS; } sw.Stop(); WriteTexelParamsToTXT(tPath, BOT_MAIN.curTEXELPARAMS); SNAPSHOT_WRITLINE_REPLACEMENT("END COST: " + CalculateAverageTexelCost(pDataset, BOT_MAIN.curTEXELPARAMS)); SNAPSHOT_WRITLINE_REPLACEMENT(BOT_MAIN.TEXELadjustmentsmade); SNAPSHOT_WRITLINE_REPLACEMENT(sw.ElapsedMilliseconds); } public void TexelTuningThreadedPackage(object obj) { SNAPSHOT_WRITLINE_REPLACEMENT("Started CThreadID [" + customThreadID + "] which is handling Params ["+ threadFrom + "] - ["+ threadTo + "]"); bool firstIter = true; do { double bestAvrgCost = CalculateAverageTexelCost(threadDataset, threadParams); int adjust_val = firstIter ? 512 : 8; do { adjust_val /= 2; bool improvedAvrgCost = true; while (improvedAvrgCost) { improvedAvrgCost = false; for (int i = threadFrom; i < threadTo; i++) { bool improvedWithThisParam = true; int tadjustval = adjust_val; bool lastTimeMaximized = false, lastTimeMinimized = false; while (improvedWithThisParam) { improvedWithThisParam = false; int[] curParams = (int[])threadParams.Clone(); int paramBefore = curParams[i]; curParams[i] = Math.Clamp(paramBefore + adjust_val, paramsLowerLimits[i], paramsUpperLimits[i]); double curAvrgCost = CalculateAverageTexelCost(threadDataset, curParams); if (curAvrgCost < bestAvrgCost) { improvedAvrgCost = true; improvedWithThisParam = true; SNAPSHOT_WRITLINE_REPLACEMENT("Improved Param [" + i + "] at CThreadID ["+ customThreadID + "]: +"+ adjust_val + " ("+ GetDoublePrecentageString(bestAvrgCost - curAvrgCost) + ")"); bestAvrgCost = curAvrgCost; threadParams = curParams; BOT_MAIN.TEXELadjustmentsmade++; BOT_MAIN.TEXELfinishedwithoutimpovement = ulAllThreadIDsUnfinished; if (lastTimeMaximized) { adjust_val *= 4; lastTimeMaximized = false; } else lastTimeMaximized = true; lastTimeMinimized = false; } else { curParams[i] = Math.Clamp(paramBefore - adjust_val, paramsLowerLimits[i], paramsUpperLimits[i]); curAvrgCost = CalculateAverageTexelCost(threadDataset, curParams); if (curAvrgCost < bestAvrgCost) { improvedAvrgCost = true; improvedWithThisParam = true; SNAPSHOT_WRITLINE_REPLACEMENT("Improved Param [" + i + "] at CThreadID ["+ customThreadID + "]: -"+ adjust_val + " ("+ GetDoublePrecentageString(bestAvrgCost - curAvrgCost) + ")"); bestAvrgCost = curAvrgCost; threadParams = curParams; BOT_MAIN.TEXELadjustmentsmade++; BOT_MAIN.TEXELfinishedwithoutimpovement = ulAllThreadIDsUnfinished; if (lastTimeMinimized) { adjust_val *= 4; lastTimeMinimized = false; } else lastTimeMinimized = true; lastTimeMaximized = false; } } if (adjust_val != 1) adjust_val /= 2; for (int j = threadFrom; j < threadTo; j++) { BOT_MAIN.curTEXELPARAMS[j] = threadParams[j]; } threadParams = (int[])BOT_MAIN.curTEXELPARAMS.Clone(); bestAvrgCost = CalculateAverageTexelCost(threadDataset, threadParams); } adjust_val = tadjustval; } } } while (adjust_val != 1); BOT_MAIN.TEXELfinishedwithoutimpovement = ULONG_OPERATIONS.SetBitToZero(BOT_MAIN.TEXELfinishedwithoutimpovement, customThreadID); SNAPSHOT_WRITLINE_REPLACEMENT("FULLY FINISHED " + customThreadID + ". IMPROVEMENT THREAD PACKAGE CYCLE"); firstIter = false; } while (BOT_MAIN.TEXELfinishedwithoutimpovement != 0); BOT_MAIN.TEXELfinished++; } private void WriteTexelParamsToTXT(string pPath, int[] pParams) { try { string tS = "PARAMS: {"; for (int i = 0; i < pParams.Length; i++) tS += pParams[i] + ","; tS = tS.Substring(0, tS.Length - 1) + "}\n"; File.AppendAllText(pPath, tS); } catch { SNAPSHOT_WRITLINE_REPLACEMENT("Mal wieder TXT zu lange gebraucht um zu aktualisieren."); } } private double costSum = 0d; private int texelCostMovesEvaluated = 0; private double CalculateAverageTexelCost(List<TLM_ChessGame> tDataset, int[] pParams, bool pFullCost = true) { costSum = 0d; texelCostMovesEvaluated = 0; SetupTexelEvaluationParams(pParams); int tGameDataSetLen = tDataset.Count; int start = 0, end = tGameDataSetLen; if (!pFullCost) { end = (start = globalRandom.Next(0, end - 256)) + 256; } for (int j = start; j < end; j++) { TLM_ChessGame tGame = tDataset[j]; double tGR = tGame.gameResult; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count - 5; texelCostMovesEvaluated += tL; for (int i = 0; i < tL; i++) { costSum += TexelCost(tGR - TexelTuningSigmoid(TexelEvaluate())); PlainMakeMove(tGame.actualMoves[i]); } } return costSum /texelCostMovesEvaluated; } private double CalculateAverageTexelCostThreadedVersionLEGACYDOESNTWORK(List<TLM_ChessGame> tDataset, int[] pParams) { Stopwatch sw = Stopwatch.StartNew(); BOT_MAIN.TEXELcostSum = 0d; BOT_MAIN.TEXELfinished = 0; BOT_MAIN.TEXELcostMovesEvaluated = 0; int tGameDataSetLen = tDataset.Count; int gamesPerThread = tGameDataSetLen /ENGINE_VALS.CPU_CORES; for (int i = 0; i < ENGINE_VALS.CPU_CORES - 1; i++) { } for (int i = 0; i < ENGINE_VALS.CPU_CORES - 1; i++) { } while (BOT_MAIN.TEXELfinished != ENGINE_VALS.CPU_CORES) Thread.Sleep(1); sw.Stop(); return BOT_MAIN.TEXELcostSum /BOT_MAIN.TEXELcostMovesEvaluated; } public void SetPlayThroughVals(List<TLM_ChessGame> pDataset, int pFrom, int pTo) { threadDataset = pDataset; threadFrom = pFrom; threadTo = pTo; } public void SetPlayTexelVals(List<TLM_ChessGame> pDataset, int pFrom, int pTo, int[] pTexelParams, int[] pLowerLimits, int[] pUpperLimits, int pThreadID, ulong pUL) { threadDataset = pDataset; threadFrom = pFrom; threadTo = pTo; threadParams = pTexelParams; paramsLowerLimits = pLowerLimits; paramsUpperLimits = pUpperLimits; customThreadID = pThreadID; ulAllThreadIDsUnfinished = pUL; } public void PlayThroughSetOfGames(object obj) { SNAPSHOT_WRITLINE_REPLACEMENT(threadFrom + "->"+ threadTo); int sortedOut = 0; for (int j = threadFrom; j < threadTo; j++) { TLM_ChessGame tGame = threadDataset[j]; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count; for (int i = 0; i < tL; i++) { int tQuietEval = isWhiteToMove ? QuiescenceWhite(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, 0, PreMinimaxCheckCheckWhite(), NULL_MOVE) : QuiescenceBlack(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, 0, PreMinimaxCheckCheckBlack(), NULL_MOVE); bool tB; tGame.isMoveNonTactical.Add(tB = (Evaluate() == tQuietEval && i > 4)); if (!tB) sortedOut++; PlainMakeMove(tGame.actualMoves[i]); } } BOT_MAIN.TEXELsortedout += sortedOut; BOT_MAIN.TEXELfinished++; } public void CalculateAverageTexelCostThreadFunction(object obj) { SetupTexelEvaluationParams(threadParams); double d = 0d; for (int j = threadFrom; j < threadTo; j++) { TLM_ChessGame tGame = threadDataset[j]; double tGR = tGame.gameResult; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count - 5; BOT_MAIN.TEXELcostMovesEvaluated += tL; for (int i = 0; i < tL; i++) { d += TexelCost(tGR - TexelTuningSigmoid(TexelEvaluate())); PlainMakeMove(tGame.actualMoves[i]); } } BOT_MAIN.TEXELcostSum += d; BOT_MAIN.TEXELfinished++; } private void ConsoleWriteLineTuneArray<T>(T[,][] pArr) { for (int j = 0; j < 3; j++) { SNAPSHOT_WRITLINE_REPLACEMENT("{"); for (int k = 0; k < 6; k++) { SNAPSHOT_WRITLINE_REPLACEMENT("{"); for (int s = 0; s < 64; s++) SNAPSHOT_WRITLINE_REPLACEMENT(pArr[j, k][s] + ", "); SNAPSHOT_WRITLINE_REPLACEMENT("\n}"); } SNAPSHOT_WRITLINE_REPLACEMENT("}"); } } private void Tune(string pGameCGFF, double pLearningRate) { TLM_ChessGame tGame = CGFF.GetGame(pGameCGFF); LoadFenString(tGame.startFen); double tDGameResult = tGame.gameResult; foreach (int hMove in tGame.hashedMoves) { Tune(tDGameResult, pLearningRate); List<Move> moveOptionList = new List<Move>(); GetLegalMoves(ref moveOptionList); int tL = moveOptionList.Count; for (int i = 0; i < tL; i++) { Move tMove = moveOptionList[i]; if (tMove.moveHash == hMove) { PlainMakeMove(tMove); tL = -1; break; } } if (tL != -1) break; } } private void Tune(double pGameResult, double pLearningRate) { int tPC = ULONG_OPERATIONS.CountBits(allPieceBitboard); double oneThroughPieceCount = 1d /tPC; double egMult = earlyGameMultipliers[tPC], mgMult = middleGameMultipliers[tPC], lgMult = lateGameMultipliers[tPC]; double tTexelResult = TexelEvaluateF(); double tSigmoidedTexelResult = TexelSigmoid(tTexelResult); double tDif = tSigmoidedTexelResult - pGameResult; double tM = oneThroughPieceCount * TexelCostDerivative(tDif) * TexelSigmoidDerivative(tTexelResult) * pLearningRate; sumCostVals += lastCostVal = TexelCost(tDif); costCalculations++; for (int i = 0; i < 64; i++) { if (ULONG_OPERATIONS.IsBitZero(allPieceBitboard, i)) continue; int tPT = pieceTypeArray[i] - 1, tI = i; if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, i)) tI = blackSidedSquares[i]; texelTuningAdjustIterations[tPT, tI]++; } } private double TexelEvaluateF() { texelTuningRuntimeVals = GetInterpolatedProcessedValues(texelTuningVals); return TexelEvaluate(); } private int TexelEvaluate() { int tEvalEG = 0, tEvalLG = 0, tProgress = 0; ulong[] attkULs = new ulong[14]; for (int p = 0; p < 64; p++) { if (((int)(allPieceBitboard >> p) & 1) == 0) continue; int aPT = pieceTypeArray[p], tPT = aPT + 7 * ((int)(blackPieceBitboard >> p) & 1); tEvalEG += texelTuningRuntimePositionalValsV2EG[tPT][p] + texelPieceEvaluationsV2EG[tPT]; tEvalLG += texelTuningRuntimePositionalValsV2LG[tPT][p] + texelPieceEvaluationsV2LG[tPT]; tProgress += pieceTypeGameProgressImpact[tPT]; } if (tProgress > 24) tProgress = 24; return (int)(earlyGameMultipliers[tProgress] * tEvalEG + lateGameMultipliers[tProgress] * tEvalLG); } private const double TexelK = 0.2; private double TexelTuningSigmoid(double pVal) { return 2d /(1 + Math.Pow(10, -TexelK * pVal /400)); } private double TexelSigmoid(double pVal) { return 2d /(Math.Exp(-0.04d * pVal) + 1d); } private double TexelSigmoidDerivative(double pVal) { double d = Math.Exp(-0.04d * pVal); return 2d * d /(25d * (d + 1d) * (d + 1d)); } private double TexelCost(double pVal) { return pVal * pVal; } private double TexelCostDerivative(double pVal) { return 2 * pVal; } private char[] fenPieces = new char[7] { 'z', 'p', 'n', 'b', 'r', 'q', 'k' }; private string[] squareNames = new string[64] { "a1", "b1", "c1", "d1", "e1", "f1", "g1", "h1", "a2", "b2", "c2", "d2", "e2", "f2", "g2", "h2", "a3", "b3", "c3", "d3", "e3", "f3", "g3", "h3", "a4", "b4", "c4", "d4", "e4", "f4", "g4", "h4", "a5", "b5", "c5", "d5", "e5", "f5", "g5", "h5", "a6", "b6", "c6", "d6", "e6", "f6", "g6", "h6", "a7", "b7", "c7", "d7", "e7", "f7", "g7", "h7", "a8", "b8", "c8", "d8", "e8", "f8", "g8", "h8"}; public string CreateFenString() { string rFEN = ""; for (int i = 7; i >= 0; i--) { int t = 0; for (int j = 0; j < 8; j++) { int sq = i * 8 + j; if (pieceTypeArray[sq] != 0) { if (t != 0) rFEN += t; t = 0; } if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, sq)) { switch (pieceTypeArray[sq]) { case 0: t++; SNAPSHOT_WRITLINE_REPLACEMENT("???"); break; case 1: rFEN += 'P'; break; case 2: rFEN += 'N'; break; case 3: rFEN += 'B'; break; case 4: rFEN += 'R'; break; case 5: rFEN += 'Q'; break; case 6: rFEN += 'K'; break; } } else { switch (pieceTypeArray[sq]) { case 0: t++; break; case 1: rFEN += 'p'; break; case 2: rFEN += 'n'; break; case 3: rFEN += 'b'; break; case 4: rFEN += 'r'; break; case 5: rFEN += 'q'; break; case 6: rFEN += 'k'; break; } } } if (t != 0) rFEN += t; if (i != 0) rFEN += "/"; } rFEN += (isWhiteToMove ? " w": " b"); rFEN += (whiteCastleRightKingSide ? " K": " "); rFEN += (whiteCastleRightQueenSide ? "Q": ""); rFEN += (blackCastleRightKingSide ? "k": ""); rFEN += (blackCastleRightQueenSide ? "q": ""); if (!whiteCastleRightKingSide && !whiteCastleRightQueenSide && !blackCastleRightKingSide && !blackCastleRightQueenSide) rFEN += "-"; if (enPassantSquare < 64) rFEN += " "+ squareNames[enPassantSquare] + " "; else rFEN += " - "; return rFEN + fiftyMoveRuleCounter + " "+ ((happenedHalfMoves - happenedHalfMoves % 2) /2); } public void LoadFenString(string fenStr) { lastMadeMove = NULL_MOVE; zobristKey = 0ul; whitePieceBitboard = blackPieceBitboard = allPieceBitboard = 0ul; for (int i = 0; i < 64; i++) pieceTypeArray[i] = 0; string[] spaceSpl = fenStr.Split(' '); string[] rowSpl = spaceSpl[0].Split('/'); string epstr = spaceSpl[3]; if (epstr == "-") enPassantSquare = 65; else enPassantSquare = (epstr[0] - 'a') + 8 * (epstr[1] - '1'); isWhiteToMove = true; if (spaceSpl[1] == "b") isWhiteToMove = false; if (!isWhiteToMove) zobristKey ^= blackTurnHash; string crstr = spaceSpl[2]; whiteCastleRightKingSide = whiteCastleRightQueenSide = blackCastleRightKingSide = blackCastleRightQueenSide = false; int crStrL = crstr.Length; for (int i = 0; i < crStrL; i++) { switch (crstr[i]) { case 'K': whiteCastleRightKingSide = true; break; case 'Q': whiteCastleRightQueenSide = true; break; case 'k': blackCastleRightKingSide = true; break; case 'q': blackCastleRightQueenSide = true; break; } } fiftyMoveRuleCounter = Convert.ToInt32(spaceSpl[4]); happenedHalfMoves = Convert.ToInt32(spaceSpl[5]) * 2; if (!isWhiteToMove) happenedHalfMoves++; int tSq = 0; for (int i = rowSpl.Length; i-- > 0;) { string tStr = rowSpl[i]; int tStrLen = tStr.Length; for (int c = 0; c < tStrLen; c++) { char tChar = tStr[c]; if (Char.IsDigit(tChar)) tSq += tChar - '0'; else { bool tCol = Char.IsLower(tChar); if (tCol) blackPieceBitboard = ULONG_OPERATIONS.SetBitToOne(blackPieceBitboard, tSq); else whitePieceBitboard = ULONG_OPERATIONS.SetBitToOne(whitePieceBitboard, tSq); if (tChar == 'k') blackKingSquare = tSq; else if (tChar == 'K') whiteKingSquare = tSq; pieceTypeArray[tSq] = Array.IndexOf(fenPieces, Char.ToLower(tChar)); if (tCol) zobristKey ^= pieceHashesBlack[tSq, pieceTypeArray[tSq]]; else zobristKey ^= pieceHashesWhite[tSq, pieceTypeArray[tSq]]; tSq++; } } } if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; zobristKey ^= enPassantSquareHashes[enPassantSquare]; allPieceBitboard = whitePieceBitboard | blackPieceBitboard; if (zobristKey == 16260251586586513106) moveHashList.Clear(); else { moveHashList.Clear(); moveHashList.Add(1); moveHashList.Add(2); moveHashList.Add(3); } } private ulong[,] pieceHashesWhite = new ulong[64, 7], pieceHashesBlack = new ulong[64, 7]; private ulong blackTurnHash, whiteKingSideRochadeRightHash, whiteQueenSideRochadeRightHash, blackKingSideRochadeRightHash, blackQueenSideRochadeRightHash; private ulong[] enPassantSquareHashes = new ulong[66]; private void InitZobrist() { Random rng = new Random(31415926); for (int sq = 0; sq < 64; sq++) { enPassantSquareHashes[sq] = ULONG_OPERATIONS.GetRandomULONG(rng); for (int it = 1; it < 7; it++) { pieceHashesWhite[sq, it] = ULONG_OPERATIONS.GetRandomULONG(rng); pieceHashesBlack[sq, it] = ULONG_OPERATIONS.GetRandomULONG(rng); } } blackTurnHash = ULONG_OPERATIONS.GetRandomULONG(rng); whiteKingSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); whiteQueenSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); blackKingSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); blackQueenSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); } public void SetKnightMasks(ulong[] uls) { knightSquareBitboards = uls; } public void SetKingMasks(ulong[] uls) { kingSquareBitboards = uls; } private Move[,] whiteEnPassantMoves = new Move[64, 64]; private Move[,] blackEnPassantMoves = new Move[64, 64]; private bool[] epValidationArray = new bool[64] { false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true , true , true , true , true , true , true , true, true , true , true , true , true , true , true , true, true , true , true , true , true , true , true , true, true , true , true , true , true , true , true , true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false }; private ulong[] kingSafetyRing1 = new ulong[64], kingSafetyRing2 = new ulong[64]; private ulong[] kingSafetySpecialRingW = new ulong[64], kingSafetySpecialRingB = new ulong[64]; private ulong[] rowPrecalcs = new ulong[8], columnPrecalcs = new ulong[8]; const ulong columnUL = 0x101010101010101, rowUL = 0b11111111; private void PrecalculateKingSafetyBitboards() { for (int i = 0; i < 8; i++) { rowPrecalcs[i] = rowUL << (8 * i); columnPrecalcs[i] = columnUL << i; } for (int i = 0; i < 64; i++) { int tMod = i % 8; int tRow = (i - tMod) /8; ulong tULC = columnPrecalcs[tMod], tULR = rowPrecalcs[tRow]; ulong tULC2 = columnPrecalcs[tMod], tULR2 = rowPrecalcs[tRow]; if (tMod < 7) tULC |= columnPrecalcs[tMod + 1]; if (tMod > 0) tULC |= columnPrecalcs[tMod - 1]; if (tRow < 7) tULR |= rowPrecalcs[tRow + 1]; if (tRow > 0) tULR |= rowPrecalcs[tRow - 1]; if (tMod < 6) tULC2 |= columnPrecalcs[tMod + 2]; if (tMod > 1) tULC2 |= columnPrecalcs[tMod - 2]; if (tRow < 6) tULR2 |= rowPrecalcs[tRow + 2]; if (tRow > 1) tULR2 |= rowPrecalcs[tRow - 2]; tULR2 |= tULR; tULC2 |= tULC; kingSafetyRing1[i] = ULONG_OPERATIONS.SetBitToZero(tULR & tULC, i); kingSafetyRing2[i] = ULONG_OPERATIONS.SetBitsToZero(tULR2 & tULC2, i, i + 1, i - 1, i + 7, i + 8, i + 9, i - 7, i - 8, i - 9); } for (int i = 0; i < 64; i++) { if (i < 56) kingSafetySpecialRingW[i] = ULONG_OPERATIONS.SetBitToZero(kingSafetyRing1[i] | kingSafetyRing1[i + 8], i); else kingSafetySpecialRingW[i] = kingSafetyRing1[i]; if (i > 7) kingSafetySpecialRingB[i] = ULONG_OPERATIONS.SetBitToZero(kingSafetyRing1[i] | kingSafetyRing1[i - 8], i); else kingSafetySpecialRingB[i] = kingSafetyRing1[i]; } } private void PrecalculateEnPassantMoves() { for (int i = 0; i < 64; i++) { if (!epValidationArray[i]) continue; for (int j = 0; j < 64; j++) { if (i == j) continue; if (Math.Abs(i - j) > 9) continue; if (!epValidationArray[j]) continue; whiteEnPassantMoves[i, j] = new Move(false, i, j, j - 8); blackEnPassantMoves[i, j] = new Move(false, i, j, j + 8); } } } private void PawnAttackBitboards() { for (int sq = 0; sq < 64; sq++) { ulong u = 0ul; if (sq % 8 != 0) u = ULONG_OPERATIONS.SetBitToOne(u, sq + 7); if (sq % 8 != 7) u = ULONG_OPERATIONS.SetBitToOne(u, sq + 9); whitePawnAttackSquareBitboards[sq] = u; u = 0ul; if (sq % 8 != 0 && sq - 9 > -1) u = ULONG_OPERATIONS.SetBitToOne(u, sq - 9); if (sq % 8 != 7 && sq - 7 > -1) u = ULONG_OPERATIONS.SetBitToOne(u, sq - 7); blackPawnAttackSquareBitboards[sq] = u; } } private int[] squareConnectivesPrecalculationArray = new int[4096]; public int[] squareConnectivesCrossDirsPrecalculationArray { get; set; } = new int[4096]; private ulong[] squareConnectivesPrecalculationRayArray = new ulong[4096]; private ulong[] squareConnectivesPrecalculationLineArray = new ulong[4096]; private List<Dictionary<ulong, int>> rayCollidingSquareCalculations = new List<Dictionary<ulong, int>>(); private readonly int[] maxIntWithSpecifiedBitcount = new int[8] { 0, 0b1, 0b11, 0b111, 0b1111, 0b11111, 0b111111, 0b1111111 }; private List<ulong> differentRays = new List<ulong>(); private void SquareConnectivesPrecalculations() { for (int square = 0; square < 64; square++) { rayCollidingSquareCalculations.Add(new Dictionary<ulong, int>()); rayCollidingSquareCalculations[square].Add(0ul, square); for (int square2 = 0; square2 < 64; square2++) { if (square == square2) continue; int t = 0, t2 = 0, difSign = Math.Sign(square2 - square), itSq = square, g = 0; ulong tRay = 0ul, tExclRay = 0ul; List<int> tRayInts = new List<int>(); if (difSign == -1) g = 7; if (square % 8 == square2 % 8) { t2 = t = 1; while ((itSq += difSign * 8) < 64 && itSq > -1) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } } else if ((square - square % 8) == (square2 - square2 % 8)) { t = 1; t2 = -1; while ((itSq += difSign) % 8 != g && itSq > -1 && itSq < 64) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } } else { int dif = Math.Abs(square2 - square); if (dif % 7 == 0) { t = 2; t2 = 2; g = (difSign == 1) ? 7 : 0; while ((itSq += difSign * 7) % 8 != g && itSq < 64 && itSq > -1) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } if (ULONG_OPERATIONS.IsBitZero(tRay, square2)) { t2 = t = 0; tRay = 0ul; } } else if (dif % 9 == 0) { t = 2; t2 = -2; if (square == 0 && square2 == 63 || square == 63 && square2 == 0) SNAPSHOT_WRITLINE_REPLACEMENT("!"); while ((itSq += difSign * 9) % 8 != g && itSq < 64 && itSq > -1) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } if (ULONG_OPERATIONS.IsBitZero(tRay, square2)) { t2 = t = 0; tRay = 0ul; } } } if (square == 0 && square2 == 63) { t2 = t = 2; tRayInts.Clear(); tExclRay = tRay = ULONG_OPERATIONS.SetBitsToOne(0ul, 9, 18, 27, 36, 45, 54, 63); tRayInts = new List<int>() { 9, 18, 27, 36, 45, 54, 63 }; } else if (square2 == 0 && square == 63) { t = 2; tRayInts.Clear(); t2 = -2; tExclRay = tRay = ULONG_OPERATIONS.SetBitsToOne(0ul, 0, 9, 18, 27, 36, 45, 54); tRayInts = new List<int>() { 54, 45, 36, 27, 18, 9, 0 }; } if (tRay != 0ul && !differentRays.Contains(tRay)) { differentRays.Add(tRay); int ccount, combI = maxIntWithSpecifiedBitcount[ccount = ULONG_OPERATIONS.CountBits(tRay)]; do { ulong curAllPieceBitboard = 0ul; int solution = square; for (int j = 0; j < ccount; j++) { if (((combI >> j) & 1) == 1) { curAllPieceBitboard = ULONG_OPERATIONS.SetBitToOne(curAllPieceBitboard, tRayInts[j]); if (solution == square) solution = tRayInts[j]; } } rayCollidingSquareCalculations[square].Add(curAllPieceBitboard, solution); } while (--combI != 0); } squareConnectivesPrecalculationArray[square << 6 | square2] = t; squareConnectivesPrecalculationRayArray[square << 6 | square2] = tRay; squareConnectivesCrossDirsPrecalculationArray[square << 6 | square2] = t2; if (t != 0) squareConnectivesPrecalculationLineArray[square << 6 | square2] = (square == 0 && square2 == 63 || square2 == 0 && square == 63) ? tExclRay : ULONG_OPERATIONS.SetBitToOne(tExclRay, square2); if (squareConnectivesPrecalculationLineArray[square << 6 | square2] == 0ul && ULONG_OPERATIONS.IsBitOne(knightSquareBitboards[square], square2)) squareConnectivesPrecalculationLineArray[square << 6 | square2] = 1ul << square2; } differentRays.Clear(); } } public void SNAPSHOT_WRITLINE_REPLACEMENT() { } public void SNAPSHOT_WRITLINE_REPLACEMENT(object pStr) { } private string GetDoublePrecentageString(double pVal) { return ((int)(pVal * 1_000_000) /10_000d) + "%"; } private string ReplaceAllULONGIsBitOne(string pCode) { const string METHOD_NAME = "ULONG_OPERATIONS.IsBitOne"; int METHOD_NAME_LEN = METHOD_NAME.Length, iterations = 0; int pIndex = pCode.IndexOf(METHOD_NAME); while (pIndex != -1 && ++iterations < 10_000) { List<int> paramIndexes = new List<int>(); int openedBracketCount = 1, closedBracketCount = 0, a = METHOD_NAME_LEN + pIndex; string tpCode = pCode.Substring(0, pIndex); paramIndexes.Add(a + 1); while (++a < pCode.Length) { switch (pCode[a]) { case '(': openedBracketCount++; break; case ')': if (++closedBracketCount == openedBracketCount) { pIndex = a; a = int.MaxValue - 5; } break; case ',': if (openedBracketCount - closedBracketCount == 1) paramIndexes.Add(a + 1); break; } } if (openedBracketCount == closedBracketCount && paramIndexes.Count == 2) { tpCode += "((int)("+ pCode.Substring(paramIndexes[0], paramIndexes[1] - paramIndexes[0] - 1) + (pCode[paramIndexes[1]] == ' ' ? " >> (": " >> (") + pCode.Substring(paramIndexes[1], pIndex - paramIndexes[1]) + ")) & 1) == 1"+ pCode.Substring(pIndex + 1, pCode.Length - pIndex - 1); } pIndex = (pCode = tpCode).IndexOf(METHOD_NAME); } SNAPSHOT_WRITLINE_REPLACEMENT(iterations + " ITERATIONS"); return pCode; } private string ReplaceAllULONGIsBitZero(string pCode) { const string METHOD_NAME = "ULONG_OPERATIONS.IsBitZero"; int METHOD_NAME_LEN = METHOD_NAME.Length, iterations = 0; int pIndex = pCode.IndexOf(METHOD_NAME); while (pIndex != -1 && ++iterations < 10_000) { List<int> paramIndexes = new List<int>(); int openedBracketCount = 1, closedBracketCount = 0, a = METHOD_NAME_LEN + pIndex; string tpCode = pCode.Substring(0, pIndex); paramIndexes.Add(a + 1); while (++a < pCode.Length) { switch (pCode[a]) { case '(': openedBracketCount++; break; case ')': if (++closedBracketCount == openedBracketCount) { pIndex = a; a = int.MaxValue - 5; } break; case ',': if (openedBracketCount - closedBracketCount == 1) paramIndexes.Add(a + 1); break; } } if (openedBracketCount == closedBracketCount && paramIndexes.Count == 2) { tpCode += "((int)("+ pCode.Substring(paramIndexes[0], paramIndexes[1] - paramIndexes[0] - 1) + (pCode[paramIndexes[1]] == ' ' ? " >>": " >> ") + pCode.Substring(paramIndexes[1], pIndex - paramIndexes[1]) + ") & 1) == 0"+ pCode.Substring(pIndex + 1, pCode.Length - pIndex - 1); } pIndex = (pCode = tpCode).IndexOf(METHOD_NAME); } SNAPSHOT_WRITLINE_REPLACEMENT(iterations + " ITERATIONS"); return pCode; } private string GetThreeDigitSeperatedInteger(int pInt) { string s = pInt.ToString(), r = s[0].ToString(); int t = s.Length % 3; for (int i = 1; i < s.Length; i++) { if (i % 3 == t) r += "."; r += s[i]; } s = ""; for (int i = 0; i < r.Length; i++) s += r[i]; return s; } public double GetAverageDepth() { return (double)depths /(double)searches; } }
public class SNAPSHOT_V01_00_002 : IBoardManager  { public int TEXEL_PARAMS { get; } = 778; private const int BESTMOVE_SORT_VAL = -2_000_000_000; private const int CAPTURE_SORT_VAL = -1_000_000_000; private const int KILLERMOVE_SORT_VAL = -1000; private readonly int[,] MVVLVA_TABLE = new int[7, 7] { { 0, 0, 0, 0, 0, 0, 0 }, { 0, 1500, 1400, 1300, 1200, 1100, 1000 }, { 0, 3500, 3400, 3300, 3200, 3100, 3000 }, { 0, 4500, 4400, 4300, 4200, 4100, 4000 }, { 0, 5500, 5400, 5300, 5200, 5100, 5000 }, { 0, 9500, 9400, 9300, 9200, 9100, 9000 }, { 0, 0, 0, 0, 0, 0, 0 }}; private int BOARD_MANAGER_ID = -1; private bool debugSearchDepthResults = false; private bool debugSortResults = false; private RookMovement rookMovement; private BishopMovement bishopMovement; private QueenMovement queenMovement; private KnightMovement knightMovement; private KingMovement kingMovement; private WhitePawnMovement whitePawnMovement; private BlackPawnMovement blackPawnMovement; private Rays rays; public List<Move> moveOptionList { get; set; } private int[] pieceTypeArray = new int[64]; public ulong whitePieceBitboard, blackPieceBitboard, allPieceBitboard; private ulong zobristKey; private int whiteKingSquare, blackKingSquare, enPassantSquare = 65, happenedHalfMoves = 0, fiftyMoveRuleCounter = 0; private bool whiteCastleRightKingSide, whiteCastleRightQueenSide, blackCastleRightKingSide, blackCastleRightQueenSide; private bool isWhiteToMove; private const ulong WHITE_KING_ROCHADE = 96, WHITE_QUEEN_ROCHADE = 14, BLACK_KING_ROCHADE = 6917529027641081856, BLACK_QUEEN_ROCHADE = 1008806316530991104, WHITE_QUEEN_ATTK_ROCHADE = 12, BLACK_QUEEN_ATTK_ROCHADE = 864691128455135232; private readonly Move mWHITE_KING_ROCHADE = new Move(4, 6, 7, 5), mWHITE_QUEEN_ROCHADE = new Move(4, 2, 0, 3), mBLACK_KING_ROCHADE = new Move(60, 62, 63, 61), mBLACK_QUEEN_ROCHADE = new Move(60, 58, 56, 59); private ulong[] knightSquareBitboards = new ulong[64]; private ulong[] whitePawnAttackSquareBitboards = new ulong[64]; private ulong[] blackPawnAttackSquareBitboards = new ulong[64]; private ulong[] kingSquareBitboards = new ulong[64]; private bool[,] pieceTypeAbilities = new bool[7, 3] { { false, false, false }, { false, false, false }, { false, false, false }, { false, false, true }, { false, true, false }, { false, true, true }, { false, false, false } }; private List<int> moveHashList = new List<int>(); private ulong[] curSearchZobristKeyLine = Array.Empty<ulong>(); private Stopwatch globalTimer = Stopwatch.StartNew(); private Move lastMadeMove; private int depths, searches; private Random globalRandom = new Random(); public SNAPSHOT_V01_00_002(string fen) { Setup(fen); } public void Setup(string pFen) { Stopwatch setupStopwatch = Stopwatch.StartNew(); BOARD_MANAGER_ID = BOT_MAIN.curBoardManagerID; for (int i = 0; i < 33; i++) for (int j = 0; j < 14; j++) piecePositionEvals[i, j] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; for (int i = 0; i < 33; i++) for (int j = 0; j < 14; j++) texelTuningRuntimeVals[i, j] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; for (int i = 0; i < 3; i++) for (int j = 0; j < 6; j++) texelTuningVals[i, j] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; for (int i = 0; i < 14; i++) { texelTuningRuntimePositionalValsV2EG[i] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; texelTuningRuntimePositionalValsV2LG[i] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; } PrecalculateKingSafetyBitboards(); PrecalculateMultipliers(); GetLowNoisePositionalEvaluation(globalRandom); MinimaxRoot(1L); SetupConsoleWrite("[PRECALCS] Zobrist Hashing"); InitZobrist(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Knight Movement"); knightMovement = new KnightMovement(this); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Square Connectives"); SquareConnectivesPrecalculations(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Pawn Attack Bitboards"); PawnAttackBitboards(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Rays"); rays = new Rays(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); queenMovement = new QueenMovement(this); SetupConsoleWrite("[PRECALCS] Rook Movement"); rookMovement = new RookMovement(this, queenMovement); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Bishop Movement"); bishopMovement = new BishopMovement(this, queenMovement); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] King Movement"); kingMovement = new KingMovement(this); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Pawn Movement"); whitePawnMovement = new WhitePawnMovement(this); blackPawnMovement = new BlackPawnMovement(this); PrecalculateEnPassantMoves(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWriteLine("[DONE]\n\n"); LoadFenString(pFen); LoadBestTexelParamsIn(); setupStopwatch.Stop(); } private void SetupConsoleWriteLine(string pStr) { if (BOT_MAIN.isFirstBoardManagerInitialized) return; SNAPSHOT_WRITLINE_REPLACEMENT(pStr); } private void SetupConsoleWrite(string pStr) { if (BOT_MAIN.isFirstBoardManagerInitialized) return; SNAPSHOT_WRITLINE_REPLACEMENT(pStr); } public void GetLowNoisePositionalEvaluation(System.Random rng) { int[,][] digitArray = new int[3, 6][]; for (int i = 0; i < 3; i++) for (int j = 0; j < 6; j++) digitArray[i, j] = GetRand64IntArray(rng, -5, 6); lowNoisePositionEvals1 = GetInterpolatedProcessedValues(digitArray); int[,][] digitArray2 = new int[3, 6][]; for (int i = 0; i < 3; i++) for (int j = 0; j < 6; j++) digitArray2[i, j] = GetRand64IntArray(rng, -5, 6); lowNoisePositionEvals2 = GetInterpolatedProcessedValues(digitArray2); } private int[] GetRand64IntArray(System.Random rng, int pMin, int pMax) { return new int[64] { rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax) }; } private string GetAIArrayValuesStringRepresentation(int[,][] pArr) { string r = "int[,][] ReLe_AI_RESULT_VALS = new int[3, 6][] {"; for (int i = 0; i < 3; i++) { r += "{"; for (int j = 0; j < 5; j++) { r += GetIntArray64LStringRepresentation(pArr[i, j]) + ","; } r += GetIntArray64LStringRepresentation(pArr[i, 5]) + "},"; } return r.Substring(0, r.Length - 1) + "};"; } private string GetIntArray64LStringRepresentation(int[] p64LArr) { if (p64LArr == null) return ""; string r = "new int[64]{"; for (int i = 0; i < 63; i++) { r += p64LArr[i] + ","; } return r + p64LArr[63] + "}"; } public void TempStuff() { } private string[] gameResultStrings = new string[5] { "Black Has Won!", "Draw!", "White Has Won!", "Non Existant Result!", "Game is Ongoing!"}; private int[,][] lowNoisePositionEvals1, lowNoisePositionEvals2; public void ThreadSelfPlay(object obj) { PlayGameAgainstItself(obj); } public void PlayGameAgainstItself(object obj, string pStartFEN = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1", long tickLimitForEngine = ENGINE_VALS.SELF_PLAY_THINK_TIME) { int ttGState; while (BOT_MAIN.goalGameCount > BOT_MAIN.gamesPlayed) { try { string tGameStr; GetLowNoisePositionalEvaluation(globalRandom); LoadFenString(tGameStr = pStartFEN); tGameStr += ";"; int tGState = 3, tmc = 0; bool lowNoiceDecider = globalRandom.NextDouble() < 0.5d; while (tGState == 3) { piecePositionEvals = lowNoiceDecider ? lowNoisePositionEvals1 : lowNoisePositionEvals2; MinimaxRoot(tickLimitForEngine); Move tM = transpositionTable[zobristKey].bestMove; PlainMakeMove(tM); tGameStr += NuCRe.GetNuCRe(tM.moveHash) + ","; BOT_MAIN.movesPlayed++; tGState = GameState(isWhiteToMove); lowNoiceDecider = !lowNoiceDecider; tmc++; } ttGState = tGState; tGameStr += ttGState + 1; SNAPSHOT_WRITLINE_REPLACEMENT(tGameStr); BOT_MAIN.gamesPlayedResultArray[ttGState + 1]++; BOT_MAIN.gamesPlayed++; BOT_MAIN.selfPlayGameStrings.Add(tGameStr); } catch (Exception tE) { SNAPSHOT_WRITLINE_REPLACEMENT(tE.ToString()); } } } public void PlayGameOnConsoleAgainstHuman(string pStartFEN = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1", bool pHumanPlaysWhite = true, long tickLimitForEngine = 10_000_000L) { debugSearchDepthResults = true; LoadFenString(pStartFEN); if (!(pHumanPlaysWhite ^ isWhiteToMove)) { var pVS = Console.ReadLine(); if (pVS == null) return; Move tm = GetMoveOfString(pVS.ToString()); SNAPSHOT_WRITLINE_REPLACEMENT(tm); PlainMakeMove(tm); } int tGState = 3; while (tGState == 3) { MinimaxRoot(tickLimitForEngine); PlayThroughZobristTree(); Move tM = transpositionTable[zobristKey].bestMove; SNAPSHOT_WRITLINE_REPLACEMENT(tM); SNAPSHOT_WRITLINE_REPLACEMENT(CreateFenString()); PlainMakeMove(tM); tGState = GameState(isWhiteToMove); if (tGState != 3 || tM == NULL_MOVE) break; var pV = ""; tM = NULL_MOVE; do { pV = Console.ReadLine(); if (pV == null) continue; tM = GetMoveOfString(pV.ToString()); SNAPSHOT_WRITLINE_REPLACEMENT(tM); } while (tM == NULL_MOVE); PlainMakeMove(tM); tGState = GameState(isWhiteToMove); } } private void PlayThroughZobristTree() { SetJumpState(); SNAPSHOT_WRITLINE_REPLACEMENT("\n- - - - - - - - - - - - -"); int tC = 1; Dictionary<ulong, bool> usedULs = new Dictionary<ulong, bool>(); while (transpositionTable.TryGetValue(zobristKey, out TranspositionEntry tM)) { if (usedULs.ContainsKey(zobristKey)) { SNAPSHOT_WRITLINE_REPLACEMENT(tC + ": AT LEAST ONE REPETION; REST NOT VISIBLE"); break; } SNAPSHOT_WRITLINE_REPLACEMENT(tC + ": "+ tM.bestMove + " > "); usedULs.Add(zobristKey, true); PlainMakeMove(tM.bestMove); tC++; } SNAPSHOT_WRITLINE_REPLACEMENT("- - - - - - - - - - - - -\n"); LoadJumpState(); } public Move? ReturnNextMove(Move? lastMove, long pThinkingTime) { if (lastMove != null) PlainMakeMove(lastMove); if (GameState(isWhiteToMove) != 3) return null; MinimaxRoot(pThinkingTime); if (!transpositionTable.ContainsKey(zobristKey)) return null; Move tm = transpositionTable[zobristKey].bestMove; PlainMakeMove(tm); return tm; } private int[] jmpSt_pieceTypeArray; private ulong jmpSt_whitePieceBitboard, jmpSt_blackPieceBitboard; private ulong jmpSt_zobristKey; private int jmpSt_whiteKingSquare, jmpSt_blackKingSquare, jmpSt_enPassantSquare, jmpSt_happenedHalfMoves, jmpSt_fiftyMoveRuleCounter; private bool jmpSt_whiteCastleRightKingSide, jmpSt_whiteCastleRightQueenSide, jmpSt_blackCastleRightKingSide, jmpSt_blackCastleRightQueenSide; private bool jmpSt_isWhiteToMove; private ulong[] jmpSt_curSearchZobristKeyLine; private int[] jmpSt_moveHashList; public void LoadJumpState() { pieceTypeArray = (int[])jmpSt_pieceTypeArray.Clone(); whitePieceBitboard = jmpSt_whitePieceBitboard; blackPieceBitboard = jmpSt_blackPieceBitboard; zobristKey = jmpSt_zobristKey; whiteKingSquare = jmpSt_whiteKingSquare; blackKingSquare = jmpSt_blackKingSquare; enPassantSquare = jmpSt_enPassantSquare; happenedHalfMoves = jmpSt_happenedHalfMoves; fiftyMoveRuleCounter = jmpSt_fiftyMoveRuleCounter; whiteCastleRightKingSide = jmpSt_whiteCastleRightKingSide; whiteCastleRightQueenSide = jmpSt_whiteCastleRightQueenSide; blackCastleRightKingSide = jmpSt_blackCastleRightKingSide; blackCastleRightQueenSide = jmpSt_blackCastleRightQueenSide; isWhiteToMove = jmpSt_isWhiteToMove; curSearchZobristKeyLine = (ulong[])jmpSt_curSearchZobristKeyLine.Clone(); allPieceBitboard = blackPieceBitboard | whitePieceBitboard; moveHashList = jmpSt_moveHashList.ToList(); } public void SetJumpState() { jmpSt_pieceTypeArray = (int[])pieceTypeArray.Clone(); jmpSt_whitePieceBitboard = whitePieceBitboard; jmpSt_blackPieceBitboard = blackPieceBitboard; jmpSt_zobristKey = zobristKey; jmpSt_whiteKingSquare = whiteKingSquare; jmpSt_blackKingSquare = blackKingSquare; jmpSt_enPassantSquare = enPassantSquare; jmpSt_happenedHalfMoves = happenedHalfMoves; jmpSt_fiftyMoveRuleCounter = fiftyMoveRuleCounter; jmpSt_whiteCastleRightKingSide = whiteCastleRightKingSide; jmpSt_whiteCastleRightQueenSide = whiteCastleRightQueenSide; jmpSt_blackCastleRightKingSide = blackCastleRightKingSide; jmpSt_blackCastleRightQueenSide = blackCastleRightQueenSide; jmpSt_isWhiteToMove = isWhiteToMove; jmpSt_curSearchZobristKeyLine = (ulong[])curSearchZobristKeyLine.Clone(); jmpSt_moveHashList = moveHashList.ToArray(); } private int PreMinimaxCheckCheckWhite() { ulong bitShiftedKingPos = 1ul << whiteKingSquare; int curR = -1; for (int p = 0; p < 64; p++) { if (ULONG_OPERATIONS.IsBitZero(blackPieceBitboard, p)) continue; int tPT; switch (tPT = pieceTypeArray[p]) { case 1: if ((bitShiftedKingPos & blackPawnAttackSquareBitboards[p]) != 0ul) return p; break; case 2: if ((bitShiftedKingPos & knightSquareBitboards[p]) != 0ul) return p; break; case 6: break; default: if ((squareConnectivesPrecalculationLineArray[whiteKingSquare << 6 | p] & allPieceBitboard) == (1ul << p) && pieceTypeAbilities[tPT, squareConnectivesPrecalculationArray[whiteKingSquare << 6 | p]]) { if (curR != -1) return -779; curR = p; } break; } } return curR; } private int PreMinimaxCheckCheckBlack() { ulong bitShiftedKingPos = 1ul << blackKingSquare; int curR = -1; for (int p = 0; p < 64; p++) { if (ULONG_OPERATIONS.IsBitZero(whitePieceBitboard, p)) continue; int tPT; switch (tPT = pieceTypeArray[p]) { case 1: if ((bitShiftedKingPos & whitePawnAttackSquareBitboards[p]) != 0ul) return p; break; case 2: if ((bitShiftedKingPos & knightSquareBitboards[p]) != 0ul) return p; break; case 6: break; default: if ((squareConnectivesPrecalculationLineArray[blackKingSquare << 6 | p] & allPieceBitboard) == (1ul << p) && pieceTypeAbilities[tPT, squareConnectivesPrecalculationArray[blackKingSquare << 6 | p]]) { if (curR != -1) return -779; curR = p; } break; } } return curR; } private int LecacyLeafCheckingPieceCheckWhite(int pStartPos, int pEndPos, int pPieceType) { int tI, tPossibleAttackPiece; if (pPieceType == 1) { if (ULONG_OPERATIONS.IsBitOne(blackPawnAttackSquareBitboards[pEndPos], whiteKingSquare)) return pEndPos; } else if (pPieceType == 2) { if (ULONG_OPERATIONS.IsBitOne(knightSquareBitboards[pEndPos], whiteKingSquare)) return pEndPos; } else if (pPieceType != 6) { tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | pEndPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; } tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | pStartPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; return -1; } private int LecacyLeafCheckingPieceCheckBlack(int pStartPos, int pEndPos, int pPieceType) { int tI, tPossibleAttackPiece; if (pPieceType == 1) { if (ULONG_OPERATIONS.IsBitOne(whitePawnAttackSquareBitboards[pEndPos], blackKingSquare)) return pEndPos; } else if (pPieceType == 2) { if (ULONG_OPERATIONS.IsBitOne(knightSquareBitboards[pEndPos], blackKingSquare)) return pEndPos; } else if (pPieceType != 6) { tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | pEndPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; } tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | pStartPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; return -1; } public void GetLegalMoves(ref List<Move> pMoveList) { int attk; if (isWhiteToMove) { attk = PreMinimaxCheckCheckWhite(); if (attk == -779) GetLegalWhiteMovesSpecialDoubleCheckCase(ref pMoveList); else GetLegalWhiteMoves(attk, ref pMoveList); } else { attk = PreMinimaxCheckCheckBlack(); if (attk == -779) GetLegalBlackMovesSpecialDoubleCheckCase(ref pMoveList); else GetLegalBlackMoves(attk, ref pMoveList); } } private void GetLegalWhiteMoves(int pCheckingPieceSquare, ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= blackPawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, whiteKingSquare); if (curCheckCount == 0) { if (whiteCastleRightKingSide && ((allPieceBitboard | oppAttkBitboard) & WHITE_KING_ROCHADE) == 0ul) pMoveList.Add(mWHITE_KING_ROCHADE); if (whiteCastleRightQueenSide && (allPieceBitboard & WHITE_QUEEN_ROCHADE | oppAttkBitboard & WHITE_QUEEN_ATTK_ROCHADE) == 0ul) pMoveList.Add(mWHITE_QUEEN_ROCHADE); if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, whitePieceBitboard, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[whiteKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare + 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, whitePieceBitboard, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveList(whiteKingSquare, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalWhiteCaptures(int pCheckingPieceSquare, ref List<Move> pMoveList) { if (pCheckingPieceSquare == -779) { GetLegalWhiteCapturesSpecialDoubleCheckCase(ref pMoveList); return; } moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= blackPawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, whiteKingSquare); if (curCheckCount == 0) { if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & blackPieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[whiteKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare + 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & blackPieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveListOnlyCaptures(whiteKingSquare, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalWhiteMovesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= blackPawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveList(whiteKingSquare, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalWhiteCapturesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= blackPawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveListOnlyCaptures(whiteKingSquare, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalBlackMoves(int pCheckingPieceSquare, ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= whitePawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, blackKingSquare); if (curCheckCount == 0) { if (blackCastleRightKingSide && ((allPieceBitboard | oppAttkBitboard) & BLACK_KING_ROCHADE) == 0ul) pMoveList.Add(mBLACK_KING_ROCHADE); if (blackCastleRightQueenSide && (allPieceBitboard & BLACK_QUEEN_ROCHADE | oppAttkBitboard & BLACK_QUEEN_ATTK_ROCHADE) == 0ul) pMoveList.Add(mBLACK_QUEEN_ROCHADE); if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveList(p, blackKingSquare, blackPieceBitboard, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[blackKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare - 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveList(p, blackKingSquare, blackPieceBitboard, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveList(blackKingSquare, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); } private void GetLegalBlackCaptures(int pCheckingPieceSquare, ref List<Move> pMoveList) { if (pCheckingPieceSquare == -779) { GetLegalBlackCapturesSpecialDoubleCheckCase(ref pMoveList); return; } moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= whitePawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, blackKingSquare); if (curCheckCount == 0) { if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & whitePieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[blackKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare - 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & whitePieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveListOnlyCaptures(blackKingSquare, ~oppAttkBitboard & whitePieceBitboard); } private void GetLegalBlackMovesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= whitePawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveList(blackKingSquare, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); } private void GetLegalBlackCapturesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= whitePawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveListOnlyCaptures(blackKingSquare, ~oppAttkBitboard & whitePieceBitboard); } public Move GetMoveOfString(string pMove) { int tSP, tEP; string[] tSpl = pMove.Split(','); if (Char.IsNumber(pMove[0])) { tSP = Convert.ToInt32(tSpl[0]); tEP = Convert.ToInt32(tSpl[1]); } else { tSP = SQUARES.NumberNotation(tSpl[0]); tEP = SQUARES.NumberNotation(tSpl[1]); } int tPT = pieceTypeArray[tSP]; bool tIC = ULONG_OPERATIONS.IsBitOne(allPieceBitboard, tEP), tIEP = enPassantSquare == tEP && tPT == 1; if (tSpl.Length == 3) return new Move(tSP, tEP, tPT, Convert.ToInt32(tSpl[2]), tIC); if (tIEP) return new Move(true, tSP, tEP, isWhiteToMove ? tEP - 8 : tEP + 8); if (tPT == 1 && Math.Abs(tSP - tEP) > 11) return new Move(tSP, tEP, 1, false, isWhiteToMove ? tSP + 8 : tSP - 8); if (tPT == 6 && (Math.Abs(tSP - tEP) == 2 || Math.Abs(tSP - tEP) == 3)) { if (isWhiteToMove) return tEP == 6 ? mWHITE_KING_ROCHADE : mWHITE_QUEEN_ROCHADE; return tEP == 62 ? mBLACK_KING_ROCHADE : mBLACK_QUEEN_ROCHADE; } return new Move(tSP, tEP, tPT, tIC); } public void PlainMakeMove(string pMoveName) { PlainMakeMove(GetMoveOfString(pMoveName)); } public void PlainMakeMove(Move pMove) { lastMadeMove = pMove; if (isWhiteToMove) WhiteMakeMove(pMove); else BlackMakeMove(pMove); } public void WhiteMakeMove(Move pMove) { int tEndPos = pMove.endPos, tStartPos = pMove.startPos, tPieceType = pMove.pieceType, tPTI = pieceTypeArray[tEndPos]; fiftyMoveRuleCounter++; whitePieceBitboard ^= pMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey ^= blackTurnHash ^ enPassantSquareHashes[enPassantSquare] ^ pieceHashesWhite[tStartPos, tPieceType] ^ pieceHashesWhite[tEndPos, tPieceType]; enPassantSquare = 65; isWhiteToMove = false; switch (pMove.moveTypeID) { case 0: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 1: fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 2: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 3: whiteKingSquare = tEndPos; if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 4: if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 5: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 6: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 7: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[whiteKingSquare = tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 8: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 9: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = pMove.enPassantOption]; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 11: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; whiteKingSquare = tEndPos; pieceTypeArray[pMove.rochadeEndPos] = 4; pieceTypeArray[pMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesWhite[pMove.rochadeStartPos, 4] ^ pieceHashesWhite[pMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 12: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[pMove.enPassantOption] = 0; zobristKey ^= pieceHashesBlack[pMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 13: fiftyMoveRuleCounter = 0; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; zobristKey ^= pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, pMove.promotionType]; break; case 14: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, tPTI] ^ pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, pMove.promotionType]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; } moveHashList.Add(pMove.moveHash); if (pMove.isCapture || tPieceType == 1) { curSearchZobristKeyLine = Array.Empty<ulong>(); return; } ulong[] u = new ulong[(tPTI = curSearchZobristKeyLine.Length) + 1]; for (int i = tPTI; i-- > 0;) u[i] = curSearchZobristKeyLine[i]; u[tPTI] = zobristKey; curSearchZobristKeyLine = u; } public void BlackMakeMove(Move pMove) { int tEndPos = pMove.endPos, tStartPos = pMove.startPos, tPieceType = pMove.pieceType, tPTI = pieceTypeArray[tEndPos]; fiftyMoveRuleCounter++; blackPieceBitboard ^= pMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey ^= blackTurnHash ^ enPassantSquareHashes[enPassantSquare] ^ pieceHashesBlack[tStartPos, tPieceType] ^ pieceHashesBlack[tEndPos, tPieceType]; enPassantSquare = 65; isWhiteToMove = true; switch (pMove.moveTypeID) { case 0: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 1: fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 2: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 3: blackKingSquare = tEndPos; if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 4: if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 5: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 6: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 7: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[blackKingSquare = tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 8: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 9: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = pMove.enPassantOption]; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 11: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; blackKingSquare = tEndPos; pieceTypeArray[pMove.rochadeEndPos] = 4; pieceTypeArray[pMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesBlack[pMove.rochadeStartPos, 4] ^ pieceHashesBlack[pMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 12: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[pMove.enPassantOption] = 0; zobristKey ^= pieceHashesWhite[pMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 13: fiftyMoveRuleCounter = 0; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, pMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 14: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } zobristKey ^= pieceHashesWhite[tEndPos, tPTI] ^ pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, pMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; } moveHashList.Add(pMove.moveHash); if (pMove.isCapture || tPieceType == 1) { curSearchZobristKeyLine = Array.Empty<ulong>(); return; } ulong[] u = new ulong[(tPTI = curSearchZobristKeyLine.Length) + 1]; for (int i = tPTI; i-- > 0;) u[i] = curSearchZobristKeyLine[i]; u[tPTI] = zobristKey; curSearchZobristKeyLine = u; } public void WhiteUndoMove(Move pMove) { } private const int WHITE_CHECKMATE_VAL = 100000, BLACK_CHECKMATE_VAL = -100000, CHECK_EXTENSION_LENGTH = -12, MAX_QUIESCENCE_TOTAL_LENGTH = -32; private readonly Move NULL_MOVE = new Move(0, 0, 0); private int curSearchDepth = 0, curSubSearchDepth = -1; public int MinimaxRoot(long pTime) { evalCount = 0; searches++; int baseLineLen = 0; long tTimestamp = globalTimer.ElapsedTicks + pTime; ClearHeuristics(); transpositionTable.Clear(); ulong[] tZobristKeyLine = Array.Empty<ulong>(); if (curSearchZobristKeyLine != null) { baseLineLen = curSearchZobristKeyLine.Length; tZobristKeyLine = new ulong[baseLineLen]; Array.Copy(curSearchZobristKeyLine, tZobristKeyLine, baseLineLen); } int perftScore, tattk = isWhiteToMove ? PreMinimaxCheckCheckWhite() : PreMinimaxCheckCheckBlack(), pDepth = 1; (string, int) bookMoveTuple = TLMDatabase.SearchForNextBookMove(moveHashList); if (bookMoveTuple.Item2 != 0) { int actualMoveHash = NuCRe.GetNumber(bookMoveTuple.Item1); List<Move> tMoves = new List<Move>(); GetLegalMoves(ref tMoves); int tL = tMoves.Count; for (int i = 0; i < tL; i++) { if (tMoves[i].moveHash == actualMoveHash) { if (debugSearchDepthResults) { SNAPSHOT_WRITLINE_REPLACEMENT("TLM_DB_Count: " + bookMoveTuple.Item2); SNAPSHOT_WRITLINE_REPLACEMENT(">> " + tMoves[i]); } transpositionTable.Add(zobristKey, new TranspositionEntry(tMoves[i], Array.Empty<int>())); return 0; } } } do { curSearchDepth = pDepth; curSubSearchDepth = pDepth - 1; ulong[] completeZobristHistory = new ulong[baseLineLen + pDepth - CHECK_EXTENSION_LENGTH + 1]; for (int i = 0; i < baseLineLen; i++) completeZobristHistory[i] = curSearchZobristKeyLine[i]; curSearchZobristKeyLine = completeZobristHistory; if (isWhiteToMove) { if (tattk == -1) perftScore = MinimaxWhite(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); else perftScore = MinimaxWhite(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); } else { if (tattk == -1) perftScore = MinimaxBlack(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); else perftScore = MinimaxBlack(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); } if (debugSearchDepthResults && pTime != 1L) { int tNpS = Convert.ToInt32((double)evalCount * 10_000_000d /(double)(pTime - tTimestamp + globalTimer.ElapsedTicks)); int tSearchEval = perftScore; int timeForSearchSoFar = (int)((pTime - tTimestamp + globalTimer.ElapsedTicks) /10000d); Move tBestMove = transpositionTable[zobristKey].bestMove; SNAPSHOT_WRITLINE_REPLACEMENT((tSearchEval >= 0 ? "+": "") + tSearchEval); SNAPSHOT_WRITLINE_REPLACEMENT(" " + tBestMove + "  ["); SNAPSHOT_WRITLINE_REPLACEMENT("Depth = " + pDepth + ", "); SNAPSHOT_WRITLINE_REPLACEMENT("Evals = " + GetThreeDigitSeperatedInteger(evalCount) + ", "); SNAPSHOT_WRITLINE_REPLACEMENT("Time = " + GetThreeDigitSeperatedInteger(timeForSearchSoFar) + "ms, "); SNAPSHOT_WRITLINE_REPLACEMENT("NpS = " + GetThreeDigitSeperatedInteger(tNpS) + "]"); } pDepth++; } while (globalTimer.ElapsedTicks < tTimestamp && pDepth < 179); depths += pDepth - 1; BOT_MAIN.depthsSearched += pDepth - 1; BOT_MAIN.searchesFinished++; BOT_MAIN.evaluationsMade += evalCount; curSearchZobristKeyLine = tZobristKeyLine; return perftScore; } private int MinimaxWhite(int pPly, int pAlpha, int pBeta, int pDepth, int pRepetitionHistoryPly, int pCheckingSquare, Move pLastMove) { if (IsDrawByRepetition(pRepetitionHistoryPly - 4)) return 0; if ((pDepth <= 0 && pCheckingSquare == -1) || pDepth < CHECK_EXTENSION_LENGTH) return QuiescenceWhite(pPly, pAlpha, pBeta, pDepth - 1, pCheckingSquare, pLastMove); List<Move> moveOptionList = new List<Move>(); Move bestMove = NULL_MOVE; if (pLastMove.isPromotion && pLastMove.isCapture && pLastMove.startPos % 8 == pCheckingSquare % 8 && pLastMove.startPos == whiteKingSquare + 8 && (pLastMove.promotionType == 4 || pLastMove.promotionType == 5)) GetLegalWhiteMovesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalWhiteMoves(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tWhiteKingSquare = whiteKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1, curEval = BLACK_CHECKMATE_VAL - pDepth; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = true; double[] moveSortingArray = new double[molc]; int[] moveSortingArrayIndexes = new int[molc], thisSearchMoveSortingArrayForTransposEntry = new int[molc]; transpositionTable.TryGetValue(zobristKey, out TranspositionEntry transposEntry); if (transposEntry == null) { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; } } else { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove == transposEntry.bestMove) moveSortingArray[m] = BESTMOVE_SORT_VAL; else if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; if (transposEntry.moveGenOrderedEvalLength > m) moveSortingArray[m] -= transposEntry.moveGenOrderedEvals[m]; } } Array.Sort(moveSortingArray, moveSortingArrayIndexes); for (int m = 0; m < molc; m++) { int tActualIndex = moveSortingArrayIndexes[m]; Move curMove = moveOptionList[tActualIndex]; if (debugSortResults && pDepth == curSubSearchDepth) { SNAPSHOT_WRITLINE_REPLACEMENT(moveSortingArray[m] + " | "+ curMove); } int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; whitePieceBitboard = tWPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesWhite[tStartPos, tPieceType] ^ pieceHashesWhite[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 0: blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 1: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 2: blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 3: whiteKingSquare = tEndPos; if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 4: blackPieceBitboard = tBPB; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 5: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[whiteKingSquare = tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = curMove.enPassantOption]; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 11: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; whiteKingSquare = tEndPos; blackPieceBitboard = tBPB; pieceTypeArray[curMove.rochadeEndPos] = 4; pieceTypeArray[curMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesWhite[curMove.rochadeStartPos, 4] ^ pieceHashesWhite[curMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | curMove.rochadeEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << curMove.rochadeEndPos)) tCheckPos = curMove.rochadeEndPos; break; case 12: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesBlack[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 13: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; zobristKey ^= pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, curMove.promotionType]; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; case 14: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, tPTI] ^ pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, curMove.promotionType]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } curSearchZobristKeyLine[pRepetitionHistoryPly] = zobristKey; int tEval = MinimaxBlack(pPly + 1, pAlpha, pBeta, pDepth - 1, pRepetitionHistoryPly + 1, tCheckPos, curMove); thisSearchMoveSortingArrayForTransposEntry[tActualIndex] = tEval; pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 3: whiteKingSquare = tWhiteKingSquare; break; case 7: whiteKingSquare = tWhiteKingSquare; break; case 10: enPassantSquare = 65; break; case 11: whiteKingSquare = tWhiteKingSquare; pieceTypeArray[curMove.rochadeStartPos] = 4; pieceTypeArray[curMove.rochadeEndPos] = 0; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 13: pieceTypeArray[tStartPos] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval > curEval) { bestMove = curMove; curEval = tEval; } if (pAlpha < curEval) pAlpha = curEval; if (curEval >= pBeta) { if (!curMove.isCapture) { killerMoveHeuristic[curMove.moveHash] = true; if (pDepth > 0) historyHeuristic[curMove.moveHash] += pDepth * pDepth; } break; } } isWhiteToMove = true; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; if (molc == 0 && pCheckingSquare == 0) curEval = 0; if (!transpositionTable.ContainsKey(zobristKey)) transpositionTable.Add(zobristKey, new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry)); else transpositionTable[zobristKey] = new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry); return curEval; } private int QuiescenceWhite(int pPly, int pAlpha, int pBeta, int pDepth, int pCheckingSquare, Move pLastMove) { int standPat = TexelEvaluate(); if (standPat >= pBeta || pDepth < MAX_QUIESCENCE_TOTAL_LENGTH) return pBeta; if (standPat > pAlpha) pAlpha = standPat; List<Move> moveOptionList = new List<Move>(); if (pLastMove.isPromotion && pLastMove.isCapture && pLastMove.startPos % 8 == pCheckingSquare % 8 && pLastMove.startPos == whiteKingSquare + 8 && (pLastMove.promotionType == 4 || pLastMove.promotionType == 5)) GetLegalWhiteCapturesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalWhiteCaptures(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tWhiteKingSquare = whiteKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = true; for (int m = 0; m < molc; m++) { Move curMove = moveOptionList[m]; int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; whitePieceBitboard = tWPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesWhite[tStartPos, tPieceType] ^ pieceHashesWhite[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 5: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[whiteKingSquare = tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 12: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesBlack[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 14: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, tPTI] ^ pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, curMove.promotionType]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } int tEval = QuiescenceBlack(pPly + 1, pAlpha, pBeta, pDepth - 1, tCheckPos, curMove); pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 7: whiteKingSquare = tWhiteKingSquare; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval >= pBeta) return pBeta; if (pAlpha < tEval) pAlpha = tEval; } isWhiteToMove = true; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; return pAlpha; } private int MinimaxBlack(int pPly, int pAlpha, int pBeta, int pDepth, int pRepetitionHistoryPly, int pCheckingSquare, Move pLastMove) { if (IsDrawByRepetition(pRepetitionHistoryPly - 4)) return 0; if ((pDepth <= 0 && pCheckingSquare == -1) || pDepth < CHECK_EXTENSION_LENGTH) return QuiescenceBlack(pPly, pAlpha, pBeta, pDepth - 1, pCheckingSquare, pLastMove); List<Move> moveOptionList = new List<Move>(); Move bestMove = NULL_MOVE; if (pLastMove.isPromotion && pLastMove.isCapture && pLastMove.startPos % 8 == pCheckingSquare % 8 && pLastMove.startPos == blackKingSquare - 8 && (pLastMove.promotionType == 4 || pLastMove.promotionType == 5)) GetLegalBlackMovesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalBlackMoves(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tBlackKingSquare = blackKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1, curEval = WHITE_CHECKMATE_VAL + pDepth; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = false; double[] moveSortingArray = new double[molc]; int[] moveSortingArrayIndexes = new int[molc], thisSearchMoveSortingArrayForTransposEntry = new int[molc]; transpositionTable.TryGetValue(zobristKey, out TranspositionEntry transposEntry); if (transposEntry == null) { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; } } else { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove == transposEntry.bestMove) moveSortingArray[m] = BESTMOVE_SORT_VAL; else if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; if (transposEntry.moveGenOrderedEvalLength > m) moveSortingArray[m] -= transposEntry.moveGenOrderedEvals[m]; } } Array.Sort(moveSortingArray, moveSortingArrayIndexes); for (int m = 0; m < molc; m++) { int tActualIndex = moveSortingArrayIndexes[m]; Move curMove = moveOptionList[tActualIndex]; if (debugSortResults && pDepth == curSearchDepth) { SNAPSHOT_WRITLINE_REPLACEMENT("=== " + moveSortingArray[m] + " | "+ curMove); } int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; blackPieceBitboard = tBPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesBlack[tStartPos, tPieceType] ^ pieceHashesBlack[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 0: whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 1: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 2: whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 3: blackKingSquare = tEndPos; if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 4: whitePieceBitboard = tWPB; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 5: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[blackKingSquare = tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = curMove.enPassantOption]; whitePieceBitboard = tWPB; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 11: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; blackKingSquare = tEndPos; whitePieceBitboard = tWPB; pieceTypeArray[curMove.rochadeEndPos] = 4; pieceTypeArray[curMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesBlack[curMove.rochadeStartPos, 4] ^ pieceHashesBlack[curMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | curMove.rochadeEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << curMove.rochadeEndPos)) tCheckPos = curMove.rochadeEndPos; break; case 12: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesWhite[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 13: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, curMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; case 14: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } zobristKey ^= pieceHashesWhite[tEndPos, tPTI] ^ pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, curMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } curSearchZobristKeyLine[pRepetitionHistoryPly] = zobristKey; int tEval = MinimaxWhite(pPly + 1, pAlpha, pBeta, pDepth - 1, pRepetitionHistoryPly + 1, tCheckPos, curMove); thisSearchMoveSortingArrayForTransposEntry[tActualIndex] = tEval; pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 3: blackKingSquare = tBlackKingSquare; break; case 7: blackKingSquare = tBlackKingSquare; break; case 10: enPassantSquare = 65; break; case 11: blackKingSquare = tBlackKingSquare; pieceTypeArray[curMove.rochadeStartPos] = 4; pieceTypeArray[curMove.rochadeEndPos] = 0; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 13: pieceTypeArray[tStartPos] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval < curEval) { bestMove = curMove; curEval = tEval; } if (pBeta > curEval) pBeta = curEval; if (curEval <= pAlpha) { if (!curMove.isCapture) { killerMoveHeuristic[curMove.moveHash] = true; if (pDepth > 0) historyHeuristic[curMove.moveHash] += pDepth * pDepth; } break; } } isWhiteToMove = false; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; if (molc == 0 && pCheckingSquare == 0) curEval = 0; if (!transpositionTable.ContainsKey(zobristKey)) transpositionTable.Add(zobristKey, new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry)); else transpositionTable[zobristKey] = new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry); return curEval; } private int QuiescenceBlack(int pPly, int pAlpha, int pBeta, int pDepth, int pCheckingSquare, Move pLastMove) { int standPat = TexelEvaluate(); if (standPat <= pAlpha || pDepth < MAX_QUIESCENCE_TOTAL_LENGTH) return pAlpha; if (standPat < pBeta) pBeta = standPat; List<Move> moveOptionList = new List<Move>(); if (pLastMove.isPromotion && pLastMove.isCapture && pLastMove.startPos % 8 == pCheckingSquare % 8 && pLastMove.startPos == blackKingSquare - 8 && (pLastMove.promotionType == 4 || pLastMove.promotionType == 5)) GetLegalBlackCapturesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalBlackCaptures(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tBlackKingSquare = blackKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = false; for (int m = 0; m < molc; m++) { Move curMove = moveOptionList[m]; int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; blackPieceBitboard = tBPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesBlack[tStartPos, tPieceType] ^ pieceHashesBlack[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 5: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[blackKingSquare = tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 12: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesWhite[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 14: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } zobristKey ^= pieceHashesWhite[tEndPos, tPTI] ^ pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, curMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } int tEval = QuiescenceWhite(pPly + 1, pAlpha, pBeta, pDepth - 1, tCheckPos, curMove); pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 7: blackKingSquare = tBlackKingSquare; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval <= pAlpha) return pAlpha; if (pBeta > tEval) pBeta = tEval; } isWhiteToMove = false; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; return pBeta; } private bool[] killerMoveHeuristic = new bool[262_144]; private int[] historyHeuristic = new int[262_144]; public void ClearHeuristics() { for (int i = 0; i < 262_144; i++) { killerMoveHeuristic[i] = false; historyHeuristic[i] = 0; } } private Dictionary<ulong, TranspositionEntry> transpositionTable = new Dictionary<ulong, TranspositionEntry>(); private int[] pieceEvals = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[,][] piecePositionEvals = new int[33, 14][]; private int evalCount = 0; private int Evaluate() { evalCount++; if (fiftyMoveRuleCounter > 99) return 0; int tEval = 0, tPT, pieceCount = ULONG_OPERATIONS.CountBits(allPieceBitboard); for (int p = 0; p < 64; p++) tEval += pieceEvals[tPT = pieceTypeArray[p] + 7 * ((int)(blackPieceBitboard >> p) & 1)] + piecePositionEvals[pieceCount, tPT][p]; return tEval; } public int GameState(bool pWhiteKingCouldBeAttacked) { if (IsDrawByRepetition(curSearchZobristKeyLine.Length - 5) || fiftyMoveRuleCounter > 99) return 0; int t; List<Move> tMoves = new List<Move>(); GetLegalMoves(ref tMoves); if (pWhiteKingCouldBeAttacked) { t = PreMinimaxCheckCheckWhite(); if (t == -1) return tMoves.Count == 0 ? 0 : 3; else if (tMoves.Count == 0) return -1; } else { t = PreMinimaxCheckCheckBlack(); if (t == -1) return tMoves.Count == 0 ? 0 : 3; else if (tMoves.Count == 0) return 1; } return 3; } private bool IsDrawByRepetition(int pPlyOfFirstPossibleRepeatedPosition) { int tC = 0; for (int i = pPlyOfFirstPossibleRepeatedPosition; i >= 0; i -= 2) { if (curSearchZobristKeyLine[i] == zobristKey) if (++tC == 2) return true; } return false; } private const int RELE_MAX_MOVE_COUNT_PER_GAME = 500; public double ReLePlayGame(int[,][] pEvalPositionValuesWhite, int[,][] pEvalPositionValuesBlack, long thinkingTimePerMove) { int[,][] processedValuesWhite = InitReLeAgent(pEvalPositionValuesWhite), processedValuesBlack = InitReLeAgent(pEvalPositionValuesBlack); int tGS, mc = 0; do { if (IsDrawByRepetition(curSearchZobristKeyLine.Length - 5)) return 0d; piecePositionEvals = isWhiteToMove ? processedValuesWhite : processedValuesBlack; MinimaxRoot(thinkingTimePerMove); if (transpositionTable.Count == 0) { SNAPSHOT_WRITLINE_REPLACEMENT("?!"); return 0d; } PlainMakeMove(transpositionTable[zobristKey].bestMove); tGS = GameState(isWhiteToMove); transpositionTable.Clear(); if (tGS != 3) break; } while (mc++ < RELE_MAX_MOVE_COUNT_PER_GAME); if (tGS == 3 || tGS == 0) return 0d; else if (tGS == 1) return 0.1d * (double)(RELE_MAX_MOVE_COUNT_PER_GAME - mc); return 0.1d * (double)(-RELE_MAX_MOVE_COUNT_PER_GAME + mc); } public int[,][] InitReLeAgent(int[,][] pEvalPositionValues) { return GetInterpolatedProcessedValues(pEvalPositionValues); } private int[,][] GetInterpolatedProcessedValues(int[,][] pEvalPositionValues) { int[,][] processedValues = new int[33, 14][]; for (int i = 0; i < 32; i++) { int ip1 = i + 1; processedValues[ip1, 7] = processedValues[ip1, 0] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; processedValues[ip1, 8] = SwapArrayViewingSide(processedValues[ip1, 1] = MultiplyArraysWithVal(pEvalPositionValues[0, 0], pEvalPositionValues[1, 0], pEvalPositionValues[2, 0], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 9] = SwapArrayViewingSide(processedValues[ip1, 2] = MultiplyArraysWithVal(pEvalPositionValues[0, 1], pEvalPositionValues[1, 1], pEvalPositionValues[2, 1], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 10] = SwapArrayViewingSide(processedValues[ip1, 3] = MultiplyArraysWithVal(pEvalPositionValues[0, 2], pEvalPositionValues[1, 2], pEvalPositionValues[2, 2], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 11] = SwapArrayViewingSide(processedValues[ip1, 4] = MultiplyArraysWithVal(pEvalPositionValues[0, 3], pEvalPositionValues[1, 3], pEvalPositionValues[2, 3], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 12] = SwapArrayViewingSide(processedValues[ip1, 5] = MultiplyArraysWithVal(pEvalPositionValues[0, 4], pEvalPositionValues[1, 4], pEvalPositionValues[2, 4], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 13] = SwapArrayViewingSide(processedValues[ip1, 6] = MultiplyArraysWithVal(pEvalPositionValues[0, 5], pEvalPositionValues[1, 5], pEvalPositionValues[2, 5], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); } return processedValues; } private double[,][] GetInterpolatedProcessedValues(double[,][] pEvalPositionValues) { double[,][] processedValues = new double[33, 14][]; for (int i = 0; i < 32; i++) { int ip1 = i + 1; processedValues[ip1, 7] = processedValues[ip1, 0] = new double[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; processedValues[ip1, 8] = SwapArrayViewingSide(processedValues[ip1, 1] = MultiplyArraysWithVal(pEvalPositionValues[0, 0], pEvalPositionValues[1, 0], pEvalPositionValues[2, 0], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 9] = SwapArrayViewingSide(processedValues[ip1, 2] = MultiplyArraysWithVal(pEvalPositionValues[0, 1], pEvalPositionValues[1, 1], pEvalPositionValues[2, 1], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 10] = SwapArrayViewingSide(processedValues[ip1, 3] = MultiplyArraysWithVal(pEvalPositionValues[0, 2], pEvalPositionValues[1, 2], pEvalPositionValues[2, 2], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 11] = SwapArrayViewingSide(processedValues[ip1, 4] = MultiplyArraysWithVal(pEvalPositionValues[0, 3], pEvalPositionValues[1, 3], pEvalPositionValues[2, 3], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 12] = SwapArrayViewingSide(processedValues[ip1, 5] = MultiplyArraysWithVal(pEvalPositionValues[0, 4], pEvalPositionValues[1, 4], pEvalPositionValues[2, 4], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 13] = SwapArrayViewingSide(processedValues[ip1, 6] = MultiplyArraysWithVal(pEvalPositionValues[0, 5], pEvalPositionValues[1, 5], pEvalPositionValues[2, 5], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); } return processedValues; } private double[] MultiplyArraysWithVal(double[] pArr1, double[] pArr2, double[] pArr3, double pVal1, double pVal2, double pVal3) { int tL = pArr1.Length; double[] rArr = new double[tL]; for (int i = 0; i < tL; i++) { rArr[i] = pArr1[i] * pVal1 + pArr2[i] * pVal2 + pArr3[i] * pVal3; } return rArr; } private int[] MultiplyArraysWithVal(int[] pArr1, int[] pArr2, int[] pArr3, double pVal1, double pVal2, double pVal3) { int tL = pArr1.Length; int[] rArr = new int[tL]; for (int i = 0; i < tL; i++) { rArr[i] = (int)(pArr1[i] * pVal1 + pArr2[i] * pVal2 + pArr3[i] * pVal3); } return rArr; } private int[] SwapArrayViewingSideAndNegate(int[] pArr) { return new int[64] { -pArr[56], -pArr[57], -pArr[58], -pArr[59], -pArr[60], -pArr[61], -pArr[62], -pArr[63], -pArr[48], -pArr[49], -pArr[50], -pArr[51], -pArr[52], -pArr[53], -pArr[54], -pArr[55], -pArr[40], -pArr[41], -pArr[42], -pArr[43], -pArr[44], -pArr[45], -pArr[46], -pArr[47], -pArr[32], -pArr[33], -pArr[34], -pArr[35], -pArr[36], -pArr[37], -pArr[38], -pArr[39], -pArr[24], -pArr[25], -pArr[26], -pArr[27], -pArr[28], -pArr[29], -pArr[30], -pArr[31], -pArr[16], -pArr[17], -pArr[18], -pArr[19], -pArr[20], -pArr[21], -pArr[22], -pArr[23], -pArr[8], -pArr[9], -pArr[10], -pArr[11], -pArr[12], -pArr[13], -pArr[14], -pArr[15], -pArr[0], -pArr[1], -pArr[2], -pArr[3], -pArr[4], -pArr[5], -pArr[6], -pArr[7] }; } private int[] SwapArrayViewingSide(int[] pArr) { return new int[64] { pArr[56], pArr[57], pArr[58], pArr[59], pArr[60], pArr[61], pArr[62], pArr[63], pArr[48], pArr[49], pArr[50], pArr[51], pArr[52], pArr[53], pArr[54], pArr[55], pArr[40], pArr[41], pArr[42], pArr[43], pArr[44], pArr[45], pArr[46], pArr[47], pArr[32], pArr[33], pArr[34], pArr[35], pArr[36], pArr[37], pArr[38], pArr[39], pArr[24], pArr[25], pArr[26], pArr[27], pArr[28], pArr[29], pArr[30], pArr[31], pArr[16], pArr[17], pArr[18], pArr[19], pArr[20], pArr[21], pArr[22], pArr[23], pArr[8], pArr[9], pArr[10], pArr[11], pArr[12], pArr[13], pArr[14], pArr[15], pArr[0], pArr[1], pArr[2], pArr[3], pArr[4], pArr[5], pArr[6], pArr[7] }; } private double[] SwapArrayViewingSide(double[] pArr) { return new double[64] { pArr[56], pArr[57], pArr[58], pArr[59], pArr[60], pArr[61], pArr[62], pArr[63], pArr[48], pArr[49], pArr[50], pArr[51], pArr[52], pArr[53], pArr[54], pArr[55], pArr[40], pArr[41], pArr[42], pArr[43], pArr[44], pArr[45], pArr[46], pArr[47], pArr[32], pArr[33], pArr[34], pArr[35], pArr[36], pArr[37], pArr[38], pArr[39], pArr[24], pArr[25], pArr[26], pArr[27], pArr[28], pArr[29], pArr[30], pArr[31], pArr[16], pArr[17], pArr[18], pArr[19], pArr[20], pArr[21], pArr[22], pArr[23], pArr[8], pArr[9], pArr[10], pArr[11], pArr[12], pArr[13], pArr[14], pArr[15], pArr[0], pArr[1], pArr[2], pArr[3], pArr[4], pArr[5], pArr[6], pArr[7] }; } private int[,][] texelTuningRuntimeVals = new int[33, 14][]; private int[,][] texelTuningVals = new int[3, 6][]; private int[,] texelTuningAdjustIterations = new int[6, 64]; private int[][] texelTuningRuntimePositionalValsV2EG = new int[14][]; private int[][] texelTuningRuntimePositionalValsV2LG = new int[14][]; private int[] texelPieceEvaluationsV2EG = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[] texelPieceEvaluationsV2LG = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[] texelKingSafetyR1EvaluationsEG = new int[9]; private int[] texelKingSafetyR2EvaluationsEG = new int[17]; private int[] texelKingSafetyR1EvaluationsLG = new int[9]; private int[] texelKingSafetyR2EvaluationsLG = new int[17]; private int[] texelKingSafetySREvaluationsPT1EG = new int[12]; private int[] texelKingSafetySREvaluationsPT2EG = new int[12]; private int[] texelKingSafetySREvaluationsPT3EG = new int[12]; private int[] texelKingSafetySREvaluationsPT4EG = new int[12]; private int[] texelKingSafetySREvaluationsPT5EG = new int[12]; private int[] texelKingSafetySREvaluationsPT6EG = new int[12]; private int[] texelKingSafetySREvaluationsPT1LG = new int[12]; private int[] texelKingSafetySREvaluationsPT2LG = new int[12]; private int[] texelKingSafetySREvaluationsPT3LG = new int[12]; private int[] texelKingSafetySREvaluationsPT4LG = new int[12]; private int[] texelKingSafetySREvaluationsPT5LG = new int[12]; private int[] texelKingSafetySREvaluationsPT6LG = new int[12]; private int[,] texelMobilityStraightEG = new int[14, 15], texelMobilityStraightLG = new int[14, 15]; private int[,] texelMobilityDiagonalEG = new int[14, 14], texelMobilityDiagonalLG = new int[14, 14]; private int[] texelPieceEvaluations = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[] blackSidedSquares = new int[64] { 56, 57, 58, 59, 60, 61, 62, 63, 48, 49, 50, 51, 52, 53, 54, 55, 40, 41, 42, 43, 44, 45, 46, 47, 32, 33, 34, 35, 36, 37, 38, 39, 24, 25, 26, 27, 28, 29, 30, 31, 16, 17, 18, 19, 20, 21, 22, 23, 08, 09, 10, 11, 12, 13, 14, 15, 00, 01, 02, 03, 04, 05, 06, 07 }; private int[,] T_Pawns = new int[3, 64] { { 0, 0, 0, 0, 0, 0, 0, 0, 98, 134, 61, 95, 68, 126, 34, -11, -6, 7, 26, 31, 65, 56, 25, -20, -14, 13, 6, 21, 23, 12, 17, -23, -27, -2, -5, 12, 17, 6, 10, -25, -26, -4, -4, -10, 3, 3, 33, -12, -35, -1, -20, -23, -15, 24, 38, -22, 0, 0, 0, 0, 0, 0, 0, 0, } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { 0, 0, 0, 0, 0, 0, 0, 0, 178, 173, 158, 134, 147, 132, 165, 187, 94, 100, 85, 67, 56, 53, 82, 84, 32, 24, 13, 5, -2, 4, 17, 17, 13, 9, -3, -7, -7, -8, 3, -1, 4, 7, -6, 1, 0, -5, -1, -8, 13, 8, 8, 10, 13, 0, 2, -7, 0, 0, 0, 0, 0, 0, 0, 0, } }; private int[,] T_Knights = new int[3, 64] { { -167, -89, -34, -49, 61, -97, -15, -107, -73, -41, 72, 36, 23, 62, 7, -17, -47, 60, 37, 65, 84, 129, 73, 44, -9, 17, 19, 53, 37, 69, 18, 22, -13, 4, 16, 13, 28, 19, 21, -8, -23, -9, 12, 10, 19, 17, 25, -16, -29, -53, -12, -3, -1, 18, -14, -19, -105, -21, -58, -33, -17, -28, -19, -23 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -58, -38, -13, -28, -31, -27, -63, -99, -25, -8, -25, -2, -9, -25, -24, -52, -24, -20, 10, 9, -1, -9, -19, -41, -17, 3, 22, 22, 22, 11, 8, -18, -18, -6, 16, 25, 16, 17, 4, -18, -23, -3, -1, 15, 10, -3, -20, -22, -42, -20, -10, -5, -2, -20, -23, -44, -29, -51, -23, -15, -22, -18, -50, -64 } }; private int[,] T_Bishops = new int[3, 64] { { -29, 4, -82, -37, -25, -42, 7, -8, -26, 16, -18, -13, 30, 59, 18, -47, -16, 37, 43, 40, 35, 50, 37, -2, -4, 5, 19, 50, 37, 37, 7, -2, -6, 13, 13, 26, 34, 12, 10, 4, 0, 15, 15, 15, 14, 27, 18, 10, 4, 15, 16, 0, 7, 21, 33, 1, -33, -3, -14, -21, -13, -12, -39, -21 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -14, -21, -11, -8, -7, -9, -17, -24, -8, -4, 7, -12, -3, -13, -4, -14, 2, -8, 0, -1, -2, 6, 0, 4, -3, 9, 12, 9, 14, 10, 3, 2, -6, 3, 13, 19, 7, 10, -3, -9, -12, -3, 8, 10, 13, 3, -7, -15, -14, -18, -7, -1, 4, -9, -15, -27, -23, -9, -23, -5, -9, -16, -5, -17 } }; private int[,] T_Rooks = new int[3, 64] { { 32, 42, 32, 51, 63, 9, 31, 43, 27, 32, 58, 62, 80, 67, 26, 44, -5, 19, 26, 36, 17, 45, 61, 16, -24, -11, 7, 26, 24, 35, -8, -20, -36, -26, -12, -1, 9, -7, 6, -23, -45, -25, -16, -17, 3, 0, -5, -33, -44, -16, -20, -9, -1, 11, -6, -71, -19, -13, 1, 17, 16, 7, -37, -26 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { 13, 10, 18, 15, 12, 12, 8, 5, 11, 13, 13, 11, -3, 3, 8, 3, 7, 7, 7, 5, 4, -3, -5, -3, 4, 3, 13, 1, 2, 1, -1, 2, 3, 5, 8, 4, -5, -6, -8, -11, -4, 0, -5, -1, -7, -12, -8, -16, -6, -6, 0, 2, -9, -9, -11, -3, -9, 2, 3, -1, -5, -13, 4, -20 } }; private int[,] T_Queens = new int[3, 64] { { -28, 0, 29, 12, 59, 44, 43, 45, -24, -39, -5, 1, -16, 57, 28, 54, -13, -17, 7, 8, 29, 56, 47, 57, -27, -27, -16, -16, -1, 17, -2, 1, -9, -26, -9, -10, -2, -4, 3, -3, -14, 2, -11, -2, -5, 2, 14, 5, -35, -8, 11, 2, 8, 15, -3, 1, -1, -18, -9, 10, -15, -25, -31, -50 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -9, 22, 22, 27, 27, 19, 10, 20, -17, 20, 32, 41, 58, 25, 30, 0, -20, 6, 9, 49, 47, 35, 19, 9, 3, 22, 24, 45, 57, 40, 57, 36, -18, 28, 19, 47, 31, 34, 39, 23, -16, -27, 15, 6, 9, 17, 10, 5, -22, -23, -30, -16, -16, -23, -36, -32, -33, -28, -22, -43, -5, -32, -20, -41 } }; private int[,] T_Kings = new int[3, 64] { { -65, 23, 16, -15, -56, -34, 2, 13, 29, -1, -20, -7, -8, -4, -38, -29, -9, 24, 2, -16, -20, 6, 22, -22, -17, -20, -12, -27, -30, -25, -14, -36, -49, -1, -27, -39, -46, -44, -33, -51, -14, -14, -22, -46, -44, -30, -15, -27, 1, 7, -8, -64, -43, -16, 9, 8, -15, 36, 12, -54, 8, -28, 24, 14 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -74, -35, -18, -18, -11, 15, 4, -17, -12, 17, 14, 17, 17, 38, 23, 11, 10, 17, 23, 15, 20, 45, 44, 13, -8, 22, 24, 27, 26, 33, 26, 3, -18, -4, 21, 24, 27, 23, 9, -11, -19, -3, 11, 21, 23, 16, 7, -9, -27, -11, 4, 13, 14, 4, -5, -17, -53, -34, -21, -11, -28, -14, -24, -43 } }; private int[] paramsLowerLimits = new int[5] { -10000, -10000, -10000, -10000, -10000 }; private int[] paramsUpperLimits = new int[5] { 10000, 10000, 10000, 10000, 10000 }; private List<TLM_ChessGame> threadDataset; private int threadFrom, threadTo; private int[] threadParams; private int customThreadID = 0; private ulong ulAllThreadIDsUnfinished = 0; private double lastCostVal = 0d; private double sumCostVals = 0d; private int costCalculations = 0; private readonly string[] TEXELPRINT_GAMEPARTS = new string[3] { "Early Game: ", "Mid Game: ", "Late Game: "}; private readonly string[] TEXELPRINT_PIECES = new string[6] { "Bauer: ", "Springer: ", "Lufer: ", "Turm: ", "Dame: ", "Knig: "}; private double[] earlyGameMultipliers = new double[33]; private double[] middleGameMultipliers = new double[33]; private double[] lateGameMultipliers = new double[33]; private int[] pieceTypeGameProgressImpact = new int[14] { 0, 0, 1, 1, 2, 4, 0, 0, 0, 1, 1, 2, 4, 0 }; private void PrecalculateMultipliers() { if (BOARD_MANAGER_ID == ENGINE_VALS.PARALLEL_BOARDS - 1) SNAPSHOT_WRITLINE_REPLACEMENT(); for (int i = 0; i < 25; i++) { earlyGameMultipliers[i] = EGMultiplierFunction(i); lateGameMultipliers[i] = LGMultiplierFunction(i); if (BOARD_MANAGER_ID == ENGINE_VALS.PARALLEL_BOARDS - 1) SNAPSHOT_WRITLINE_REPLACEMENT("[" + i + "] "+ earlyGameMultipliers[i] + " | "+ middleGameMultipliers[i] + " | "+ lateGameMultipliers[i]); } } private double MultiplierFunction(double pVal, double pXShift) { double d = Math.Exp(1d /6d * (pVal - pXShift)); return 5 * (d /Math.Pow(d + 1, 2d)); } private double EGMultiplierFunction(double pVal) { return Math.Clamp(1 /16d * (pVal - 4d), 0d, 1d); } private double LGMultiplierFunction(double pVal) { return Math.Clamp(1 /-16d * (pVal - 4d) + 1d, 0d, 1d); } private double EGMultiplierFunction2(double pVal) { return Math.Clamp(1 /32d * pVal, 0d, 1d); } private double LGMultiplierFunction2(double pVal) { return Math.Clamp(1 /-32d * pVal + 1d, 0d, 1d); } private void TuneWithTxtFile(string pTXTName) { List<TLM_ChessGame> gameDataset = new List<TLM_ChessGame>(); string tPath = PathManager.GetTXTPath(pTXTName); string[] tStrs = File.ReadAllLines(tPath); List<string> tGames = new List<string>(); foreach (string s in tStrs) if (s.Contains(';') && s.Replace(" ", "") != "") tGames.Add(s); foreach (string s in tGames) { TLM_ChessGame tGame = CGFF.GetGame(s); LoadFenString(tGame.startFen); foreach (int hMove in tGame.hashedMoves) { List<Move> moveOptionList = new List<Move>(); GetLegalMoves(ref moveOptionList); int tL = moveOptionList.Count; for (int j = 0; j < tL; j++) { Move tMove = moveOptionList[j]; if (tMove.moveHash == hMove) { tGame.actualMoves.Add(tMove); PlainMakeMove(tMove); tL = -1; break; } } if (tL != -1) break; } gameDataset.Add(tGame); } SNAPSHOT_WRITLINE_REPLACEMENT("[TLM TEXEL TUNER] " + tGames.Count + " Games Loaded In!"); BOT_MAIN.curTEXELPARAMS = new int[TEXEL_PARAMS]; BOT_MAIN.ParallelTexelTuning(gameDataset); } private void LoadBestTexelParamsIn() { int[] ttt = new int[778] { 82, 341, 416, 470, 1106, 102, 302, 304, 518, 960, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, -46, 0, -20, 0, 64, -21, -71, 37, 29, 6, 98, 13, 44, 0, -26, -14, -36, -20, 94, 16, 60, 10, -62, -19, -38, -8, -28, 14, -26, -4, -32, -28, -52, 30, 56, -40, -72, -22, 100, 4, -98, -34, 6, -49, 32, -10, 72, 20, 84, -56, -60, -112, 128, -28, 152, 34, 26, -52, 200, -56, 76, 44, -56, -113, -156, 188, -39, 28, 200, -90, -60, -86, 100, -178, -119, -200, 200, 200, -20, -22, -78, -158, -200, 196, 200, -200, -200, -200, 104, 200, 138, -122, 200, 200, 124, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 200, 156, -37, -68, -148, -200, 200, -70, 72, 76, -31, -200, -21, 178, -200, 200, 200, -200, 123, -188, -6, 164, -74, 24, -28, -8, 71, -50, -112, -200, -8, -44, 27, -23, -50, 19, 19, 41, 150, 152, 4, -98, -36, -34, 174, -106, -16, 17, 141, -48, -108, 162, 6, -112, -52, 76, 68, 8, -86, 68, -176, 189, 81, 162, -200, 152, -41, 128, 172, -173, -144, 56, 22, 94, -28, 32, 16, -63, 36, -200, -200, -200, -22, 56, -116, 76, -36, -30, 100, 52, -166, -114, 142, -52, -44, -200, -18, -72, 60, 200, -160, 96, 46, -200, -28, -32, -44, 132, 60, -200, -137, -200, -176, 200, -200, -200, 4, 200, -200, 72, 200, -78, 200, 160, -105, 200, 96, -114, 200, 200, -88, -24, 11, -34, 184, 26, 83, -140, 10, -16, -72, -200, 12, -200, 46, -200, 11, 82, 66, -102, 22, -184, 32, 114, 140, -26, -18, -36, 66, 100, 25, -24, 133, -96, 50, 2, 80, 184, 43, -136, 44, 124, -148, 180, 69, -126, -200, 6, 78, -96, 89, -68, 200, -116, 114, 158, 5, -154, 115, 200, -152, -171, 41, -80, -23, 137, 98, -80, 40, -42, 200, 52, 146, 200, 6, -112, 32, 200, 132, 4, 90, -200, -200, 104, 67, -56, 186, 124, 140, 97, -144, 200, -4, -160, -117, -200, 24, -80, 200, 28, -46, -24, -52, -200, -200, 72, 20, 34, 200, -16, 88, 56, 200, -146, 120, 174, 200, -200, -86, 125, 172, -70, 4, 124, -72, 0, -2, 70, -14, 48, -32, 200, 80, 24, -132, 74, -44, 184, -4, -136, 0, -16, 20, -18, -32, 96, 92, 56, 2, 174, 196, -200, -56, -116, 88, 200, -8, 168, -13, 74, -106, 200, -182, 80, 82, -128, -16, 90, -200, 66, -88, 58, -16, 80, -34, 96, -95, -96, -200, 76, 26, -72, 32, -27, -108, 164, 200, -36, -93, -10, -56, 22, 36, 74, -200, -96, 200, 88, -88, 156, -92, 96, -200, 200, 191, -8, 62, -8, -100, 136, -72, -36, 200, -64, -114, 153, -110, 174, 46, 108, 142, 121, -200, 108, -200, 74, -4, 104, -200, 116, 82, 200, -76, 176, -200, 76, -8, 200, 46, 29, -86, 12, -24, -80, -12, 200, 124, -16, 54, 104, 200, -94, 140, 36, 32, -64, 24, -178, 15, -200, 0, -200, 4, -32, -124, 148, 176, 192, 90, 164, -91, 200, 172, -200, 64, 34, 40, -200, 0, -200, 12, -124, 48, -200, -56, 184, -8, -184, 0, 200, -16, 200, -8, 180, -18, -20, 24, -200, -58, 174, -200, 40, -4, -200, -24, 200, 54, 200, -24, -32, 37, 192, 48, 44, 26, 200, -22, 200, -145, -200, 30, 86, 54, 200, -102, -34, 94, -98, 92, -200, -76, 196, -18, -200, -180, 16, 186, -92, -200, -200, 164, -200, 62, 192, 159, -112, -12, -70, 184, 104, 200, -200, -148, -4, 86, -144, 200, -100, 200, 200, -104, 114, 132, -168, 12, 56, -10, 82, 200, -200, -200, -196, -6, 52, -200, 84, 200, -192, 128, 200, -200, -200, 200, 88, 168, -32, -84, 172, 52, -172, 0, -40, 68, -186, 42, 96, -200, -198, 200, -56, -176, 88, 0, 86, 16, -124, -46, 40, -16, -4, 54, -184, 200, 58, -200, 77, -200, -44, 102, 0, -50, -10, -92, 100, -86, 8, 20, -20, -200, 38, -200, -49, -4, 2, -200, 78, 0, -40, -92, 32, 0, -164, -88, -38, -138, -118, 29, -34, -200, -200, -200, -71, -200, 200, -200, -108, -200, 0, 192, -24, 104, -200, 200, 190, -28, -200, -200, -200, 128, -96, 200, 200, 200, 200, -200, -200, 177, -24, 200, 132, 200, -190, 200, -130, 200, 148, 200, 200, -200, -100, 200, -196, -200, 90, 200, -200, 200, 200, -200, -200, -200, -200, -200, 118, -200, 85, -200, 166, 199, -200 }; SetupTexelEvaluationParams(ttt); } private void SetupTexelEvaluationParams(int[] pParams) { texelPieceEvaluationsV2EG[8] = -(texelPieceEvaluationsV2EG[1] = pParams[0]); texelPieceEvaluationsV2EG[9] = -(texelPieceEvaluationsV2EG[2] = pParams[1]); texelPieceEvaluationsV2EG[10] = -(texelPieceEvaluationsV2EG[3] = pParams[2]); texelPieceEvaluationsV2EG[11] = -(texelPieceEvaluationsV2EG[4] = pParams[3]); texelPieceEvaluationsV2EG[12] = -(texelPieceEvaluationsV2EG[5] = pParams[4]); texelPieceEvaluationsV2LG[8] = -(texelPieceEvaluationsV2LG[1] = pParams[5]); texelPieceEvaluationsV2LG[9] = -(texelPieceEvaluationsV2LG[2] = pParams[6]); texelPieceEvaluationsV2LG[10] = -(texelPieceEvaluationsV2LG[3] = pParams[7]); texelPieceEvaluationsV2LG[11] = -(texelPieceEvaluationsV2LG[4] = pParams[8]); texelPieceEvaluationsV2LG[12] = -(texelPieceEvaluationsV2LG[5] = pParams[9]); int c = 10; for (int p = 1; p < 7; p++) { for (int s = 0; s < 64; s++) { texelTuningRuntimePositionalValsV2EG[p + 7][blackSidedSquares[s]] = -(texelTuningRuntimePositionalValsV2EG[p][s] = pParams[c++]); texelTuningRuntimePositionalValsV2LG[p + 7][blackSidedSquares[s]] = -(texelTuningRuntimePositionalValsV2LG[p][s] = pParams[c++]); } } return; for (int p = 2; p < 7; p++) { for (int a = 0; a < 15; a++) { if (a != 14) { texelMobilityDiagonalEG[p + 7, a] = -(texelMobilityDiagonalEG[p, a] = pParams[c++]); texelMobilityDiagonalLG[p + 7, a] = -(texelMobilityDiagonalLG[p, a] = pParams[c++]); } texelMobilityStraightEG[p + 7, a] = -(texelMobilityStraightEG[p, a] = pParams[c++]); texelMobilityStraightLG[p + 7, a] = -(texelMobilityStraightLG[p, a] = pParams[c++]); } } for (int i = 0; i < 12; i++) { texelKingSafetySREvaluationsPT1EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT2EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT3EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT4EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT5EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT6EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT1LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT2LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT3LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT4LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT5LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT6LG[i] = pParams[c++]; } } private void PrintDefinedTexelParams(int[] pParams) { int c = 0; for (int t = 0; t < 3; t++) { SNAPSHOT_WRITLINE_REPLACEMENT(TEXELPRINT_GAMEPARTS[t]); for (int p = 0; p < 6; p++) { SNAPSHOT_WRITLINE_REPLACEMENT(TEXELPRINT_PIECES[p]); texelTuningVals[t, p] = new int[64]; for (int s = 0; s < 64; s++) { if (s % 8 == 0 && s != 0) SNAPSHOT_WRITLINE_REPLACEMENT(); SNAPSHOT_WRITLINE_REPLACEMENT((texelTuningVals[t, p][s] = pParams[c++]) + ", "); } SNAPSHOT_WRITLINE_REPLACEMENT(); } } piecePositionEvals = GetInterpolatedProcessedValues(texelTuningVals); } public void TLMTuning(List<TLM_ChessGame> pDataset) { int tGameDataSetLen = pDataset.Count; int[,][] tRatio = new int[33, 6][]; int[,][] tTotalMoves = new int[33, 6][]; double[,][] tSummedRatios = new double[33, 6][]; double[,][] tSummedDataAmount = new double[33, 6][]; double[,][] tTuningResults = new double[33, 6][]; for (int t = 1; t < 33; t++) { for (int p = 0; p < 6; p++) { tRatio[t, p] = new int[64]; tTotalMoves[t, p] = new int[64]; tSummedRatios[t, p] = new double[64]; tSummedDataAmount[t, p] = new double[64]; tTuningResults[t, p] = new double[64]; } } for (int j = 0; j < tGameDataSetLen; j++) { TLM_ChessGame tGame = pDataset[j]; int tGR = tGame.gameResult - 1; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count - 5; for (int i = 0; i < tL; i++) { if (tGame.isMoveNonTactical[i]) { int tPieceAmount = ULONG_OPERATIONS.CountBits(allPieceBitboard); for (int s = 0; s < 64; s++) { int tPT = pieceTypeArray[s] - 1; if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, s)) { tTotalMoves[tPieceAmount, tPT][s]++; tRatio[tPieceAmount, tPT][s] += tGR; } else if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, s)) { int b = blackSidedSquares[s]; tTotalMoves[tPieceAmount, tPT][b]++; tRatio[tPieceAmount, tPT][b] += tGR; } } } PlainMakeMove(tGame.actualMoves[i]); } } double[,] allMultipliers = new double[33, 33]; for (int sh = 0; sh < 33; sh++) { for (int i = 0; i < 33; i++) { allMultipliers[sh, i] = MultiplierFunction(i, sh); } } for (int t = 1; t < 33; t++) { for (int p = 0; p < 6; p++) { for (int s = 0; s < 64; s++) { for (int t2 = 1; t2 < 33; t2++) { double cmult = allMultipliers[t, t2]; tSummedRatios[t, p][s] += tRatio[t2, p][s] * cmult; tSummedDataAmount[t, p][s] += tTotalMoves[t2, p][s] * cmult; } tTuningResults[t, p][s] = TTT(tSummedRatios[t, p][s], tSummedDataAmount[t, p][s]); } } } int c = 0; int[] tparams = new int[1152]; for (int t = 1; t < 33; t += 15) { if (t == 31) t = 32; SNAPSHOT_WRITLINE_REPLACEMENT("PieceCount = " + t + ": "); for (int p = 0; p < 6; p++) { SNAPSHOT_WRITLINE_REPLACEMENT(TEXELPRINT_PIECES[p]); for (int s = 0; s < 64; s++) { if (s % 8 == 0 && s != 0) SNAPSHOT_WRITLINE_REPLACEMENT(); SNAPSHOT_WRITLINE_REPLACEMENT((tparams[c++] = (int)(tTuningResults[t, p][s] * 100)).ToString().Replace(",", ".") + "("+ (int)tSummedDataAmount[t, p][s] + ")"+ ", "); } SNAPSHOT_WRITLINE_REPLACEMENT(); } } string tS = "PARAMS: {"; for (int i = 0; i < tparams.Length; i++) tS += tparams[i] + ","; tS = tS.Substring(0, tS.Length - 1) + "}\n"; SNAPSHOT_WRITLINE_REPLACEMENT(tS); TexelTuning(pDataset, tparams); } private double TTT(double d1, double d2) { if (d2 == 0) return 0; return d1 /d2; } public void TexelTuning(List<TLM_ChessGame> pDataset, int[] pCurBestParams) { Stopwatch sw = Stopwatch.StartNew(); string tPath = PathManager.GetTXTPath("OTHER/TEXEL_TUNING"); int paramCount = pCurBestParams.Length; double bestAvrgCost = CalculateAverageTexelCost(pDataset, pCurBestParams); SNAPSHOT_WRITLINE_REPLACEMENT("CUR PARAMS COST: " + bestAvrgCost); int packetSize = Math.Clamp(paramCount /ENGINE_VALS.CPU_CORES, 1, 100000); paramsLowerLimits = new int[paramCount]; paramsUpperLimits = new int[paramCount]; for (int i = 0; i < paramCount; i++) { int lim = i < 10 ? 100000 : 200; paramsLowerLimits[i] = -lim; paramsUpperLimits[i] = lim; } SNAPSHOT_WRITLINE_REPLACEMENT("PARAM-COUNT: " + paramCount); SNAPSHOT_WRITLINE_REPLACEMENT("PACKET-SIZE: " + packetSize); while (packetSize <= paramCount) { BOT_MAIN.TEXELfinished = 0; int lM = 0, tC = 0; ulong tUL = 0ul; for (int m = packetSize; lM < paramCount; m += packetSize) { if (m > paramCount) m = paramCount; tUL = ULONG_OPERATIONS.SetBitToOne(tUL, ++tC); lM = m; } tC = lM = 0; for (int m = packetSize; lM < paramCount; m += packetSize) { if (m > paramCount) m = paramCount; tC++; BOT_MAIN.boardManagers[tC].SetPlayTexelVals(pDataset, lM, m, pCurBestParams, paramsLowerLimits, paramsUpperLimits, tC, tUL); ThreadPool.QueueUserWorkItem(new WaitCallback(BOT_MAIN.boardManagers[tC].TexelTuningThreadedPackage)); lM = m; } packetSize = paramCount + 1; int tmod = 0; while (tC != BOT_MAIN.TEXELfinished) { if (++tmod % 20 == 0) { WriteTexelParamsToTXT(tPath, BOT_MAIN.curTEXELPARAMS); SNAPSHOT_WRITLINE_REPLACEMENT(CalculateAverageTexelCost(pDataset, BOT_MAIN.curTEXELPARAMS) + " | "+ BOT_MAIN.TEXELadjustmentsmade); SNAPSHOT_WRITLINE_REPLACEMENT(ULONG_OPERATIONS.GetBitVisualization(BOT_MAIN.TEXELfinishedwithoutimpovement)); } Thread.Sleep(100); } SNAPSHOT_WRITLINE_REPLACEMENT("One Thread Generation FINISHED! :) :) :)"); pCurBestParams = BOT_MAIN.curTEXELPARAMS; } sw.Stop(); WriteTexelParamsToTXT(tPath, BOT_MAIN.curTEXELPARAMS); SNAPSHOT_WRITLINE_REPLACEMENT("END COST: " + CalculateAverageTexelCost(pDataset, BOT_MAIN.curTEXELPARAMS)); SNAPSHOT_WRITLINE_REPLACEMENT(BOT_MAIN.TEXELadjustmentsmade); SNAPSHOT_WRITLINE_REPLACEMENT(sw.ElapsedMilliseconds); } public void TexelTuningThreadedPackage(object obj) { SNAPSHOT_WRITLINE_REPLACEMENT("Started CThreadID [" + customThreadID + "] which is handling Params ["+ threadFrom + "] - ["+ threadTo + "]"); bool firstIter = true; do { double bestAvrgCost = CalculateAverageTexelCost(threadDataset, threadParams); int adjust_val = firstIter ? 512 : 8; do { adjust_val /= 2; bool improvedAvrgCost = true; while (improvedAvrgCost) { improvedAvrgCost = false; for (int i = threadFrom; i < threadTo; i++) { bool improvedWithThisParam = true; int tadjustval = adjust_val; bool lastTimeMaximized = false, lastTimeMinimized = false; while (improvedWithThisParam) { improvedWithThisParam = false; int[] curParams = (int[])threadParams.Clone(); int paramBefore = curParams[i]; curParams[i] = Math.Clamp(paramBefore + adjust_val, paramsLowerLimits[i], paramsUpperLimits[i]); double curAvrgCost = CalculateAverageTexelCost(threadDataset, curParams); if (curAvrgCost < bestAvrgCost) { improvedAvrgCost = true; improvedWithThisParam = true; SNAPSHOT_WRITLINE_REPLACEMENT("Improved Param [" + i + "] at CThreadID ["+ customThreadID + "]: +"+ adjust_val + " ("+ GetDoublePrecentageString(bestAvrgCost - curAvrgCost) + ")"); bestAvrgCost = curAvrgCost; threadParams = curParams; BOT_MAIN.TEXELadjustmentsmade++; BOT_MAIN.TEXELfinishedwithoutimpovement = ulAllThreadIDsUnfinished; if (lastTimeMaximized) { adjust_val *= 4; lastTimeMaximized = false; } else lastTimeMaximized = true; lastTimeMinimized = false; } else { curParams[i] = Math.Clamp(paramBefore - adjust_val, paramsLowerLimits[i], paramsUpperLimits[i]); curAvrgCost = CalculateAverageTexelCost(threadDataset, curParams); if (curAvrgCost < bestAvrgCost) { improvedAvrgCost = true; improvedWithThisParam = true; SNAPSHOT_WRITLINE_REPLACEMENT("Improved Param [" + i + "] at CThreadID ["+ customThreadID + "]: -"+ adjust_val + " ("+ GetDoublePrecentageString(bestAvrgCost - curAvrgCost) + ")"); bestAvrgCost = curAvrgCost; threadParams = curParams; BOT_MAIN.TEXELadjustmentsmade++; BOT_MAIN.TEXELfinishedwithoutimpovement = ulAllThreadIDsUnfinished; if (lastTimeMinimized) { adjust_val *= 4; lastTimeMinimized = false; } else lastTimeMinimized = true; lastTimeMaximized = false; } } if (adjust_val != 1) adjust_val /= 2; for (int j = threadFrom; j < threadTo; j++) { BOT_MAIN.curTEXELPARAMS[j] = threadParams[j]; } threadParams = (int[])BOT_MAIN.curTEXELPARAMS.Clone(); bestAvrgCost = CalculateAverageTexelCost(threadDataset, threadParams); } adjust_val = tadjustval; } } } while (adjust_val != 1); BOT_MAIN.TEXELfinishedwithoutimpovement = ULONG_OPERATIONS.SetBitToZero(BOT_MAIN.TEXELfinishedwithoutimpovement, customThreadID); SNAPSHOT_WRITLINE_REPLACEMENT("FULLY FINISHED " + customThreadID + ". IMPROVEMENT THREAD PACKAGE CYCLE"); firstIter = false; } while (BOT_MAIN.TEXELfinishedwithoutimpovement != 0); BOT_MAIN.TEXELfinished++; } private void WriteTexelParamsToTXT(string pPath, int[] pParams) { try { string tS = "PARAMS: {"; for (int i = 0; i < pParams.Length; i++) tS += pParams[i] + ","; tS = tS.Substring(0, tS.Length - 1) + "}\n"; File.AppendAllText(pPath, tS); } catch { SNAPSHOT_WRITLINE_REPLACEMENT("Mal wieder TXT zu lange gebraucht um zu aktualisieren."); } } private double costSum = 0d; private int texelCostMovesEvaluated = 0; private double CalculateAverageTexelCost(List<TLM_ChessGame> tDataset, int[] pParams, bool pFullCost = true) { costSum = 0d; texelCostMovesEvaluated = 0; SetupTexelEvaluationParams(pParams); int tGameDataSetLen = tDataset.Count; int start = 0, end = tGameDataSetLen; if (!pFullCost) { end = (start = globalRandom.Next(0, end - 256)) + 256; } for (int j = start; j < end; j++) { TLM_ChessGame tGame = tDataset[j]; double tGR = tGame.gameResult; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count - 5; texelCostMovesEvaluated += tL; for (int i = 0; i < tL; i++) { costSum += TexelCost(tGR - TexelTuningSigmoid(TexelEvaluate())); PlainMakeMove(tGame.actualMoves[i]); } } return costSum /texelCostMovesEvaluated; } private double CalculateAverageTexelCostThreadedVersionLEGACYDOESNTWORK(List<TLM_ChessGame> tDataset, int[] pParams) { Stopwatch sw = Stopwatch.StartNew(); BOT_MAIN.TEXELcostSum = 0d; BOT_MAIN.TEXELfinished = 0; BOT_MAIN.TEXELcostMovesEvaluated = 0; int tGameDataSetLen = tDataset.Count; int gamesPerThread = tGameDataSetLen /ENGINE_VALS.CPU_CORES; for (int i = 0; i < ENGINE_VALS.CPU_CORES - 1; i++) { } for (int i = 0; i < ENGINE_VALS.CPU_CORES - 1; i++) { } while (BOT_MAIN.TEXELfinished != ENGINE_VALS.CPU_CORES) Thread.Sleep(1); sw.Stop(); return BOT_MAIN.TEXELcostSum /BOT_MAIN.TEXELcostMovesEvaluated; } public void SetPlayThroughVals(List<TLM_ChessGame> pDataset, int pFrom, int pTo) { threadDataset = pDataset; threadFrom = pFrom; threadTo = pTo; } public void SetPlayTexelVals(List<TLM_ChessGame> pDataset, int pFrom, int pTo, int[] pTexelParams, int[] pLowerLimits, int[] pUpperLimits, int pThreadID, ulong pUL) { threadDataset = pDataset; threadFrom = pFrom; threadTo = pTo; threadParams = pTexelParams; paramsLowerLimits = pLowerLimits; paramsUpperLimits = pUpperLimits; customThreadID = pThreadID; ulAllThreadIDsUnfinished = pUL; } public void PlayThroughSetOfGames(object obj) { SNAPSHOT_WRITLINE_REPLACEMENT(threadFrom + "->"+ threadTo); int sortedOut = 0; for (int j = threadFrom; j < threadTo; j++) { TLM_ChessGame tGame = threadDataset[j]; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count; for (int i = 0; i < tL; i++) { int tQuietEval = isWhiteToMove ? QuiescenceWhite(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, 0, PreMinimaxCheckCheckWhite(), NULL_MOVE) : QuiescenceBlack(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, 0, PreMinimaxCheckCheckBlack(), NULL_MOVE); bool tB; tGame.isMoveNonTactical.Add(tB = (Evaluate() == tQuietEval && i > 4)); if (!tB) sortedOut++; PlainMakeMove(tGame.actualMoves[i]); } } BOT_MAIN.TEXELsortedout += sortedOut; BOT_MAIN.TEXELfinished++; } public void CalculateAverageTexelCostThreadFunction(object obj) { SetupTexelEvaluationParams(threadParams); double d = 0d; for (int j = threadFrom; j < threadTo; j++) { TLM_ChessGame tGame = threadDataset[j]; double tGR = tGame.gameResult; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count - 5; BOT_MAIN.TEXELcostMovesEvaluated += tL; for (int i = 0; i < tL; i++) { d += TexelCost(tGR - TexelTuningSigmoid(TexelEvaluate())); PlainMakeMove(tGame.actualMoves[i]); } } BOT_MAIN.TEXELcostSum += d; BOT_MAIN.TEXELfinished++; } private void ConsoleWriteLineTuneArray<T>(T[,][] pArr) { for (int j = 0; j < 3; j++) { SNAPSHOT_WRITLINE_REPLACEMENT("{"); for (int k = 0; k < 6; k++) { SNAPSHOT_WRITLINE_REPLACEMENT("{"); for (int s = 0; s < 64; s++) SNAPSHOT_WRITLINE_REPLACEMENT(pArr[j, k][s] + ", "); SNAPSHOT_WRITLINE_REPLACEMENT("\n}"); } SNAPSHOT_WRITLINE_REPLACEMENT("}"); } } private void Tune(string pGameCGFF, double pLearningRate) { TLM_ChessGame tGame = CGFF.GetGame(pGameCGFF); LoadFenString(tGame.startFen); double tDGameResult = tGame.gameResult; foreach (int hMove in tGame.hashedMoves) { Tune(tDGameResult, pLearningRate); List<Move> moveOptionList = new List<Move>(); GetLegalMoves(ref moveOptionList); int tL = moveOptionList.Count; for (int i = 0; i < tL; i++) { Move tMove = moveOptionList[i]; if (tMove.moveHash == hMove) { PlainMakeMove(tMove); tL = -1; break; } } if (tL != -1) break; } } private void Tune(double pGameResult, double pLearningRate) { int tPC = ULONG_OPERATIONS.CountBits(allPieceBitboard); double oneThroughPieceCount = 1d /tPC; double egMult = earlyGameMultipliers[tPC], mgMult = middleGameMultipliers[tPC], lgMult = lateGameMultipliers[tPC]; double tTexelResult = TexelEvaluateF(); double tSigmoidedTexelResult = TexelSigmoid(tTexelResult); double tDif = tSigmoidedTexelResult - pGameResult; double tM = oneThroughPieceCount * TexelCostDerivative(tDif) * TexelSigmoidDerivative(tTexelResult) * pLearningRate; sumCostVals += lastCostVal = TexelCost(tDif); costCalculations++; for (int i = 0; i < 64; i++) { if (ULONG_OPERATIONS.IsBitZero(allPieceBitboard, i)) continue; int tPT = pieceTypeArray[i] - 1, tI = i; if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, i)) tI = blackSidedSquares[i]; texelTuningAdjustIterations[tPT, tI]++; } } private double TexelEvaluateF() { texelTuningRuntimeVals = GetInterpolatedProcessedValues(texelTuningVals); return TexelEvaluate(); } private int TexelEvaluate() { int tEvalEG = 0, tEvalLG = 0, tProgress = 0; ulong[] attkULs = new ulong[14]; for (int p = 0; p < 64; p++) { if (((int)(allPieceBitboard >> p) & 1) == 0) continue; int aPT = pieceTypeArray[p], tPT = aPT + 7 * ((int)(blackPieceBitboard >> p) & 1); tEvalEG += texelTuningRuntimePositionalValsV2EG[tPT][p] + texelPieceEvaluationsV2EG[tPT]; tEvalLG += texelTuningRuntimePositionalValsV2LG[tPT][p] + texelPieceEvaluationsV2LG[tPT]; tProgress += pieceTypeGameProgressImpact[tPT]; } if (tProgress > 24) tProgress = 24; return (int)(earlyGameMultipliers[tProgress] * tEvalEG + lateGameMultipliers[tProgress] * tEvalLG); } private const double TexelK = 0.2; private double TexelTuningSigmoid(double pVal) { return 2d /(1 + Math.Pow(10, -TexelK * pVal /400)); } private double TexelSigmoid(double pVal) { return 2d /(Math.Exp(-0.04d * pVal) + 1d); } private double TexelSigmoidDerivative(double pVal) { double d = Math.Exp(-0.04d * pVal); return 2d * d /(25d * (d + 1d) * (d + 1d)); } private double TexelCost(double pVal) { return pVal * pVal; } private double TexelCostDerivative(double pVal) { return 2 * pVal; } private char[] fenPieces = new char[7] { 'z', 'p', 'n', 'b', 'r', 'q', 'k' }; private string[] squareNames = new string[64] { "a1", "b1", "c1", "d1", "e1", "f1", "g1", "h1", "a2", "b2", "c2", "d2", "e2", "f2", "g2", "h2", "a3", "b3", "c3", "d3", "e3", "f3", "g3", "h3", "a4", "b4", "c4", "d4", "e4", "f4", "g4", "h4", "a5", "b5", "c5", "d5", "e5", "f5", "g5", "h5", "a6", "b6", "c6", "d6", "e6", "f6", "g6", "h6", "a7", "b7", "c7", "d7", "e7", "f7", "g7", "h7", "a8", "b8", "c8", "d8", "e8", "f8", "g8", "h8"}; public string CreateFenString() { string rFEN = ""; for (int i = 7; i >= 0; i--) { int t = 0; for (int j = 0; j < 8; j++) { int sq = i * 8 + j; if (pieceTypeArray[sq] != 0) { if (t != 0) rFEN += t; t = 0; } if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, sq)) { switch (pieceTypeArray[sq]) { case 0: t++; SNAPSHOT_WRITLINE_REPLACEMENT("???"); break; case 1: rFEN += 'P'; break; case 2: rFEN += 'N'; break; case 3: rFEN += 'B'; break; case 4: rFEN += 'R'; break; case 5: rFEN += 'Q'; break; case 6: rFEN += 'K'; break; } } else { switch (pieceTypeArray[sq]) { case 0: t++; break; case 1: rFEN += 'p'; break; case 2: rFEN += 'n'; break; case 3: rFEN += 'b'; break; case 4: rFEN += 'r'; break; case 5: rFEN += 'q'; break; case 6: rFEN += 'k'; break; } } } if (t != 0) rFEN += t; if (i != 0) rFEN += "/"; } rFEN += (isWhiteToMove ? " w": " b"); rFEN += (whiteCastleRightKingSide ? " K": " "); rFEN += (whiteCastleRightQueenSide ? "Q": ""); rFEN += (blackCastleRightKingSide ? "k": ""); rFEN += (blackCastleRightQueenSide ? "q": ""); if (!whiteCastleRightKingSide && !whiteCastleRightQueenSide && !blackCastleRightKingSide && !blackCastleRightQueenSide) rFEN += "-"; if (enPassantSquare < 64) rFEN += " "+ squareNames[enPassantSquare] + " "; else rFEN += " - "; return rFEN + fiftyMoveRuleCounter + " "+ ((happenedHalfMoves - happenedHalfMoves % 2) /2); } public void LoadFenString(string fenStr) { lastMadeMove = NULL_MOVE; zobristKey = 0ul; whitePieceBitboard = blackPieceBitboard = allPieceBitboard = 0ul; for (int i = 0; i < 64; i++) pieceTypeArray[i] = 0; string[] spaceSpl = fenStr.Split(' '); string[] rowSpl = spaceSpl[0].Split('/'); string epstr = spaceSpl[3]; if (epstr == "-") enPassantSquare = 65; else enPassantSquare = (epstr[0] - 'a') + 8 * (epstr[1] - '1'); isWhiteToMove = true; if (spaceSpl[1] == "b") isWhiteToMove = false; if (!isWhiteToMove) zobristKey ^= blackTurnHash; string crstr = spaceSpl[2]; whiteCastleRightKingSide = whiteCastleRightQueenSide = blackCastleRightKingSide = blackCastleRightQueenSide = false; int crStrL = crstr.Length; for (int i = 0; i < crStrL; i++) { switch (crstr[i]) { case 'K': whiteCastleRightKingSide = true; break; case 'Q': whiteCastleRightQueenSide = true; break; case 'k': blackCastleRightKingSide = true; break; case 'q': blackCastleRightQueenSide = true; break; } } fiftyMoveRuleCounter = Convert.ToInt32(spaceSpl[4]); happenedHalfMoves = Convert.ToInt32(spaceSpl[5]) * 2; if (!isWhiteToMove) happenedHalfMoves++; int tSq = 0; for (int i = rowSpl.Length; i-- > 0;) { string tStr = rowSpl[i]; int tStrLen = tStr.Length; for (int c = 0; c < tStrLen; c++) { char tChar = tStr[c]; if (Char.IsDigit(tChar)) tSq += tChar - '0'; else { bool tCol = Char.IsLower(tChar); if (tCol) blackPieceBitboard = ULONG_OPERATIONS.SetBitToOne(blackPieceBitboard, tSq); else whitePieceBitboard = ULONG_OPERATIONS.SetBitToOne(whitePieceBitboard, tSq); if (tChar == 'k') blackKingSquare = tSq; else if (tChar == 'K') whiteKingSquare = tSq; pieceTypeArray[tSq] = Array.IndexOf(fenPieces, Char.ToLower(tChar)); if (tCol) zobristKey ^= pieceHashesBlack[tSq, pieceTypeArray[tSq]]; else zobristKey ^= pieceHashesWhite[tSq, pieceTypeArray[tSq]]; tSq++; } } } if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; zobristKey ^= enPassantSquareHashes[enPassantSquare]; allPieceBitboard = whitePieceBitboard | blackPieceBitboard; if (zobristKey == 16260251586586513106) moveHashList.Clear(); else { moveHashList.Clear(); moveHashList.Add(1); moveHashList.Add(2); moveHashList.Add(3); } } private ulong[,] pieceHashesWhite = new ulong[64, 7], pieceHashesBlack = new ulong[64, 7]; private ulong blackTurnHash, whiteKingSideRochadeRightHash, whiteQueenSideRochadeRightHash, blackKingSideRochadeRightHash, blackQueenSideRochadeRightHash; private ulong[] enPassantSquareHashes = new ulong[66]; private void InitZobrist() { Random rng = new Random(31415926); for (int sq = 0; sq < 64; sq++) { enPassantSquareHashes[sq] = ULONG_OPERATIONS.GetRandomULONG(rng); for (int it = 1; it < 7; it++) { pieceHashesWhite[sq, it] = ULONG_OPERATIONS.GetRandomULONG(rng); pieceHashesBlack[sq, it] = ULONG_OPERATIONS.GetRandomULONG(rng); } } blackTurnHash = ULONG_OPERATIONS.GetRandomULONG(rng); whiteKingSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); whiteQueenSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); blackKingSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); blackQueenSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); } public void SetKnightMasks(ulong[] uls) { knightSquareBitboards = uls; } public void SetKingMasks(ulong[] uls) { kingSquareBitboards = uls; } private Move[,] whiteEnPassantMoves = new Move[64, 64]; private Move[,] blackEnPassantMoves = new Move[64, 64]; private bool[] epValidationArray = new bool[64] { false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true , true , true , true , true , true , true , true, true , true , true , true , true , true , true , true, true , true , true , true , true , true , true , true, true , true , true , true , true , true , true , true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false }; private ulong[] kingSafetyRing1 = new ulong[64], kingSafetyRing2 = new ulong[64]; private ulong[] kingSafetySpecialRingW = new ulong[64], kingSafetySpecialRingB = new ulong[64]; private ulong[] rowPrecalcs = new ulong[8], columnPrecalcs = new ulong[8]; const ulong columnUL = 0x101010101010101, rowUL = 0b11111111; private void PrecalculateKingSafetyBitboards() { for (int i = 0; i < 8; i++) { rowPrecalcs[i] = rowUL << (8 * i); columnPrecalcs[i] = columnUL << i; } for (int i = 0; i < 64; i++) { int tMod = i % 8; int tRow = (i - tMod) /8; ulong tULC = columnPrecalcs[tMod], tULR = rowPrecalcs[tRow]; ulong tULC2 = columnPrecalcs[tMod], tULR2 = rowPrecalcs[tRow]; if (tMod < 7) tULC |= columnPrecalcs[tMod + 1]; if (tMod > 0) tULC |= columnPrecalcs[tMod - 1]; if (tRow < 7) tULR |= rowPrecalcs[tRow + 1]; if (tRow > 0) tULR |= rowPrecalcs[tRow - 1]; if (tMod < 6) tULC2 |= columnPrecalcs[tMod + 2]; if (tMod > 1) tULC2 |= columnPrecalcs[tMod - 2]; if (tRow < 6) tULR2 |= rowPrecalcs[tRow + 2]; if (tRow > 1) tULR2 |= rowPrecalcs[tRow - 2]; tULR2 |= tULR; tULC2 |= tULC; kingSafetyRing1[i] = ULONG_OPERATIONS.SetBitToZero(tULR & tULC, i); kingSafetyRing2[i] = ULONG_OPERATIONS.SetBitsToZero(tULR2 & tULC2, i, i + 1, i - 1, i + 7, i + 8, i + 9, i - 7, i - 8, i - 9); } for (int i = 0; i < 64; i++) { if (i < 56) kingSafetySpecialRingW[i] = ULONG_OPERATIONS.SetBitToZero(kingSafetyRing1[i] | kingSafetyRing1[i + 8], i); else kingSafetySpecialRingW[i] = kingSafetyRing1[i]; if (i > 7) kingSafetySpecialRingB[i] = ULONG_OPERATIONS.SetBitToZero(kingSafetyRing1[i] | kingSafetyRing1[i - 8], i); else kingSafetySpecialRingB[i] = kingSafetyRing1[i]; } } private void PrecalculateEnPassantMoves() { for (int i = 0; i < 64; i++) { if (!epValidationArray[i]) continue; for (int j = 0; j < 64; j++) { if (i == j) continue; if (Math.Abs(i - j) > 9) continue; if (!epValidationArray[j]) continue; whiteEnPassantMoves[i, j] = new Move(false, i, j, j - 8); blackEnPassantMoves[i, j] = new Move(false, i, j, j + 8); } } } private void PawnAttackBitboards() { for (int sq = 0; sq < 64; sq++) { ulong u = 0ul; if (sq % 8 != 0) u = ULONG_OPERATIONS.SetBitToOne(u, sq + 7); if (sq % 8 != 7) u = ULONG_OPERATIONS.SetBitToOne(u, sq + 9); whitePawnAttackSquareBitboards[sq] = u; u = 0ul; if (sq % 8 != 0 && sq - 9 > -1) u = ULONG_OPERATIONS.SetBitToOne(u, sq - 9); if (sq % 8 != 7 && sq - 7 > -1) u = ULONG_OPERATIONS.SetBitToOne(u, sq - 7); blackPawnAttackSquareBitboards[sq] = u; } } private int[] squareConnectivesPrecalculationArray = new int[4096]; public int[] squareConnectivesCrossDirsPrecalculationArray { get; set; } = new int[4096]; private ulong[] squareConnectivesPrecalculationRayArray = new ulong[4096]; private ulong[] squareConnectivesPrecalculationLineArray = new ulong[4096]; private List<Dictionary<ulong, int>> rayCollidingSquareCalculations = new List<Dictionary<ulong, int>>(); private readonly int[] maxIntWithSpecifiedBitcount = new int[8] { 0, 0b1, 0b11, 0b111, 0b1111, 0b11111, 0b111111, 0b1111111 }; private List<ulong> differentRays = new List<ulong>(); private void SquareConnectivesPrecalculations() { for (int square = 0; square < 64; square++) { rayCollidingSquareCalculations.Add(new Dictionary<ulong, int>()); rayCollidingSquareCalculations[square].Add(0ul, square); for (int square2 = 0; square2 < 64; square2++) { if (square == square2) continue; int t = 0, t2 = 0, difSign = Math.Sign(square2 - square), itSq = square, g = 0; ulong tRay = 0ul, tExclRay = 0ul; List<int> tRayInts = new List<int>(); if (difSign == -1) g = 7; if (square % 8 == square2 % 8) { t2 = t = 1; while ((itSq += difSign * 8) < 64 && itSq > -1) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } } else if ((square - square % 8) == (square2 - square2 % 8)) { t = 1; t2 = -1; while ((itSq += difSign) % 8 != g && itSq > -1 && itSq < 64) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } } else { int dif = Math.Abs(square2 - square); if (dif % 7 == 0) { t = 2; t2 = 2; g = (difSign == 1) ? 7 : 0; while ((itSq += difSign * 7) % 8 != g && itSq < 64 && itSq > -1) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } if (ULONG_OPERATIONS.IsBitZero(tRay, square2)) { t2 = t = 0; tRay = 0ul; } } else if (dif % 9 == 0) { t = 2; t2 = -2; if (square == 0 && square2 == 63 || square == 63 && square2 == 0) SNAPSHOT_WRITLINE_REPLACEMENT("!"); while ((itSq += difSign * 9) % 8 != g && itSq < 64 && itSq > -1) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } if (ULONG_OPERATIONS.IsBitZero(tRay, square2)) { t2 = t = 0; tRay = 0ul; } } } if (square == 0 && square2 == 63) { t2 = t = 2; tRayInts.Clear(); tExclRay = tRay = ULONG_OPERATIONS.SetBitsToOne(0ul, 9, 18, 27, 36, 45, 54, 63); tRayInts = new List<int>() { 9, 18, 27, 36, 45, 54, 63 }; } else if (square2 == 0 && square == 63) { t = 2; tRayInts.Clear(); t2 = -2; tExclRay = tRay = ULONG_OPERATIONS.SetBitsToOne(0ul, 0, 9, 18, 27, 36, 45, 54); tRayInts = new List<int>() { 54, 45, 36, 27, 18, 9, 0 }; } if (tRay != 0ul && !differentRays.Contains(tRay)) { differentRays.Add(tRay); int ccount, combI = maxIntWithSpecifiedBitcount[ccount = ULONG_OPERATIONS.CountBits(tRay)]; do { ulong curAllPieceBitboard = 0ul; int solution = square; for (int j = 0; j < ccount; j++) { if (((combI >> j) & 1) == 1) { curAllPieceBitboard = ULONG_OPERATIONS.SetBitToOne(curAllPieceBitboard, tRayInts[j]); if (solution == square) solution = tRayInts[j]; } } rayCollidingSquareCalculations[square].Add(curAllPieceBitboard, solution); } while (--combI != 0); } squareConnectivesPrecalculationArray[square << 6 | square2] = t; squareConnectivesPrecalculationRayArray[square << 6 | square2] = tRay; squareConnectivesCrossDirsPrecalculationArray[square << 6 | square2] = t2; if (t != 0) squareConnectivesPrecalculationLineArray[square << 6 | square2] = (square == 0 && square2 == 63 || square2 == 0 && square == 63) ? tExclRay : ULONG_OPERATIONS.SetBitToOne(tExclRay, square2); if (squareConnectivesPrecalculationLineArray[square << 6 | square2] == 0ul && ULONG_OPERATIONS.IsBitOne(knightSquareBitboards[square], square2)) squareConnectivesPrecalculationLineArray[square << 6 | square2] = 1ul << square2; } differentRays.Clear(); } } public void SNAPSHOT_WRITLINE_REPLACEMENT() { } public void SNAPSHOT_WRITLINE_REPLACEMENT(object pStr) { } private string GetDoublePrecentageString(double pVal) { return ((int)(pVal * 1_000_000) /10_000d) + "%"; } private string ReplaceAllULONGIsBitOne(string pCode) { const string METHOD_NAME = "ULONG_OPERATIONS.IsBitOne"; int METHOD_NAME_LEN = METHOD_NAME.Length, iterations = 0; int pIndex = pCode.IndexOf(METHOD_NAME); while (pIndex != -1 && ++iterations < 10_000) { List<int> paramIndexes = new List<int>(); int openedBracketCount = 1, closedBracketCount = 0, a = METHOD_NAME_LEN + pIndex; string tpCode = pCode.Substring(0, pIndex); paramIndexes.Add(a + 1); while (++a < pCode.Length) { switch (pCode[a]) { case '(': openedBracketCount++; break; case ')': if (++closedBracketCount == openedBracketCount) { pIndex = a; a = int.MaxValue - 5; } break; case ',': if (openedBracketCount - closedBracketCount == 1) paramIndexes.Add(a + 1); break; } } if (openedBracketCount == closedBracketCount && paramIndexes.Count == 2) { tpCode += "((int)("+ pCode.Substring(paramIndexes[0], paramIndexes[1] - paramIndexes[0] - 1) + (pCode[paramIndexes[1]] == ' ' ? " >> (": " >> (") + pCode.Substring(paramIndexes[1], pIndex - paramIndexes[1]) + ")) & 1) == 1"+ pCode.Substring(pIndex + 1, pCode.Length - pIndex - 1); } pIndex = (pCode = tpCode).IndexOf(METHOD_NAME); } SNAPSHOT_WRITLINE_REPLACEMENT(iterations + " ITERATIONS"); return pCode; } private string ReplaceAllULONGIsBitZero(string pCode) { const string METHOD_NAME = "ULONG_OPERATIONS.IsBitZero"; int METHOD_NAME_LEN = METHOD_NAME.Length, iterations = 0; int pIndex = pCode.IndexOf(METHOD_NAME); while (pIndex != -1 && ++iterations < 10_000) { List<int> paramIndexes = new List<int>(); int openedBracketCount = 1, closedBracketCount = 0, a = METHOD_NAME_LEN + pIndex; string tpCode = pCode.Substring(0, pIndex); paramIndexes.Add(a + 1); while (++a < pCode.Length) { switch (pCode[a]) { case '(': openedBracketCount++; break; case ')': if (++closedBracketCount == openedBracketCount) { pIndex = a; a = int.MaxValue - 5; } break; case ',': if (openedBracketCount - closedBracketCount == 1) paramIndexes.Add(a + 1); break; } } if (openedBracketCount == closedBracketCount && paramIndexes.Count == 2) { tpCode += "((int)("+ pCode.Substring(paramIndexes[0], paramIndexes[1] - paramIndexes[0] - 1) + (pCode[paramIndexes[1]] == ' ' ? " >>": " >> ") + pCode.Substring(paramIndexes[1], pIndex - paramIndexes[1]) + ") & 1) == 0"+ pCode.Substring(pIndex + 1, pCode.Length - pIndex - 1); } pIndex = (pCode = tpCode).IndexOf(METHOD_NAME); } SNAPSHOT_WRITLINE_REPLACEMENT(iterations + " ITERATIONS"); return pCode; } private string GetThreeDigitSeperatedInteger(int pInt) { string s = pInt.ToString(), r = s[0].ToString(); int t = s.Length % 3; for (int i = 1; i < s.Length; i++) { if (i % 3 == t) r += "."; r += s[i]; } s = ""; for (int i = 0; i < r.Length; i++) s += r[i]; return s; } public double GetAverageDepth() { return (double)depths /(double)searches; } }
public class SNAPSHOT_V01_00_003 : IBoardManager  { public int TEXEL_PARAMS { get; } = 778; private const int BESTMOVE_SORT_VAL = -2_000_000_000; private const int CAPTURE_SORT_VAL = -1_000_000_000; private const int KILLERMOVE_SORT_VAL = -1000; private readonly int[,] MVVLVA_TABLE = new int[7, 7] { { 0, 0, 0, 0, 0, 0, 0 }, { 0, 1500, 1400, 1300, 1200, 1100, 1000 }, { 0, 3500, 3400, 3300, 3200, 3100, 3000 }, { 0, 4500, 4400, 4300, 4200, 4100, 4000 }, { 0, 5500, 5400, 5300, 5200, 5100, 5000 }, { 0, 9500, 9400, 9300, 9200, 9100, 9000 }, { 0, 0, 0, 0, 0, 0, 0 }}; private int BOARD_MANAGER_ID = -1; private bool debugSearchDepthResults = false; private bool debugSortResults = false; private RookMovement rookMovement; private BishopMovement bishopMovement; private QueenMovement queenMovement; private KnightMovement knightMovement; private KingMovement kingMovement; private WhitePawnMovement whitePawnMovement; private BlackPawnMovement blackPawnMovement; private Rays rays; public List<Move> moveOptionList { get; set; } private int[] pieceTypeArray = new int[64]; public ulong whitePieceBitboard, blackPieceBitboard, allPieceBitboard; private ulong zobristKey; private int whiteKingSquare, blackKingSquare, enPassantSquare = 65, happenedHalfMoves = 0, fiftyMoveRuleCounter = 0; private bool whiteCastleRightKingSide, whiteCastleRightQueenSide, blackCastleRightKingSide, blackCastleRightQueenSide; private bool isWhiteToMove; private const ulong WHITE_KING_ROCHADE = 96, WHITE_QUEEN_ROCHADE = 14, BLACK_KING_ROCHADE = 6917529027641081856, BLACK_QUEEN_ROCHADE = 1008806316530991104, WHITE_QUEEN_ATTK_ROCHADE = 12, BLACK_QUEEN_ATTK_ROCHADE = 864691128455135232; private readonly Move mWHITE_KING_ROCHADE = new Move(4, 6, 7, 5), mWHITE_QUEEN_ROCHADE = new Move(4, 2, 0, 3), mBLACK_KING_ROCHADE = new Move(60, 62, 63, 61), mBLACK_QUEEN_ROCHADE = new Move(60, 58, 56, 59); private ulong[] knightSquareBitboards = new ulong[64]; private ulong[] whitePawnAttackSquareBitboards = new ulong[64]; private ulong[] blackPawnAttackSquareBitboards = new ulong[64]; private ulong[] kingSquareBitboards = new ulong[64]; private bool[,] pieceTypeAbilities = new bool[7, 3] { { false, false, false }, { false, false, false }, { false, false, false }, { false, false, true }, { false, true, false }, { false, true, true }, { false, false, false } }; private List<int> moveHashList = new List<int>(); private ulong[] curSearchZobristKeyLine = Array.Empty<ulong>(); private Stopwatch globalTimer = Stopwatch.StartNew(); private Move lastMadeMove; private int depths, searches; private Random globalRandom = new Random(); public SNAPSHOT_V01_00_003(string fen) { Setup(fen); } public void Setup(string pFen) { Stopwatch setupStopwatch = Stopwatch.StartNew(); BOARD_MANAGER_ID = BOT_MAIN.curBoardManagerID; for (int i = 0; i < 33; i++) for (int j = 0; j < 14; j++) piecePositionEvals[i, j] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; for (int i = 0; i < 33; i++) for (int j = 0; j < 14; j++) texelTuningRuntimeVals[i, j] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; for (int i = 0; i < 3; i++) for (int j = 0; j < 6; j++) texelTuningVals[i, j] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; for (int i = 0; i < 14; i++) { texelTuningRuntimePositionalValsV2EG[i] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; texelTuningRuntimePositionalValsV2LG[i] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; } PrecalculateKingSafetyBitboards(); PrecalculateMultipliers(); GetLowNoisePositionalEvaluation(globalRandom); MinimaxRoot(1L); SetupConsoleWrite("[PRECALCS] Zobrist Hashing"); InitZobrist(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Knight Movement"); knightMovement = new KnightMovement(this); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Square Connectives"); SquareConnectivesPrecalculations(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Pawn Attack Bitboards"); PawnAttackBitboards(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Rays"); rays = new Rays(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); queenMovement = new QueenMovement(this); SetupConsoleWrite("[PRECALCS] Rook Movement"); rookMovement = new RookMovement(this, queenMovement); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Bishop Movement"); bishopMovement = new BishopMovement(this, queenMovement); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] King Movement"); kingMovement = new KingMovement(this); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Pawn Movement"); whitePawnMovement = new WhitePawnMovement(this); blackPawnMovement = new BlackPawnMovement(this); PrecalculateEnPassantMoves(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWriteLine("[DONE]\n\n"); LoadFenString(pFen); LoadBestTexelParamsIn(); setupStopwatch.Stop(); } private void SetupConsoleWriteLine(string pStr) { if (BOT_MAIN.isFirstBoardManagerInitialized) return; SNAPSHOT_WRITLINE_REPLACEMENT(pStr); } private void SetupConsoleWrite(string pStr) { if (BOT_MAIN.isFirstBoardManagerInitialized) return; SNAPSHOT_WRITLINE_REPLACEMENT(pStr); } public void GetLowNoisePositionalEvaluation(System.Random rng) { int[,][] digitArray = new int[3, 6][]; for (int i = 0; i < 3; i++) for (int j = 0; j < 6; j++) digitArray[i, j] = GetRand64IntArray(rng, -5, 6); lowNoisePositionEvals1 = GetInterpolatedProcessedValues(digitArray); int[,][] digitArray2 = new int[3, 6][]; for (int i = 0; i < 3; i++) for (int j = 0; j < 6; j++) digitArray2[i, j] = GetRand64IntArray(rng, -5, 6); lowNoisePositionEvals2 = GetInterpolatedProcessedValues(digitArray2); } private int[] GetRand64IntArray(System.Random rng, int pMin, int pMax) { return new int[64] { rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax) }; } private string GetAIArrayValuesStringRepresentation(int[,][] pArr) { string r = "int[,][] ReLe_AI_RESULT_VALS = new int[3, 6][] {"; for (int i = 0; i < 3; i++) { r += "{"; for (int j = 0; j < 5; j++) { r += GetIntArray64LStringRepresentation(pArr[i, j]) + ","; } r += GetIntArray64LStringRepresentation(pArr[i, 5]) + "},"; } return r.Substring(0, r.Length - 1) + "};"; } private string GetIntArray64LStringRepresentation(int[] p64LArr) { if (p64LArr == null) return ""; string r = "new int[64]{"; for (int i = 0; i < 63; i++) { r += p64LArr[i] + ","; } return r + p64LArr[63] + "}"; } public void TempStuff() { } private string[] gameResultStrings = new string[5] { "Black Has Won!", "Draw!", "White Has Won!", "Non Existant Result!", "Game is Ongoing!"}; private int[,][] lowNoisePositionEvals1, lowNoisePositionEvals2; public void ThreadSelfPlay(object obj) { PlayGameAgainstItself(obj); } public void PlayGameAgainstItself(object obj, string pStartFEN = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1", long tickLimitForEngine = ENGINE_VALS.SELF_PLAY_THINK_TIME) { int ttGState; while (BOT_MAIN.goalGameCount > BOT_MAIN.gamesPlayed) { try { string tGameStr; GetLowNoisePositionalEvaluation(globalRandom); LoadFenString(tGameStr = pStartFEN); tGameStr += ";"; int tGState = 3, tmc = 0; bool lowNoiceDecider = globalRandom.NextDouble() < 0.5d; while (tGState == 3) { piecePositionEvals = lowNoiceDecider ? lowNoisePositionEvals1 : lowNoisePositionEvals2; MinimaxRoot(tickLimitForEngine); Move tM = transpositionTable[zobristKey].bestMove; PlainMakeMove(tM); tGameStr += NuCRe.GetNuCRe(tM.moveHash) + ","; BOT_MAIN.movesPlayed++; tGState = GameState(isWhiteToMove); lowNoiceDecider = !lowNoiceDecider; tmc++; } ttGState = tGState; tGameStr += ttGState + 1; SNAPSHOT_WRITLINE_REPLACEMENT(tGameStr); BOT_MAIN.gamesPlayedResultArray[ttGState + 1]++; BOT_MAIN.gamesPlayed++; BOT_MAIN.selfPlayGameStrings.Add(tGameStr); } catch (Exception tE) { SNAPSHOT_WRITLINE_REPLACEMENT(tE.ToString()); } } } public void PlayGameOnConsoleAgainstHuman(string pStartFEN = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1", bool pHumanPlaysWhite = true, long tickLimitForEngine = 10_000_000L) { debugSearchDepthResults = true; LoadFenString(pStartFEN); if (!(pHumanPlaysWhite ^ isWhiteToMove)) { var pVS = Console.ReadLine(); if (pVS == null) return; Move tm = GetMoveOfString(pVS.ToString()); SNAPSHOT_WRITLINE_REPLACEMENT(tm); PlainMakeMove(tm); } int tGState = 3; while (tGState == 3) { MinimaxRoot(tickLimitForEngine); PlayThroughZobristTree(); Move tM = transpositionTable[zobristKey].bestMove; SNAPSHOT_WRITLINE_REPLACEMENT(tM); SNAPSHOT_WRITLINE_REPLACEMENT(CreateFenString()); PlainMakeMove(tM); tGState = GameState(isWhiteToMove); if (tGState != 3 || tM == NULL_MOVE) break; var pV = ""; tM = NULL_MOVE; do { pV = Console.ReadLine(); if (pV == null) continue; tM = GetMoveOfString(pV.ToString()); SNAPSHOT_WRITLINE_REPLACEMENT(tM); } while (tM == NULL_MOVE); PlainMakeMove(tM); tGState = GameState(isWhiteToMove); } } private void PlayThroughZobristTree() { SetJumpState(); SNAPSHOT_WRITLINE_REPLACEMENT("\n- - - - - - - - - - - - -"); int tC = 1; Dictionary<ulong, bool> usedULs = new Dictionary<ulong, bool>(); while (transpositionTable.TryGetValue(zobristKey, out TranspositionEntry tM)) { if (usedULs.ContainsKey(zobristKey)) { SNAPSHOT_WRITLINE_REPLACEMENT(tC + ": AT LEAST ONE REPETION; REST NOT VISIBLE"); break; } SNAPSHOT_WRITLINE_REPLACEMENT(tC + ": "+ tM.bestMove + " > "); usedULs.Add(zobristKey, true); PlainMakeMove(tM.bestMove); tC++; } SNAPSHOT_WRITLINE_REPLACEMENT("- - - - - - - - - - - - -\n"); LoadJumpState(); } public Move? ReturnNextMove(Move? lastMove, long pThinkingTime) { if (lastMove != null) PlainMakeMove(lastMove); if (GameState(isWhiteToMove) != 3) return null; MinimaxRoot(pThinkingTime); if (!transpositionTable.ContainsKey(zobristKey)) return null; Move tm = transpositionTable[zobristKey].bestMove; PlainMakeMove(tm); return tm; } private int[] jmpSt_pieceTypeArray; private ulong jmpSt_whitePieceBitboard, jmpSt_blackPieceBitboard; private ulong jmpSt_zobristKey; private int jmpSt_whiteKingSquare, jmpSt_blackKingSquare, jmpSt_enPassantSquare, jmpSt_happenedHalfMoves, jmpSt_fiftyMoveRuleCounter; private bool jmpSt_whiteCastleRightKingSide, jmpSt_whiteCastleRightQueenSide, jmpSt_blackCastleRightKingSide, jmpSt_blackCastleRightQueenSide; private bool jmpSt_isWhiteToMove; private ulong[] jmpSt_curSearchZobristKeyLine; private int[] jmpSt_moveHashList; public void LoadJumpState() { pieceTypeArray = (int[])jmpSt_pieceTypeArray.Clone(); whitePieceBitboard = jmpSt_whitePieceBitboard; blackPieceBitboard = jmpSt_blackPieceBitboard; zobristKey = jmpSt_zobristKey; whiteKingSquare = jmpSt_whiteKingSquare; blackKingSquare = jmpSt_blackKingSquare; enPassantSquare = jmpSt_enPassantSquare; happenedHalfMoves = jmpSt_happenedHalfMoves; fiftyMoveRuleCounter = jmpSt_fiftyMoveRuleCounter; whiteCastleRightKingSide = jmpSt_whiteCastleRightKingSide; whiteCastleRightQueenSide = jmpSt_whiteCastleRightQueenSide; blackCastleRightKingSide = jmpSt_blackCastleRightKingSide; blackCastleRightQueenSide = jmpSt_blackCastleRightQueenSide; isWhiteToMove = jmpSt_isWhiteToMove; curSearchZobristKeyLine = (ulong[])jmpSt_curSearchZobristKeyLine.Clone(); allPieceBitboard = blackPieceBitboard | whitePieceBitboard; moveHashList = jmpSt_moveHashList.ToList(); } public void SetJumpState() { jmpSt_pieceTypeArray = (int[])pieceTypeArray.Clone(); jmpSt_whitePieceBitboard = whitePieceBitboard; jmpSt_blackPieceBitboard = blackPieceBitboard; jmpSt_zobristKey = zobristKey; jmpSt_whiteKingSquare = whiteKingSquare; jmpSt_blackKingSquare = blackKingSquare; jmpSt_enPassantSquare = enPassantSquare; jmpSt_happenedHalfMoves = happenedHalfMoves; jmpSt_fiftyMoveRuleCounter = fiftyMoveRuleCounter; jmpSt_whiteCastleRightKingSide = whiteCastleRightKingSide; jmpSt_whiteCastleRightQueenSide = whiteCastleRightQueenSide; jmpSt_blackCastleRightKingSide = blackCastleRightKingSide; jmpSt_blackCastleRightQueenSide = blackCastleRightQueenSide; jmpSt_isWhiteToMove = isWhiteToMove; jmpSt_curSearchZobristKeyLine = (ulong[])curSearchZobristKeyLine.Clone(); jmpSt_moveHashList = moveHashList.ToArray(); } private int PreMinimaxCheckCheckWhite() { ulong bitShiftedKingPos = 1ul << whiteKingSquare; int curR = -1; for (int p = 0; p < 64; p++) { if (ULONG_OPERATIONS.IsBitZero(blackPieceBitboard, p)) continue; int tPT; switch (tPT = pieceTypeArray[p]) { case 1: if ((bitShiftedKingPos & blackPawnAttackSquareBitboards[p]) != 0ul) return p; break; case 2: if ((bitShiftedKingPos & knightSquareBitboards[p]) != 0ul) return p; break; case 6: break; default: if ((squareConnectivesPrecalculationLineArray[whiteKingSquare << 6 | p] & allPieceBitboard) == (1ul << p) && pieceTypeAbilities[tPT, squareConnectivesPrecalculationArray[whiteKingSquare << 6 | p]]) { if (curR != -1) return -779; curR = p; } break; } } return curR; } private int PreMinimaxCheckCheckBlack() { ulong bitShiftedKingPos = 1ul << blackKingSquare; int curR = -1; for (int p = 0; p < 64; p++) { if (ULONG_OPERATIONS.IsBitZero(whitePieceBitboard, p)) continue; int tPT; switch (tPT = pieceTypeArray[p]) { case 1: if ((bitShiftedKingPos & whitePawnAttackSquareBitboards[p]) != 0ul) return p; break; case 2: if ((bitShiftedKingPos & knightSquareBitboards[p]) != 0ul) return p; break; case 6: break; default: if ((squareConnectivesPrecalculationLineArray[blackKingSquare << 6 | p] & allPieceBitboard) == (1ul << p) && pieceTypeAbilities[tPT, squareConnectivesPrecalculationArray[blackKingSquare << 6 | p]]) { if (curR != -1) return -779; curR = p; } break; } } return curR; } private int LecacyLeafCheckingPieceCheckWhite(int pStartPos, int pEndPos, int pPieceType) { int tI, tPossibleAttackPiece; if (pPieceType == 1) { if (ULONG_OPERATIONS.IsBitOne(blackPawnAttackSquareBitboards[pEndPos], whiteKingSquare)) return pEndPos; } else if (pPieceType == 2) { if (ULONG_OPERATIONS.IsBitOne(knightSquareBitboards[pEndPos], whiteKingSquare)) return pEndPos; } else if (pPieceType != 6) { tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | pEndPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; } tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | pStartPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; return -1; } private int LecacyLeafCheckingPieceCheckBlack(int pStartPos, int pEndPos, int pPieceType) { int tI, tPossibleAttackPiece; if (pPieceType == 1) { if (ULONG_OPERATIONS.IsBitOne(whitePawnAttackSquareBitboards[pEndPos], blackKingSquare)) return pEndPos; } else if (pPieceType == 2) { if (ULONG_OPERATIONS.IsBitOne(knightSquareBitboards[pEndPos], blackKingSquare)) return pEndPos; } else if (pPieceType != 6) { tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | pEndPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; } tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | pStartPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; return -1; } public void GetLegalMoves(ref List<Move> pMoveList) { int attk; if (isWhiteToMove) { attk = PreMinimaxCheckCheckWhite(); if (attk == -779) GetLegalWhiteMovesSpecialDoubleCheckCase(ref pMoveList); else GetLegalWhiteMoves(attk, ref pMoveList); } else { attk = PreMinimaxCheckCheckBlack(); if (attk == -779) GetLegalBlackMovesSpecialDoubleCheckCase(ref pMoveList); else GetLegalBlackMoves(attk, ref pMoveList); } } private void GetLegalWhiteMoves(int pCheckingPieceSquare, ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= blackPawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, whiteKingSquare); if (curCheckCount == 0) { if (whiteCastleRightKingSide && ((allPieceBitboard | oppAttkBitboard) & WHITE_KING_ROCHADE) == 0ul) pMoveList.Add(mWHITE_KING_ROCHADE); if (whiteCastleRightQueenSide && (allPieceBitboard & WHITE_QUEEN_ROCHADE | oppAttkBitboard & WHITE_QUEEN_ATTK_ROCHADE) == 0ul) pMoveList.Add(mWHITE_QUEEN_ROCHADE); if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, whitePieceBitboard, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[whiteKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare + 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, whitePieceBitboard, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveList(whiteKingSquare, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalWhiteCaptures(int pCheckingPieceSquare, ref List<Move> pMoveList) { if (pCheckingPieceSquare == -779) { GetLegalWhiteCapturesSpecialDoubleCheckCase(ref pMoveList); return; } moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= blackPawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, whiteKingSquare); if (curCheckCount == 0) { if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & blackPieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[whiteKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare + 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & blackPieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveListOnlyCaptures(whiteKingSquare, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalWhiteMovesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= blackPawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveList(whiteKingSquare, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalWhiteCapturesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= blackPawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveListOnlyCaptures(whiteKingSquare, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalBlackMoves(int pCheckingPieceSquare, ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= whitePawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, blackKingSquare); if (curCheckCount == 0) { if (blackCastleRightKingSide && ((allPieceBitboard | oppAttkBitboard) & BLACK_KING_ROCHADE) == 0ul) pMoveList.Add(mBLACK_KING_ROCHADE); if (blackCastleRightQueenSide && (allPieceBitboard & BLACK_QUEEN_ROCHADE | oppAttkBitboard & BLACK_QUEEN_ATTK_ROCHADE) == 0ul) pMoveList.Add(mBLACK_QUEEN_ROCHADE); if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveList(p, blackKingSquare, blackPieceBitboard, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[blackKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare - 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveList(p, blackKingSquare, blackPieceBitboard, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveList(blackKingSquare, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); } private void GetLegalBlackCaptures(int pCheckingPieceSquare, ref List<Move> pMoveList) { if (pCheckingPieceSquare == -779) { GetLegalBlackCapturesSpecialDoubleCheckCase(ref pMoveList); return; } moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= whitePawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, blackKingSquare); if (curCheckCount == 0) { if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & whitePieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[blackKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare - 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & whitePieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveListOnlyCaptures(blackKingSquare, ~oppAttkBitboard & whitePieceBitboard); } private void GetLegalBlackMovesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= whitePawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveList(blackKingSquare, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); } private void GetLegalBlackCapturesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= whitePawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveListOnlyCaptures(blackKingSquare, ~oppAttkBitboard & whitePieceBitboard); } public Move GetMoveOfString(string pMove) { int tSP, tEP; string[] tSpl = pMove.Split(','); if (Char.IsNumber(pMove[0])) { tSP = Convert.ToInt32(tSpl[0]); tEP = Convert.ToInt32(tSpl[1]); } else { tSP = SQUARES.NumberNotation(tSpl[0]); tEP = SQUARES.NumberNotation(tSpl[1]); } int tPT = pieceTypeArray[tSP]; bool tIC = ULONG_OPERATIONS.IsBitOne(allPieceBitboard, tEP), tIEP = enPassantSquare == tEP && tPT == 1; if (tSpl.Length == 3) return new Move(tSP, tEP, tPT, Convert.ToInt32(tSpl[2]), tIC); if (tIEP) return new Move(true, tSP, tEP, isWhiteToMove ? tEP - 8 : tEP + 8); if (tPT == 1 && Math.Abs(tSP - tEP) > 11) return new Move(tSP, tEP, 1, false, isWhiteToMove ? tSP + 8 : tSP - 8); if (tPT == 6 && (Math.Abs(tSP - tEP) == 2 || Math.Abs(tSP - tEP) == 3)) { if (isWhiteToMove) return tEP == 6 ? mWHITE_KING_ROCHADE : mWHITE_QUEEN_ROCHADE; return tEP == 62 ? mBLACK_KING_ROCHADE : mBLACK_QUEEN_ROCHADE; } return new Move(tSP, tEP, tPT, tIC); } public void PlainMakeMove(string pMoveName) { PlainMakeMove(GetMoveOfString(pMoveName)); } public void PlainMakeMove(Move pMove) { lastMadeMove = pMove; if (isWhiteToMove) WhiteMakeMove(pMove); else BlackMakeMove(pMove); } public void WhiteMakeMove(Move pMove) { int tEndPos = pMove.endPos, tStartPos = pMove.startPos, tPieceType = pMove.pieceType, tPTI = pieceTypeArray[tEndPos]; fiftyMoveRuleCounter++; whitePieceBitboard ^= pMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey ^= blackTurnHash ^ enPassantSquareHashes[enPassantSquare] ^ pieceHashesWhite[tStartPos, tPieceType] ^ pieceHashesWhite[tEndPos, tPieceType]; enPassantSquare = 65; isWhiteToMove = false; switch (pMove.moveTypeID) { case 0: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 1: fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 2: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 3: whiteKingSquare = tEndPos; if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 4: if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 5: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 6: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 7: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[whiteKingSquare = tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 8: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 9: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = pMove.enPassantOption]; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 11: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; whiteKingSquare = tEndPos; pieceTypeArray[pMove.rochadeEndPos] = 4; pieceTypeArray[pMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesWhite[pMove.rochadeStartPos, 4] ^ pieceHashesWhite[pMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 12: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[pMove.enPassantOption] = 0; zobristKey ^= pieceHashesBlack[pMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 13: fiftyMoveRuleCounter = 0; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; zobristKey ^= pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, pMove.promotionType]; break; case 14: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, tPTI] ^ pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, pMove.promotionType]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; } moveHashList.Add(pMove.moveHash); if (pMove.isCapture || tPieceType == 1) { curSearchZobristKeyLine = Array.Empty<ulong>(); return; } ulong[] u = new ulong[(tPTI = curSearchZobristKeyLine.Length) + 1]; for (int i = tPTI; i-- > 0;) u[i] = curSearchZobristKeyLine[i]; u[tPTI] = zobristKey; curSearchZobristKeyLine = u; } public void BlackMakeMove(Move pMove) { int tEndPos = pMove.endPos, tStartPos = pMove.startPos, tPieceType = pMove.pieceType, tPTI = pieceTypeArray[tEndPos]; fiftyMoveRuleCounter++; blackPieceBitboard ^= pMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey ^= blackTurnHash ^ enPassantSquareHashes[enPassantSquare] ^ pieceHashesBlack[tStartPos, tPieceType] ^ pieceHashesBlack[tEndPos, tPieceType]; enPassantSquare = 65; isWhiteToMove = true; switch (pMove.moveTypeID) { case 0: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 1: fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 2: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 3: blackKingSquare = tEndPos; if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 4: if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 5: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 6: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 7: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[blackKingSquare = tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 8: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 9: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = pMove.enPassantOption]; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 11: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; blackKingSquare = tEndPos; pieceTypeArray[pMove.rochadeEndPos] = 4; pieceTypeArray[pMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesBlack[pMove.rochadeStartPos, 4] ^ pieceHashesBlack[pMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 12: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[pMove.enPassantOption] = 0; zobristKey ^= pieceHashesWhite[pMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 13: fiftyMoveRuleCounter = 0; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, pMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 14: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } zobristKey ^= pieceHashesWhite[tEndPos, tPTI] ^ pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, pMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; } moveHashList.Add(pMove.moveHash); if (pMove.isCapture || tPieceType == 1) { curSearchZobristKeyLine = Array.Empty<ulong>(); return; } ulong[] u = new ulong[(tPTI = curSearchZobristKeyLine.Length) + 1]; for (int i = tPTI; i-- > 0;) u[i] = curSearchZobristKeyLine[i]; u[tPTI] = zobristKey; curSearchZobristKeyLine = u; } public void WhiteUndoMove(Move pMove) { } private const int WHITE_CHECKMATE_VAL = 100000, BLACK_CHECKMATE_VAL = -100000, CHECK_EXTENSION_LENGTH = -12, MAX_QUIESCENCE_TOTAL_LENGTH = -32; private readonly Move NULL_MOVE = new Move(0, 0, 0); private int curSearchDepth = 0, curSubSearchDepth = -1; public int MinimaxRoot(long pTime) { evalCount = 0; searches++; int baseLineLen = 0; long tTimestamp = globalTimer.ElapsedTicks + pTime; ClearHeuristics(); transpositionTable.Clear(); ulong[] tZobristKeyLine = Array.Empty<ulong>(); if (curSearchZobristKeyLine != null) { baseLineLen = curSearchZobristKeyLine.Length; tZobristKeyLine = new ulong[baseLineLen]; Array.Copy(curSearchZobristKeyLine, tZobristKeyLine, baseLineLen); } int perftScore, tattk = isWhiteToMove ? PreMinimaxCheckCheckWhite() : PreMinimaxCheckCheckBlack(), pDepth = 1; (string, int) bookMoveTuple = TLMDatabase.SearchForNextBookMove(moveHashList); if (bookMoveTuple.Item2 != 0) { int actualMoveHash = NuCRe.GetNumber(bookMoveTuple.Item1); List<Move> tMoves = new List<Move>(); GetLegalMoves(ref tMoves); int tL = tMoves.Count; for (int i = 0; i < tL; i++) { if (tMoves[i].moveHash == actualMoveHash) { if (debugSearchDepthResults) { SNAPSHOT_WRITLINE_REPLACEMENT("TLM_DB_Count: " + bookMoveTuple.Item2); SNAPSHOT_WRITLINE_REPLACEMENT(">> " + tMoves[i]); } transpositionTable.Add(zobristKey, new TranspositionEntry(tMoves[i], Array.Empty<int>())); return 0; } } } do { curSearchDepth = pDepth; curSubSearchDepth = pDepth - 1; ulong[] completeZobristHistory = new ulong[baseLineLen + pDepth - CHECK_EXTENSION_LENGTH + 1]; for (int i = 0; i < baseLineLen; i++) completeZobristHistory[i] = curSearchZobristKeyLine[i]; curSearchZobristKeyLine = completeZobristHistory; if (isWhiteToMove) { if (tattk == -1) perftScore = MinimaxWhite(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); else perftScore = MinimaxWhite(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); } else { if (tattk == -1) perftScore = MinimaxBlack(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); else perftScore = MinimaxBlack(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); } if (debugSearchDepthResults && pTime != 1L) { int tNpS = Convert.ToInt32((double)evalCount * 10_000_000d /(double)(pTime - tTimestamp + globalTimer.ElapsedTicks)); int tSearchEval = perftScore; int timeForSearchSoFar = (int)((pTime - tTimestamp + globalTimer.ElapsedTicks) /10000d); Move tBestMove = transpositionTable[zobristKey].bestMove; SNAPSHOT_WRITLINE_REPLACEMENT((tSearchEval >= 0 ? "+": "") + tSearchEval); SNAPSHOT_WRITLINE_REPLACEMENT(" " + tBestMove + "  ["); SNAPSHOT_WRITLINE_REPLACEMENT("Depth = " + pDepth + ", "); SNAPSHOT_WRITLINE_REPLACEMENT("Evals = " + GetThreeDigitSeperatedInteger(evalCount) + ", "); SNAPSHOT_WRITLINE_REPLACEMENT("Time = " + GetThreeDigitSeperatedInteger(timeForSearchSoFar) + "ms, "); SNAPSHOT_WRITLINE_REPLACEMENT("NpS = " + GetThreeDigitSeperatedInteger(tNpS) + "]"); } pDepth++; } while (globalTimer.ElapsedTicks < tTimestamp && pDepth < 179); depths += pDepth - 1; BOT_MAIN.depthsSearched += pDepth - 1; BOT_MAIN.searchesFinished++; BOT_MAIN.evaluationsMade += evalCount; curSearchZobristKeyLine = tZobristKeyLine; return perftScore; } private int MinimaxWhite(int pPly, int pAlpha, int pBeta, int pDepth, int pRepetitionHistoryPly, int pCheckingSquare, Move pLastMove) { if (IsDrawByRepetition(pRepetitionHistoryPly - 4)) return 0; if ((pDepth <= 0 && pCheckingSquare == -1) || pDepth < CHECK_EXTENSION_LENGTH) return QuiescenceWhite(pPly, pAlpha, pBeta, pDepth - 1, pCheckingSquare, pLastMove); List<Move> moveOptionList = new List<Move>(); Move bestMove = NULL_MOVE; if (pLastMove.isPromotion && pLastMove.isCapture && pLastMove.startPos % 8 == pCheckingSquare % 8 && pLastMove.startPos == whiteKingSquare + 8 && (pLastMove.promotionType == 4 || pLastMove.promotionType == 5)) GetLegalWhiteMovesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalWhiteMoves(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tWhiteKingSquare = whiteKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1, curEval = BLACK_CHECKMATE_VAL - pDepth; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = true; double[] moveSortingArray = new double[molc]; int[] moveSortingArrayIndexes = new int[molc], thisSearchMoveSortingArrayForTransposEntry = new int[molc]; transpositionTable.TryGetValue(zobristKey, out TranspositionEntry transposEntry); if (transposEntry == null) { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; } } else { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove == transposEntry.bestMove) moveSortingArray[m] = BESTMOVE_SORT_VAL; else if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; if (transposEntry.moveGenOrderedEvalLength > m) moveSortingArray[m] -= transposEntry.moveGenOrderedEvals[m]; } } Array.Sort(moveSortingArray, moveSortingArrayIndexes); for (int m = 0; m < molc; m++) { int tActualIndex = moveSortingArrayIndexes[m]; Move curMove = moveOptionList[tActualIndex]; if (debugSortResults && pDepth == curSubSearchDepth) { SNAPSHOT_WRITLINE_REPLACEMENT(moveSortingArray[m] + " | "+ curMove); } int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; whitePieceBitboard = tWPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesWhite[tStartPos, tPieceType] ^ pieceHashesWhite[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 0: blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 1: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 2: blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 3: whiteKingSquare = tEndPos; if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 4: blackPieceBitboard = tBPB; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 5: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[whiteKingSquare = tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = curMove.enPassantOption]; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 11: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; whiteKingSquare = tEndPos; blackPieceBitboard = tBPB; pieceTypeArray[curMove.rochadeEndPos] = 4; pieceTypeArray[curMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesWhite[curMove.rochadeStartPos, 4] ^ pieceHashesWhite[curMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | curMove.rochadeEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << curMove.rochadeEndPos)) tCheckPos = curMove.rochadeEndPos; break; case 12: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesBlack[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 13: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; zobristKey ^= pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, curMove.promotionType]; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; case 14: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, tPTI] ^ pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, curMove.promotionType]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } curSearchZobristKeyLine[pRepetitionHistoryPly] = zobristKey; int tEval = MinimaxBlack(pPly + 1, pAlpha, pBeta, pDepth - 1, pRepetitionHistoryPly + 1, tCheckPos, curMove); thisSearchMoveSortingArrayForTransposEntry[tActualIndex] = tEval; pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 3: whiteKingSquare = tWhiteKingSquare; break; case 7: whiteKingSquare = tWhiteKingSquare; break; case 10: enPassantSquare = 65; break; case 11: whiteKingSquare = tWhiteKingSquare; pieceTypeArray[curMove.rochadeStartPos] = 4; pieceTypeArray[curMove.rochadeEndPos] = 0; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 13: pieceTypeArray[tStartPos] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval > curEval) { bestMove = curMove; curEval = tEval; } if (pAlpha < curEval) pAlpha = curEval; if (curEval >= pBeta) { if (!curMove.isCapture) { killerMoveHeuristic[curMove.moveHash] = true; if (pDepth > 0) historyHeuristic[curMove.moveHash] += pDepth * pDepth; } break; } } isWhiteToMove = true; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; if (molc == 0 && pCheckingSquare == 0) curEval = 0; if (!transpositionTable.ContainsKey(zobristKey)) transpositionTable.Add(zobristKey, new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry)); else transpositionTable[zobristKey] = new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry); return curEval; } private int QuiescenceWhite(int pPly, int pAlpha, int pBeta, int pDepth, int pCheckingSquare, Move pLastMove) { int standPat = TexelEvaluate(); if (standPat >= pBeta || pDepth < MAX_QUIESCENCE_TOTAL_LENGTH) return pBeta; if (standPat > pAlpha) pAlpha = standPat; List<Move> moveOptionList = new List<Move>(); if (pLastMove.isPromotion && pLastMove.isCapture && pLastMove.startPos % 8 == pCheckingSquare % 8 && pLastMove.startPos == whiteKingSquare + 8 && (pLastMove.promotionType == 4 || pLastMove.promotionType == 5)) GetLegalWhiteCapturesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalWhiteCaptures(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tWhiteKingSquare = whiteKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = true; for (int m = 0; m < molc; m++) { Move curMove = moveOptionList[m]; int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; whitePieceBitboard = tWPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesWhite[tStartPos, tPieceType] ^ pieceHashesWhite[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 5: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[whiteKingSquare = tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 12: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesBlack[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 14: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, tPTI] ^ pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, curMove.promotionType]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } int tEval = QuiescenceBlack(pPly + 1, pAlpha, pBeta, pDepth - 1, tCheckPos, curMove); pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 7: whiteKingSquare = tWhiteKingSquare; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval >= pBeta) return pBeta; if (pAlpha < tEval) pAlpha = tEval; } isWhiteToMove = true; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; return pAlpha; } private int MinimaxBlack(int pPly, int pAlpha, int pBeta, int pDepth, int pRepetitionHistoryPly, int pCheckingSquare, Move pLastMove) { if (IsDrawByRepetition(pRepetitionHistoryPly - 4)) return 0; if ((pDepth <= 0 && pCheckingSquare == -1) || pDepth < CHECK_EXTENSION_LENGTH) return QuiescenceBlack(pPly, pAlpha, pBeta, pDepth - 1, pCheckingSquare, pLastMove); List<Move> moveOptionList = new List<Move>(); Move bestMove = NULL_MOVE; if (pLastMove.isPromotion && pLastMove.isCapture && pLastMove.startPos % 8 == pCheckingSquare % 8 && pLastMove.startPos == blackKingSquare - 8 && (pLastMove.promotionType == 4 || pLastMove.promotionType == 5)) GetLegalBlackMovesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalBlackMoves(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tBlackKingSquare = blackKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1, curEval = WHITE_CHECKMATE_VAL + pDepth; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = false; double[] moveSortingArray = new double[molc]; int[] moveSortingArrayIndexes = new int[molc], thisSearchMoveSortingArrayForTransposEntry = new int[molc]; transpositionTable.TryGetValue(zobristKey, out TranspositionEntry transposEntry); if (transposEntry == null) { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; } } else { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove == transposEntry.bestMove) moveSortingArray[m] = BESTMOVE_SORT_VAL; else if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; if (transposEntry.moveGenOrderedEvalLength > m) moveSortingArray[m] -= transposEntry.moveGenOrderedEvals[m]; } } Array.Sort(moveSortingArray, moveSortingArrayIndexes); for (int m = 0; m < molc; m++) { int tActualIndex = moveSortingArrayIndexes[m]; Move curMove = moveOptionList[tActualIndex]; if (debugSortResults && pDepth == curSearchDepth) { SNAPSHOT_WRITLINE_REPLACEMENT("=== " + moveSortingArray[m] + " | "+ curMove); } int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; blackPieceBitboard = tBPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesBlack[tStartPos, tPieceType] ^ pieceHashesBlack[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 0: whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 1: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 2: whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 3: blackKingSquare = tEndPos; if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 4: whitePieceBitboard = tWPB; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 5: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[blackKingSquare = tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = curMove.enPassantOption]; whitePieceBitboard = tWPB; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 11: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; blackKingSquare = tEndPos; whitePieceBitboard = tWPB; pieceTypeArray[curMove.rochadeEndPos] = 4; pieceTypeArray[curMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesBlack[curMove.rochadeStartPos, 4] ^ pieceHashesBlack[curMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | curMove.rochadeEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << curMove.rochadeEndPos)) tCheckPos = curMove.rochadeEndPos; break; case 12: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesWhite[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 13: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, curMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; case 14: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } zobristKey ^= pieceHashesWhite[tEndPos, tPTI] ^ pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, curMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } curSearchZobristKeyLine[pRepetitionHistoryPly] = zobristKey; int tEval = MinimaxWhite(pPly + 1, pAlpha, pBeta, pDepth - 1, pRepetitionHistoryPly + 1, tCheckPos, curMove); thisSearchMoveSortingArrayForTransposEntry[tActualIndex] = tEval; pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 3: blackKingSquare = tBlackKingSquare; break; case 7: blackKingSquare = tBlackKingSquare; break; case 10: enPassantSquare = 65; break; case 11: blackKingSquare = tBlackKingSquare; pieceTypeArray[curMove.rochadeStartPos] = 4; pieceTypeArray[curMove.rochadeEndPos] = 0; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 13: pieceTypeArray[tStartPos] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval < curEval) { bestMove = curMove; curEval = tEval; } if (pBeta > curEval) pBeta = curEval; if (curEval <= pAlpha) { if (!curMove.isCapture) { killerMoveHeuristic[curMove.moveHash] = true; if (pDepth > 0) historyHeuristic[curMove.moveHash] += pDepth * pDepth; } break; } } isWhiteToMove = false; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; if (molc == 0 && pCheckingSquare == 0) curEval = 0; if (!transpositionTable.ContainsKey(zobristKey)) transpositionTable.Add(zobristKey, new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry)); else transpositionTable[zobristKey] = new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry); return curEval; } private int QuiescenceBlack(int pPly, int pAlpha, int pBeta, int pDepth, int pCheckingSquare, Move pLastMove) { int standPat = TexelEvaluate(); if (standPat <= pAlpha || pDepth < MAX_QUIESCENCE_TOTAL_LENGTH) return pAlpha; if (standPat < pBeta) pBeta = standPat; List<Move> moveOptionList = new List<Move>(); if (pLastMove.isPromotion && pLastMove.isCapture && pLastMove.startPos % 8 == pCheckingSquare % 8 && pLastMove.startPos == blackKingSquare - 8 && (pLastMove.promotionType == 4 || pLastMove.promotionType == 5)) GetLegalBlackCapturesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalBlackCaptures(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tBlackKingSquare = blackKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = false; for (int m = 0; m < molc; m++) { Move curMove = moveOptionList[m]; int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; blackPieceBitboard = tBPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesBlack[tStartPos, tPieceType] ^ pieceHashesBlack[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 5: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[blackKingSquare = tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 12: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesWhite[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 14: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } zobristKey ^= pieceHashesWhite[tEndPos, tPTI] ^ pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, curMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } int tEval = QuiescenceWhite(pPly + 1, pAlpha, pBeta, pDepth - 1, tCheckPos, curMove); pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 7: blackKingSquare = tBlackKingSquare; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval <= pAlpha) return pAlpha; if (pBeta > tEval) pBeta = tEval; } isWhiteToMove = false; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; return pBeta; } private bool[] killerMoveHeuristic = new bool[262_144]; private int[] historyHeuristic = new int[262_144]; public void ClearHeuristics() { for (int i = 0; i < 262_144; i++) { killerMoveHeuristic[i] = false; historyHeuristic[i] = 0; } } private Dictionary<ulong, TranspositionEntry> transpositionTable = new Dictionary<ulong, TranspositionEntry>(); private int[] pieceEvals = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[,][] piecePositionEvals = new int[33, 14][]; private int evalCount = 0; private int Evaluate() { evalCount++; if (fiftyMoveRuleCounter > 99) return 0; int tEval = 0, tPT, pieceCount = ULONG_OPERATIONS.CountBits(allPieceBitboard); for (int p = 0; p < 64; p++) tEval += pieceEvals[tPT = pieceTypeArray[p] + 7 * ((int)(blackPieceBitboard >> p) & 1)] + piecePositionEvals[pieceCount, tPT][p]; return tEval; } public int GameState(bool pWhiteKingCouldBeAttacked) { if (IsDrawByRepetition(curSearchZobristKeyLine.Length - 5) || fiftyMoveRuleCounter > 99) return 0; int t; List<Move> tMoves = new List<Move>(); GetLegalMoves(ref tMoves); if (pWhiteKingCouldBeAttacked) { t = PreMinimaxCheckCheckWhite(); if (t == -1) return tMoves.Count == 0 ? 0 : 3; else if (tMoves.Count == 0) return -1; } else { t = PreMinimaxCheckCheckBlack(); if (t == -1) return tMoves.Count == 0 ? 0 : 3; else if (tMoves.Count == 0) return 1; } return 3; } private bool IsDrawByRepetition(int pPlyOfFirstPossibleRepeatedPosition) { int tC = 0; for (int i = pPlyOfFirstPossibleRepeatedPosition; i >= 0; i -= 2) { if (curSearchZobristKeyLine[i] == zobristKey) if (++tC == 2) return true; } return false; } private const int RELE_MAX_MOVE_COUNT_PER_GAME = 500; public double ReLePlayGame(int[,][] pEvalPositionValuesWhite, int[,][] pEvalPositionValuesBlack, long thinkingTimePerMove) { int[,][] processedValuesWhite = InitReLeAgent(pEvalPositionValuesWhite), processedValuesBlack = InitReLeAgent(pEvalPositionValuesBlack); int tGS, mc = 0; do { if (IsDrawByRepetition(curSearchZobristKeyLine.Length - 5)) return 0d; piecePositionEvals = isWhiteToMove ? processedValuesWhite : processedValuesBlack; MinimaxRoot(thinkingTimePerMove); if (transpositionTable.Count == 0) { SNAPSHOT_WRITLINE_REPLACEMENT("?!"); return 0d; } PlainMakeMove(transpositionTable[zobristKey].bestMove); tGS = GameState(isWhiteToMove); transpositionTable.Clear(); if (tGS != 3) break; } while (mc++ < RELE_MAX_MOVE_COUNT_PER_GAME); if (tGS == 3 || tGS == 0) return 0d; else if (tGS == 1) return 0.1d * (double)(RELE_MAX_MOVE_COUNT_PER_GAME - mc); return 0.1d * (double)(-RELE_MAX_MOVE_COUNT_PER_GAME + mc); } public int[,][] InitReLeAgent(int[,][] pEvalPositionValues) { return GetInterpolatedProcessedValues(pEvalPositionValues); } private int[,][] GetInterpolatedProcessedValues(int[,][] pEvalPositionValues) { int[,][] processedValues = new int[33, 14][]; for (int i = 0; i < 32; i++) { int ip1 = i + 1; processedValues[ip1, 7] = processedValues[ip1, 0] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; processedValues[ip1, 8] = SwapArrayViewingSide(processedValues[ip1, 1] = MultiplyArraysWithVal(pEvalPositionValues[0, 0], pEvalPositionValues[1, 0], pEvalPositionValues[2, 0], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 9] = SwapArrayViewingSide(processedValues[ip1, 2] = MultiplyArraysWithVal(pEvalPositionValues[0, 1], pEvalPositionValues[1, 1], pEvalPositionValues[2, 1], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 10] = SwapArrayViewingSide(processedValues[ip1, 3] = MultiplyArraysWithVal(pEvalPositionValues[0, 2], pEvalPositionValues[1, 2], pEvalPositionValues[2, 2], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 11] = SwapArrayViewingSide(processedValues[ip1, 4] = MultiplyArraysWithVal(pEvalPositionValues[0, 3], pEvalPositionValues[1, 3], pEvalPositionValues[2, 3], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 12] = SwapArrayViewingSide(processedValues[ip1, 5] = MultiplyArraysWithVal(pEvalPositionValues[0, 4], pEvalPositionValues[1, 4], pEvalPositionValues[2, 4], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 13] = SwapArrayViewingSide(processedValues[ip1, 6] = MultiplyArraysWithVal(pEvalPositionValues[0, 5], pEvalPositionValues[1, 5], pEvalPositionValues[2, 5], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); } return processedValues; } private double[,][] GetInterpolatedProcessedValues(double[,][] pEvalPositionValues) { double[,][] processedValues = new double[33, 14][]; for (int i = 0; i < 32; i++) { int ip1 = i + 1; processedValues[ip1, 7] = processedValues[ip1, 0] = new double[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; processedValues[ip1, 8] = SwapArrayViewingSide(processedValues[ip1, 1] = MultiplyArraysWithVal(pEvalPositionValues[0, 0], pEvalPositionValues[1, 0], pEvalPositionValues[2, 0], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 9] = SwapArrayViewingSide(processedValues[ip1, 2] = MultiplyArraysWithVal(pEvalPositionValues[0, 1], pEvalPositionValues[1, 1], pEvalPositionValues[2, 1], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 10] = SwapArrayViewingSide(processedValues[ip1, 3] = MultiplyArraysWithVal(pEvalPositionValues[0, 2], pEvalPositionValues[1, 2], pEvalPositionValues[2, 2], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 11] = SwapArrayViewingSide(processedValues[ip1, 4] = MultiplyArraysWithVal(pEvalPositionValues[0, 3], pEvalPositionValues[1, 3], pEvalPositionValues[2, 3], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 12] = SwapArrayViewingSide(processedValues[ip1, 5] = MultiplyArraysWithVal(pEvalPositionValues[0, 4], pEvalPositionValues[1, 4], pEvalPositionValues[2, 4], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 13] = SwapArrayViewingSide(processedValues[ip1, 6] = MultiplyArraysWithVal(pEvalPositionValues[0, 5], pEvalPositionValues[1, 5], pEvalPositionValues[2, 5], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); } return processedValues; } private double[] MultiplyArraysWithVal(double[] pArr1, double[] pArr2, double[] pArr3, double pVal1, double pVal2, double pVal3) { int tL = pArr1.Length; double[] rArr = new double[tL]; for (int i = 0; i < tL; i++) { rArr[i] = pArr1[i] * pVal1 + pArr2[i] * pVal2 + pArr3[i] * pVal3; } return rArr; } private int[] MultiplyArraysWithVal(int[] pArr1, int[] pArr2, int[] pArr3, double pVal1, double pVal2, double pVal3) { int tL = pArr1.Length; int[] rArr = new int[tL]; for (int i = 0; i < tL; i++) { rArr[i] = (int)(pArr1[i] * pVal1 + pArr2[i] * pVal2 + pArr3[i] * pVal3); } return rArr; } private int[] SwapArrayViewingSideAndNegate(int[] pArr) { return new int[64] { -pArr[56], -pArr[57], -pArr[58], -pArr[59], -pArr[60], -pArr[61], -pArr[62], -pArr[63], -pArr[48], -pArr[49], -pArr[50], -pArr[51], -pArr[52], -pArr[53], -pArr[54], -pArr[55], -pArr[40], -pArr[41], -pArr[42], -pArr[43], -pArr[44], -pArr[45], -pArr[46], -pArr[47], -pArr[32], -pArr[33], -pArr[34], -pArr[35], -pArr[36], -pArr[37], -pArr[38], -pArr[39], -pArr[24], -pArr[25], -pArr[26], -pArr[27], -pArr[28], -pArr[29], -pArr[30], -pArr[31], -pArr[16], -pArr[17], -pArr[18], -pArr[19], -pArr[20], -pArr[21], -pArr[22], -pArr[23], -pArr[8], -pArr[9], -pArr[10], -pArr[11], -pArr[12], -pArr[13], -pArr[14], -pArr[15], -pArr[0], -pArr[1], -pArr[2], -pArr[3], -pArr[4], -pArr[5], -pArr[6], -pArr[7] }; } private int[] SwapArrayViewingSide(int[] pArr) { return new int[64] { pArr[56], pArr[57], pArr[58], pArr[59], pArr[60], pArr[61], pArr[62], pArr[63], pArr[48], pArr[49], pArr[50], pArr[51], pArr[52], pArr[53], pArr[54], pArr[55], pArr[40], pArr[41], pArr[42], pArr[43], pArr[44], pArr[45], pArr[46], pArr[47], pArr[32], pArr[33], pArr[34], pArr[35], pArr[36], pArr[37], pArr[38], pArr[39], pArr[24], pArr[25], pArr[26], pArr[27], pArr[28], pArr[29], pArr[30], pArr[31], pArr[16], pArr[17], pArr[18], pArr[19], pArr[20], pArr[21], pArr[22], pArr[23], pArr[8], pArr[9], pArr[10], pArr[11], pArr[12], pArr[13], pArr[14], pArr[15], pArr[0], pArr[1], pArr[2], pArr[3], pArr[4], pArr[5], pArr[6], pArr[7] }; } private double[] SwapArrayViewingSide(double[] pArr) { return new double[64] { pArr[56], pArr[57], pArr[58], pArr[59], pArr[60], pArr[61], pArr[62], pArr[63], pArr[48], pArr[49], pArr[50], pArr[51], pArr[52], pArr[53], pArr[54], pArr[55], pArr[40], pArr[41], pArr[42], pArr[43], pArr[44], pArr[45], pArr[46], pArr[47], pArr[32], pArr[33], pArr[34], pArr[35], pArr[36], pArr[37], pArr[38], pArr[39], pArr[24], pArr[25], pArr[26], pArr[27], pArr[28], pArr[29], pArr[30], pArr[31], pArr[16], pArr[17], pArr[18], pArr[19], pArr[20], pArr[21], pArr[22], pArr[23], pArr[8], pArr[9], pArr[10], pArr[11], pArr[12], pArr[13], pArr[14], pArr[15], pArr[0], pArr[1], pArr[2], pArr[3], pArr[4], pArr[5], pArr[6], pArr[7] }; } private int[,][] texelTuningRuntimeVals = new int[33, 14][]; private int[,][] texelTuningVals = new int[3, 6][]; private int[,] texelTuningAdjustIterations = new int[6, 64]; private int[][] texelTuningRuntimePositionalValsV2EG = new int[14][]; private int[][] texelTuningRuntimePositionalValsV2LG = new int[14][]; private int[] texelPieceEvaluationsV2EG = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[] texelPieceEvaluationsV2LG = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[] texelKingSafetyR1EvaluationsEG = new int[9]; private int[] texelKingSafetyR2EvaluationsEG = new int[17]; private int[] texelKingSafetyR1EvaluationsLG = new int[9]; private int[] texelKingSafetyR2EvaluationsLG = new int[17]; private int[] texelKingSafetySREvaluationsPT1EG = new int[12]; private int[] texelKingSafetySREvaluationsPT2EG = new int[12]; private int[] texelKingSafetySREvaluationsPT3EG = new int[12]; private int[] texelKingSafetySREvaluationsPT4EG = new int[12]; private int[] texelKingSafetySREvaluationsPT5EG = new int[12]; private int[] texelKingSafetySREvaluationsPT6EG = new int[12]; private int[] texelKingSafetySREvaluationsPT1LG = new int[12]; private int[] texelKingSafetySREvaluationsPT2LG = new int[12]; private int[] texelKingSafetySREvaluationsPT3LG = new int[12]; private int[] texelKingSafetySREvaluationsPT4LG = new int[12]; private int[] texelKingSafetySREvaluationsPT5LG = new int[12]; private int[] texelKingSafetySREvaluationsPT6LG = new int[12]; private int[,] texelMobilityStraightEG = new int[14, 15], texelMobilityStraightLG = new int[14, 15]; private int[,] texelMobilityDiagonalEG = new int[14, 14], texelMobilityDiagonalLG = new int[14, 14]; private int[] texelPieceEvaluations = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[] blackSidedSquares = new int[64] { 56, 57, 58, 59, 60, 61, 62, 63, 48, 49, 50, 51, 52, 53, 54, 55, 40, 41, 42, 43, 44, 45, 46, 47, 32, 33, 34, 35, 36, 37, 38, 39, 24, 25, 26, 27, 28, 29, 30, 31, 16, 17, 18, 19, 20, 21, 22, 23, 08, 09, 10, 11, 12, 13, 14, 15, 00, 01, 02, 03, 04, 05, 06, 07 }; private int[,] T_Pawns = new int[3, 64] { { 0, 0, 0, 0, 0, 0, 0, 0, 98, 134, 61, 95, 68, 126, 34, -11, -6, 7, 26, 31, 65, 56, 25, -20, -14, 13, 6, 21, 23, 12, 17, -23, -27, -2, -5, 12, 17, 6, 10, -25, -26, -4, -4, -10, 3, 3, 33, -12, -35, -1, -20, -23, -15, 24, 38, -22, 0, 0, 0, 0, 0, 0, 0, 0, } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { 0, 0, 0, 0, 0, 0, 0, 0, 178, 173, 158, 134, 147, 132, 165, 187, 94, 100, 85, 67, 56, 53, 82, 84, 32, 24, 13, 5, -2, 4, 17, 17, 13, 9, -3, -7, -7, -8, 3, -1, 4, 7, -6, 1, 0, -5, -1, -8, 13, 8, 8, 10, 13, 0, 2, -7, 0, 0, 0, 0, 0, 0, 0, 0, } }; private int[,] T_Knights = new int[3, 64] { { -167, -89, -34, -49, 61, -97, -15, -107, -73, -41, 72, 36, 23, 62, 7, -17, -47, 60, 37, 65, 84, 129, 73, 44, -9, 17, 19, 53, 37, 69, 18, 22, -13, 4, 16, 13, 28, 19, 21, -8, -23, -9, 12, 10, 19, 17, 25, -16, -29, -53, -12, -3, -1, 18, -14, -19, -105, -21, -58, -33, -17, -28, -19, -23 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -58, -38, -13, -28, -31, -27, -63, -99, -25, -8, -25, -2, -9, -25, -24, -52, -24, -20, 10, 9, -1, -9, -19, -41, -17, 3, 22, 22, 22, 11, 8, -18, -18, -6, 16, 25, 16, 17, 4, -18, -23, -3, -1, 15, 10, -3, -20, -22, -42, -20, -10, -5, -2, -20, -23, -44, -29, -51, -23, -15, -22, -18, -50, -64 } }; private int[,] T_Bishops = new int[3, 64] { { -29, 4, -82, -37, -25, -42, 7, -8, -26, 16, -18, -13, 30, 59, 18, -47, -16, 37, 43, 40, 35, 50, 37, -2, -4, 5, 19, 50, 37, 37, 7, -2, -6, 13, 13, 26, 34, 12, 10, 4, 0, 15, 15, 15, 14, 27, 18, 10, 4, 15, 16, 0, 7, 21, 33, 1, -33, -3, -14, -21, -13, -12, -39, -21 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -14, -21, -11, -8, -7, -9, -17, -24, -8, -4, 7, -12, -3, -13, -4, -14, 2, -8, 0, -1, -2, 6, 0, 4, -3, 9, 12, 9, 14, 10, 3, 2, -6, 3, 13, 19, 7, 10, -3, -9, -12, -3, 8, 10, 13, 3, -7, -15, -14, -18, -7, -1, 4, -9, -15, -27, -23, -9, -23, -5, -9, -16, -5, -17 } }; private int[,] T_Rooks = new int[3, 64] { { 32, 42, 32, 51, 63, 9, 31, 43, 27, 32, 58, 62, 80, 67, 26, 44, -5, 19, 26, 36, 17, 45, 61, 16, -24, -11, 7, 26, 24, 35, -8, -20, -36, -26, -12, -1, 9, -7, 6, -23, -45, -25, -16, -17, 3, 0, -5, -33, -44, -16, -20, -9, -1, 11, -6, -71, -19, -13, 1, 17, 16, 7, -37, -26 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { 13, 10, 18, 15, 12, 12, 8, 5, 11, 13, 13, 11, -3, 3, 8, 3, 7, 7, 7, 5, 4, -3, -5, -3, 4, 3, 13, 1, 2, 1, -1, 2, 3, 5, 8, 4, -5, -6, -8, -11, -4, 0, -5, -1, -7, -12, -8, -16, -6, -6, 0, 2, -9, -9, -11, -3, -9, 2, 3, -1, -5, -13, 4, -20 } }; private int[,] T_Queens = new int[3, 64] { { -28, 0, 29, 12, 59, 44, 43, 45, -24, -39, -5, 1, -16, 57, 28, 54, -13, -17, 7, 8, 29, 56, 47, 57, -27, -27, -16, -16, -1, 17, -2, 1, -9, -26, -9, -10, -2, -4, 3, -3, -14, 2, -11, -2, -5, 2, 14, 5, -35, -8, 11, 2, 8, 15, -3, 1, -1, -18, -9, 10, -15, -25, -31, -50 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -9, 22, 22, 27, 27, 19, 10, 20, -17, 20, 32, 41, 58, 25, 30, 0, -20, 6, 9, 49, 47, 35, 19, 9, 3, 22, 24, 45, 57, 40, 57, 36, -18, 28, 19, 47, 31, 34, 39, 23, -16, -27, 15, 6, 9, 17, 10, 5, -22, -23, -30, -16, -16, -23, -36, -32, -33, -28, -22, -43, -5, -32, -20, -41 } }; private int[,] T_Kings = new int[3, 64] { { -65, 23, 16, -15, -56, -34, 2, 13, 29, -1, -20, -7, -8, -4, -38, -29, -9, 24, 2, -16, -20, 6, 22, -22, -17, -20, -12, -27, -30, -25, -14, -36, -49, -1, -27, -39, -46, -44, -33, -51, -14, -14, -22, -46, -44, -30, -15, -27, 1, 7, -8, -64, -43, -16, 9, 8, -15, 36, 12, -54, 8, -28, 24, 14 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -74, -35, -18, -18, -11, 15, 4, -17, -12, 17, 14, 17, 17, 38, 23, 11, 10, 17, 23, 15, 20, 45, 44, 13, -8, 22, 24, 27, 26, 33, 26, 3, -18, -4, 21, 24, 27, 23, 9, -11, -19, -3, 11, 21, 23, 16, 7, -9, -27, -11, 4, 13, 14, 4, -5, -17, -53, -34, -21, -11, -28, -14, -24, -43 } }; private int[] paramsLowerLimits = new int[5] { -10000, -10000, -10000, -10000, -10000 }; private int[] paramsUpperLimits = new int[5] { 10000, 10000, 10000, 10000, 10000 }; private List<TLM_ChessGame> threadDataset; private int threadFrom, threadTo; private int[] threadParams; private int customThreadID = 0; private ulong ulAllThreadIDsUnfinished = 0; private double lastCostVal = 0d; private double sumCostVals = 0d; private int costCalculations = 0; private readonly string[] TEXELPRINT_GAMEPARTS = new string[3] { "Early Game: ", "Mid Game: ", "Late Game: "}; private readonly string[] TEXELPRINT_PIECES = new string[6] { "Bauer: ", "Springer: ", "Lufer: ", "Turm: ", "Dame: ", "Knig: "}; private double[] earlyGameMultipliers = new double[33]; private double[] middleGameMultipliers = new double[33]; private double[] lateGameMultipliers = new double[33]; private int[] pieceTypeGameProgressImpact = new int[14] { 0, 0, 1, 1, 2, 4, 0, 0, 0, 1, 1, 2, 4, 0 }; private void PrecalculateMultipliers() { if (BOARD_MANAGER_ID == ENGINE_VALS.PARALLEL_BOARDS - 1) SNAPSHOT_WRITLINE_REPLACEMENT(); for (int i = 0; i < 25; i++) { earlyGameMultipliers[i] = EGMultiplierFunction(i); lateGameMultipliers[i] = LGMultiplierFunction(i); if (BOARD_MANAGER_ID == ENGINE_VALS.PARALLEL_BOARDS - 1) SNAPSHOT_WRITLINE_REPLACEMENT("[" + i + "] "+ earlyGameMultipliers[i] + " | "+ middleGameMultipliers[i] + " | "+ lateGameMultipliers[i]); } } private double MultiplierFunction(double pVal, double pXShift) { double d = Math.Exp(1d /6d * (pVal - pXShift)); return 5 * (d /Math.Pow(d + 1, 2d)); } private double EGMultiplierFunction(double pVal) { return Math.Clamp(1 /16d * (pVal - 4d), 0d, 1d); } private double LGMultiplierFunction(double pVal) { return Math.Clamp(1 /-16d * (pVal - 4d) + 1d, 0d, 1d); } private double EGMultiplierFunction2(double pVal) { return Math.Clamp(1 /32d * pVal, 0d, 1d); } private double LGMultiplierFunction2(double pVal) { return Math.Clamp(1 /-32d * pVal + 1d, 0d, 1d); } private void TuneWithTxtFile(string pTXTName) { List<TLM_ChessGame> gameDataset = new List<TLM_ChessGame>(); string tPath = PathManager.GetTXTPath(pTXTName); string[] tStrs = File.ReadAllLines(tPath); List<string> tGames = new List<string>(); foreach (string s in tStrs) if (s.Contains(';') && s.Replace(" ", "") != "") tGames.Add(s); foreach (string s in tGames) { TLM_ChessGame tGame = CGFF.GetGame(s); LoadFenString(tGame.startFen); foreach (int hMove in tGame.hashedMoves) { List<Move> moveOptionList = new List<Move>(); GetLegalMoves(ref moveOptionList); int tL = moveOptionList.Count; for (int j = 0; j < tL; j++) { Move tMove = moveOptionList[j]; if (tMove.moveHash == hMove) { tGame.actualMoves.Add(tMove); PlainMakeMove(tMove); tL = -1; break; } } if (tL != -1) break; } gameDataset.Add(tGame); } SNAPSHOT_WRITLINE_REPLACEMENT("[TLM TEXEL TUNER] " + tGames.Count + " Games Loaded In!"); BOT_MAIN.curTEXELPARAMS = new int[TEXEL_PARAMS]; BOT_MAIN.ParallelTexelTuning(gameDataset); } private void LoadBestTexelParamsIn() { int[] ttt = new int[778] { 72, 300, 484, 528, 904, 128, 272, 280, 504, 720, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -56, 88, -92, -200, 56, -40, -48, -148, -100, 96, -32, -100, 8, -28, -8, 32, -64, -200, 44, -184, 12, -8, 96, -200, -16, -104, -40, 40, 24, -134, -136, -8, -16, 80, -8, -32, 136, -120, -12, -136, -16, 20, -136, 68, 32, -200, 0, 88, -176, 128, -72, 128, 88, -200, 104, -200, 124, 40, 64, 84, 8, -124, -48, 128, 100, -36, -32, -32, -64, 200, -200, 200, 200, -200, 8, 156, -20, 76, 72, 200, 196, 200, 200, 200, -66, 8, 200, 200, -200, 200, -200, 200, 56, 200, -200, 200, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -200, -200, -28, 200, -200, -22, 200, 192, 172, 200, 12, 120, 12, -200, -200, 200, 18, -194, 200, -200, 46, -168, 52, 200, 176, 56, -56, 200, -40, 32, 8, 200, 70, -176, -112, 200, 168, -48, 192, 76, 192, -72, 136, 46, 64, -200, -24, -200, 172, -200, -200, 88, 24, 200, 112, -68, 200, 200, 168, -120, 200, -88, -12, 200, 76, 40, 56, 200, 200, 200, 64, -200, 138, -56, 200, -16, 96, 136, 200, -112, 200, 200, 200, 200, 101, -200, 176, 200, -200, 200, 120, -200, 54, -128, 200, -24, -200, 200, 200, -72, 200, 200, 200, 200, -200, -200, 176, -200, 80, 176, 200, -24, 112, -200, 200, 200, -200, -200, -200, 128, -200, 112, -200, -200, 200, -200, 16, -200, 16, -80, -200, 184, -8, 200, -32, -200, -176, -200, -56, 200, 56, 200, -104, -152, -200, 200, 32, 200, 112, 8, -24, 160, 92, -76, -120, -200, 64, -200, 200, -200, 32, 136, -140, -144, 24, 8, 16, 200, 132, 24, 40, -24, -62, -200, 200, -15, -8, -116, 148, 200, -76, 200, 200, -200, 96, -200, 8, 200, -148, -200, -200, 188, 200, 86, 64, 80, -180, -200, 64, 200, 200, 200, -200, -132, 184, -184, 200, -156, -136, -200, 200, -104, -184, 60, -200, -184, -32, 0, -169, 96, 200, 200, 200, 200, 200, 200, -200, -200, 200, -200, -200, 68, -200, -200, 200, 200, -200, 176, -200, 200, -56, 200, -200, 152, -200, -168, -46, -200, 200, -200, -200, 192, -200, 68, -200, -200, -16, 16, 4, 200, -168, 112, 176, -200, 92, -128, -200, 16, 34, 144, -68, 24, -40, -200, -64, 40, -128, 152, 48, -24, -200, -35, 200, -56, -88, 4, -96, 128, 200, -200, 200, -100, 200, -80, 32, -172, 200, -200, -40, -200, -78, 200, 96, -24, -26, 200, 80, -32, 200, -76, 200, 48, 200, -200, 16, -148, -200, -64, 32, -72, 120, -180, 200, 84, 200, 136, 200, 200, 200, 200, -52, 200, 72, 200, 200, -200, -64, 200, 200, -144, -136, 40, 200, -104, -8, 200, 88, -200, -173, -112, 200, -88, -40, 200, 32, -200, -200, 72, 200, 68, 200, -156, -200, -40, 128, 4, 144, -88, -200, 200, 174, -136, 200, -200, 184, -176, 200, -56, -200, 200, -200, -152, -200, 160, 200, -171, -96, -200, 88, 200, -62, 72, -200, -200, -200, 200, 194, -200, -200, -200, -140, 200, -32, 56, 88, 200, 200, 200, -53, -200, -38, -200, 84, -200, -200, 200, -8, 100, 3, -140, 38, 172, -48, 200, -20, -160, 80, -200, 200, -200, -200, 200, -200, -200, -56, -52, -72, -124, 80, 80, 88, -8, 104, -88, 104, 200, -24, -200, -8, -200, -80, 22, 164, 200, 152, 80, 104, -200, 88, -104, 200, 200, 25, 200, -112, -200, 56, -200, 200, 200, 100, -80, 176, 200, 200, 104, 200, 200, -200, -200, 24, 200, 200, 200, 200, -200, -200, -30, 200, 200, 200, 48, 200, 200, -76, -200, 200, -184, 200, 200, -200, -200, 174, 200, 108, 192, 128, 200, 80, 200, 200, 40, -200, -200, -48, -84, -88, 64, -24, -200, 8, -16, 160, -200, 176, -100, 200, 200, -200, -174, 48, -112, 72, 44, -136, -84, 44, -104, 64, -16, -96, 200, 64, -200, -200, 200, -200, 80, -200, 144, -200, 144, -192, 152, -104, 24, -200, 200, -200, -136, -8, -112, -200, -200, 200, 112, -200, 200, 48, 0, -200, 144, -200, -136, -48, 200, 200, -134, -200, -56, -200, -28, -192, -200, 200, 92, -200, 200, 134, 200, 200, 144, 200, -94, 200, 120, 200, 200, 200, 200, -200, -200, -200, 200, -200, 200, 200, -200, 200, 200, -197, 200, -200, 200, 197, 200, 200, 200, 0, 0, 200, -200, 200, 200, -200, -200, -200, 200, -200, -200, -200, 128, -200, -200, -200, -200, 0, -200, -200, -200 }; SetupTexelEvaluationParams(ttt); } private void SetupTexelEvaluationParams(int[] pParams) { texelPieceEvaluationsV2EG[8] = -(texelPieceEvaluationsV2EG[1] = pParams[0]); texelPieceEvaluationsV2EG[9] = -(texelPieceEvaluationsV2EG[2] = pParams[1]); texelPieceEvaluationsV2EG[10] = -(texelPieceEvaluationsV2EG[3] = pParams[2]); texelPieceEvaluationsV2EG[11] = -(texelPieceEvaluationsV2EG[4] = pParams[3]); texelPieceEvaluationsV2EG[12] = -(texelPieceEvaluationsV2EG[5] = pParams[4]); texelPieceEvaluationsV2LG[8] = -(texelPieceEvaluationsV2LG[1] = pParams[5]); texelPieceEvaluationsV2LG[9] = -(texelPieceEvaluationsV2LG[2] = pParams[6]); texelPieceEvaluationsV2LG[10] = -(texelPieceEvaluationsV2LG[3] = pParams[7]); texelPieceEvaluationsV2LG[11] = -(texelPieceEvaluationsV2LG[4] = pParams[8]); texelPieceEvaluationsV2LG[12] = -(texelPieceEvaluationsV2LG[5] = pParams[9]); int c = 10; for (int p = 1; p < 7; p++) { for (int s = 0; s < 64; s++) { texelTuningRuntimePositionalValsV2EG[p + 7][blackSidedSquares[s]] = -(texelTuningRuntimePositionalValsV2EG[p][s] = pParams[c++]); texelTuningRuntimePositionalValsV2LG[p + 7][blackSidedSquares[s]] = -(texelTuningRuntimePositionalValsV2LG[p][s] = pParams[c++]); } } return; for (int p = 2; p < 7; p++) { for (int a = 0; a < 15; a++) { if (a != 14) { texelMobilityDiagonalEG[p + 7, a] = -(texelMobilityDiagonalEG[p, a] = pParams[c++]); texelMobilityDiagonalLG[p + 7, a] = -(texelMobilityDiagonalLG[p, a] = pParams[c++]); } texelMobilityStraightEG[p + 7, a] = -(texelMobilityStraightEG[p, a] = pParams[c++]); texelMobilityStraightLG[p + 7, a] = -(texelMobilityStraightLG[p, a] = pParams[c++]); } } for (int i = 0; i < 12; i++) { texelKingSafetySREvaluationsPT1EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT2EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT3EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT4EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT5EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT6EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT1LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT2LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT3LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT4LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT5LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT6LG[i] = pParams[c++]; } } private void PrintDefinedTexelParams(int[] pParams) { int c = 0; for (int t = 0; t < 3; t++) { SNAPSHOT_WRITLINE_REPLACEMENT(TEXELPRINT_GAMEPARTS[t]); for (int p = 0; p < 6; p++) { SNAPSHOT_WRITLINE_REPLACEMENT(TEXELPRINT_PIECES[p]); texelTuningVals[t, p] = new int[64]; for (int s = 0; s < 64; s++) { if (s % 8 == 0 && s != 0) SNAPSHOT_WRITLINE_REPLACEMENT(); SNAPSHOT_WRITLINE_REPLACEMENT((texelTuningVals[t, p][s] = pParams[c++]) + ", "); } SNAPSHOT_WRITLINE_REPLACEMENT(); } } piecePositionEvals = GetInterpolatedProcessedValues(texelTuningVals); } public void TLMTuning(List<TLM_ChessGame> pDataset) { int tGameDataSetLen = pDataset.Count; int[,][] tRatio = new int[33, 6][]; int[,][] tTotalMoves = new int[33, 6][]; double[,][] tSummedRatios = new double[33, 6][]; double[,][] tSummedDataAmount = new double[33, 6][]; double[,][] tTuningResults = new double[33, 6][]; for (int t = 1; t < 33; t++) { for (int p = 0; p < 6; p++) { tRatio[t, p] = new int[64]; tTotalMoves[t, p] = new int[64]; tSummedRatios[t, p] = new double[64]; tSummedDataAmount[t, p] = new double[64]; tTuningResults[t, p] = new double[64]; } } for (int j = 0; j < tGameDataSetLen; j++) { TLM_ChessGame tGame = pDataset[j]; int tGR = tGame.gameResult - 1; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count - 5; for (int i = 0; i < tL; i++) { if (tGame.isMoveNonTactical[i]) { int tPieceAmount = ULONG_OPERATIONS.CountBits(allPieceBitboard); for (int s = 0; s < 64; s++) { int tPT = pieceTypeArray[s] - 1; if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, s)) { tTotalMoves[tPieceAmount, tPT][s]++; tRatio[tPieceAmount, tPT][s] += tGR; } else if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, s)) { int b = blackSidedSquares[s]; tTotalMoves[tPieceAmount, tPT][b]++; tRatio[tPieceAmount, tPT][b] += tGR; } } } PlainMakeMove(tGame.actualMoves[i]); } } double[,] allMultipliers = new double[33, 33]; for (int sh = 0; sh < 33; sh++) { for (int i = 0; i < 33; i++) { allMultipliers[sh, i] = MultiplierFunction(i, sh); } } for (int t = 1; t < 33; t++) { for (int p = 0; p < 6; p++) { for (int s = 0; s < 64; s++) { for (int t2 = 1; t2 < 33; t2++) { double cmult = allMultipliers[t, t2]; tSummedRatios[t, p][s] += tRatio[t2, p][s] * cmult; tSummedDataAmount[t, p][s] += tTotalMoves[t2, p][s] * cmult; } tTuningResults[t, p][s] = TTT(tSummedRatios[t, p][s], tSummedDataAmount[t, p][s]); } } } int c = 0; int[] tparams = new int[1152]; for (int t = 1; t < 33; t += 15) { if (t == 31) t = 32; SNAPSHOT_WRITLINE_REPLACEMENT("PieceCount = " + t + ": "); for (int p = 0; p < 6; p++) { SNAPSHOT_WRITLINE_REPLACEMENT(TEXELPRINT_PIECES[p]); for (int s = 0; s < 64; s++) { if (s % 8 == 0 && s != 0) SNAPSHOT_WRITLINE_REPLACEMENT(); SNAPSHOT_WRITLINE_REPLACEMENT((tparams[c++] = (int)(tTuningResults[t, p][s] * 100)).ToString().Replace(",", ".") + "("+ (int)tSummedDataAmount[t, p][s] + ")"+ ", "); } SNAPSHOT_WRITLINE_REPLACEMENT(); } } string tS = "PARAMS: {"; for (int i = 0; i < tparams.Length; i++) tS += tparams[i] + ","; tS = tS.Substring(0, tS.Length - 1) + "}\n"; SNAPSHOT_WRITLINE_REPLACEMENT(tS); TexelTuning(pDataset, tparams); } private double TTT(double d1, double d2) { if (d2 == 0) return 0; return d1 /d2; } public void TexelTuning(List<TLM_ChessGame> pDataset, int[] pCurBestParams) { Stopwatch sw = Stopwatch.StartNew(); string tPath = PathManager.GetTXTPath("OTHER/TEXEL_TUNING"); int paramCount = pCurBestParams.Length; double bestAvrgCost = CalculateAverageTexelCost(pDataset, pCurBestParams); SNAPSHOT_WRITLINE_REPLACEMENT("CUR PARAMS COST: " + bestAvrgCost); int packetSize = Math.Clamp(paramCount /ENGINE_VALS.CPU_CORES, 1, 100000); paramsLowerLimits = new int[paramCount]; paramsUpperLimits = new int[paramCount]; for (int i = 0; i < paramCount; i++) { int lim = i < 10 ? 100000 : 200; paramsLowerLimits[i] = -lim; paramsUpperLimits[i] = lim; } SNAPSHOT_WRITLINE_REPLACEMENT("PARAM-COUNT: " + paramCount); SNAPSHOT_WRITLINE_REPLACEMENT("PACKET-SIZE: " + packetSize); while (packetSize <= paramCount) { BOT_MAIN.TEXELfinished = 0; int lM = 0, tC = 0; ulong tUL = 0ul; for (int m = packetSize; lM < paramCount; m += packetSize) { if (m > paramCount) m = paramCount; tUL = ULONG_OPERATIONS.SetBitToOne(tUL, ++tC); lM = m; } tC = lM = 0; for (int m = packetSize; lM < paramCount; m += packetSize) { if (m > paramCount) m = paramCount; tC++; BOT_MAIN.boardManagers[tC].SetPlayTexelVals(pDataset, lM, m, pCurBestParams, paramsLowerLimits, paramsUpperLimits, tC, tUL); ThreadPool.QueueUserWorkItem(new WaitCallback(BOT_MAIN.boardManagers[tC].TexelTuningThreadedPackage)); lM = m; } packetSize = paramCount + 1; int tmod = 0; while (tC != BOT_MAIN.TEXELfinished) { if (++tmod % 20 == 0) { WriteTexelParamsToTXT(tPath, BOT_MAIN.curTEXELPARAMS); SNAPSHOT_WRITLINE_REPLACEMENT(CalculateAverageTexelCost(pDataset, BOT_MAIN.curTEXELPARAMS) + " | "+ BOT_MAIN.TEXELadjustmentsmade); SNAPSHOT_WRITLINE_REPLACEMENT(ULONG_OPERATIONS.GetBitVisualization(BOT_MAIN.TEXELfinishedwithoutimpovement)); } Thread.Sleep(100); } SNAPSHOT_WRITLINE_REPLACEMENT("One Thread Generation FINISHED! :) :) :)"); pCurBestParams = BOT_MAIN.curTEXELPARAMS; } sw.Stop(); WriteTexelParamsToTXT(tPath, BOT_MAIN.curTEXELPARAMS); SNAPSHOT_WRITLINE_REPLACEMENT("END COST: " + CalculateAverageTexelCost(pDataset, BOT_MAIN.curTEXELPARAMS)); SNAPSHOT_WRITLINE_REPLACEMENT(BOT_MAIN.TEXELadjustmentsmade); SNAPSHOT_WRITLINE_REPLACEMENT(sw.ElapsedMilliseconds); } public void TexelTuningThreadedPackage(object obj) { SNAPSHOT_WRITLINE_REPLACEMENT("Started CThreadID [" + customThreadID + "] which is handling Params ["+ threadFrom + "] - ["+ threadTo + "]"); bool firstIter = true; do { double bestAvrgCost = CalculateAverageTexelCost(threadDataset, threadParams); int adjust_val = firstIter ? 512 : 8; do { adjust_val /= 2; bool improvedAvrgCost = true; while (improvedAvrgCost) { improvedAvrgCost = false; for (int i = threadFrom; i < threadTo; i++) { bool improvedWithThisParam = true; int tadjustval = adjust_val; bool lastTimeMaximized = false, lastTimeMinimized = false; while (improvedWithThisParam) { improvedWithThisParam = false; int[] curParams = (int[])threadParams.Clone(); int paramBefore = curParams[i]; curParams[i] = Math.Clamp(paramBefore + adjust_val, paramsLowerLimits[i], paramsUpperLimits[i]); double curAvrgCost = CalculateAverageTexelCost(threadDataset, curParams); if (curAvrgCost < bestAvrgCost) { improvedAvrgCost = true; improvedWithThisParam = true; SNAPSHOT_WRITLINE_REPLACEMENT("Improved Param [" + i + "] at CThreadID ["+ customThreadID + "]: +"+ adjust_val + " ("+ GetDoublePrecentageString(bestAvrgCost - curAvrgCost) + ")"); bestAvrgCost = curAvrgCost; threadParams = curParams; BOT_MAIN.TEXELadjustmentsmade++; BOT_MAIN.TEXELfinishedwithoutimpovement = ulAllThreadIDsUnfinished; if (lastTimeMaximized) { adjust_val *= 4; lastTimeMaximized = false; } else lastTimeMaximized = true; lastTimeMinimized = false; } else { curParams[i] = Math.Clamp(paramBefore - adjust_val, paramsLowerLimits[i], paramsUpperLimits[i]); curAvrgCost = CalculateAverageTexelCost(threadDataset, curParams); if (curAvrgCost < bestAvrgCost) { improvedAvrgCost = true; improvedWithThisParam = true; SNAPSHOT_WRITLINE_REPLACEMENT("Improved Param [" + i + "] at CThreadID ["+ customThreadID + "]: -"+ adjust_val + " ("+ GetDoublePrecentageString(bestAvrgCost - curAvrgCost) + ")"); bestAvrgCost = curAvrgCost; threadParams = curParams; BOT_MAIN.TEXELadjustmentsmade++; BOT_MAIN.TEXELfinishedwithoutimpovement = ulAllThreadIDsUnfinished; if (lastTimeMinimized) { adjust_val *= 4; lastTimeMinimized = false; } else lastTimeMinimized = true; lastTimeMaximized = false; } } if (adjust_val != 1) adjust_val /= 2; for (int j = threadFrom; j < threadTo; j++) { BOT_MAIN.curTEXELPARAMS[j] = threadParams[j]; } threadParams = (int[])BOT_MAIN.curTEXELPARAMS.Clone(); bestAvrgCost = CalculateAverageTexelCost(threadDataset, threadParams); } adjust_val = tadjustval; } } } while (adjust_val != 1); BOT_MAIN.TEXELfinishedwithoutimpovement = ULONG_OPERATIONS.SetBitToZero(BOT_MAIN.TEXELfinishedwithoutimpovement, customThreadID); SNAPSHOT_WRITLINE_REPLACEMENT("FULLY FINISHED " + customThreadID + ". IMPROVEMENT THREAD PACKAGE CYCLE"); firstIter = false; } while (BOT_MAIN.TEXELfinishedwithoutimpovement != 0); BOT_MAIN.TEXELfinished++; } private void WriteTexelParamsToTXT(string pPath, int[] pParams) { try { string tS = "PARAMS: {"; for (int i = 0; i < pParams.Length; i++) tS += pParams[i] + ","; tS = tS.Substring(0, tS.Length - 1) + "}\n"; File.AppendAllText(pPath, tS); } catch { SNAPSHOT_WRITLINE_REPLACEMENT("Mal wieder TXT zu lange gebraucht um zu aktualisieren."); } } private double costSum = 0d; private int texelCostMovesEvaluated = 0; private double CalculateAverageTexelCost(List<TLM_ChessGame> tDataset, int[] pParams, bool pFullCost = true) { costSum = 0d; texelCostMovesEvaluated = 0; SetupTexelEvaluationParams(pParams); int tGameDataSetLen = tDataset.Count; int start = 0, end = tGameDataSetLen; if (!pFullCost) { end = (start = globalRandom.Next(0, end - 256)) + 256; } for (int j = start; j < end; j++) { TLM_ChessGame tGame = tDataset[j]; double tGR = tGame.gameResult; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count - 5; texelCostMovesEvaluated += tL; for (int i = 0; i < tL; i++) { costSum += TexelCost(tGR - TexelTuningSigmoid(TexelEvaluate())); PlainMakeMove(tGame.actualMoves[i]); } } return costSum /texelCostMovesEvaluated; } private double CalculateAverageTexelCostThreadedVersionLEGACYDOESNTWORK(List<TLM_ChessGame> tDataset, int[] pParams) { Stopwatch sw = Stopwatch.StartNew(); BOT_MAIN.TEXELcostSum = 0d; BOT_MAIN.TEXELfinished = 0; BOT_MAIN.TEXELcostMovesEvaluated = 0; int tGameDataSetLen = tDataset.Count; int gamesPerThread = tGameDataSetLen /ENGINE_VALS.CPU_CORES; for (int i = 0; i < ENGINE_VALS.CPU_CORES - 1; i++) { } for (int i = 0; i < ENGINE_VALS.CPU_CORES - 1; i++) { } while (BOT_MAIN.TEXELfinished != ENGINE_VALS.CPU_CORES) Thread.Sleep(1); sw.Stop(); return BOT_MAIN.TEXELcostSum /BOT_MAIN.TEXELcostMovesEvaluated; } public void SetPlayThroughVals(List<TLM_ChessGame> pDataset, int pFrom, int pTo) { threadDataset = pDataset; threadFrom = pFrom; threadTo = pTo; } public void SetPlayTexelVals(List<TLM_ChessGame> pDataset, int pFrom, int pTo, int[] pTexelParams, int[] pLowerLimits, int[] pUpperLimits, int pThreadID, ulong pUL) { threadDataset = pDataset; threadFrom = pFrom; threadTo = pTo; threadParams = pTexelParams; paramsLowerLimits = pLowerLimits; paramsUpperLimits = pUpperLimits; customThreadID = pThreadID; ulAllThreadIDsUnfinished = pUL; } public void PlayThroughSetOfGames(object obj) { SNAPSHOT_WRITLINE_REPLACEMENT(threadFrom + "->"+ threadTo); int sortedOut = 0; for (int j = threadFrom; j < threadTo; j++) { TLM_ChessGame tGame = threadDataset[j]; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count; for (int i = 0; i < tL; i++) { int tQuietEval = isWhiteToMove ? QuiescenceWhite(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, 0, PreMinimaxCheckCheckWhite(), NULL_MOVE) : QuiescenceBlack(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, 0, PreMinimaxCheckCheckBlack(), NULL_MOVE); bool tB; tGame.isMoveNonTactical.Add(tB = (Evaluate() == tQuietEval && i > 4)); if (!tB) sortedOut++; PlainMakeMove(tGame.actualMoves[i]); } } BOT_MAIN.TEXELsortedout += sortedOut; BOT_MAIN.TEXELfinished++; } public void CalculateAverageTexelCostThreadFunction(object obj) { SetupTexelEvaluationParams(threadParams); double d = 0d; for (int j = threadFrom; j < threadTo; j++) { TLM_ChessGame tGame = threadDataset[j]; double tGR = tGame.gameResult; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count - 5; BOT_MAIN.TEXELcostMovesEvaluated += tL; for (int i = 0; i < tL; i++) { d += TexelCost(tGR - TexelTuningSigmoid(TexelEvaluate())); PlainMakeMove(tGame.actualMoves[i]); } } BOT_MAIN.TEXELcostSum += d; BOT_MAIN.TEXELfinished++; } private void ConsoleWriteLineTuneArray<T>(T[,][] pArr) { for (int j = 0; j < 3; j++) { SNAPSHOT_WRITLINE_REPLACEMENT("{"); for (int k = 0; k < 6; k++) { SNAPSHOT_WRITLINE_REPLACEMENT("{"); for (int s = 0; s < 64; s++) SNAPSHOT_WRITLINE_REPLACEMENT(pArr[j, k][s] + ", "); SNAPSHOT_WRITLINE_REPLACEMENT("\n}"); } SNAPSHOT_WRITLINE_REPLACEMENT("}"); } } private void Tune(string pGameCGFF, double pLearningRate) { TLM_ChessGame tGame = CGFF.GetGame(pGameCGFF); LoadFenString(tGame.startFen); double tDGameResult = tGame.gameResult; foreach (int hMove in tGame.hashedMoves) { Tune(tDGameResult, pLearningRate); List<Move> moveOptionList = new List<Move>(); GetLegalMoves(ref moveOptionList); int tL = moveOptionList.Count; for (int i = 0; i < tL; i++) { Move tMove = moveOptionList[i]; if (tMove.moveHash == hMove) { PlainMakeMove(tMove); tL = -1; break; } } if (tL != -1) break; } } private void Tune(double pGameResult, double pLearningRate) { int tPC = ULONG_OPERATIONS.CountBits(allPieceBitboard); double oneThroughPieceCount = 1d /tPC; double egMult = earlyGameMultipliers[tPC], mgMult = middleGameMultipliers[tPC], lgMult = lateGameMultipliers[tPC]; double tTexelResult = TexelEvaluateF(); double tSigmoidedTexelResult = TexelSigmoid(tTexelResult); double tDif = tSigmoidedTexelResult - pGameResult; double tM = oneThroughPieceCount * TexelCostDerivative(tDif) * TexelSigmoidDerivative(tTexelResult) * pLearningRate; sumCostVals += lastCostVal = TexelCost(tDif); costCalculations++; for (int i = 0; i < 64; i++) { if (ULONG_OPERATIONS.IsBitZero(allPieceBitboard, i)) continue; int tPT = pieceTypeArray[i] - 1, tI = i; if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, i)) tI = blackSidedSquares[i]; texelTuningAdjustIterations[tPT, tI]++; } } private double TexelEvaluateF() { texelTuningRuntimeVals = GetInterpolatedProcessedValues(texelTuningVals); return TexelEvaluate(); } private int TexelEvaluate() { int tEvalEG = 0, tEvalLG = 0, tProgress = 0; ulong[] attkULs = new ulong[14]; for (int p = 0; p < 64; p++) { if (((int)(allPieceBitboard >> p) & 1) == 0) continue; int aPT = pieceTypeArray[p], tPT = aPT + 7 * ((int)(blackPieceBitboard >> p) & 1); tEvalEG += texelTuningRuntimePositionalValsV2EG[tPT][p] + texelPieceEvaluationsV2EG[tPT]; tEvalLG += texelTuningRuntimePositionalValsV2LG[tPT][p] + texelPieceEvaluationsV2LG[tPT]; tProgress += pieceTypeGameProgressImpact[tPT]; } if (tProgress > 24) tProgress = 24; return (int)(earlyGameMultipliers[tProgress] * tEvalEG + lateGameMultipliers[tProgress] * tEvalLG); } private const double TexelK = 0.2; private double TexelTuningSigmoid(double pVal) { return 2d /(1 + Math.Pow(10, -TexelK * pVal /400)); } private double TexelSigmoid(double pVal) { return 2d /(Math.Exp(-0.04d * pVal) + 1d); } private double TexelSigmoidDerivative(double pVal) { double d = Math.Exp(-0.04d * pVal); return 2d * d /(25d * (d + 1d) * (d + 1d)); } private double TexelCost(double pVal) { return pVal * pVal; } private double TexelCostDerivative(double pVal) { return 2 * pVal; } private char[] fenPieces = new char[7] { 'z', 'p', 'n', 'b', 'r', 'q', 'k' }; private string[] squareNames = new string[64] { "a1", "b1", "c1", "d1", "e1", "f1", "g1", "h1", "a2", "b2", "c2", "d2", "e2", "f2", "g2", "h2", "a3", "b3", "c3", "d3", "e3", "f3", "g3", "h3", "a4", "b4", "c4", "d4", "e4", "f4", "g4", "h4", "a5", "b5", "c5", "d5", "e5", "f5", "g5", "h5", "a6", "b6", "c6", "d6", "e6", "f6", "g6", "h6", "a7", "b7", "c7", "d7", "e7", "f7", "g7", "h7", "a8", "b8", "c8", "d8", "e8", "f8", "g8", "h8"}; public string CreateFenString() { string rFEN = ""; for (int i = 7; i >= 0; i--) { int t = 0; for (int j = 0; j < 8; j++) { int sq = i * 8 + j; if (pieceTypeArray[sq] != 0) { if (t != 0) rFEN += t; t = 0; } if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, sq)) { switch (pieceTypeArray[sq]) { case 0: t++; SNAPSHOT_WRITLINE_REPLACEMENT("???"); break; case 1: rFEN += 'P'; break; case 2: rFEN += 'N'; break; case 3: rFEN += 'B'; break; case 4: rFEN += 'R'; break; case 5: rFEN += 'Q'; break; case 6: rFEN += 'K'; break; } } else { switch (pieceTypeArray[sq]) { case 0: t++; break; case 1: rFEN += 'p'; break; case 2: rFEN += 'n'; break; case 3: rFEN += 'b'; break; case 4: rFEN += 'r'; break; case 5: rFEN += 'q'; break; case 6: rFEN += 'k'; break; } } } if (t != 0) rFEN += t; if (i != 0) rFEN += "/"; } rFEN += (isWhiteToMove ? " w": " b"); rFEN += (whiteCastleRightKingSide ? " K": " "); rFEN += (whiteCastleRightQueenSide ? "Q": ""); rFEN += (blackCastleRightKingSide ? "k": ""); rFEN += (blackCastleRightQueenSide ? "q": ""); if (!whiteCastleRightKingSide && !whiteCastleRightQueenSide && !blackCastleRightKingSide && !blackCastleRightQueenSide) rFEN += "-"; if (enPassantSquare < 64) rFEN += " "+ squareNames[enPassantSquare] + " "; else rFEN += " - "; return rFEN + fiftyMoveRuleCounter + " "+ ((happenedHalfMoves - happenedHalfMoves % 2) /2); } public void LoadFenString(string fenStr) { lastMadeMove = NULL_MOVE; zobristKey = 0ul; whitePieceBitboard = blackPieceBitboard = allPieceBitboard = 0ul; for (int i = 0; i < 64; i++) pieceTypeArray[i] = 0; string[] spaceSpl = fenStr.Split(' '); string[] rowSpl = spaceSpl[0].Split('/'); string epstr = spaceSpl[3]; if (epstr == "-") enPassantSquare = 65; else enPassantSquare = (epstr[0] - 'a') + 8 * (epstr[1] - '1'); isWhiteToMove = true; if (spaceSpl[1] == "b") isWhiteToMove = false; if (!isWhiteToMove) zobristKey ^= blackTurnHash; string crstr = spaceSpl[2]; whiteCastleRightKingSide = whiteCastleRightQueenSide = blackCastleRightKingSide = blackCastleRightQueenSide = false; int crStrL = crstr.Length; for (int i = 0; i < crStrL; i++) { switch (crstr[i]) { case 'K': whiteCastleRightKingSide = true; break; case 'Q': whiteCastleRightQueenSide = true; break; case 'k': blackCastleRightKingSide = true; break; case 'q': blackCastleRightQueenSide = true; break; } } fiftyMoveRuleCounter = Convert.ToInt32(spaceSpl[4]); happenedHalfMoves = Convert.ToInt32(spaceSpl[5]) * 2; if (!isWhiteToMove) happenedHalfMoves++; int tSq = 0; for (int i = rowSpl.Length; i-- > 0;) { string tStr = rowSpl[i]; int tStrLen = tStr.Length; for (int c = 0; c < tStrLen; c++) { char tChar = tStr[c]; if (Char.IsDigit(tChar)) tSq += tChar - '0'; else { bool tCol = Char.IsLower(tChar); if (tCol) blackPieceBitboard = ULONG_OPERATIONS.SetBitToOne(blackPieceBitboard, tSq); else whitePieceBitboard = ULONG_OPERATIONS.SetBitToOne(whitePieceBitboard, tSq); if (tChar == 'k') blackKingSquare = tSq; else if (tChar == 'K') whiteKingSquare = tSq; pieceTypeArray[tSq] = Array.IndexOf(fenPieces, Char.ToLower(tChar)); if (tCol) zobristKey ^= pieceHashesBlack[tSq, pieceTypeArray[tSq]]; else zobristKey ^= pieceHashesWhite[tSq, pieceTypeArray[tSq]]; tSq++; } } } if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; zobristKey ^= enPassantSquareHashes[enPassantSquare]; allPieceBitboard = whitePieceBitboard | blackPieceBitboard; if (zobristKey == 16260251586586513106) moveHashList.Clear(); else { moveHashList.Clear(); moveHashList.Add(1); moveHashList.Add(2); moveHashList.Add(3); } } private ulong[,] pieceHashesWhite = new ulong[64, 7], pieceHashesBlack = new ulong[64, 7]; private ulong blackTurnHash, whiteKingSideRochadeRightHash, whiteQueenSideRochadeRightHash, blackKingSideRochadeRightHash, blackQueenSideRochadeRightHash; private ulong[] enPassantSquareHashes = new ulong[66]; private void InitZobrist() { Random rng = new Random(31415926); for (int sq = 0; sq < 64; sq++) { enPassantSquareHashes[sq] = ULONG_OPERATIONS.GetRandomULONG(rng); for (int it = 1; it < 7; it++) { pieceHashesWhite[sq, it] = ULONG_OPERATIONS.GetRandomULONG(rng); pieceHashesBlack[sq, it] = ULONG_OPERATIONS.GetRandomULONG(rng); } } blackTurnHash = ULONG_OPERATIONS.GetRandomULONG(rng); whiteKingSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); whiteQueenSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); blackKingSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); blackQueenSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); } public void SetKnightMasks(ulong[] uls) { knightSquareBitboards = uls; } public void SetKingMasks(ulong[] uls) { kingSquareBitboards = uls; } private Move[,] whiteEnPassantMoves = new Move[64, 64]; private Move[,] blackEnPassantMoves = new Move[64, 64]; private bool[] epValidationArray = new bool[64] { false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true , true , true , true , true , true , true , true, true , true , true , true , true , true , true , true, true , true , true , true , true , true , true , true, true , true , true , true , true , true , true , true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false }; private ulong[] kingSafetyRing1 = new ulong[64], kingSafetyRing2 = new ulong[64]; private ulong[] kingSafetySpecialRingW = new ulong[64], kingSafetySpecialRingB = new ulong[64]; private ulong[] rowPrecalcs = new ulong[8], columnPrecalcs = new ulong[8]; const ulong columnUL = 0x101010101010101, rowUL = 0b11111111; private void PrecalculateKingSafetyBitboards() { for (int i = 0; i < 8; i++) { rowPrecalcs[i] = rowUL << (8 * i); columnPrecalcs[i] = columnUL << i; } for (int i = 0; i < 64; i++) { int tMod = i % 8; int tRow = (i - tMod) /8; ulong tULC = columnPrecalcs[tMod], tULR = rowPrecalcs[tRow]; ulong tULC2 = columnPrecalcs[tMod], tULR2 = rowPrecalcs[tRow]; if (tMod < 7) tULC |= columnPrecalcs[tMod + 1]; if (tMod > 0) tULC |= columnPrecalcs[tMod - 1]; if (tRow < 7) tULR |= rowPrecalcs[tRow + 1]; if (tRow > 0) tULR |= rowPrecalcs[tRow - 1]; if (tMod < 6) tULC2 |= columnPrecalcs[tMod + 2]; if (tMod > 1) tULC2 |= columnPrecalcs[tMod - 2]; if (tRow < 6) tULR2 |= rowPrecalcs[tRow + 2]; if (tRow > 1) tULR2 |= rowPrecalcs[tRow - 2]; tULR2 |= tULR; tULC2 |= tULC; kingSafetyRing1[i] = ULONG_OPERATIONS.SetBitToZero(tULR & tULC, i); kingSafetyRing2[i] = ULONG_OPERATIONS.SetBitsToZero(tULR2 & tULC2, i, i + 1, i - 1, i + 7, i + 8, i + 9, i - 7, i - 8, i - 9); } for (int i = 0; i < 64; i++) { if (i < 56) kingSafetySpecialRingW[i] = ULONG_OPERATIONS.SetBitToZero(kingSafetyRing1[i] | kingSafetyRing1[i + 8], i); else kingSafetySpecialRingW[i] = kingSafetyRing1[i]; if (i > 7) kingSafetySpecialRingB[i] = ULONG_OPERATIONS.SetBitToZero(kingSafetyRing1[i] | kingSafetyRing1[i - 8], i); else kingSafetySpecialRingB[i] = kingSafetyRing1[i]; } } private void PrecalculateEnPassantMoves() { for (int i = 0; i < 64; i++) { if (!epValidationArray[i]) continue; for (int j = 0; j < 64; j++) { if (i == j) continue; if (Math.Abs(i - j) > 9) continue; if (!epValidationArray[j]) continue; whiteEnPassantMoves[i, j] = new Move(false, i, j, j - 8); blackEnPassantMoves[i, j] = new Move(false, i, j, j + 8); } } } private void PawnAttackBitboards() { for (int sq = 0; sq < 64; sq++) { ulong u = 0ul; if (sq % 8 != 0) u = ULONG_OPERATIONS.SetBitToOne(u, sq + 7); if (sq % 8 != 7) u = ULONG_OPERATIONS.SetBitToOne(u, sq + 9); whitePawnAttackSquareBitboards[sq] = u; u = 0ul; if (sq % 8 != 0 && sq - 9 > -1) u = ULONG_OPERATIONS.SetBitToOne(u, sq - 9); if (sq % 8 != 7 && sq - 7 > -1) u = ULONG_OPERATIONS.SetBitToOne(u, sq - 7); blackPawnAttackSquareBitboards[sq] = u; } } private int[] squareConnectivesPrecalculationArray = new int[4096]; public int[] squareConnectivesCrossDirsPrecalculationArray { get; set; } = new int[4096]; private ulong[] squareConnectivesPrecalculationRayArray = new ulong[4096]; private ulong[] squareConnectivesPrecalculationLineArray = new ulong[4096]; private List<Dictionary<ulong, int>> rayCollidingSquareCalculations = new List<Dictionary<ulong, int>>(); private readonly int[] maxIntWithSpecifiedBitcount = new int[8] { 0, 0b1, 0b11, 0b111, 0b1111, 0b11111, 0b111111, 0b1111111 }; private List<ulong> differentRays = new List<ulong>(); private void SquareConnectivesPrecalculations() { for (int square = 0; square < 64; square++) { rayCollidingSquareCalculations.Add(new Dictionary<ulong, int>()); rayCollidingSquareCalculations[square].Add(0ul, square); for (int square2 = 0; square2 < 64; square2++) { if (square == square2) continue; int t = 0, t2 = 0, difSign = Math.Sign(square2 - square), itSq = square, g = 0; ulong tRay = 0ul, tExclRay = 0ul; List<int> tRayInts = new List<int>(); if (difSign == -1) g = 7; if (square % 8 == square2 % 8) { t2 = t = 1; while ((itSq += difSign * 8) < 64 && itSq > -1) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } } else if ((square - square % 8) == (square2 - square2 % 8)) { t = 1; t2 = -1; while ((itSq += difSign) % 8 != g && itSq > -1 && itSq < 64) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } } else { int dif = Math.Abs(square2 - square); if (dif % 7 == 0) { t = 2; t2 = 2; g = (difSign == 1) ? 7 : 0; while ((itSq += difSign * 7) % 8 != g && itSq < 64 && itSq > -1) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } if (ULONG_OPERATIONS.IsBitZero(tRay, square2)) { t2 = t = 0; tRay = 0ul; } } else if (dif % 9 == 0) { t = 2; t2 = -2; if (square == 0 && square2 == 63 || square == 63 && square2 == 0) SNAPSHOT_WRITLINE_REPLACEMENT("!"); while ((itSq += difSign * 9) % 8 != g && itSq < 64 && itSq > -1) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } if (ULONG_OPERATIONS.IsBitZero(tRay, square2)) { t2 = t = 0; tRay = 0ul; } } } if (square == 0 && square2 == 63) { t2 = t = 2; tRayInts.Clear(); tExclRay = tRay = ULONG_OPERATIONS.SetBitsToOne(0ul, 9, 18, 27, 36, 45, 54, 63); tRayInts = new List<int>() { 9, 18, 27, 36, 45, 54, 63 }; } else if (square2 == 0 && square == 63) { t = 2; tRayInts.Clear(); t2 = -2; tExclRay = tRay = ULONG_OPERATIONS.SetBitsToOne(0ul, 0, 9, 18, 27, 36, 45, 54); tRayInts = new List<int>() { 54, 45, 36, 27, 18, 9, 0 }; } if (tRay != 0ul && !differentRays.Contains(tRay)) { differentRays.Add(tRay); int ccount, combI = maxIntWithSpecifiedBitcount[ccount = ULONG_OPERATIONS.CountBits(tRay)]; do { ulong curAllPieceBitboard = 0ul; int solution = square; for (int j = 0; j < ccount; j++) { if (((combI >> j) & 1) == 1) { curAllPieceBitboard = ULONG_OPERATIONS.SetBitToOne(curAllPieceBitboard, tRayInts[j]); if (solution == square) solution = tRayInts[j]; } } rayCollidingSquareCalculations[square].Add(curAllPieceBitboard, solution); } while (--combI != 0); } squareConnectivesPrecalculationArray[square << 6 | square2] = t; squareConnectivesPrecalculationRayArray[square << 6 | square2] = tRay; squareConnectivesCrossDirsPrecalculationArray[square << 6 | square2] = t2; if (t != 0) squareConnectivesPrecalculationLineArray[square << 6 | square2] = (square == 0 && square2 == 63 || square2 == 0 && square == 63) ? tExclRay : ULONG_OPERATIONS.SetBitToOne(tExclRay, square2); if (squareConnectivesPrecalculationLineArray[square << 6 | square2] == 0ul && ULONG_OPERATIONS.IsBitOne(knightSquareBitboards[square], square2)) squareConnectivesPrecalculationLineArray[square << 6 | square2] = 1ul << square2; } differentRays.Clear(); } } public void SNAPSHOT_WRITLINE_REPLACEMENT() { } public void SNAPSHOT_WRITLINE_REPLACEMENT(object pStr) { } private string GetDoublePrecentageString(double pVal) { return ((int)(pVal * 1_000_000) /10_000d) + "%"; } private string ReplaceAllULONGIsBitOne(string pCode) { const string METHOD_NAME = "ULONG_OPERATIONS.IsBitOne"; int METHOD_NAME_LEN = METHOD_NAME.Length, iterations = 0; int pIndex = pCode.IndexOf(METHOD_NAME); while (pIndex != -1 && ++iterations < 10_000) { List<int> paramIndexes = new List<int>(); int openedBracketCount = 1, closedBracketCount = 0, a = METHOD_NAME_LEN + pIndex; string tpCode = pCode.Substring(0, pIndex); paramIndexes.Add(a + 1); while (++a < pCode.Length) { switch (pCode[a]) { case '(': openedBracketCount++; break; case ')': if (++closedBracketCount == openedBracketCount) { pIndex = a; a = int.MaxValue - 5; } break; case ',': if (openedBracketCount - closedBracketCount == 1) paramIndexes.Add(a + 1); break; } } if (openedBracketCount == closedBracketCount && paramIndexes.Count == 2) { tpCode += "((int)("+ pCode.Substring(paramIndexes[0], paramIndexes[1] - paramIndexes[0] - 1) + (pCode[paramIndexes[1]] == ' ' ? " >> (": " >> (") + pCode.Substring(paramIndexes[1], pIndex - paramIndexes[1]) + ")) & 1) == 1"+ pCode.Substring(pIndex + 1, pCode.Length - pIndex - 1); } pIndex = (pCode = tpCode).IndexOf(METHOD_NAME); } SNAPSHOT_WRITLINE_REPLACEMENT(iterations + " ITERATIONS"); return pCode; } private string ReplaceAllULONGIsBitZero(string pCode) { const string METHOD_NAME = "ULONG_OPERATIONS.IsBitZero"; int METHOD_NAME_LEN = METHOD_NAME.Length, iterations = 0; int pIndex = pCode.IndexOf(METHOD_NAME); while (pIndex != -1 && ++iterations < 10_000) { List<int> paramIndexes = new List<int>(); int openedBracketCount = 1, closedBracketCount = 0, a = METHOD_NAME_LEN + pIndex; string tpCode = pCode.Substring(0, pIndex); paramIndexes.Add(a + 1); while (++a < pCode.Length) { switch (pCode[a]) { case '(': openedBracketCount++; break; case ')': if (++closedBracketCount == openedBracketCount) { pIndex = a; a = int.MaxValue - 5; } break; case ',': if (openedBracketCount - closedBracketCount == 1) paramIndexes.Add(a + 1); break; } } if (openedBracketCount == closedBracketCount && paramIndexes.Count == 2) { tpCode += "((int)("+ pCode.Substring(paramIndexes[0], paramIndexes[1] - paramIndexes[0] - 1) + (pCode[paramIndexes[1]] == ' ' ? " >>": " >> ") + pCode.Substring(paramIndexes[1], pIndex - paramIndexes[1]) + ") & 1) == 0"+ pCode.Substring(pIndex + 1, pCode.Length - pIndex - 1); } pIndex = (pCode = tpCode).IndexOf(METHOD_NAME); } SNAPSHOT_WRITLINE_REPLACEMENT(iterations + " ITERATIONS"); return pCode; } private string GetThreeDigitSeperatedInteger(int pInt) { string s = pInt.ToString(), r = s[0].ToString(); int t = s.Length % 3; for (int i = 1; i < s.Length; i++) { if (i % 3 == t) r += "."; r += s[i]; } s = ""; for (int i = 0; i < r.Length; i++) s += r[i]; return s; } public double GetAverageDepth() { return (double)depths /(double)searches; } }
public class SNAPSHOT_V01_00_005 : IBoardManager  { public int TEXEL_PARAMS { get; } = 778; private const int BESTMOVE_SORT_VAL = -2_000_000_000; private const int CAPTURE_SORT_VAL = -1_000_000_000; private const int KILLERMOVE_SORT_VAL = -1000; private readonly int[,] MVVLVA_TABLE = new int[7, 7] { { 0, 0, 0, 0, 0, 0, 0 }, { 0, 1500, 1400, 1300, 1200, 1100, 1000 }, { 0, 3500, 3400, 3300, 3200, 3100, 3000 }, { 0, 4500, 4400, 4300, 4200, 4100, 4000 }, { 0, 5500, 5400, 5300, 5200, 5100, 5000 }, { 0, 9500, 9400, 9300, 9200, 9100, 9000 }, { 0, 0, 0, 0, 0, 0, 0 }}; private int BOARD_MANAGER_ID = -1; private bool debugSearchDepthResults = false; private bool debugSortResults = false; private RookMovement rookMovement; private BishopMovement bishopMovement; private QueenMovement queenMovement; private KnightMovement knightMovement; private KingMovement kingMovement; private WhitePawnMovement whitePawnMovement; private BlackPawnMovement blackPawnMovement; private Rays rays; public List<Move> moveOptionList { get; set; } private int[] pieceTypeArray = new int[64]; public ulong whitePieceBitboard, blackPieceBitboard, allPieceBitboard; private ulong zobristKey; private int whiteKingSquare, blackKingSquare, enPassantSquare = 65, happenedHalfMoves = 0, fiftyMoveRuleCounter = 0; private bool whiteCastleRightKingSide, whiteCastleRightQueenSide, blackCastleRightKingSide, blackCastleRightQueenSide; private bool isWhiteToMove; private const ulong WHITE_KING_ROCHADE = 96, WHITE_QUEEN_ROCHADE = 14, BLACK_KING_ROCHADE = 6917529027641081856, BLACK_QUEEN_ROCHADE = 1008806316530991104, WHITE_QUEEN_ATTK_ROCHADE = 12, BLACK_QUEEN_ATTK_ROCHADE = 864691128455135232; private readonly Move mWHITE_KING_ROCHADE = new Move(4, 6, 7, 5), mWHITE_QUEEN_ROCHADE = new Move(4, 2, 0, 3), mBLACK_KING_ROCHADE = new Move(60, 62, 63, 61), mBLACK_QUEEN_ROCHADE = new Move(60, 58, 56, 59); private ulong[] knightSquareBitboards = new ulong[64]; private ulong[] whitePawnAttackSquareBitboards = new ulong[64]; private ulong[] blackPawnAttackSquareBitboards = new ulong[64]; private ulong[] kingSquareBitboards = new ulong[64]; private bool[,] pieceTypeAbilities = new bool[7, 3] { { false, false, false }, { false, false, false }, { false, false, false }, { false, false, true }, { false, true, false }, { false, true, true }, { false, false, false } }; private List<int> moveHashList = new List<int>(); private ulong[] curSearchZobristKeyLine = Array.Empty<ulong>(); private Stopwatch globalTimer = Stopwatch.StartNew(); private Move lastMadeMove; private int depths, searches; private Random globalRandom = new Random(); public SNAPSHOT_V01_00_005(string fen) { Setup(fen); } public void Setup(string pFen) { Stopwatch setupStopwatch = Stopwatch.StartNew(); BOARD_MANAGER_ID = BOT_MAIN.curBoardManagerID; for (int i = 0; i < 33; i++) for (int j = 0; j < 14; j++) piecePositionEvals[i, j] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; for (int i = 0; i < 33; i++) for (int j = 0; j < 14; j++) texelTuningRuntimeVals[i, j] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; for (int i = 0; i < 3; i++) for (int j = 0; j < 6; j++) texelTuningVals[i, j] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; for (int i = 0; i < 14; i++) { texelTuningRuntimePositionalValsV2EG[i] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; texelTuningRuntimePositionalValsV2LG[i] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; } PrecalculateKingSafetyBitboards(); PrecalculateMultipliers(); GetLowNoisePositionalEvaluation(globalRandom); MinimaxRoot(1L); SetupConsoleWrite("[PRECALCS] Zobrist Hashing"); InitZobrist(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Knight Movement"); knightMovement = new KnightMovement(this); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Square Connectives"); SquareConnectivesPrecalculations(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Pawn Attack Bitboards"); PawnAttackBitboards(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Rays"); rays = new Rays(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); queenMovement = new QueenMovement(this); SetupConsoleWrite("[PRECALCS] Rook Movement"); rookMovement = new RookMovement(this, queenMovement); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Bishop Movement"); bishopMovement = new BishopMovement(this, queenMovement); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] King Movement"); kingMovement = new KingMovement(this); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Pawn Movement"); whitePawnMovement = new WhitePawnMovement(this); blackPawnMovement = new BlackPawnMovement(this); PrecalculateEnPassantMoves(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWriteLine("[DONE]\n\n"); LoadFenString(pFen); LoadBestTexelParamsIn(); setupStopwatch.Stop(); } private void SetupConsoleWriteLine(string pStr) { if (BOT_MAIN.isFirstBoardManagerInitialized) return; SNAPSHOT_WRITLINE_REPLACEMENT(pStr); } private void SetupConsoleWrite(string pStr) { if (BOT_MAIN.isFirstBoardManagerInitialized) return; SNAPSHOT_WRITLINE_REPLACEMENT(pStr); } public void GetLowNoisePositionalEvaluation(System.Random rng) { int[,][] digitArray = new int[3, 6][]; for (int i = 0; i < 3; i++) for (int j = 0; j < 6; j++) digitArray[i, j] = GetRand64IntArray(rng, -5, 6); lowNoisePositionEvals1 = GetInterpolatedProcessedValues(digitArray); int[,][] digitArray2 = new int[3, 6][]; for (int i = 0; i < 3; i++) for (int j = 0; j < 6; j++) digitArray2[i, j] = GetRand64IntArray(rng, -5, 6); lowNoisePositionEvals2 = GetInterpolatedProcessedValues(digitArray2); } private int[] GetRand64IntArray(System.Random rng, int pMin, int pMax) { return new int[64] { rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax) }; } private string GetAIArrayValuesStringRepresentation(int[,][] pArr) { string r = "int[,][] ReLe_AI_RESULT_VALS = new int[3, 6][] {"; for (int i = 0; i < 3; i++) { r += "{"; for (int j = 0; j < 5; j++) { r += GetIntArray64LStringRepresentation(pArr[i, j]) + ","; } r += GetIntArray64LStringRepresentation(pArr[i, 5]) + "},"; } return r.Substring(0, r.Length - 1) + "};"; } private string GetIntArray64LStringRepresentation(int[] p64LArr) { if (p64LArr == null) return ""; string r = "new int[64]{"; for (int i = 0; i < 63; i++) { r += p64LArr[i] + ","; } return r + p64LArr[63] + "}"; } public void TempStuff() { } private string[] gameResultStrings = new string[5] { "Black Has Won!", "Draw!", "White Has Won!", "Non Existant Result!", "Game is Ongoing!"}; private int[,][] lowNoisePositionEvals1, lowNoisePositionEvals2; public void ThreadSelfPlay(object obj) { PlayGameAgainstItself(obj); } public void PlayGameAgainstItself(object obj, string pStartFEN = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1", long tickLimitForEngine = ENGINE_VALS.SELF_PLAY_THINK_TIME) { int ttGState; while (BOT_MAIN.goalGameCount > BOT_MAIN.gamesPlayed) { try { string tGameStr; GetLowNoisePositionalEvaluation(globalRandom); LoadFenString(tGameStr = pStartFEN); tGameStr += ";"; int tGState = 3, tmc = 0; bool lowNoiceDecider = globalRandom.NextDouble() < 0.5d; while (tGState == 3) { piecePositionEvals = lowNoiceDecider ? lowNoisePositionEvals1 : lowNoisePositionEvals2; MinimaxRoot(tickLimitForEngine); Move tM = transpositionTable[zobristKey].bestMove; PlainMakeMove(tM); tGameStr += NuCRe.GetNuCRe(tM.moveHash) + ","; BOT_MAIN.movesPlayed++; tGState = GameState(isWhiteToMove); lowNoiceDecider = !lowNoiceDecider; tmc++; } ttGState = tGState; tGameStr += ttGState + 1; SNAPSHOT_WRITLINE_REPLACEMENT(tGameStr); BOT_MAIN.gamesPlayedResultArray[ttGState + 1]++; BOT_MAIN.gamesPlayed++; BOT_MAIN.selfPlayGameStrings.Add(tGameStr); } catch (Exception tE) { SNAPSHOT_WRITLINE_REPLACEMENT(tE.ToString()); } } } public void PlayGameOnConsoleAgainstHuman(string pStartFEN = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1", bool pHumanPlaysWhite = true, long tickLimitForEngine = 10_000_000L) { debugSearchDepthResults = true; LoadFenString(pStartFEN); if (!(pHumanPlaysWhite ^ isWhiteToMove)) { var pVS = Console.ReadLine(); if (pVS == null) return; Move tm = GetMoveOfString(pVS.ToString()); SNAPSHOT_WRITLINE_REPLACEMENT(tm); PlainMakeMove(tm); } int tGState = 3; while (tGState == 3) { MinimaxRoot(tickLimitForEngine); PlayThroughZobristTree(); Move tM = transpositionTable[zobristKey].bestMove; SNAPSHOT_WRITLINE_REPLACEMENT(tM); SNAPSHOT_WRITLINE_REPLACEMENT(CreateFenString()); PlainMakeMove(tM); tGState = GameState(isWhiteToMove); if (tGState != 3 || tM == NULL_MOVE) break; var pV = ""; tM = NULL_MOVE; do { pV = Console.ReadLine(); if (pV == null) continue; tM = GetMoveOfString(pV.ToString()); SNAPSHOT_WRITLINE_REPLACEMENT(tM); } while (tM == NULL_MOVE); PlainMakeMove(tM); tGState = GameState(isWhiteToMove); } } private void PlayThroughZobristTree() { SetJumpState(); SNAPSHOT_WRITLINE_REPLACEMENT("\n- - - - - - - - - - - - -"); int tC = 1; Dictionary<ulong, bool> usedULs = new Dictionary<ulong, bool>(); while (transpositionTable.TryGetValue(zobristKey, out TranspositionEntry tM)) { if (usedULs.ContainsKey(zobristKey)) { SNAPSHOT_WRITLINE_REPLACEMENT(tC + ": AT LEAST ONE REPETION; REST NOT VISIBLE"); break; } SNAPSHOT_WRITLINE_REPLACEMENT(tC + ": "+ tM.bestMove + " > "); usedULs.Add(zobristKey, true); PlainMakeMove(tM.bestMove); tC++; } SNAPSHOT_WRITLINE_REPLACEMENT("- - - - - - - - - - - - -\n"); LoadJumpState(); } public Move? ReturnNextMove(Move? lastMove, long pThinkingTime) { if (lastMove != null) PlainMakeMove(lastMove); if (GameState(isWhiteToMove) != 3) return null; MinimaxRoot(pThinkingTime); if (!transpositionTable.ContainsKey(zobristKey)) return null; Move tm = transpositionTable[zobristKey].bestMove; PlainMakeMove(tm); return tm; } private int[] jmpSt_pieceTypeArray; private ulong jmpSt_whitePieceBitboard, jmpSt_blackPieceBitboard; private ulong jmpSt_zobristKey; private int jmpSt_whiteKingSquare, jmpSt_blackKingSquare, jmpSt_enPassantSquare, jmpSt_happenedHalfMoves, jmpSt_fiftyMoveRuleCounter; private bool jmpSt_whiteCastleRightKingSide, jmpSt_whiteCastleRightQueenSide, jmpSt_blackCastleRightKingSide, jmpSt_blackCastleRightQueenSide; private bool jmpSt_isWhiteToMove; private ulong[] jmpSt_curSearchZobristKeyLine; private int[] jmpSt_moveHashList; public void LoadJumpState() { pieceTypeArray = (int[])jmpSt_pieceTypeArray.Clone(); whitePieceBitboard = jmpSt_whitePieceBitboard; blackPieceBitboard = jmpSt_blackPieceBitboard; zobristKey = jmpSt_zobristKey; whiteKingSquare = jmpSt_whiteKingSquare; blackKingSquare = jmpSt_blackKingSquare; enPassantSquare = jmpSt_enPassantSquare; happenedHalfMoves = jmpSt_happenedHalfMoves; fiftyMoveRuleCounter = jmpSt_fiftyMoveRuleCounter; whiteCastleRightKingSide = jmpSt_whiteCastleRightKingSide; whiteCastleRightQueenSide = jmpSt_whiteCastleRightQueenSide; blackCastleRightKingSide = jmpSt_blackCastleRightKingSide; blackCastleRightQueenSide = jmpSt_blackCastleRightQueenSide; isWhiteToMove = jmpSt_isWhiteToMove; curSearchZobristKeyLine = (ulong[])jmpSt_curSearchZobristKeyLine.Clone(); allPieceBitboard = blackPieceBitboard | whitePieceBitboard; moveHashList = jmpSt_moveHashList.ToList(); } public void SetJumpState() { jmpSt_pieceTypeArray = (int[])pieceTypeArray.Clone(); jmpSt_whitePieceBitboard = whitePieceBitboard; jmpSt_blackPieceBitboard = blackPieceBitboard; jmpSt_zobristKey = zobristKey; jmpSt_whiteKingSquare = whiteKingSquare; jmpSt_blackKingSquare = blackKingSquare; jmpSt_enPassantSquare = enPassantSquare; jmpSt_happenedHalfMoves = happenedHalfMoves; jmpSt_fiftyMoveRuleCounter = fiftyMoveRuleCounter; jmpSt_whiteCastleRightKingSide = whiteCastleRightKingSide; jmpSt_whiteCastleRightQueenSide = whiteCastleRightQueenSide; jmpSt_blackCastleRightKingSide = blackCastleRightKingSide; jmpSt_blackCastleRightQueenSide = blackCastleRightQueenSide; jmpSt_isWhiteToMove = isWhiteToMove; jmpSt_curSearchZobristKeyLine = (ulong[])curSearchZobristKeyLine.Clone(); jmpSt_moveHashList = moveHashList.ToArray(); } private int PreMinimaxCheckCheckWhite() { ulong bitShiftedKingPos = 1ul << whiteKingSquare; int curR = -1; for (int p = 0; p < 64; p++) { if (ULONG_OPERATIONS.IsBitZero(blackPieceBitboard, p)) continue; int tPT; switch (tPT = pieceTypeArray[p]) { case 1: if ((bitShiftedKingPos & blackPawnAttackSquareBitboards[p]) != 0ul) return p; break; case 2: if ((bitShiftedKingPos & knightSquareBitboards[p]) != 0ul) return p; break; case 6: break; default: if ((squareConnectivesPrecalculationLineArray[whiteKingSquare << 6 | p] & allPieceBitboard) == (1ul << p) && pieceTypeAbilities[tPT, squareConnectivesPrecalculationArray[whiteKingSquare << 6 | p]]) { if (curR != -1) return -779; curR = p; } break; } } return curR; } private int PreMinimaxCheckCheckBlack() { ulong bitShiftedKingPos = 1ul << blackKingSquare; int curR = -1; for (int p = 0; p < 64; p++) { if (ULONG_OPERATIONS.IsBitZero(whitePieceBitboard, p)) continue; int tPT; switch (tPT = pieceTypeArray[p]) { case 1: if ((bitShiftedKingPos & whitePawnAttackSquareBitboards[p]) != 0ul) return p; break; case 2: if ((bitShiftedKingPos & knightSquareBitboards[p]) != 0ul) return p; break; case 6: break; default: if ((squareConnectivesPrecalculationLineArray[blackKingSquare << 6 | p] & allPieceBitboard) == (1ul << p) && pieceTypeAbilities[tPT, squareConnectivesPrecalculationArray[blackKingSquare << 6 | p]]) { if (curR != -1) return -779; curR = p; } break; } } return curR; } private int LecacyLeafCheckingPieceCheckWhite(int pStartPos, int pEndPos, int pPieceType) { int tI, tPossibleAttackPiece; if (pPieceType == 1) { if (ULONG_OPERATIONS.IsBitOne(blackPawnAttackSquareBitboards[pEndPos], whiteKingSquare)) return pEndPos; } else if (pPieceType == 2) { if (ULONG_OPERATIONS.IsBitOne(knightSquareBitboards[pEndPos], whiteKingSquare)) return pEndPos; } else if (pPieceType != 6) { tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | pEndPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; } tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | pStartPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; return -1; } private int LecacyLeafCheckingPieceCheckBlack(int pStartPos, int pEndPos, int pPieceType) { int tI, tPossibleAttackPiece; if (pPieceType == 1) { if (ULONG_OPERATIONS.IsBitOne(whitePawnAttackSquareBitboards[pEndPos], blackKingSquare)) return pEndPos; } else if (pPieceType == 2) { if (ULONG_OPERATIONS.IsBitOne(knightSquareBitboards[pEndPos], blackKingSquare)) return pEndPos; } else if (pPieceType != 6) { tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | pEndPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; } tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | pStartPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; return -1; } public void GetLegalMoves(ref List<Move> pMoveList) { int attk; if (isWhiteToMove) { attk = PreMinimaxCheckCheckWhite(); if (attk == -779) GetLegalWhiteMovesSpecialDoubleCheckCase(ref pMoveList); else GetLegalWhiteMoves(attk, ref pMoveList); } else { attk = PreMinimaxCheckCheckBlack(); if (attk == -779) GetLegalBlackMovesSpecialDoubleCheckCase(ref pMoveList); else GetLegalBlackMoves(attk, ref pMoveList); } } private void GetLegalWhiteMoves(int pCheckingPieceSquare, ref List<Move> pMoveList) { if (pCheckingPieceSquare == -779) { GetLegalWhiteMovesSpecialDoubleCheckCase(ref pMoveList); return; } moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= blackPawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, whiteKingSquare); if (curCheckCount == 0) { if (whiteCastleRightKingSide && ((allPieceBitboard | oppAttkBitboard) & WHITE_KING_ROCHADE) == 0ul) pMoveList.Add(mWHITE_KING_ROCHADE); if (whiteCastleRightQueenSide && (allPieceBitboard & WHITE_QUEEN_ROCHADE | oppAttkBitboard & WHITE_QUEEN_ATTK_ROCHADE) == 0ul) pMoveList.Add(mWHITE_QUEEN_ROCHADE); if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, whitePieceBitboard, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[whiteKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare + 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, whitePieceBitboard, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveList(whiteKingSquare, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalWhiteCaptures(int pCheckingPieceSquare, ref List<Move> pMoveList) { if (pCheckingPieceSquare == -779) { GetLegalWhiteCapturesSpecialDoubleCheckCase(ref pMoveList); return; } moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= blackPawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, whiteKingSquare); if (curCheckCount == 0) { if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & blackPieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[whiteKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare + 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & blackPieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveListOnlyCaptures(whiteKingSquare, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalWhiteMovesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= blackPawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveList(whiteKingSquare, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalWhiteCapturesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= blackPawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveListOnlyCaptures(whiteKingSquare, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalBlackMoves(int pCheckingPieceSquare, ref List<Move> pMoveList) { if (pCheckingPieceSquare == -779) { GetLegalBlackMovesSpecialDoubleCheckCase(ref pMoveList); return; } moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= whitePawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, blackKingSquare); if (curCheckCount == 0) { if (blackCastleRightKingSide && ((allPieceBitboard | oppAttkBitboard) & BLACK_KING_ROCHADE) == 0ul) pMoveList.Add(mBLACK_KING_ROCHADE); if (blackCastleRightQueenSide && (allPieceBitboard & BLACK_QUEEN_ROCHADE | oppAttkBitboard & BLACK_QUEEN_ATTK_ROCHADE) == 0ul) pMoveList.Add(mBLACK_QUEEN_ROCHADE); if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveList(p, blackKingSquare, blackPieceBitboard, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[blackKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare - 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveList(p, blackKingSquare, blackPieceBitboard, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveList(blackKingSquare, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); } private void GetLegalBlackCaptures(int pCheckingPieceSquare, ref List<Move> pMoveList) { if (pCheckingPieceSquare == -779) { GetLegalBlackCapturesSpecialDoubleCheckCase(ref pMoveList); return; } moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= whitePawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, blackKingSquare); if (curCheckCount == 0) { if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & whitePieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[blackKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare - 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & whitePieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveListOnlyCaptures(blackKingSquare, ~oppAttkBitboard & whitePieceBitboard); } private void GetLegalBlackMovesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= whitePawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveList(blackKingSquare, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); } private void GetLegalBlackCapturesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= whitePawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveListOnlyCaptures(blackKingSquare, ~oppAttkBitboard & whitePieceBitboard); } public Move GetMoveOfString(string pMove) { int tSP, tEP; string[] tSpl = pMove.Split(','); if (Char.IsNumber(pMove[0])) { tSP = Convert.ToInt32(tSpl[0]); tEP = Convert.ToInt32(tSpl[1]); } else { tSP = SQUARES.NumberNotation(tSpl[0]); tEP = SQUARES.NumberNotation(tSpl[1]); } int tPT = pieceTypeArray[tSP]; bool tIC = ULONG_OPERATIONS.IsBitOne(allPieceBitboard, tEP), tIEP = enPassantSquare == tEP && tPT == 1; if (tSpl.Length == 3) return new Move(tSP, tEP, tPT, Convert.ToInt32(tSpl[2]), tIC); if (tIEP) return new Move(true, tSP, tEP, isWhiteToMove ? tEP - 8 : tEP + 8); if (tPT == 1 && Math.Abs(tSP - tEP) > 11) return new Move(tSP, tEP, 1, false, isWhiteToMove ? tSP + 8 : tSP - 8); if (tPT == 6 && (Math.Abs(tSP - tEP) == 2 || Math.Abs(tSP - tEP) == 3)) { if (isWhiteToMove) return tEP == 6 ? mWHITE_KING_ROCHADE : mWHITE_QUEEN_ROCHADE; return tEP == 62 ? mBLACK_KING_ROCHADE : mBLACK_QUEEN_ROCHADE; } return new Move(tSP, tEP, tPT, tIC); } public void PlainMakeMove(string pMoveName) { PlainMakeMove(GetMoveOfString(pMoveName)); } public void PlainMakeMove(Move pMove) { lastMadeMove = pMove; if (isWhiteToMove) WhiteMakeMove(pMove); else BlackMakeMove(pMove); } public void WhiteMakeMove(Move pMove) { int tEndPos = pMove.endPos, tStartPos = pMove.startPos, tPieceType = pMove.pieceType, tPTI = pieceTypeArray[tEndPos]; fiftyMoveRuleCounter++; whitePieceBitboard ^= pMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey ^= blackTurnHash ^ enPassantSquareHashes[enPassantSquare] ^ pieceHashesWhite[tStartPos, tPieceType] ^ pieceHashesWhite[tEndPos, tPieceType]; enPassantSquare = 65; isWhiteToMove = false; switch (pMove.moveTypeID) { case 0: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 1: fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 2: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 3: whiteKingSquare = tEndPos; if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 4: if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 5: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 6: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 7: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[whiteKingSquare = tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 8: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 9: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = pMove.enPassantOption]; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 11: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; whiteKingSquare = tEndPos; pieceTypeArray[pMove.rochadeEndPos] = 4; pieceTypeArray[pMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesWhite[pMove.rochadeStartPos, 4] ^ pieceHashesWhite[pMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 12: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[pMove.enPassantOption] = 0; zobristKey ^= pieceHashesBlack[pMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 13: fiftyMoveRuleCounter = 0; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; zobristKey ^= pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, pMove.promotionType]; break; case 14: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, tPTI] ^ pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, pMove.promotionType]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; } moveHashList.Add(pMove.moveHash); if (pMove.isCapture || tPieceType == 1) { curSearchZobristKeyLine = Array.Empty<ulong>(); return; } ulong[] u = new ulong[(tPTI = curSearchZobristKeyLine.Length) + 1]; for (int i = tPTI; i-- > 0;) u[i] = curSearchZobristKeyLine[i]; u[tPTI] = zobristKey; curSearchZobristKeyLine = u; } public void BlackMakeMove(Move pMove) { int tEndPos = pMove.endPos, tStartPos = pMove.startPos, tPieceType = pMove.pieceType, tPTI = pieceTypeArray[tEndPos]; fiftyMoveRuleCounter++; blackPieceBitboard ^= pMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey ^= blackTurnHash ^ enPassantSquareHashes[enPassantSquare] ^ pieceHashesBlack[tStartPos, tPieceType] ^ pieceHashesBlack[tEndPos, tPieceType]; enPassantSquare = 65; isWhiteToMove = true; switch (pMove.moveTypeID) { case 0: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 1: fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 2: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 3: blackKingSquare = tEndPos; if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 4: if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 5: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 6: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 7: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[blackKingSquare = tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 8: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 9: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = pMove.enPassantOption]; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 11: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; blackKingSquare = tEndPos; pieceTypeArray[pMove.rochadeEndPos] = 4; pieceTypeArray[pMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesBlack[pMove.rochadeStartPos, 4] ^ pieceHashesBlack[pMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 12: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[pMove.enPassantOption] = 0; zobristKey ^= pieceHashesWhite[pMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 13: fiftyMoveRuleCounter = 0; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, pMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 14: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } zobristKey ^= pieceHashesWhite[tEndPos, tPTI] ^ pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, pMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; } moveHashList.Add(pMove.moveHash); if (pMove.isCapture || tPieceType == 1) { curSearchZobristKeyLine = Array.Empty<ulong>(); return; } ulong[] u = new ulong[(tPTI = curSearchZobristKeyLine.Length) + 1]; for (int i = tPTI; i-- > 0;) u[i] = curSearchZobristKeyLine[i]; u[tPTI] = zobristKey; curSearchZobristKeyLine = u; } public void WhiteUndoMove(Move pMove) { } private const int WHITE_CHECKMATE_VAL = 100000, BLACK_CHECKMATE_VAL = -100000, CHECK_EXTENSION_LENGTH = -12, MAX_QUIESCENCE_TOTAL_LENGTH = -32; private readonly Move NULL_MOVE = new Move(0, 0, 0); private int curSearchDepth = 0, curSubSearchDepth = -1; public int MinimaxRoot(long pTime) { evalCount = 0; searches++; int baseLineLen = 0; long tTimestamp = globalTimer.ElapsedTicks + pTime; ClearHeuristics(); transpositionTable.Clear(); ulong[] tZobristKeyLine = Array.Empty<ulong>(); if (curSearchZobristKeyLine != null) { baseLineLen = curSearchZobristKeyLine.Length; tZobristKeyLine = new ulong[baseLineLen]; Array.Copy(curSearchZobristKeyLine, tZobristKeyLine, baseLineLen); } int perftScore, tattk = isWhiteToMove ? PreMinimaxCheckCheckWhite() : PreMinimaxCheckCheckBlack(), pDepth = 1; (string, int) bookMoveTuple = TLMDatabase.SearchForNextBookMove(moveHashList); if (bookMoveTuple.Item2 != 0) { int actualMoveHash = NuCRe.GetNumber(bookMoveTuple.Item1); List<Move> tMoves = new List<Move>(); GetLegalMoves(ref tMoves); int tL = tMoves.Count; for (int i = 0; i < tL; i++) { if (tMoves[i].moveHash == actualMoveHash) { if (debugSearchDepthResults) { SNAPSHOT_WRITLINE_REPLACEMENT("TLM_DB_Count: " + bookMoveTuple.Item2); SNAPSHOT_WRITLINE_REPLACEMENT(">> " + tMoves[i]); } transpositionTable.Add(zobristKey, new TranspositionEntry(tMoves[i], Array.Empty<int>())); return 0; } } } do { curSearchDepth = pDepth; curSubSearchDepth = pDepth - 1; ulong[] completeZobristHistory = new ulong[baseLineLen + pDepth - CHECK_EXTENSION_LENGTH + 1]; for (int i = 0; i < baseLineLen; i++) completeZobristHistory[i] = curSearchZobristKeyLine[i]; curSearchZobristKeyLine = completeZobristHistory; if (isWhiteToMove) { if (tattk == -1) perftScore = MinimaxWhite(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); else perftScore = MinimaxWhite(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); } else { if (tattk == -1) perftScore = MinimaxBlack(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); else perftScore = MinimaxBlack(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); } if (debugSearchDepthResults && pTime != 1L) { int tNpS = Convert.ToInt32((double)evalCount * 10_000_000d /(double)(pTime - tTimestamp + globalTimer.ElapsedTicks)); int tSearchEval = perftScore; int timeForSearchSoFar = (int)((pTime - tTimestamp + globalTimer.ElapsedTicks) /10000d); Move tBestMove = transpositionTable[zobristKey].bestMove; SNAPSHOT_WRITLINE_REPLACEMENT((tSearchEval >= 0 ? "+": "") + tSearchEval); SNAPSHOT_WRITLINE_REPLACEMENT(" " + tBestMove + "  ["); SNAPSHOT_WRITLINE_REPLACEMENT("Depth = " + pDepth + ", "); SNAPSHOT_WRITLINE_REPLACEMENT("Evals = " + GetThreeDigitSeperatedInteger(evalCount) + ", "); SNAPSHOT_WRITLINE_REPLACEMENT("Time = " + GetThreeDigitSeperatedInteger(timeForSearchSoFar) + "ms, "); SNAPSHOT_WRITLINE_REPLACEMENT("NpS = " + GetThreeDigitSeperatedInteger(tNpS) + "]"); } pDepth++; } while (globalTimer.ElapsedTicks < tTimestamp && pDepth < 179); depths += pDepth - 1; BOT_MAIN.depthsSearched += pDepth - 1; BOT_MAIN.searchesFinished++; BOT_MAIN.evaluationsMade += evalCount; curSearchZobristKeyLine = tZobristKeyLine; return perftScore; } private int MinimaxWhite(int pPly, int pAlpha, int pBeta, int pDepth, int pRepetitionHistoryPly, int pCheckingSquare, Move pLastMove) { if (IsDrawByRepetition(pRepetitionHistoryPly - 4)) return 0; if ((pDepth <= 0 && pCheckingSquare == -1) || pDepth < CHECK_EXTENSION_LENGTH) return QuiescenceWhite(pPly, pAlpha, pBeta, pDepth - 1, pCheckingSquare, pLastMove); List<Move> moveOptionList = new List<Move>(); Move bestMove = NULL_MOVE; if (pLastMove.isPromotion && pLastMove.isCapture && pLastMove.startPos % 8 == pCheckingSquare % 8 && pLastMove.startPos == whiteKingSquare + 8 && (pLastMove.promotionType == 4 || pLastMove.promotionType == 5)) GetLegalWhiteMovesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalWhiteMoves(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tWhiteKingSquare = whiteKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1, curEval = BLACK_CHECKMATE_VAL - pDepth; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = true; double[] moveSortingArray = new double[molc]; int[] moveSortingArrayIndexes = new int[molc], thisSearchMoveSortingArrayForTransposEntry = new int[molc]; transpositionTable.TryGetValue(zobristKey, out TranspositionEntry transposEntry); if (transposEntry == null) { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; } } else { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove == transposEntry.bestMove) moveSortingArray[m] = BESTMOVE_SORT_VAL; else if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; if (transposEntry.moveGenOrderedEvalLength > m) moveSortingArray[m] -= transposEntry.moveGenOrderedEvals[m]; } } Array.Sort(moveSortingArray, moveSortingArrayIndexes); for (int m = 0; m < molc; m++) { int tActualIndex = moveSortingArrayIndexes[m]; Move curMove = moveOptionList[tActualIndex]; if (debugSortResults && pDepth == curSubSearchDepth) { SNAPSHOT_WRITLINE_REPLACEMENT(moveSortingArray[m] + " | "+ curMove); } int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; whitePieceBitboard = tWPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesWhite[tStartPos, tPieceType] ^ pieceHashesWhite[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 0: blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 1: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 2: blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 3: whiteKingSquare = tEndPos; if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 4: blackPieceBitboard = tBPB; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 5: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[whiteKingSquare = tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = curMove.enPassantOption]; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 11: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; whiteKingSquare = tEndPos; blackPieceBitboard = tBPB; pieceTypeArray[curMove.rochadeEndPos] = 4; pieceTypeArray[curMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesWhite[curMove.rochadeStartPos, 4] ^ pieceHashesWhite[curMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | curMove.rochadeEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << curMove.rochadeEndPos)) tCheckPos = curMove.rochadeEndPos; break; case 12: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesBlack[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 13: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; zobristKey ^= pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, curMove.promotionType]; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; case 14: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, tPTI] ^ pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, curMove.promotionType]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } curSearchZobristKeyLine[pRepetitionHistoryPly] = zobristKey; int tEval = MinimaxBlack(pPly + 1, pAlpha, pBeta, pDepth - 1, pRepetitionHistoryPly + 1, tCheckPos, curMove); thisSearchMoveSortingArrayForTransposEntry[tActualIndex] = tEval; pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 3: whiteKingSquare = tWhiteKingSquare; break; case 7: whiteKingSquare = tWhiteKingSquare; break; case 10: enPassantSquare = 65; break; case 11: whiteKingSquare = tWhiteKingSquare; pieceTypeArray[curMove.rochadeStartPos] = 4; pieceTypeArray[curMove.rochadeEndPos] = 0; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 13: pieceTypeArray[tStartPos] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval > curEval) { bestMove = curMove; curEval = tEval; } if (pAlpha < curEval) pAlpha = curEval; if (curEval >= pBeta) { if (!curMove.isCapture) { killerMoveHeuristic[curMove.moveHash] = true; if (pDepth > 0) historyHeuristic[curMove.moveHash] += pDepth * pDepth; } break; } } isWhiteToMove = true; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; if (molc == 0 && pCheckingSquare == 0) curEval = 0; if (!transpositionTable.ContainsKey(zobristKey)) transpositionTable.Add(zobristKey, new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry)); else transpositionTable[zobristKey] = new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry); return curEval; } private int QuiescenceWhite(int pPly, int pAlpha, int pBeta, int pDepth, int pCheckingSquare, Move pLastMove) { int standPat = TexelEvaluate(); if (standPat >= pBeta || pDepth < MAX_QUIESCENCE_TOTAL_LENGTH) return pBeta; if (standPat > pAlpha) pAlpha = standPat; List<Move> moveOptionList = new List<Move>(); if (pLastMove.isPromotion && pLastMove.isCapture && pLastMove.startPos % 8 == pCheckingSquare % 8 && pLastMove.startPos == whiteKingSquare + 8 && (pLastMove.promotionType == 4 || pLastMove.promotionType == 5)) GetLegalWhiteCapturesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalWhiteCaptures(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tWhiteKingSquare = whiteKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = true; for (int m = 0; m < molc; m++) { Move curMove = moveOptionList[m]; int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; whitePieceBitboard = tWPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesWhite[tStartPos, tPieceType] ^ pieceHashesWhite[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 5: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[whiteKingSquare = tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 12: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesBlack[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 14: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, tPTI] ^ pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, curMove.promotionType]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } int tEval = QuiescenceBlack(pPly + 1, pAlpha, pBeta, pDepth - 1, tCheckPos, curMove); pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 7: whiteKingSquare = tWhiteKingSquare; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval >= pBeta) return pBeta; if (pAlpha < tEval) pAlpha = tEval; } isWhiteToMove = true; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; return pAlpha; } private int MinimaxBlack(int pPly, int pAlpha, int pBeta, int pDepth, int pRepetitionHistoryPly, int pCheckingSquare, Move pLastMove) { if (IsDrawByRepetition(pRepetitionHistoryPly - 4)) return 0; if ((pDepth <= 0 && pCheckingSquare == -1) || pDepth < CHECK_EXTENSION_LENGTH) return QuiescenceBlack(pPly, pAlpha, pBeta, pDepth - 1, pCheckingSquare, pLastMove); List<Move> moveOptionList = new List<Move>(); Move bestMove = NULL_MOVE; if (pLastMove.isPromotion && pLastMove.isCapture && pLastMove.startPos % 8 == pCheckingSquare % 8 && pLastMove.startPos == blackKingSquare - 8 && (pLastMove.promotionType == 4 || pLastMove.promotionType == 5)) GetLegalBlackMovesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalBlackMoves(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tBlackKingSquare = blackKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1, curEval = WHITE_CHECKMATE_VAL + pDepth; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = false; double[] moveSortingArray = new double[molc]; int[] moveSortingArrayIndexes = new int[molc], thisSearchMoveSortingArrayForTransposEntry = new int[molc]; transpositionTable.TryGetValue(zobristKey, out TranspositionEntry transposEntry); if (transposEntry == null) { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; } } else { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove == transposEntry.bestMove) moveSortingArray[m] = BESTMOVE_SORT_VAL; else if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; if (transposEntry.moveGenOrderedEvalLength > m) moveSortingArray[m] -= transposEntry.moveGenOrderedEvals[m]; } } Array.Sort(moveSortingArray, moveSortingArrayIndexes); for (int m = 0; m < molc; m++) { int tActualIndex = moveSortingArrayIndexes[m]; Move curMove = moveOptionList[tActualIndex]; if (debugSortResults && pDepth == curSearchDepth) { SNAPSHOT_WRITLINE_REPLACEMENT("=== " + moveSortingArray[m] + " | "+ curMove); } int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; blackPieceBitboard = tBPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesBlack[tStartPos, tPieceType] ^ pieceHashesBlack[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 0: whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 1: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 2: whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 3: blackKingSquare = tEndPos; if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 4: whitePieceBitboard = tWPB; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 5: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[blackKingSquare = tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = curMove.enPassantOption]; whitePieceBitboard = tWPB; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 11: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; blackKingSquare = tEndPos; whitePieceBitboard = tWPB; pieceTypeArray[curMove.rochadeEndPos] = 4; pieceTypeArray[curMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesBlack[curMove.rochadeStartPos, 4] ^ pieceHashesBlack[curMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | curMove.rochadeEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << curMove.rochadeEndPos)) tCheckPos = curMove.rochadeEndPos; break; case 12: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesWhite[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 13: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, curMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; case 14: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } zobristKey ^= pieceHashesWhite[tEndPos, tPTI] ^ pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, curMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } curSearchZobristKeyLine[pRepetitionHistoryPly] = zobristKey; int tEval = MinimaxWhite(pPly + 1, pAlpha, pBeta, pDepth - 1, pRepetitionHistoryPly + 1, tCheckPos, curMove); thisSearchMoveSortingArrayForTransposEntry[tActualIndex] = tEval; pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 3: blackKingSquare = tBlackKingSquare; break; case 7: blackKingSquare = tBlackKingSquare; break; case 10: enPassantSquare = 65; break; case 11: blackKingSquare = tBlackKingSquare; pieceTypeArray[curMove.rochadeStartPos] = 4; pieceTypeArray[curMove.rochadeEndPos] = 0; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 13: pieceTypeArray[tStartPos] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval < curEval) { bestMove = curMove; curEval = tEval; } if (pBeta > curEval) pBeta = curEval; if (curEval <= pAlpha) { if (!curMove.isCapture) { killerMoveHeuristic[curMove.moveHash] = true; if (pDepth > 0) historyHeuristic[curMove.moveHash] += pDepth * pDepth; } break; } } isWhiteToMove = false; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; if (molc == 0 && pCheckingSquare == 0) curEval = 0; if (!transpositionTable.ContainsKey(zobristKey)) transpositionTable.Add(zobristKey, new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry)); else transpositionTable[zobristKey] = new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry); return curEval; } private int QuiescenceBlack(int pPly, int pAlpha, int pBeta, int pDepth, int pCheckingSquare, Move pLastMove) { int standPat = TexelEvaluate(); if (standPat <= pAlpha || pDepth < MAX_QUIESCENCE_TOTAL_LENGTH) return pAlpha; if (standPat < pBeta) pBeta = standPat; List<Move> moveOptionList = new List<Move>(); if (pLastMove.isPromotion && pLastMove.isCapture && pLastMove.startPos % 8 == pCheckingSquare % 8 && pLastMove.startPos == blackKingSquare - 8 && (pLastMove.promotionType == 4 || pLastMove.promotionType == 5)) GetLegalBlackCapturesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalBlackCaptures(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tBlackKingSquare = blackKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = false; for (int m = 0; m < molc; m++) { Move curMove = moveOptionList[m]; int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; blackPieceBitboard = tBPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesBlack[tStartPos, tPieceType] ^ pieceHashesBlack[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 5: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[blackKingSquare = tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 12: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesWhite[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 14: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } zobristKey ^= pieceHashesWhite[tEndPos, tPTI] ^ pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, curMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } int tEval = QuiescenceWhite(pPly + 1, pAlpha, pBeta, pDepth - 1, tCheckPos, curMove); pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 7: blackKingSquare = tBlackKingSquare; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval <= pAlpha) return pAlpha; if (pBeta > tEval) pBeta = tEval; } isWhiteToMove = false; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; return pBeta; } private bool[] killerMoveHeuristic = new bool[262_144]; private int[] historyHeuristic = new int[262_144]; public void ClearHeuristics() { for (int i = 0; i < 262_144; i++) { killerMoveHeuristic[i] = false; historyHeuristic[i] = 0; } } private Dictionary<ulong, TranspositionEntry> transpositionTable = new Dictionary<ulong, TranspositionEntry>(); private int[] pieceEvals = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[,][] piecePositionEvals = new int[33, 14][]; private int evalCount = 0; private int Evaluate() { evalCount++; if (fiftyMoveRuleCounter > 99) return 0; int tEval = 0, tPT, pieceCount = ULONG_OPERATIONS.CountBits(allPieceBitboard); for (int p = 0; p < 64; p++) tEval += pieceEvals[tPT = pieceTypeArray[p] + 7 * ((int)(blackPieceBitboard >> p) & 1)] + piecePositionEvals[pieceCount, tPT][p]; return tEval; } public int GameState(bool pWhiteKingCouldBeAttacked) { if (IsDrawByRepetition(curSearchZobristKeyLine.Length - 5) || fiftyMoveRuleCounter > 99) return 0; int t; List<Move> tMoves = new List<Move>(); GetLegalMoves(ref tMoves); if (pWhiteKingCouldBeAttacked) { t = PreMinimaxCheckCheckWhite(); if (t == -1) return tMoves.Count == 0 ? 0 : 3; else if (tMoves.Count == 0) return -1; } else { t = PreMinimaxCheckCheckBlack(); if (t == -1) return tMoves.Count == 0 ? 0 : 3; else if (tMoves.Count == 0) return 1; } return 3; } private bool IsDrawByRepetition(int pPlyOfFirstPossibleRepeatedPosition) { int tC = 0; for (int i = pPlyOfFirstPossibleRepeatedPosition; i >= 0; i -= 2) { if (curSearchZobristKeyLine[i] == zobristKey) if (++tC == 2) return true; } return false; } private const int RELE_MAX_MOVE_COUNT_PER_GAME = 500; public double ReLePlayGame(int[,][] pEvalPositionValuesWhite, int[,][] pEvalPositionValuesBlack, long thinkingTimePerMove) { int[,][] processedValuesWhite = InitReLeAgent(pEvalPositionValuesWhite), processedValuesBlack = InitReLeAgent(pEvalPositionValuesBlack); int tGS, mc = 0; do { if (IsDrawByRepetition(curSearchZobristKeyLine.Length - 5)) return 0d; piecePositionEvals = isWhiteToMove ? processedValuesWhite : processedValuesBlack; MinimaxRoot(thinkingTimePerMove); if (transpositionTable.Count == 0) { SNAPSHOT_WRITLINE_REPLACEMENT("?!"); return 0d; } PlainMakeMove(transpositionTable[zobristKey].bestMove); tGS = GameState(isWhiteToMove); transpositionTable.Clear(); if (tGS != 3) break; } while (mc++ < RELE_MAX_MOVE_COUNT_PER_GAME); if (tGS == 3 || tGS == 0) return 0d; else if (tGS == 1) return 0.1d * (double)(RELE_MAX_MOVE_COUNT_PER_GAME - mc); return 0.1d * (double)(-RELE_MAX_MOVE_COUNT_PER_GAME + mc); } public int[,][] InitReLeAgent(int[,][] pEvalPositionValues) { return GetInterpolatedProcessedValues(pEvalPositionValues); } private int[,][] GetInterpolatedProcessedValues(int[,][] pEvalPositionValues) { int[,][] processedValues = new int[33, 14][]; for (int i = 0; i < 32; i++) { int ip1 = i + 1; processedValues[ip1, 7] = processedValues[ip1, 0] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; processedValues[ip1, 8] = SwapArrayViewingSide(processedValues[ip1, 1] = MultiplyArraysWithVal(pEvalPositionValues[0, 0], pEvalPositionValues[1, 0], pEvalPositionValues[2, 0], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 9] = SwapArrayViewingSide(processedValues[ip1, 2] = MultiplyArraysWithVal(pEvalPositionValues[0, 1], pEvalPositionValues[1, 1], pEvalPositionValues[2, 1], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 10] = SwapArrayViewingSide(processedValues[ip1, 3] = MultiplyArraysWithVal(pEvalPositionValues[0, 2], pEvalPositionValues[1, 2], pEvalPositionValues[2, 2], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 11] = SwapArrayViewingSide(processedValues[ip1, 4] = MultiplyArraysWithVal(pEvalPositionValues[0, 3], pEvalPositionValues[1, 3], pEvalPositionValues[2, 3], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 12] = SwapArrayViewingSide(processedValues[ip1, 5] = MultiplyArraysWithVal(pEvalPositionValues[0, 4], pEvalPositionValues[1, 4], pEvalPositionValues[2, 4], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 13] = SwapArrayViewingSide(processedValues[ip1, 6] = MultiplyArraysWithVal(pEvalPositionValues[0, 5], pEvalPositionValues[1, 5], pEvalPositionValues[2, 5], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); } return processedValues; } private double[,][] GetInterpolatedProcessedValues(double[,][] pEvalPositionValues) { double[,][] processedValues = new double[33, 14][]; for (int i = 0; i < 32; i++) { int ip1 = i + 1; processedValues[ip1, 7] = processedValues[ip1, 0] = new double[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; processedValues[ip1, 8] = SwapArrayViewingSide(processedValues[ip1, 1] = MultiplyArraysWithVal(pEvalPositionValues[0, 0], pEvalPositionValues[1, 0], pEvalPositionValues[2, 0], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 9] = SwapArrayViewingSide(processedValues[ip1, 2] = MultiplyArraysWithVal(pEvalPositionValues[0, 1], pEvalPositionValues[1, 1], pEvalPositionValues[2, 1], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 10] = SwapArrayViewingSide(processedValues[ip1, 3] = MultiplyArraysWithVal(pEvalPositionValues[0, 2], pEvalPositionValues[1, 2], pEvalPositionValues[2, 2], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 11] = SwapArrayViewingSide(processedValues[ip1, 4] = MultiplyArraysWithVal(pEvalPositionValues[0, 3], pEvalPositionValues[1, 3], pEvalPositionValues[2, 3], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 12] = SwapArrayViewingSide(processedValues[ip1, 5] = MultiplyArraysWithVal(pEvalPositionValues[0, 4], pEvalPositionValues[1, 4], pEvalPositionValues[2, 4], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 13] = SwapArrayViewingSide(processedValues[ip1, 6] = MultiplyArraysWithVal(pEvalPositionValues[0, 5], pEvalPositionValues[1, 5], pEvalPositionValues[2, 5], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); } return processedValues; } private double[] MultiplyArraysWithVal(double[] pArr1, double[] pArr2, double[] pArr3, double pVal1, double pVal2, double pVal3) { int tL = pArr1.Length; double[] rArr = new double[tL]; for (int i = 0; i < tL; i++) { rArr[i] = pArr1[i] * pVal1 + pArr2[i] * pVal2 + pArr3[i] * pVal3; } return rArr; } private int[] MultiplyArraysWithVal(int[] pArr1, int[] pArr2, int[] pArr3, double pVal1, double pVal2, double pVal3) { int tL = pArr1.Length; int[] rArr = new int[tL]; for (int i = 0; i < tL; i++) { rArr[i] = (int)(pArr1[i] * pVal1 + pArr2[i] * pVal2 + pArr3[i] * pVal3); } return rArr; } private int[] SwapArrayViewingSideAndNegate(int[] pArr) { return new int[64] { -pArr[56], -pArr[57], -pArr[58], -pArr[59], -pArr[60], -pArr[61], -pArr[62], -pArr[63], -pArr[48], -pArr[49], -pArr[50], -pArr[51], -pArr[52], -pArr[53], -pArr[54], -pArr[55], -pArr[40], -pArr[41], -pArr[42], -pArr[43], -pArr[44], -pArr[45], -pArr[46], -pArr[47], -pArr[32], -pArr[33], -pArr[34], -pArr[35], -pArr[36], -pArr[37], -pArr[38], -pArr[39], -pArr[24], -pArr[25], -pArr[26], -pArr[27], -pArr[28], -pArr[29], -pArr[30], -pArr[31], -pArr[16], -pArr[17], -pArr[18], -pArr[19], -pArr[20], -pArr[21], -pArr[22], -pArr[23], -pArr[8], -pArr[9], -pArr[10], -pArr[11], -pArr[12], -pArr[13], -pArr[14], -pArr[15], -pArr[0], -pArr[1], -pArr[2], -pArr[3], -pArr[4], -pArr[5], -pArr[6], -pArr[7] }; } private int[] SwapArrayViewingSide(int[] pArr) { return new int[64] { pArr[56], pArr[57], pArr[58], pArr[59], pArr[60], pArr[61], pArr[62], pArr[63], pArr[48], pArr[49], pArr[50], pArr[51], pArr[52], pArr[53], pArr[54], pArr[55], pArr[40], pArr[41], pArr[42], pArr[43], pArr[44], pArr[45], pArr[46], pArr[47], pArr[32], pArr[33], pArr[34], pArr[35], pArr[36], pArr[37], pArr[38], pArr[39], pArr[24], pArr[25], pArr[26], pArr[27], pArr[28], pArr[29], pArr[30], pArr[31], pArr[16], pArr[17], pArr[18], pArr[19], pArr[20], pArr[21], pArr[22], pArr[23], pArr[8], pArr[9], pArr[10], pArr[11], pArr[12], pArr[13], pArr[14], pArr[15], pArr[0], pArr[1], pArr[2], pArr[3], pArr[4], pArr[5], pArr[6], pArr[7] }; } private double[] SwapArrayViewingSide(double[] pArr) { return new double[64] { pArr[56], pArr[57], pArr[58], pArr[59], pArr[60], pArr[61], pArr[62], pArr[63], pArr[48], pArr[49], pArr[50], pArr[51], pArr[52], pArr[53], pArr[54], pArr[55], pArr[40], pArr[41], pArr[42], pArr[43], pArr[44], pArr[45], pArr[46], pArr[47], pArr[32], pArr[33], pArr[34], pArr[35], pArr[36], pArr[37], pArr[38], pArr[39], pArr[24], pArr[25], pArr[26], pArr[27], pArr[28], pArr[29], pArr[30], pArr[31], pArr[16], pArr[17], pArr[18], pArr[19], pArr[20], pArr[21], pArr[22], pArr[23], pArr[8], pArr[9], pArr[10], pArr[11], pArr[12], pArr[13], pArr[14], pArr[15], pArr[0], pArr[1], pArr[2], pArr[3], pArr[4], pArr[5], pArr[6], pArr[7] }; } private int[,][] texelTuningRuntimeVals = new int[33, 14][]; private int[,][] texelTuningVals = new int[3, 6][]; private int[,] texelTuningAdjustIterations = new int[6, 64]; private int[][] texelTuningRuntimePositionalValsV2EG = new int[14][]; private int[][] texelTuningRuntimePositionalValsV2LG = new int[14][]; private int[] texelPieceEvaluationsV2EG = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[] texelPieceEvaluationsV2LG = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[] texelKingSafetyR1EvaluationsEG = new int[9]; private int[] texelKingSafetyR2EvaluationsEG = new int[17]; private int[] texelKingSafetyR1EvaluationsLG = new int[9]; private int[] texelKingSafetyR2EvaluationsLG = new int[17]; private int[] texelKingSafetySREvaluationsPT1EG = new int[12]; private int[] texelKingSafetySREvaluationsPT2EG = new int[12]; private int[] texelKingSafetySREvaluationsPT3EG = new int[12]; private int[] texelKingSafetySREvaluationsPT4EG = new int[12]; private int[] texelKingSafetySREvaluationsPT5EG = new int[12]; private int[] texelKingSafetySREvaluationsPT6EG = new int[12]; private int[] texelKingSafetySREvaluationsPT1LG = new int[12]; private int[] texelKingSafetySREvaluationsPT2LG = new int[12]; private int[] texelKingSafetySREvaluationsPT3LG = new int[12]; private int[] texelKingSafetySREvaluationsPT4LG = new int[12]; private int[] texelKingSafetySREvaluationsPT5LG = new int[12]; private int[] texelKingSafetySREvaluationsPT6LG = new int[12]; private int[,] texelMobilityStraightEG = new int[14, 15], texelMobilityStraightLG = new int[14, 15]; private int[,] texelMobilityDiagonalEG = new int[14, 14], texelMobilityDiagonalLG = new int[14, 14]; private int[] texelPieceEvaluations = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[] blackSidedSquares = new int[64] { 56, 57, 58, 59, 60, 61, 62, 63, 48, 49, 50, 51, 52, 53, 54, 55, 40, 41, 42, 43, 44, 45, 46, 47, 32, 33, 34, 35, 36, 37, 38, 39, 24, 25, 26, 27, 28, 29, 30, 31, 16, 17, 18, 19, 20, 21, 22, 23, 08, 09, 10, 11, 12, 13, 14, 15, 00, 01, 02, 03, 04, 05, 06, 07 }; private int[,] T_Pawns = new int[3, 64] { { 0, 0, 0, 0, 0, 0, 0, 0, 98, 134, 61, 95, 68, 126, 34, -11, -6, 7, 26, 31, 65, 56, 25, -20, -14, 13, 6, 21, 23, 12, 17, -23, -27, -2, -5, 12, 17, 6, 10, -25, -26, -4, -4, -10, 3, 3, 33, -12, -35, -1, -20, -23, -15, 24, 38, -22, 0, 0, 0, 0, 0, 0, 0, 0, } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { 0, 0, 0, 0, 0, 0, 0, 0, 178, 173, 158, 134, 147, 132, 165, 187, 94, 100, 85, 67, 56, 53, 82, 84, 32, 24, 13, 5, -2, 4, 17, 17, 13, 9, -3, -7, -7, -8, 3, -1, 4, 7, -6, 1, 0, -5, -1, -8, 13, 8, 8, 10, 13, 0, 2, -7, 0, 0, 0, 0, 0, 0, 0, 0, } }; private int[,] T_Knights = new int[3, 64] { { -167, -89, -34, -49, 61, -97, -15, -107, -73, -41, 72, 36, 23, 62, 7, -17, -47, 60, 37, 65, 84, 129, 73, 44, -9, 17, 19, 53, 37, 69, 18, 22, -13, 4, 16, 13, 28, 19, 21, -8, -23, -9, 12, 10, 19, 17, 25, -16, -29, -53, -12, -3, -1, 18, -14, -19, -105, -21, -58, -33, -17, -28, -19, -23 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -58, -38, -13, -28, -31, -27, -63, -99, -25, -8, -25, -2, -9, -25, -24, -52, -24, -20, 10, 9, -1, -9, -19, -41, -17, 3, 22, 22, 22, 11, 8, -18, -18, -6, 16, 25, 16, 17, 4, -18, -23, -3, -1, 15, 10, -3, -20, -22, -42, -20, -10, -5, -2, -20, -23, -44, -29, -51, -23, -15, -22, -18, -50, -64 } }; private int[,] T_Bishops = new int[3, 64] { { -29, 4, -82, -37, -25, -42, 7, -8, -26, 16, -18, -13, 30, 59, 18, -47, -16, 37, 43, 40, 35, 50, 37, -2, -4, 5, 19, 50, 37, 37, 7, -2, -6, 13, 13, 26, 34, 12, 10, 4, 0, 15, 15, 15, 14, 27, 18, 10, 4, 15, 16, 0, 7, 21, 33, 1, -33, -3, -14, -21, -13, -12, -39, -21 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -14, -21, -11, -8, -7, -9, -17, -24, -8, -4, 7, -12, -3, -13, -4, -14, 2, -8, 0, -1, -2, 6, 0, 4, -3, 9, 12, 9, 14, 10, 3, 2, -6, 3, 13, 19, 7, 10, -3, -9, -12, -3, 8, 10, 13, 3, -7, -15, -14, -18, -7, -1, 4, -9, -15, -27, -23, -9, -23, -5, -9, -16, -5, -17 } }; private int[,] T_Rooks = new int[3, 64] { { 32, 42, 32, 51, 63, 9, 31, 43, 27, 32, 58, 62, 80, 67, 26, 44, -5, 19, 26, 36, 17, 45, 61, 16, -24, -11, 7, 26, 24, 35, -8, -20, -36, -26, -12, -1, 9, -7, 6, -23, -45, -25, -16, -17, 3, 0, -5, -33, -44, -16, -20, -9, -1, 11, -6, -71, -19, -13, 1, 17, 16, 7, -37, -26 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { 13, 10, 18, 15, 12, 12, 8, 5, 11, 13, 13, 11, -3, 3, 8, 3, 7, 7, 7, 5, 4, -3, -5, -3, 4, 3, 13, 1, 2, 1, -1, 2, 3, 5, 8, 4, -5, -6, -8, -11, -4, 0, -5, -1, -7, -12, -8, -16, -6, -6, 0, 2, -9, -9, -11, -3, -9, 2, 3, -1, -5, -13, 4, -20 } }; private int[,] T_Queens = new int[3, 64] { { -28, 0, 29, 12, 59, 44, 43, 45, -24, -39, -5, 1, -16, 57, 28, 54, -13, -17, 7, 8, 29, 56, 47, 57, -27, -27, -16, -16, -1, 17, -2, 1, -9, -26, -9, -10, -2, -4, 3, -3, -14, 2, -11, -2, -5, 2, 14, 5, -35, -8, 11, 2, 8, 15, -3, 1, -1, -18, -9, 10, -15, -25, -31, -50 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -9, 22, 22, 27, 27, 19, 10, 20, -17, 20, 32, 41, 58, 25, 30, 0, -20, 6, 9, 49, 47, 35, 19, 9, 3, 22, 24, 45, 57, 40, 57, 36, -18, 28, 19, 47, 31, 34, 39, 23, -16, -27, 15, 6, 9, 17, 10, 5, -22, -23, -30, -16, -16, -23, -36, -32, -33, -28, -22, -43, -5, -32, -20, -41 } }; private int[,] T_Kings = new int[3, 64] { { -65, 23, 16, -15, -56, -34, 2, 13, 29, -1, -20, -7, -8, -4, -38, -29, -9, 24, 2, -16, -20, 6, 22, -22, -17, -20, -12, -27, -30, -25, -14, -36, -49, -1, -27, -39, -46, -44, -33, -51, -14, -14, -22, -46, -44, -30, -15, -27, 1, 7, -8, -64, -43, -16, 9, 8, -15, 36, 12, -54, 8, -28, 24, 14 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -74, -35, -18, -18, -11, 15, 4, -17, -12, 17, 14, 17, 17, 38, 23, 11, 10, 17, 23, 15, 20, 45, 44, 13, -8, 22, 24, 27, 26, 33, 26, 3, -18, -4, 21, 24, 27, 23, 9, -11, -19, -3, 11, 21, 23, 16, 7, -9, -27, -11, 4, 13, 14, 4, -5, -17, -53, -34, -21, -11, -28, -14, -24, -43 } }; private int[] paramsLowerLimits = new int[5] { -10000, -10000, -10000, -10000, -10000 }; private int[] paramsUpperLimits = new int[5] { 10000, 10000, 10000, 10000, 10000 }; private List<TLM_ChessGame> threadDataset; private int threadFrom, threadTo; private int[] threadParams; private int customThreadID = 0; private ulong ulAllThreadIDsUnfinished = 0; private double lastCostVal = 0d; private double sumCostVals = 0d; private int costCalculations = 0; private readonly string[] TEXELPRINT_GAMEPARTS = new string[3] { "Early Game: ", "Mid Game: ", "Late Game: "}; private readonly string[] TEXELPRINT_PIECES = new string[6] { "Bauer: ", "Springer: ", "Lufer: ", "Turm: ", "Dame: ", "Knig: "}; private double[] earlyGameMultipliers = new double[33]; private double[] middleGameMultipliers = new double[33]; private double[] lateGameMultipliers = new double[33]; private int[] pieceTypeGameProgressImpact = new int[14] { 0, 0, 1, 1, 2, 4, 0, 0, 0, 1, 1, 2, 4, 0 }; private void PrecalculateMultipliers() { if (BOARD_MANAGER_ID == ENGINE_VALS.PARALLEL_BOARDS - 1) SNAPSHOT_WRITLINE_REPLACEMENT(); for (int i = 0; i < 25; i++) { earlyGameMultipliers[i] = EGMultiplierFunction(i); lateGameMultipliers[i] = LGMultiplierFunction(i); if (BOARD_MANAGER_ID == ENGINE_VALS.PARALLEL_BOARDS - 1) SNAPSHOT_WRITLINE_REPLACEMENT("[" + i + "] "+ earlyGameMultipliers[i] + " | "+ middleGameMultipliers[i] + " | "+ lateGameMultipliers[i]); } } private double MultiplierFunction(double pVal, double pXShift) { double d = Math.Exp(1d /6d * (pVal - pXShift)); return 5 * (d /Math.Pow(d + 1, 2d)); } private double EGMultiplierFunction(double pVal) { return Math.Clamp(1 /16d * (pVal - 4d), 0d, 1d); } private double LGMultiplierFunction(double pVal) { return Math.Clamp(1 /-16d * (pVal - 4d) + 1d, 0d, 1d); } private double EGMultiplierFunction2(double pVal) { return Math.Clamp(1 /32d * pVal, 0d, 1d); } private double LGMultiplierFunction2(double pVal) { return Math.Clamp(1 /-32d * pVal + 1d, 0d, 1d); } private void TuneWithTxtFile(string pTXTName) { List<TLM_ChessGame> gameDataset = new List<TLM_ChessGame>(); string tPath = PathManager.GetTXTPath(pTXTName); string[] tStrs = File.ReadAllLines(tPath); List<string> tGames = new List<string>(); foreach (string s in tStrs) if (s.Contains(';') && s.Replace(" ", "") != "") tGames.Add(s); foreach (string s in tGames) { TLM_ChessGame tGame = CGFF.GetGame(s); LoadFenString(tGame.startFen); foreach (int hMove in tGame.hashedMoves) { List<Move> moveOptionList = new List<Move>(); GetLegalMoves(ref moveOptionList); int tL = moveOptionList.Count; for (int j = 0; j < tL; j++) { Move tMove = moveOptionList[j]; if (tMove.moveHash == hMove) { tGame.actualMoves.Add(tMove); PlainMakeMove(tMove); tL = -1; break; } } if (tL != -1) break; } gameDataset.Add(tGame); } SNAPSHOT_WRITLINE_REPLACEMENT("[TLM TEXEL TUNER] " + tGames.Count + " Games Loaded In!"); BOT_MAIN.curTEXELPARAMS = new int[TEXEL_PARAMS]; BOT_MAIN.ParallelTexelTuning(gameDataset); } private void LoadBestTexelParamsIn() { int[] ttt = new int[778] { 72, 300, 484, 528, 904, 128, 272, 280, 504, 720, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -56, 88, -92, -200, 56, -40, -48, -148, -100, 96, -32, -100, 8, -28, -8, 32, -64, -200, 44, -184, 12, -8, 96, -200, -16, -104, -40, 40, 24, -134, -136, -8, -16, 80, -8, -32, 136, -120, -12, -136, -16, 20, -136, 68, 32, -200, 0, 88, -176, 128, -72, 128, 88, -200, 104, -200, 124, 40, 64, 84, 8, -124, -48, 128, 100, -36, -32, -32, -64, 200, -200, 200, 200, -200, 8, 156, -20, 76, 72, 200, 196, 200, 200, 200, -66, 8, 200, 200, -200, 200, -200, 200, 56, 200, -200, 200, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -200, -200, -28, 200, -200, -22, 200, 192, 172, 200, 12, 120, 12, -200, -200, 200, 18, -194, 200, -200, 46, -168, 52, 200, 176, 56, -56, 200, -40, 32, 8, 200, 70, -176, -112, 200, 168, -48, 192, 76, 192, -72, 136, 46, 64, -200, -24, -200, 172, -200, -200, 88, 24, 200, 112, -68, 200, 200, 168, -120, 200, -88, -12, 200, 76, 40, 56, 200, 200, 200, 64, -200, 138, -56, 200, -16, 96, 136, 200, -112, 200, 200, 200, 200, 101, -200, 176, 200, -200, 200, 120, -200, 54, -128, 200, -24, -200, 200, 200, -72, 200, 200, 200, 200, -200, -200, 176, -200, 80, 176, 200, -24, 112, -200, 200, 200, -200, -200, -200, 128, -200, 112, -200, -200, 200, -200, 16, -200, 16, -80, -200, 184, -8, 200, -32, -200, -176, -200, -56, 200, 56, 200, -104, -152, -200, 200, 32, 200, 112, 8, -24, 160, 92, -76, -120, -200, 64, -200, 200, -200, 32, 136, -140, -144, 24, 8, 16, 200, 132, 24, 40, -24, -62, -200, 200, -15, -8, -116, 148, 200, -76, 200, 200, -200, 96, -200, 8, 200, -148, -200, -200, 188, 200, 86, 64, 80, -180, -200, 64, 200, 200, 200, -200, -132, 184, -184, 200, -156, -136, -200, 200, -104, -184, 60, -200, -184, -32, 0, -169, 96, 200, 200, 200, 200, 200, 200, -200, -200, 200, -200, -200, 68, -200, -200, 200, 200, -200, 176, -200, 200, -56, 200, -200, 152, -200, -168, -46, -200, 200, -200, -200, 192, -200, 68, -200, -200, -16, 16, 4, 200, -168, 112, 176, -200, 92, -128, -200, 16, 34, 144, -68, 24, -40, -200, -64, 40, -128, 152, 48, -24, -200, -35, 200, -56, -88, 4, -96, 128, 200, -200, 200, -100, 200, -80, 32, -172, 200, -200, -40, -200, -78, 200, 96, -24, -26, 200, 80, -32, 200, -76, 200, 48, 200, -200, 16, -148, -200, -64, 32, -72, 120, -180, 200, 84, 200, 136, 200, 200, 200, 200, -52, 200, 72, 200, 200, -200, -64, 200, 200, -144, -136, 40, 200, -104, -8, 200, 88, -200, -173, -112, 200, -88, -40, 200, 32, -200, -200, 72, 200, 68, 200, -156, -200, -40, 128, 4, 144, -88, -200, 200, 174, -136, 200, -200, 184, -176, 200, -56, -200, 200, -200, -152, -200, 160, 200, -171, -96, -200, 88, 200, -62, 72, -200, -200, -200, 200, 194, -200, -200, -200, -140, 200, -32, 56, 88, 200, 200, 200, -53, -200, -38, -200, 84, -200, -200, 200, -8, 100, 3, -140, 38, 172, -48, 200, -20, -160, 80, -200, 200, -200, -200, 200, -200, -200, -56, -52, -72, -124, 80, 80, 88, -8, 104, -88, 104, 200, -24, -200, -8, -200, -80, 22, 164, 200, 152, 80, 104, -200, 88, -104, 200, 200, 25, 200, -112, -200, 56, -200, 200, 200, 100, -80, 176, 200, 200, 104, 200, 200, -200, -200, 24, 200, 200, 200, 200, -200, -200, -30, 200, 200, 200, 48, 200, 200, -76, -200, 200, -184, 200, 200, -200, -200, 174, 200, 108, 192, 128, 200, 80, 200, 200, 40, -200, -200, -48, -84, -88, 64, -24, -200, 8, -16, 160, -200, 176, -100, 200, 200, -200, -174, 48, -112, 72, 44, -136, -84, 44, -104, 64, -16, -96, 200, 64, -200, -200, 200, -200, 80, -200, 144, -200, 144, -192, 152, -104, 24, -200, 200, -200, -136, -8, -112, -200, -200, 200, 112, -200, 200, 48, 0, -200, 144, -200, -136, -48, 200, 200, -134, -200, -56, -200, -28, -192, -200, 200, 92, -200, 200, 134, 200, 200, 144, 200, -94, 200, 120, 200, 200, 200, 200, -200, -200, -200, 200, -200, 200, 200, -200, 200, 200, -197, 200, -200, 200, 197, 200, 200, 200, 0, 0, 200, -200, 200, 200, -200, -200, -200, 200, -200, -200, -200, 128, -200, -200, -200, -200, 0, -200, -200, -200 }; SetupTexelEvaluationParams(ttt); } private void SetupTexelEvaluationParams(int[] pParams) { texelPieceEvaluationsV2EG[8] = -(texelPieceEvaluationsV2EG[1] = pParams[0]); texelPieceEvaluationsV2EG[9] = -(texelPieceEvaluationsV2EG[2] = pParams[1]); texelPieceEvaluationsV2EG[10] = -(texelPieceEvaluationsV2EG[3] = pParams[2]); texelPieceEvaluationsV2EG[11] = -(texelPieceEvaluationsV2EG[4] = pParams[3]); texelPieceEvaluationsV2EG[12] = -(texelPieceEvaluationsV2EG[5] = pParams[4]); texelPieceEvaluationsV2LG[8] = -(texelPieceEvaluationsV2LG[1] = pParams[5]); texelPieceEvaluationsV2LG[9] = -(texelPieceEvaluationsV2LG[2] = pParams[6]); texelPieceEvaluationsV2LG[10] = -(texelPieceEvaluationsV2LG[3] = pParams[7]); texelPieceEvaluationsV2LG[11] = -(texelPieceEvaluationsV2LG[4] = pParams[8]); texelPieceEvaluationsV2LG[12] = -(texelPieceEvaluationsV2LG[5] = pParams[9]); int c = 10; for (int p = 1; p < 7; p++) { for (int s = 0; s < 64; s++) { texelTuningRuntimePositionalValsV2EG[p + 7][blackSidedSquares[s]] = -(texelTuningRuntimePositionalValsV2EG[p][s] = pParams[c++]); texelTuningRuntimePositionalValsV2LG[p + 7][blackSidedSquares[s]] = -(texelTuningRuntimePositionalValsV2LG[p][s] = pParams[c++]); } } return; for (int p = 2; p < 7; p++) { for (int a = 0; a < 15; a++) { if (a != 14) { texelMobilityDiagonalEG[p + 7, a] = -(texelMobilityDiagonalEG[p, a] = pParams[c++]); texelMobilityDiagonalLG[p + 7, a] = -(texelMobilityDiagonalLG[p, a] = pParams[c++]); } texelMobilityStraightEG[p + 7, a] = -(texelMobilityStraightEG[p, a] = pParams[c++]); texelMobilityStraightLG[p + 7, a] = -(texelMobilityStraightLG[p, a] = pParams[c++]); } } for (int i = 0; i < 12; i++) { texelKingSafetySREvaluationsPT1EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT2EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT3EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT4EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT5EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT6EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT1LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT2LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT3LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT4LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT5LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT6LG[i] = pParams[c++]; } } private void PrintDefinedTexelParams(int[] pParams) { int c = 0; for (int t = 0; t < 3; t++) { SNAPSHOT_WRITLINE_REPLACEMENT(TEXELPRINT_GAMEPARTS[t]); for (int p = 0; p < 6; p++) { SNAPSHOT_WRITLINE_REPLACEMENT(TEXELPRINT_PIECES[p]); texelTuningVals[t, p] = new int[64]; for (int s = 0; s < 64; s++) { if (s % 8 == 0 && s != 0) SNAPSHOT_WRITLINE_REPLACEMENT(); SNAPSHOT_WRITLINE_REPLACEMENT((texelTuningVals[t, p][s] = pParams[c++]) + ", "); } SNAPSHOT_WRITLINE_REPLACEMENT(); } } piecePositionEvals = GetInterpolatedProcessedValues(texelTuningVals); } public void TLMTuning(List<TLM_ChessGame> pDataset) { int tGameDataSetLen = pDataset.Count; int[,][] tRatio = new int[33, 6][]; int[,][] tTotalMoves = new int[33, 6][]; double[,][] tSummedRatios = new double[33, 6][]; double[,][] tSummedDataAmount = new double[33, 6][]; double[,][] tTuningResults = new double[33, 6][]; for (int t = 1; t < 33; t++) { for (int p = 0; p < 6; p++) { tRatio[t, p] = new int[64]; tTotalMoves[t, p] = new int[64]; tSummedRatios[t, p] = new double[64]; tSummedDataAmount[t, p] = new double[64]; tTuningResults[t, p] = new double[64]; } } for (int j = 0; j < tGameDataSetLen; j++) { TLM_ChessGame tGame = pDataset[j]; int tGR = tGame.gameResult - 1; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count - 5; for (int i = 0; i < tL; i++) { if (tGame.isMoveNonTactical[i]) { int tPieceAmount = ULONG_OPERATIONS.CountBits(allPieceBitboard); for (int s = 0; s < 64; s++) { int tPT = pieceTypeArray[s] - 1; if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, s)) { tTotalMoves[tPieceAmount, tPT][s]++; tRatio[tPieceAmount, tPT][s] += tGR; } else if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, s)) { int b = blackSidedSquares[s]; tTotalMoves[tPieceAmount, tPT][b]++; tRatio[tPieceAmount, tPT][b] += tGR; } } } PlainMakeMove(tGame.actualMoves[i]); } } double[,] allMultipliers = new double[33, 33]; for (int sh = 0; sh < 33; sh++) { for (int i = 0; i < 33; i++) { allMultipliers[sh, i] = MultiplierFunction(i, sh); } } for (int t = 1; t < 33; t++) { for (int p = 0; p < 6; p++) { for (int s = 0; s < 64; s++) { for (int t2 = 1; t2 < 33; t2++) { double cmult = allMultipliers[t, t2]; tSummedRatios[t, p][s] += tRatio[t2, p][s] * cmult; tSummedDataAmount[t, p][s] += tTotalMoves[t2, p][s] * cmult; } tTuningResults[t, p][s] = TTT(tSummedRatios[t, p][s], tSummedDataAmount[t, p][s]); } } } int c = 0; int[] tparams = new int[1152]; for (int t = 1; t < 33; t += 15) { if (t == 31) t = 32; SNAPSHOT_WRITLINE_REPLACEMENT("PieceCount = " + t + ": "); for (int p = 0; p < 6; p++) { SNAPSHOT_WRITLINE_REPLACEMENT(TEXELPRINT_PIECES[p]); for (int s = 0; s < 64; s++) { if (s % 8 == 0 && s != 0) SNAPSHOT_WRITLINE_REPLACEMENT(); SNAPSHOT_WRITLINE_REPLACEMENT((tparams[c++] = (int)(tTuningResults[t, p][s] * 100)).ToString().Replace(",", ".") + "("+ (int)tSummedDataAmount[t, p][s] + ")"+ ", "); } SNAPSHOT_WRITLINE_REPLACEMENT(); } } string tS = "PARAMS: {"; for (int i = 0; i < tparams.Length; i++) tS += tparams[i] + ","; tS = tS.Substring(0, tS.Length - 1) + "}\n"; SNAPSHOT_WRITLINE_REPLACEMENT(tS); TexelTuning(pDataset, tparams); } private double TTT(double d1, double d2) { if (d2 == 0) return 0; return d1 /d2; } public void TexelTuning(List<TLM_ChessGame> pDataset, int[] pCurBestParams) { Stopwatch sw = Stopwatch.StartNew(); string tPath = PathManager.GetTXTPath("OTHER/TEXEL_TUNING"); int paramCount = pCurBestParams.Length; double bestAvrgCost = CalculateAverageTexelCost(pDataset, pCurBestParams); SNAPSHOT_WRITLINE_REPLACEMENT("CUR PARAMS COST: " + bestAvrgCost); int packetSize = Math.Clamp(paramCount /ENGINE_VALS.CPU_CORES, 1, 100000); paramsLowerLimits = new int[paramCount]; paramsUpperLimits = new int[paramCount]; for (int i = 0; i < paramCount; i++) { int lim = i < 10 ? 100000 : 200; paramsLowerLimits[i] = -lim; paramsUpperLimits[i] = lim; } SNAPSHOT_WRITLINE_REPLACEMENT("PARAM-COUNT: " + paramCount); SNAPSHOT_WRITLINE_REPLACEMENT("PACKET-SIZE: " + packetSize); while (packetSize <= paramCount) { BOT_MAIN.TEXELfinished = 0; int lM = 0, tC = 0; ulong tUL = 0ul; for (int m = packetSize; lM < paramCount; m += packetSize) { if (m > paramCount) m = paramCount; tUL = ULONG_OPERATIONS.SetBitToOne(tUL, ++tC); lM = m; } tC = lM = 0; for (int m = packetSize; lM < paramCount; m += packetSize) { if (m > paramCount) m = paramCount; tC++; BOT_MAIN.boardManagers[tC].SetPlayTexelVals(pDataset, lM, m, pCurBestParams, paramsLowerLimits, paramsUpperLimits, tC, tUL); ThreadPool.QueueUserWorkItem(new WaitCallback(BOT_MAIN.boardManagers[tC].TexelTuningThreadedPackage)); lM = m; } packetSize = paramCount + 1; int tmod = 0; while (tC != BOT_MAIN.TEXELfinished) { if (++tmod % 20 == 0) { WriteTexelParamsToTXT(tPath, BOT_MAIN.curTEXELPARAMS); SNAPSHOT_WRITLINE_REPLACEMENT(CalculateAverageTexelCost(pDataset, BOT_MAIN.curTEXELPARAMS) + " | "+ BOT_MAIN.TEXELadjustmentsmade); SNAPSHOT_WRITLINE_REPLACEMENT(ULONG_OPERATIONS.GetBitVisualization(BOT_MAIN.TEXELfinishedwithoutimpovement)); } Thread.Sleep(100); } SNAPSHOT_WRITLINE_REPLACEMENT("One Thread Generation FINISHED! :) :) :)"); pCurBestParams = BOT_MAIN.curTEXELPARAMS; } sw.Stop(); WriteTexelParamsToTXT(tPath, BOT_MAIN.curTEXELPARAMS); SNAPSHOT_WRITLINE_REPLACEMENT("END COST: " + CalculateAverageTexelCost(pDataset, BOT_MAIN.curTEXELPARAMS)); SNAPSHOT_WRITLINE_REPLACEMENT(BOT_MAIN.TEXELadjustmentsmade); SNAPSHOT_WRITLINE_REPLACEMENT(sw.ElapsedMilliseconds); } public void TexelTuningThreadedPackage(object obj) { SNAPSHOT_WRITLINE_REPLACEMENT("Started CThreadID [" + customThreadID + "] which is handling Params ["+ threadFrom + "] - ["+ threadTo + "]"); bool firstIter = true; do { double bestAvrgCost = CalculateAverageTexelCost(threadDataset, threadParams); int adjust_val = firstIter ? 512 : 8; do { adjust_val /= 2; bool improvedAvrgCost = true; while (improvedAvrgCost) { improvedAvrgCost = false; for (int i = threadFrom; i < threadTo; i++) { bool improvedWithThisParam = true; int tadjustval = adjust_val; bool lastTimeMaximized = false, lastTimeMinimized = false; while (improvedWithThisParam) { improvedWithThisParam = false; int[] curParams = (int[])threadParams.Clone(); int paramBefore = curParams[i]; curParams[i] = Math.Clamp(paramBefore + adjust_val, paramsLowerLimits[i], paramsUpperLimits[i]); double curAvrgCost = CalculateAverageTexelCost(threadDataset, curParams); if (curAvrgCost < bestAvrgCost) { improvedAvrgCost = true; improvedWithThisParam = true; SNAPSHOT_WRITLINE_REPLACEMENT("Improved Param [" + i + "] at CThreadID ["+ customThreadID + "]: +"+ adjust_val + " ("+ GetDoublePrecentageString(bestAvrgCost - curAvrgCost) + ")"); bestAvrgCost = curAvrgCost; threadParams = curParams; BOT_MAIN.TEXELadjustmentsmade++; BOT_MAIN.TEXELfinishedwithoutimpovement = ulAllThreadIDsUnfinished; if (lastTimeMaximized) { adjust_val *= 4; lastTimeMaximized = false; } else lastTimeMaximized = true; lastTimeMinimized = false; } else { curParams[i] = Math.Clamp(paramBefore - adjust_val, paramsLowerLimits[i], paramsUpperLimits[i]); curAvrgCost = CalculateAverageTexelCost(threadDataset, curParams); if (curAvrgCost < bestAvrgCost) { improvedAvrgCost = true; improvedWithThisParam = true; SNAPSHOT_WRITLINE_REPLACEMENT("Improved Param [" + i + "] at CThreadID ["+ customThreadID + "]: -"+ adjust_val + " ("+ GetDoublePrecentageString(bestAvrgCost - curAvrgCost) + ")"); bestAvrgCost = curAvrgCost; threadParams = curParams; BOT_MAIN.TEXELadjustmentsmade++; BOT_MAIN.TEXELfinishedwithoutimpovement = ulAllThreadIDsUnfinished; if (lastTimeMinimized) { adjust_val *= 4; lastTimeMinimized = false; } else lastTimeMinimized = true; lastTimeMaximized = false; } } if (adjust_val != 1) adjust_val /= 2; for (int j = threadFrom; j < threadTo; j++) { BOT_MAIN.curTEXELPARAMS[j] = threadParams[j]; } threadParams = (int[])BOT_MAIN.curTEXELPARAMS.Clone(); bestAvrgCost = CalculateAverageTexelCost(threadDataset, threadParams); } adjust_val = tadjustval; } } } while (adjust_val != 1); BOT_MAIN.TEXELfinishedwithoutimpovement = ULONG_OPERATIONS.SetBitToZero(BOT_MAIN.TEXELfinishedwithoutimpovement, customThreadID); SNAPSHOT_WRITLINE_REPLACEMENT("FULLY FINISHED " + customThreadID + ". IMPROVEMENT THREAD PACKAGE CYCLE"); firstIter = false; } while (BOT_MAIN.TEXELfinishedwithoutimpovement != 0); BOT_MAIN.TEXELfinished++; } private void WriteTexelParamsToTXT(string pPath, int[] pParams) { try { string tS = "PARAMS: {"; for (int i = 0; i < pParams.Length; i++) tS += pParams[i] + ","; tS = tS.Substring(0, tS.Length - 1) + "}\n"; File.AppendAllText(pPath, tS); } catch { SNAPSHOT_WRITLINE_REPLACEMENT("Mal wieder TXT zu lange gebraucht um zu aktualisieren."); } } private double costSum = 0d; private int texelCostMovesEvaluated = 0; private double CalculateAverageTexelCost(List<TLM_ChessGame> tDataset, int[] pParams, bool pFullCost = true) { costSum = 0d; texelCostMovesEvaluated = 0; SetupTexelEvaluationParams(pParams); int tGameDataSetLen = tDataset.Count; int start = 0, end = tGameDataSetLen; if (!pFullCost) { end = (start = globalRandom.Next(0, end - 256)) + 256; } for (int j = start; j < end; j++) { TLM_ChessGame tGame = tDataset[j]; double tGR = tGame.gameResult; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count - 5; texelCostMovesEvaluated += tL; for (int i = 0; i < tL; i++) { costSum += TexelCost(tGR - TexelTuningSigmoid(TexelEvaluate())); PlainMakeMove(tGame.actualMoves[i]); } } return costSum /texelCostMovesEvaluated; } private double CalculateAverageTexelCostThreadedVersionLEGACYDOESNTWORK(List<TLM_ChessGame> tDataset, int[] pParams) { Stopwatch sw = Stopwatch.StartNew(); BOT_MAIN.TEXELcostSum = 0d; BOT_MAIN.TEXELfinished = 0; BOT_MAIN.TEXELcostMovesEvaluated = 0; int tGameDataSetLen = tDataset.Count; int gamesPerThread = tGameDataSetLen /ENGINE_VALS.CPU_CORES; for (int i = 0; i < ENGINE_VALS.CPU_CORES - 1; i++) { } for (int i = 0; i < ENGINE_VALS.CPU_CORES - 1; i++) { } while (BOT_MAIN.TEXELfinished != ENGINE_VALS.CPU_CORES) Thread.Sleep(1); sw.Stop(); return BOT_MAIN.TEXELcostSum /BOT_MAIN.TEXELcostMovesEvaluated; } public void SetPlayThroughVals(List<TLM_ChessGame> pDataset, int pFrom, int pTo) { threadDataset = pDataset; threadFrom = pFrom; threadTo = pTo; } public void SetPlayTexelVals(List<TLM_ChessGame> pDataset, int pFrom, int pTo, int[] pTexelParams, int[] pLowerLimits, int[] pUpperLimits, int pThreadID, ulong pUL) { threadDataset = pDataset; threadFrom = pFrom; threadTo = pTo; threadParams = pTexelParams; paramsLowerLimits = pLowerLimits; paramsUpperLimits = pUpperLimits; customThreadID = pThreadID; ulAllThreadIDsUnfinished = pUL; } public void PlayThroughSetOfGames(object obj) { SNAPSHOT_WRITLINE_REPLACEMENT(threadFrom + "->"+ threadTo); int sortedOut = 0; for (int j = threadFrom; j < threadTo; j++) { TLM_ChessGame tGame = threadDataset[j]; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count; for (int i = 0; i < tL; i++) { int tQuietEval = isWhiteToMove ? QuiescenceWhite(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, 0, PreMinimaxCheckCheckWhite(), NULL_MOVE) : QuiescenceBlack(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, 0, PreMinimaxCheckCheckBlack(), NULL_MOVE); bool tB; tGame.isMoveNonTactical.Add(tB = (Evaluate() == tQuietEval && i > 4)); if (!tB) sortedOut++; PlainMakeMove(tGame.actualMoves[i]); } } BOT_MAIN.TEXELsortedout += sortedOut; BOT_MAIN.TEXELfinished++; } public void CalculateAverageTexelCostThreadFunction(object obj) { SetupTexelEvaluationParams(threadParams); double d = 0d; for (int j = threadFrom; j < threadTo; j++) { TLM_ChessGame tGame = threadDataset[j]; double tGR = tGame.gameResult; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count - 5; BOT_MAIN.TEXELcostMovesEvaluated += tL; for (int i = 0; i < tL; i++) { d += TexelCost(tGR - TexelTuningSigmoid(TexelEvaluate())); PlainMakeMove(tGame.actualMoves[i]); } } BOT_MAIN.TEXELcostSum += d; BOT_MAIN.TEXELfinished++; } private void ConsoleWriteLineTuneArray<T>(T[,][] pArr) { for (int j = 0; j < 3; j++) { SNAPSHOT_WRITLINE_REPLACEMENT("{"); for (int k = 0; k < 6; k++) { SNAPSHOT_WRITLINE_REPLACEMENT("{"); for (int s = 0; s < 64; s++) SNAPSHOT_WRITLINE_REPLACEMENT(pArr[j, k][s] + ", "); SNAPSHOT_WRITLINE_REPLACEMENT("\n}"); } SNAPSHOT_WRITLINE_REPLACEMENT("}"); } } private void Tune(string pGameCGFF, double pLearningRate) { TLM_ChessGame tGame = CGFF.GetGame(pGameCGFF); LoadFenString(tGame.startFen); double tDGameResult = tGame.gameResult; foreach (int hMove in tGame.hashedMoves) { Tune(tDGameResult, pLearningRate); List<Move> moveOptionList = new List<Move>(); GetLegalMoves(ref moveOptionList); int tL = moveOptionList.Count; for (int i = 0; i < tL; i++) { Move tMove = moveOptionList[i]; if (tMove.moveHash == hMove) { PlainMakeMove(tMove); tL = -1; break; } } if (tL != -1) break; } } private void Tune(double pGameResult, double pLearningRate) { int tPC = ULONG_OPERATIONS.CountBits(allPieceBitboard); double oneThroughPieceCount = 1d /tPC; double egMult = earlyGameMultipliers[tPC], mgMult = middleGameMultipliers[tPC], lgMult = lateGameMultipliers[tPC]; double tTexelResult = TexelEvaluateF(); double tSigmoidedTexelResult = TexelSigmoid(tTexelResult); double tDif = tSigmoidedTexelResult - pGameResult; double tM = oneThroughPieceCount * TexelCostDerivative(tDif) * TexelSigmoidDerivative(tTexelResult) * pLearningRate; sumCostVals += lastCostVal = TexelCost(tDif); costCalculations++; for (int i = 0; i < 64; i++) { if (ULONG_OPERATIONS.IsBitZero(allPieceBitboard, i)) continue; int tPT = pieceTypeArray[i] - 1, tI = i; if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, i)) tI = blackSidedSquares[i]; texelTuningAdjustIterations[tPT, tI]++; } } private double TexelEvaluateF() { texelTuningRuntimeVals = GetInterpolatedProcessedValues(texelTuningVals); return TexelEvaluate(); } private int TexelEvaluate() { int tEvalEG = 0, tEvalLG = 0, tProgress = 0; ulong[] attkULs = new ulong[14]; for (int p = 0; p < 64; p++) { if (((int)(allPieceBitboard >> p) & 1) == 0) continue; int aPT = pieceTypeArray[p], tPT = aPT + 7 * ((int)(blackPieceBitboard >> p) & 1); tEvalEG += texelTuningRuntimePositionalValsV2EG[tPT][p] + texelPieceEvaluationsV2EG[tPT]; tEvalLG += texelTuningRuntimePositionalValsV2LG[tPT][p] + texelPieceEvaluationsV2LG[tPT]; tProgress += pieceTypeGameProgressImpact[tPT]; } if (tProgress > 24) tProgress = 24; return (int)(earlyGameMultipliers[tProgress] * tEvalEG + lateGameMultipliers[tProgress] * tEvalLG); } private const double TexelK = 0.2; private double TexelTuningSigmoid(double pVal) { return 2d /(1 + Math.Pow(10, -TexelK * pVal /400)); } private double TexelSigmoid(double pVal) { return 2d /(Math.Exp(-0.04d * pVal) + 1d); } private double TexelSigmoidDerivative(double pVal) { double d = Math.Exp(-0.04d * pVal); return 2d * d /(25d * (d + 1d) * (d + 1d)); } private double TexelCost(double pVal) { return pVal * pVal; } private double TexelCostDerivative(double pVal) { return 2 * pVal; } private char[] fenPieces = new char[7] { 'z', 'p', 'n', 'b', 'r', 'q', 'k' }; private string[] squareNames = new string[64] { "a1", "b1", "c1", "d1", "e1", "f1", "g1", "h1", "a2", "b2", "c2", "d2", "e2", "f2", "g2", "h2", "a3", "b3", "c3", "d3", "e3", "f3", "g3", "h3", "a4", "b4", "c4", "d4", "e4", "f4", "g4", "h4", "a5", "b5", "c5", "d5", "e5", "f5", "g5", "h5", "a6", "b6", "c6", "d6", "e6", "f6", "g6", "h6", "a7", "b7", "c7", "d7", "e7", "f7", "g7", "h7", "a8", "b8", "c8", "d8", "e8", "f8", "g8", "h8"}; public string CreateFenString() { string rFEN = ""; for (int i = 7; i >= 0; i--) { int t = 0; for (int j = 0; j < 8; j++) { int sq = i * 8 + j; if (pieceTypeArray[sq] != 0) { if (t != 0) rFEN += t; t = 0; } if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, sq)) { switch (pieceTypeArray[sq]) { case 0: t++; SNAPSHOT_WRITLINE_REPLACEMENT("???"); break; case 1: rFEN += 'P'; break; case 2: rFEN += 'N'; break; case 3: rFEN += 'B'; break; case 4: rFEN += 'R'; break; case 5: rFEN += 'Q'; break; case 6: rFEN += 'K'; break; } } else { switch (pieceTypeArray[sq]) { case 0: t++; break; case 1: rFEN += 'p'; break; case 2: rFEN += 'n'; break; case 3: rFEN += 'b'; break; case 4: rFEN += 'r'; break; case 5: rFEN += 'q'; break; case 6: rFEN += 'k'; break; } } } if (t != 0) rFEN += t; if (i != 0) rFEN += "/"; } rFEN += (isWhiteToMove ? " w": " b"); rFEN += (whiteCastleRightKingSide ? " K": " "); rFEN += (whiteCastleRightQueenSide ? "Q": ""); rFEN += (blackCastleRightKingSide ? "k": ""); rFEN += (blackCastleRightQueenSide ? "q": ""); if (!whiteCastleRightKingSide && !whiteCastleRightQueenSide && !blackCastleRightKingSide && !blackCastleRightQueenSide) rFEN += "-"; if (enPassantSquare < 64) rFEN += " "+ squareNames[enPassantSquare] + " "; else rFEN += " - "; return rFEN + fiftyMoveRuleCounter + " "+ ((happenedHalfMoves - happenedHalfMoves % 2) /2); } public void LoadFenString(string fenStr) { lastMadeMove = NULL_MOVE; zobristKey = 0ul; whitePieceBitboard = blackPieceBitboard = allPieceBitboard = 0ul; for (int i = 0; i < 64; i++) pieceTypeArray[i] = 0; string[] spaceSpl = fenStr.Split(' '); string[] rowSpl = spaceSpl[0].Split('/'); string epstr = spaceSpl[3]; if (epstr == "-") enPassantSquare = 65; else enPassantSquare = (epstr[0] - 'a') + 8 * (epstr[1] - '1'); isWhiteToMove = true; if (spaceSpl[1] == "b") isWhiteToMove = false; if (!isWhiteToMove) zobristKey ^= blackTurnHash; string crstr = spaceSpl[2]; whiteCastleRightKingSide = whiteCastleRightQueenSide = blackCastleRightKingSide = blackCastleRightQueenSide = false; int crStrL = crstr.Length; for (int i = 0; i < crStrL; i++) { switch (crstr[i]) { case 'K': whiteCastleRightKingSide = true; break; case 'Q': whiteCastleRightQueenSide = true; break; case 'k': blackCastleRightKingSide = true; break; case 'q': blackCastleRightQueenSide = true; break; } } fiftyMoveRuleCounter = Convert.ToInt32(spaceSpl[4]); happenedHalfMoves = Convert.ToInt32(spaceSpl[5]) * 2; if (!isWhiteToMove) happenedHalfMoves++; int tSq = 0; for (int i = rowSpl.Length; i-- > 0;) { string tStr = rowSpl[i]; int tStrLen = tStr.Length; for (int c = 0; c < tStrLen; c++) { char tChar = tStr[c]; if (Char.IsDigit(tChar)) tSq += tChar - '0'; else { bool tCol = Char.IsLower(tChar); if (tCol) blackPieceBitboard = ULONG_OPERATIONS.SetBitToOne(blackPieceBitboard, tSq); else whitePieceBitboard = ULONG_OPERATIONS.SetBitToOne(whitePieceBitboard, tSq); if (tChar == 'k') blackKingSquare = tSq; else if (tChar == 'K') whiteKingSquare = tSq; pieceTypeArray[tSq] = Array.IndexOf(fenPieces, Char.ToLower(tChar)); if (tCol) zobristKey ^= pieceHashesBlack[tSq, pieceTypeArray[tSq]]; else zobristKey ^= pieceHashesWhite[tSq, pieceTypeArray[tSq]]; tSq++; } } } if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; zobristKey ^= enPassantSquareHashes[enPassantSquare]; allPieceBitboard = whitePieceBitboard | blackPieceBitboard; if (zobristKey == 16260251586586513106) moveHashList.Clear(); else { moveHashList.Clear(); moveHashList.Add(1); moveHashList.Add(2); moveHashList.Add(3); } } private ulong[,] pieceHashesWhite = new ulong[64, 7], pieceHashesBlack = new ulong[64, 7]; private ulong blackTurnHash, whiteKingSideRochadeRightHash, whiteQueenSideRochadeRightHash, blackKingSideRochadeRightHash, blackQueenSideRochadeRightHash; private ulong[] enPassantSquareHashes = new ulong[66]; private void InitZobrist() { Random rng = new Random(31415926); for (int sq = 0; sq < 64; sq++) { enPassantSquareHashes[sq] = ULONG_OPERATIONS.GetRandomULONG(rng); for (int it = 1; it < 7; it++) { pieceHashesWhite[sq, it] = ULONG_OPERATIONS.GetRandomULONG(rng); pieceHashesBlack[sq, it] = ULONG_OPERATIONS.GetRandomULONG(rng); } } blackTurnHash = ULONG_OPERATIONS.GetRandomULONG(rng); whiteKingSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); whiteQueenSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); blackKingSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); blackQueenSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); } public void SetKnightMasks(ulong[] uls) { knightSquareBitboards = uls; } public void SetKingMasks(ulong[] uls) { kingSquareBitboards = uls; } private Move[,] whiteEnPassantMoves = new Move[64, 64]; private Move[,] blackEnPassantMoves = new Move[64, 64]; private bool[] epValidationArray = new bool[64] { false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true , true , true , true , true , true , true , true, true , true , true , true , true , true , true , true, true , true , true , true , true , true , true , true, true , true , true , true , true , true , true , true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false }; private ulong[] kingSafetyRing1 = new ulong[64], kingSafetyRing2 = new ulong[64]; private ulong[] kingSafetySpecialRingW = new ulong[64], kingSafetySpecialRingB = new ulong[64]; private ulong[] rowPrecalcs = new ulong[8], columnPrecalcs = new ulong[8]; const ulong columnUL = 0x101010101010101, rowUL = 0b11111111; private void PrecalculateKingSafetyBitboards() { for (int i = 0; i < 8; i++) { rowPrecalcs[i] = rowUL << (8 * i); columnPrecalcs[i] = columnUL << i; } for (int i = 0; i < 64; i++) { int tMod = i % 8; int tRow = (i - tMod) /8; ulong tULC = columnPrecalcs[tMod], tULR = rowPrecalcs[tRow]; ulong tULC2 = columnPrecalcs[tMod], tULR2 = rowPrecalcs[tRow]; if (tMod < 7) tULC |= columnPrecalcs[tMod + 1]; if (tMod > 0) tULC |= columnPrecalcs[tMod - 1]; if (tRow < 7) tULR |= rowPrecalcs[tRow + 1]; if (tRow > 0) tULR |= rowPrecalcs[tRow - 1]; if (tMod < 6) tULC2 |= columnPrecalcs[tMod + 2]; if (tMod > 1) tULC2 |= columnPrecalcs[tMod - 2]; if (tRow < 6) tULR2 |= rowPrecalcs[tRow + 2]; if (tRow > 1) tULR2 |= rowPrecalcs[tRow - 2]; tULR2 |= tULR; tULC2 |= tULC; kingSafetyRing1[i] = ULONG_OPERATIONS.SetBitToZero(tULR & tULC, i); kingSafetyRing2[i] = ULONG_OPERATIONS.SetBitsToZero(tULR2 & tULC2, i, i + 1, i - 1, i + 7, i + 8, i + 9, i - 7, i - 8, i - 9); } for (int i = 0; i < 64; i++) { if (i < 56) kingSafetySpecialRingW[i] = ULONG_OPERATIONS.SetBitToZero(kingSafetyRing1[i] | kingSafetyRing1[i + 8], i); else kingSafetySpecialRingW[i] = kingSafetyRing1[i]; if (i > 7) kingSafetySpecialRingB[i] = ULONG_OPERATIONS.SetBitToZero(kingSafetyRing1[i] | kingSafetyRing1[i - 8], i); else kingSafetySpecialRingB[i] = kingSafetyRing1[i]; } } private void PrecalculateEnPassantMoves() { for (int i = 0; i < 64; i++) { if (!epValidationArray[i]) continue; for (int j = 0; j < 64; j++) { if (i == j) continue; if (Math.Abs(i - j) > 9) continue; if (!epValidationArray[j]) continue; whiteEnPassantMoves[i, j] = new Move(false, i, j, j - 8); blackEnPassantMoves[i, j] = new Move(false, i, j, j + 8); } } } private void PawnAttackBitboards() { for (int sq = 0; sq < 64; sq++) { ulong u = 0ul; if (sq % 8 != 0) u = ULONG_OPERATIONS.SetBitToOne(u, sq + 7); if (sq % 8 != 7) u = ULONG_OPERATIONS.SetBitToOne(u, sq + 9); whitePawnAttackSquareBitboards[sq] = u; u = 0ul; if (sq % 8 != 0 && sq - 9 > -1) u = ULONG_OPERATIONS.SetBitToOne(u, sq - 9); if (sq % 8 != 7 && sq - 7 > -1) u = ULONG_OPERATIONS.SetBitToOne(u, sq - 7); blackPawnAttackSquareBitboards[sq] = u; } } private int[] squareConnectivesPrecalculationArray = new int[4096]; public int[] squareConnectivesCrossDirsPrecalculationArray { get; set; } = new int[4096]; private ulong[] squareConnectivesPrecalculationRayArray = new ulong[4096]; private ulong[] squareConnectivesPrecalculationLineArray = new ulong[4096]; private List<Dictionary<ulong, int>> rayCollidingSquareCalculations = new List<Dictionary<ulong, int>>(); private readonly int[] maxIntWithSpecifiedBitcount = new int[8] { 0, 0b1, 0b11, 0b111, 0b1111, 0b11111, 0b111111, 0b1111111 }; private List<ulong> differentRays = new List<ulong>(); private void SquareConnectivesPrecalculations() { for (int square = 0; square < 64; square++) { rayCollidingSquareCalculations.Add(new Dictionary<ulong, int>()); rayCollidingSquareCalculations[square].Add(0ul, square); for (int square2 = 0; square2 < 64; square2++) { if (square == square2) continue; int t = 0, t2 = 0, difSign = Math.Sign(square2 - square), itSq = square, g = 0; ulong tRay = 0ul, tExclRay = 0ul; List<int> tRayInts = new List<int>(); if (difSign == -1) g = 7; if (square % 8 == square2 % 8) { t2 = t = 1; while ((itSq += difSign * 8) < 64 && itSq > -1) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } } else if ((square - square % 8) == (square2 - square2 % 8)) { t = 1; t2 = -1; while ((itSq += difSign) % 8 != g && itSq > -1 && itSq < 64) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } } else { int dif = Math.Abs(square2 - square); if (dif % 7 == 0) { t = 2; t2 = 2; g = (difSign == 1) ? 7 : 0; while ((itSq += difSign * 7) % 8 != g && itSq < 64 && itSq > -1) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } if (ULONG_OPERATIONS.IsBitZero(tRay, square2)) { t2 = t = 0; tRay = 0ul; } } else if (dif % 9 == 0) { t = 2; t2 = -2; if (square == 0 && square2 == 63 || square == 63 && square2 == 0) SNAPSHOT_WRITLINE_REPLACEMENT("!"); while ((itSq += difSign * 9) % 8 != g && itSq < 64 && itSq > -1) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } if (ULONG_OPERATIONS.IsBitZero(tRay, square2)) { t2 = t = 0; tRay = 0ul; } } } if (square == 0 && square2 == 63) { t2 = t = 2; tRayInts.Clear(); tExclRay = tRay = ULONG_OPERATIONS.SetBitsToOne(0ul, 9, 18, 27, 36, 45, 54, 63); tRayInts = new List<int>() { 9, 18, 27, 36, 45, 54, 63 }; } else if (square2 == 0 && square == 63) { t = 2; tRayInts.Clear(); t2 = -2; tExclRay = tRay = ULONG_OPERATIONS.SetBitsToOne(0ul, 0, 9, 18, 27, 36, 45, 54); tRayInts = new List<int>() { 54, 45, 36, 27, 18, 9, 0 }; } if (tRay != 0ul && !differentRays.Contains(tRay)) { differentRays.Add(tRay); int ccount, combI = maxIntWithSpecifiedBitcount[ccount = ULONG_OPERATIONS.CountBits(tRay)]; do { ulong curAllPieceBitboard = 0ul; int solution = square; for (int j = 0; j < ccount; j++) { if (((combI >> j) & 1) == 1) { curAllPieceBitboard = ULONG_OPERATIONS.SetBitToOne(curAllPieceBitboard, tRayInts[j]); if (solution == square) solution = tRayInts[j]; } } rayCollidingSquareCalculations[square].Add(curAllPieceBitboard, solution); } while (--combI != 0); } squareConnectivesPrecalculationArray[square << 6 | square2] = t; squareConnectivesPrecalculationRayArray[square << 6 | square2] = tRay; squareConnectivesCrossDirsPrecalculationArray[square << 6 | square2] = t2; if (t != 0) squareConnectivesPrecalculationLineArray[square << 6 | square2] = (square == 0 && square2 == 63 || square2 == 0 && square == 63) ? tExclRay : ULONG_OPERATIONS.SetBitToOne(tExclRay, square2); if (squareConnectivesPrecalculationLineArray[square << 6 | square2] == 0ul && ULONG_OPERATIONS.IsBitOne(knightSquareBitboards[square], square2)) squareConnectivesPrecalculationLineArray[square << 6 | square2] = 1ul << square2; } differentRays.Clear(); } } public void SNAPSHOT_WRITLINE_REPLACEMENT() { } public void SNAPSHOT_WRITLINE_REPLACEMENT(object pStr) { } private string GetDoublePrecentageString(double pVal) { return ((int)(pVal * 1_000_000) /10_000d) + "%"; } private string ReplaceAllULONGIsBitOne(string pCode) { const string METHOD_NAME = "ULONG_OPERATIONS.IsBitOne"; int METHOD_NAME_LEN = METHOD_NAME.Length, iterations = 0; int pIndex = pCode.IndexOf(METHOD_NAME); while (pIndex != -1 && ++iterations < 10_000) { List<int> paramIndexes = new List<int>(); int openedBracketCount = 1, closedBracketCount = 0, a = METHOD_NAME_LEN + pIndex; string tpCode = pCode.Substring(0, pIndex); paramIndexes.Add(a + 1); while (++a < pCode.Length) { switch (pCode[a]) { case '(': openedBracketCount++; break; case ')': if (++closedBracketCount == openedBracketCount) { pIndex = a; a = int.MaxValue - 5; } break; case ',': if (openedBracketCount - closedBracketCount == 1) paramIndexes.Add(a + 1); break; } } if (openedBracketCount == closedBracketCount && paramIndexes.Count == 2) { tpCode += "((int)("+ pCode.Substring(paramIndexes[0], paramIndexes[1] - paramIndexes[0] - 1) + (pCode[paramIndexes[1]] == ' ' ? " >> (": " >> (") + pCode.Substring(paramIndexes[1], pIndex - paramIndexes[1]) + ")) & 1) == 1"+ pCode.Substring(pIndex + 1, pCode.Length - pIndex - 1); } pIndex = (pCode = tpCode).IndexOf(METHOD_NAME); } SNAPSHOT_WRITLINE_REPLACEMENT(iterations + " ITERATIONS"); return pCode; } private string ReplaceAllULONGIsBitZero(string pCode) { const string METHOD_NAME = "ULONG_OPERATIONS.IsBitZero"; int METHOD_NAME_LEN = METHOD_NAME.Length, iterations = 0; int pIndex = pCode.IndexOf(METHOD_NAME); while (pIndex != -1 && ++iterations < 10_000) { List<int> paramIndexes = new List<int>(); int openedBracketCount = 1, closedBracketCount = 0, a = METHOD_NAME_LEN + pIndex; string tpCode = pCode.Substring(0, pIndex); paramIndexes.Add(a + 1); while (++a < pCode.Length) { switch (pCode[a]) { case '(': openedBracketCount++; break; case ')': if (++closedBracketCount == openedBracketCount) { pIndex = a; a = int.MaxValue - 5; } break; case ',': if (openedBracketCount - closedBracketCount == 1) paramIndexes.Add(a + 1); break; } } if (openedBracketCount == closedBracketCount && paramIndexes.Count == 2) { tpCode += "((int)("+ pCode.Substring(paramIndexes[0], paramIndexes[1] - paramIndexes[0] - 1) + (pCode[paramIndexes[1]] == ' ' ? " >>": " >> ") + pCode.Substring(paramIndexes[1], pIndex - paramIndexes[1]) + ") & 1) == 0"+ pCode.Substring(pIndex + 1, pCode.Length - pIndex - 1); } pIndex = (pCode = tpCode).IndexOf(METHOD_NAME); } SNAPSHOT_WRITLINE_REPLACEMENT(iterations + " ITERATIONS"); return pCode; } private string GetThreeDigitSeperatedInteger(int pInt) { string s = pInt.ToString(), r = s[0].ToString(); int t = s.Length % 3; for (int i = 1; i < s.Length; i++) { if (i % 3 == t) r += "."; r += s[i]; } s = ""; for (int i = 0; i < r.Length; i++) s += r[i]; return s; } public double GetAverageDepth() { return (double)depths /(double)searches; } }
public class SNAPSHOT_V01_00_004 : IBoardManager  { public int TEXEL_PARAMS { get; } = 778; private const int BESTMOVE_SORT_VAL = -2_000_000_000; private const int CAPTURE_SORT_VAL = -1_000_000_000; private const int KILLERMOVE_SORT_VAL = -1000; private readonly int[,] MVVLVA_TABLE = new int[7, 7] { { 0, 0, 0, 0, 0, 0, 0 }, { 0, 1500, 1400, 1300, 1200, 1100, 1000 }, { 0, 3500, 3400, 3300, 3200, 3100, 3000 }, { 0, 4500, 4400, 4300, 4200, 4100, 4000 }, { 0, 5500, 5400, 5300, 5200, 5100, 5000 }, { 0, 9500, 9400, 9300, 9200, 9100, 9000 }, { 0, 0, 0, 0, 0, 0, 0 }}; private int BOARD_MANAGER_ID = -1; private bool debugSearchDepthResults = false; private bool debugSortResults = false; private RookMovement rookMovement; private BishopMovement bishopMovement; private QueenMovement queenMovement; private KnightMovement knightMovement; private KingMovement kingMovement; private WhitePawnMovement whitePawnMovement; private BlackPawnMovement blackPawnMovement; private Rays rays; public List<Move> moveOptionList { get; set; } private int[] pieceTypeArray = new int[64]; public ulong whitePieceBitboard, blackPieceBitboard, allPieceBitboard; private ulong zobristKey; private int whiteKingSquare, blackKingSquare, enPassantSquare = 65, happenedHalfMoves = 0, fiftyMoveRuleCounter = 0; private bool whiteCastleRightKingSide, whiteCastleRightQueenSide, blackCastleRightKingSide, blackCastleRightQueenSide; private bool isWhiteToMove; private const ulong WHITE_KING_ROCHADE = 96, WHITE_QUEEN_ROCHADE = 14, BLACK_KING_ROCHADE = 6917529027641081856, BLACK_QUEEN_ROCHADE = 1008806316530991104, WHITE_QUEEN_ATTK_ROCHADE = 12, BLACK_QUEEN_ATTK_ROCHADE = 864691128455135232; private readonly Move mWHITE_KING_ROCHADE = new Move(4, 6, 7, 5), mWHITE_QUEEN_ROCHADE = new Move(4, 2, 0, 3), mBLACK_KING_ROCHADE = new Move(60, 62, 63, 61), mBLACK_QUEEN_ROCHADE = new Move(60, 58, 56, 59); private ulong[] knightSquareBitboards = new ulong[64]; private ulong[] whitePawnAttackSquareBitboards = new ulong[64]; private ulong[] blackPawnAttackSquareBitboards = new ulong[64]; private ulong[] kingSquareBitboards = new ulong[64]; private bool[,] pieceTypeAbilities = new bool[7, 3] { { false, false, false }, { false, false, false }, { false, false, false }, { false, false, true }, { false, true, false }, { false, true, true }, { false, false, false } }; private List<int> moveHashList = new List<int>(); private ulong[] curSearchZobristKeyLine = Array.Empty<ulong>(); private Stopwatch globalTimer = Stopwatch.StartNew(); private Move lastMadeMove; private int depths, searches; private Random globalRandom = new Random(); public SNAPSHOT_V01_00_004(string fen) { Setup(fen); } public void Setup(string pFen) { Stopwatch setupStopwatch = Stopwatch.StartNew(); BOARD_MANAGER_ID = BOT_MAIN.curBoardManagerID; for (int i = 0; i < 33; i++) for (int j = 0; j < 14; j++) piecePositionEvals[i, j] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; for (int i = 0; i < 33; i++) for (int j = 0; j < 14; j++) texelTuningRuntimeVals[i, j] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; for (int i = 0; i < 3; i++) for (int j = 0; j < 6; j++) texelTuningVals[i, j] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; for (int i = 0; i < 14; i++) { texelTuningRuntimePositionalValsV2EG[i] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; texelTuningRuntimePositionalValsV2LG[i] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; } PrecalculateKingSafetyBitboards(); PrecalculateMultipliers(); GetLowNoisePositionalEvaluation(globalRandom); MinimaxRoot(1L); SetupConsoleWrite("[PRECALCS] Zobrist Hashing"); InitZobrist(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Knight Movement"); knightMovement = new KnightMovement(this); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Square Connectives"); SquareConnectivesPrecalculations(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Pawn Attack Bitboards"); PawnAttackBitboards(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Rays"); rays = new Rays(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); queenMovement = new QueenMovement(this); SetupConsoleWrite("[PRECALCS] Rook Movement"); rookMovement = new RookMovement(this, queenMovement); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Bishop Movement"); bishopMovement = new BishopMovement(this, queenMovement); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] King Movement"); kingMovement = new KingMovement(this); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Pawn Movement"); whitePawnMovement = new WhitePawnMovement(this); blackPawnMovement = new BlackPawnMovement(this); PrecalculateEnPassantMoves(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWriteLine("[DONE]\n\n"); LoadFenString(pFen); LoadBestTexelParamsIn(); setupStopwatch.Stop(); } private void SetupConsoleWriteLine(string pStr) { if (BOT_MAIN.isFirstBoardManagerInitialized) return; SNAPSHOT_WRITLINE_REPLACEMENT(pStr); } private void SetupConsoleWrite(string pStr) { if (BOT_MAIN.isFirstBoardManagerInitialized) return; SNAPSHOT_WRITLINE_REPLACEMENT(pStr); } public void GetLowNoisePositionalEvaluation(System.Random rng) { int[,][] digitArray = new int[3, 6][]; for (int i = 0; i < 3; i++) for (int j = 0; j < 6; j++) digitArray[i, j] = GetRand64IntArray(rng, -5, 6); lowNoisePositionEvals1 = GetInterpolatedProcessedValues(digitArray); int[,][] digitArray2 = new int[3, 6][]; for (int i = 0; i < 3; i++) for (int j = 0; j < 6; j++) digitArray2[i, j] = GetRand64IntArray(rng, -5, 6); lowNoisePositionEvals2 = GetInterpolatedProcessedValues(digitArray2); } private int[] GetRand64IntArray(System.Random rng, int pMin, int pMax) { return new int[64] { rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax) }; } private string GetAIArrayValuesStringRepresentation(int[,][] pArr) { string r = "int[,][] ReLe_AI_RESULT_VALS = new int[3, 6][] {"; for (int i = 0; i < 3; i++) { r += "{"; for (int j = 0; j < 5; j++) { r += GetIntArray64LStringRepresentation(pArr[i, j]) + ","; } r += GetIntArray64LStringRepresentation(pArr[i, 5]) + "},"; } return r.Substring(0, r.Length - 1) + "};"; } private string GetIntArray64LStringRepresentation(int[] p64LArr) { if (p64LArr == null) return ""; string r = "new int[64]{"; for (int i = 0; i < 63; i++) { r += p64LArr[i] + ","; } return r + p64LArr[63] + "}"; } public void TempStuff() { } private string[] gameResultStrings = new string[5] { "Black Has Won!", "Draw!", "White Has Won!", "Non Existant Result!", "Game is Ongoing!"}; private int[,][] lowNoisePositionEvals1, lowNoisePositionEvals2; public void ThreadSelfPlay(object obj) { PlayGameAgainstItself(obj); } public void PlayGameAgainstItself(object obj, string pStartFEN = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1", long tickLimitForEngine = ENGINE_VALS.SELF_PLAY_THINK_TIME) { int ttGState; while (BOT_MAIN.goalGameCount > BOT_MAIN.gamesPlayed) { try { string tGameStr; GetLowNoisePositionalEvaluation(globalRandom); LoadFenString(tGameStr = pStartFEN); tGameStr += ";"; int tGState = 3, tmc = 0; bool lowNoiceDecider = globalRandom.NextDouble() < 0.5d; while (tGState == 3) { piecePositionEvals = lowNoiceDecider ? lowNoisePositionEvals1 : lowNoisePositionEvals2; MinimaxRoot(tickLimitForEngine); Move tM = transpositionTable[zobristKey].bestMove; PlainMakeMove(tM); tGameStr += NuCRe.GetNuCRe(tM.moveHash) + ","; BOT_MAIN.movesPlayed++; tGState = GameState(isWhiteToMove); lowNoiceDecider = !lowNoiceDecider; tmc++; } ttGState = tGState; tGameStr += ttGState + 1; SNAPSHOT_WRITLINE_REPLACEMENT(tGameStr); BOT_MAIN.gamesPlayedResultArray[ttGState + 1]++; BOT_MAIN.gamesPlayed++; BOT_MAIN.selfPlayGameStrings.Add(tGameStr); } catch (Exception tE) { SNAPSHOT_WRITLINE_REPLACEMENT(tE.ToString()); } } } public void PlayGameOnConsoleAgainstHuman(string pStartFEN = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1", bool pHumanPlaysWhite = true, long tickLimitForEngine = 10_000_000L) { debugSearchDepthResults = true; LoadFenString(pStartFEN); if (!(pHumanPlaysWhite ^ isWhiteToMove)) { var pVS = Console.ReadLine(); if (pVS == null) return; Move tm = GetMoveOfString(pVS.ToString()); SNAPSHOT_WRITLINE_REPLACEMENT(tm); PlainMakeMove(tm); } int tGState = 3; while (tGState == 3) { MinimaxRoot(tickLimitForEngine); PlayThroughZobristTree(); Move tM = transpositionTable[zobristKey].bestMove; SNAPSHOT_WRITLINE_REPLACEMENT(tM); SNAPSHOT_WRITLINE_REPLACEMENT(CreateFenString()); PlainMakeMove(tM); tGState = GameState(isWhiteToMove); if (tGState != 3 || tM == NULL_MOVE) break; var pV = ""; tM = NULL_MOVE; do { pV = Console.ReadLine(); if (pV == null) continue; tM = GetMoveOfString(pV.ToString()); SNAPSHOT_WRITLINE_REPLACEMENT(tM); } while (tM == NULL_MOVE); PlainMakeMove(tM); tGState = GameState(isWhiteToMove); } } private void PlayThroughZobristTree() { SetJumpState(); SNAPSHOT_WRITLINE_REPLACEMENT("\n- - - - - - - - - - - - -"); int tC = 1; Dictionary<ulong, bool> usedULs = new Dictionary<ulong, bool>(); while (transpositionTable.TryGetValue(zobristKey, out TranspositionEntry tM)) { if (usedULs.ContainsKey(zobristKey)) { SNAPSHOT_WRITLINE_REPLACEMENT(tC + ": AT LEAST ONE REPETION; REST NOT VISIBLE"); break; } SNAPSHOT_WRITLINE_REPLACEMENT(tC + ": "+ tM.bestMove + " > "); usedULs.Add(zobristKey, true); PlainMakeMove(tM.bestMove); tC++; } SNAPSHOT_WRITLINE_REPLACEMENT("- - - - - - - - - - - - -\n"); LoadJumpState(); } public Move? ReturnNextMove(Move? lastMove, long pThinkingTime) { if (lastMove != null) PlainMakeMove(lastMove); if (GameState(isWhiteToMove) != 3) return null; MinimaxRoot(pThinkingTime); if (!transpositionTable.ContainsKey(zobristKey)) return null; Move tm = transpositionTable[zobristKey].bestMove; PlainMakeMove(tm); return tm; } private int[] jmpSt_pieceTypeArray; private ulong jmpSt_whitePieceBitboard, jmpSt_blackPieceBitboard; private ulong jmpSt_zobristKey; private int jmpSt_whiteKingSquare, jmpSt_blackKingSquare, jmpSt_enPassantSquare, jmpSt_happenedHalfMoves, jmpSt_fiftyMoveRuleCounter; private bool jmpSt_whiteCastleRightKingSide, jmpSt_whiteCastleRightQueenSide, jmpSt_blackCastleRightKingSide, jmpSt_blackCastleRightQueenSide; private bool jmpSt_isWhiteToMove; private ulong[] jmpSt_curSearchZobristKeyLine; private int[] jmpSt_moveHashList; public void LoadJumpState() { pieceTypeArray = (int[])jmpSt_pieceTypeArray.Clone(); whitePieceBitboard = jmpSt_whitePieceBitboard; blackPieceBitboard = jmpSt_blackPieceBitboard; zobristKey = jmpSt_zobristKey; whiteKingSquare = jmpSt_whiteKingSquare; blackKingSquare = jmpSt_blackKingSquare; enPassantSquare = jmpSt_enPassantSquare; happenedHalfMoves = jmpSt_happenedHalfMoves; fiftyMoveRuleCounter = jmpSt_fiftyMoveRuleCounter; whiteCastleRightKingSide = jmpSt_whiteCastleRightKingSide; whiteCastleRightQueenSide = jmpSt_whiteCastleRightQueenSide; blackCastleRightKingSide = jmpSt_blackCastleRightKingSide; blackCastleRightQueenSide = jmpSt_blackCastleRightQueenSide; isWhiteToMove = jmpSt_isWhiteToMove; curSearchZobristKeyLine = (ulong[])jmpSt_curSearchZobristKeyLine.Clone(); allPieceBitboard = blackPieceBitboard | whitePieceBitboard; moveHashList = jmpSt_moveHashList.ToList(); } public void SetJumpState() { jmpSt_pieceTypeArray = (int[])pieceTypeArray.Clone(); jmpSt_whitePieceBitboard = whitePieceBitboard; jmpSt_blackPieceBitboard = blackPieceBitboard; jmpSt_zobristKey = zobristKey; jmpSt_whiteKingSquare = whiteKingSquare; jmpSt_blackKingSquare = blackKingSquare; jmpSt_enPassantSquare = enPassantSquare; jmpSt_happenedHalfMoves = happenedHalfMoves; jmpSt_fiftyMoveRuleCounter = fiftyMoveRuleCounter; jmpSt_whiteCastleRightKingSide = whiteCastleRightKingSide; jmpSt_whiteCastleRightQueenSide = whiteCastleRightQueenSide; jmpSt_blackCastleRightKingSide = blackCastleRightKingSide; jmpSt_blackCastleRightQueenSide = blackCastleRightQueenSide; jmpSt_isWhiteToMove = isWhiteToMove; jmpSt_curSearchZobristKeyLine = (ulong[])curSearchZobristKeyLine.Clone(); jmpSt_moveHashList = moveHashList.ToArray(); } private int PreMinimaxCheckCheckWhite() { ulong bitShiftedKingPos = 1ul << whiteKingSquare; int curR = -1; for (int p = 0; p < 64; p++) { if (ULONG_OPERATIONS.IsBitZero(blackPieceBitboard, p)) continue; int tPT; switch (tPT = pieceTypeArray[p]) { case 1: if ((bitShiftedKingPos & blackPawnAttackSquareBitboards[p]) != 0ul) return p; break; case 2: if ((bitShiftedKingPos & knightSquareBitboards[p]) != 0ul) return p; break; case 6: break; default: if ((squareConnectivesPrecalculationLineArray[whiteKingSquare << 6 | p] & allPieceBitboard) == (1ul << p) && pieceTypeAbilities[tPT, squareConnectivesPrecalculationArray[whiteKingSquare << 6 | p]]) { if (curR != -1) return -779; curR = p; } break; } } return curR; } private int PreMinimaxCheckCheckBlack() { ulong bitShiftedKingPos = 1ul << blackKingSquare; int curR = -1; for (int p = 0; p < 64; p++) { if (ULONG_OPERATIONS.IsBitZero(whitePieceBitboard, p)) continue; int tPT; switch (tPT = pieceTypeArray[p]) { case 1: if ((bitShiftedKingPos & whitePawnAttackSquareBitboards[p]) != 0ul) return p; break; case 2: if ((bitShiftedKingPos & knightSquareBitboards[p]) != 0ul) return p; break; case 6: break; default: if ((squareConnectivesPrecalculationLineArray[blackKingSquare << 6 | p] & allPieceBitboard) == (1ul << p) && pieceTypeAbilities[tPT, squareConnectivesPrecalculationArray[blackKingSquare << 6 | p]]) { if (curR != -1) return -779; curR = p; } break; } } return curR; } private int LecacyLeafCheckingPieceCheckWhite(int pStartPos, int pEndPos, int pPieceType) { int tI, tPossibleAttackPiece; if (pPieceType == 1) { if (ULONG_OPERATIONS.IsBitOne(blackPawnAttackSquareBitboards[pEndPos], whiteKingSquare)) return pEndPos; } else if (pPieceType == 2) { if (ULONG_OPERATIONS.IsBitOne(knightSquareBitboards[pEndPos], whiteKingSquare)) return pEndPos; } else if (pPieceType != 6) { tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | pEndPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; } tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | pStartPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; return -1; } private int LecacyLeafCheckingPieceCheckBlack(int pStartPos, int pEndPos, int pPieceType) { int tI, tPossibleAttackPiece; if (pPieceType == 1) { if (ULONG_OPERATIONS.IsBitOne(whitePawnAttackSquareBitboards[pEndPos], blackKingSquare)) return pEndPos; } else if (pPieceType == 2) { if (ULONG_OPERATIONS.IsBitOne(knightSquareBitboards[pEndPos], blackKingSquare)) return pEndPos; } else if (pPieceType != 6) { tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | pEndPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; } tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | pStartPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; return -1; } public void GetLegalMoves(ref List<Move> pMoveList) { int attk; if (isWhiteToMove) { attk = PreMinimaxCheckCheckWhite(); if (attk == -779) GetLegalWhiteMovesSpecialDoubleCheckCase(ref pMoveList); else GetLegalWhiteMoves(attk, ref pMoveList); } else { attk = PreMinimaxCheckCheckBlack(); if (attk == -779) GetLegalBlackMovesSpecialDoubleCheckCase(ref pMoveList); else GetLegalBlackMoves(attk, ref pMoveList); } } private void GetLegalWhiteMoves(int pCheckingPieceSquare, ref List<Move> pMoveList) { if (pCheckingPieceSquare == -779) { GetLegalWhiteMovesSpecialDoubleCheckCase(ref pMoveList); return; } moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= blackPawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, whiteKingSquare); if (curCheckCount == 0) { if (whiteCastleRightKingSide && ((allPieceBitboard | oppAttkBitboard) & WHITE_KING_ROCHADE) == 0ul) pMoveList.Add(mWHITE_KING_ROCHADE); if (whiteCastleRightQueenSide && (allPieceBitboard & WHITE_QUEEN_ROCHADE | oppAttkBitboard & WHITE_QUEEN_ATTK_ROCHADE) == 0ul) pMoveList.Add(mWHITE_QUEEN_ROCHADE); if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, whitePieceBitboard, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[whiteKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare + 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, whitePieceBitboard, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveList(whiteKingSquare, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalWhiteCaptures(int pCheckingPieceSquare, ref List<Move> pMoveList) { if (pCheckingPieceSquare == -779) { GetLegalWhiteCapturesSpecialDoubleCheckCase(ref pMoveList); return; } moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= blackPawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, whiteKingSquare); if (curCheckCount == 0) { if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & blackPieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[whiteKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare + 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & blackPieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveListOnlyCaptures(whiteKingSquare, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalWhiteMovesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= blackPawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveList(whiteKingSquare, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalWhiteCapturesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= blackPawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveListOnlyCaptures(whiteKingSquare, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalBlackMoves(int pCheckingPieceSquare, ref List<Move> pMoveList) { if (pCheckingPieceSquare == -779) { GetLegalBlackMovesSpecialDoubleCheckCase(ref pMoveList); return; } moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= whitePawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, blackKingSquare); if (curCheckCount == 0) { if (blackCastleRightKingSide && ((allPieceBitboard | oppAttkBitboard) & BLACK_KING_ROCHADE) == 0ul) pMoveList.Add(mBLACK_KING_ROCHADE); if (blackCastleRightQueenSide && (allPieceBitboard & BLACK_QUEEN_ROCHADE | oppAttkBitboard & BLACK_QUEEN_ATTK_ROCHADE) == 0ul) pMoveList.Add(mBLACK_QUEEN_ROCHADE); if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveList(p, blackKingSquare, blackPieceBitboard, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[blackKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare - 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveList(p, blackKingSquare, blackPieceBitboard, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveList(blackKingSquare, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); } private void GetLegalBlackCaptures(int pCheckingPieceSquare, ref List<Move> pMoveList) { if (pCheckingPieceSquare == -779) { GetLegalBlackCapturesSpecialDoubleCheckCase(ref pMoveList); return; } moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= whitePawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, blackKingSquare); if (curCheckCount == 0) { if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & whitePieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[blackKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare - 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & whitePieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveListOnlyCaptures(blackKingSquare, ~oppAttkBitboard & whitePieceBitboard); } private void GetLegalBlackMovesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= whitePawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveList(blackKingSquare, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); } private void GetLegalBlackCapturesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= whitePawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveListOnlyCaptures(blackKingSquare, ~oppAttkBitboard & whitePieceBitboard); } public Move GetMoveOfString(string pMove) { int tSP, tEP; string[] tSpl = pMove.Split(','); if (Char.IsNumber(pMove[0])) { tSP = Convert.ToInt32(tSpl[0]); tEP = Convert.ToInt32(tSpl[1]); } else { tSP = SQUARES.NumberNotation(tSpl[0]); tEP = SQUARES.NumberNotation(tSpl[1]); } int tPT = pieceTypeArray[tSP]; bool tIC = ULONG_OPERATIONS.IsBitOne(allPieceBitboard, tEP), tIEP = enPassantSquare == tEP && tPT == 1; if (tSpl.Length == 3) return new Move(tSP, tEP, tPT, Convert.ToInt32(tSpl[2]), tIC); if (tIEP) return new Move(true, tSP, tEP, isWhiteToMove ? tEP - 8 : tEP + 8); if (tPT == 1 && Math.Abs(tSP - tEP) > 11) return new Move(tSP, tEP, 1, false, isWhiteToMove ? tSP + 8 : tSP - 8); if (tPT == 6 && (Math.Abs(tSP - tEP) == 2 || Math.Abs(tSP - tEP) == 3)) { if (isWhiteToMove) return tEP == 6 ? mWHITE_KING_ROCHADE : mWHITE_QUEEN_ROCHADE; return tEP == 62 ? mBLACK_KING_ROCHADE : mBLACK_QUEEN_ROCHADE; } return new Move(tSP, tEP, tPT, tIC); } public void PlainMakeMove(string pMoveName) { PlainMakeMove(GetMoveOfString(pMoveName)); } public void PlainMakeMove(Move pMove) { lastMadeMove = pMove; if (isWhiteToMove) WhiteMakeMove(pMove); else BlackMakeMove(pMove); } public void WhiteMakeMove(Move pMove) { int tEndPos = pMove.endPos, tStartPos = pMove.startPos, tPieceType = pMove.pieceType, tPTI = pieceTypeArray[tEndPos]; fiftyMoveRuleCounter++; whitePieceBitboard ^= pMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey ^= blackTurnHash ^ enPassantSquareHashes[enPassantSquare] ^ pieceHashesWhite[tStartPos, tPieceType] ^ pieceHashesWhite[tEndPos, tPieceType]; enPassantSquare = 65; isWhiteToMove = false; switch (pMove.moveTypeID) { case 0: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 1: fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 2: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 3: whiteKingSquare = tEndPos; if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 4: if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 5: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 6: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 7: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[whiteKingSquare = tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 8: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 9: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = pMove.enPassantOption]; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 11: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; whiteKingSquare = tEndPos; pieceTypeArray[pMove.rochadeEndPos] = 4; pieceTypeArray[pMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesWhite[pMove.rochadeStartPos, 4] ^ pieceHashesWhite[pMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 12: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[pMove.enPassantOption] = 0; zobristKey ^= pieceHashesBlack[pMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 13: fiftyMoveRuleCounter = 0; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; zobristKey ^= pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, pMove.promotionType]; break; case 14: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, tPTI] ^ pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, pMove.promotionType]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; } moveHashList.Add(pMove.moveHash); if (pMove.isCapture || tPieceType == 1) { curSearchZobristKeyLine = Array.Empty<ulong>(); return; } ulong[] u = new ulong[(tPTI = curSearchZobristKeyLine.Length) + 1]; for (int i = tPTI; i-- > 0;) u[i] = curSearchZobristKeyLine[i]; u[tPTI] = zobristKey; curSearchZobristKeyLine = u; } public void BlackMakeMove(Move pMove) { int tEndPos = pMove.endPos, tStartPos = pMove.startPos, tPieceType = pMove.pieceType, tPTI = pieceTypeArray[tEndPos]; fiftyMoveRuleCounter++; blackPieceBitboard ^= pMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey ^= blackTurnHash ^ enPassantSquareHashes[enPassantSquare] ^ pieceHashesBlack[tStartPos, tPieceType] ^ pieceHashesBlack[tEndPos, tPieceType]; enPassantSquare = 65; isWhiteToMove = true; switch (pMove.moveTypeID) { case 0: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 1: fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 2: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 3: blackKingSquare = tEndPos; if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 4: if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 5: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 6: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 7: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[blackKingSquare = tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 8: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 9: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = pMove.enPassantOption]; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 11: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; blackKingSquare = tEndPos; pieceTypeArray[pMove.rochadeEndPos] = 4; pieceTypeArray[pMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesBlack[pMove.rochadeStartPos, 4] ^ pieceHashesBlack[pMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 12: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[pMove.enPassantOption] = 0; zobristKey ^= pieceHashesWhite[pMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 13: fiftyMoveRuleCounter = 0; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, pMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 14: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } zobristKey ^= pieceHashesWhite[tEndPos, tPTI] ^ pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, pMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; } moveHashList.Add(pMove.moveHash); if (pMove.isCapture || tPieceType == 1) { curSearchZobristKeyLine = Array.Empty<ulong>(); return; } ulong[] u = new ulong[(tPTI = curSearchZobristKeyLine.Length) + 1]; for (int i = tPTI; i-- > 0;) u[i] = curSearchZobristKeyLine[i]; u[tPTI] = zobristKey; curSearchZobristKeyLine = u; } public void WhiteUndoMove(Move pMove) { } private const int WHITE_CHECKMATE_VAL = 100000, BLACK_CHECKMATE_VAL = -100000, CHECK_EXTENSION_LENGTH = -12, MAX_QUIESCENCE_TOTAL_LENGTH = -32; private readonly Move NULL_MOVE = new Move(0, 0, 0); private int curSearchDepth = 0, curSubSearchDepth = -1; public int MinimaxRoot(long pTime) { evalCount = 0; searches++; int baseLineLen = 0; long tTimestamp = globalTimer.ElapsedTicks + pTime; ClearHeuristics(); transpositionTable.Clear(); ulong[] tZobristKeyLine = Array.Empty<ulong>(); if (curSearchZobristKeyLine != null) { baseLineLen = curSearchZobristKeyLine.Length; tZobristKeyLine = new ulong[baseLineLen]; Array.Copy(curSearchZobristKeyLine, tZobristKeyLine, baseLineLen); } int perftScore, tattk = isWhiteToMove ? PreMinimaxCheckCheckWhite() : PreMinimaxCheckCheckBlack(), pDepth = 1; (string, int) bookMoveTuple = TLMDatabase.SearchForNextBookMove(moveHashList); if (bookMoveTuple.Item2 != 0) { int actualMoveHash = NuCRe.GetNumber(bookMoveTuple.Item1); List<Move> tMoves = new List<Move>(); GetLegalMoves(ref tMoves); int tL = tMoves.Count; for (int i = 0; i < tL; i++) { if (tMoves[i].moveHash == actualMoveHash) { if (debugSearchDepthResults) { SNAPSHOT_WRITLINE_REPLACEMENT("TLM_DB_Count: " + bookMoveTuple.Item2); SNAPSHOT_WRITLINE_REPLACEMENT(">> " + tMoves[i]); } transpositionTable.Add(zobristKey, new TranspositionEntry(tMoves[i], Array.Empty<int>())); return 0; } } } do { curSearchDepth = pDepth; curSubSearchDepth = pDepth - 1; ulong[] completeZobristHistory = new ulong[baseLineLen + pDepth - CHECK_EXTENSION_LENGTH + 1]; for (int i = 0; i < baseLineLen; i++) completeZobristHistory[i] = curSearchZobristKeyLine[i]; curSearchZobristKeyLine = completeZobristHistory; if (isWhiteToMove) { if (tattk == -1) perftScore = MinimaxWhite(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); else perftScore = MinimaxWhite(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); } else { if (tattk == -1) perftScore = MinimaxBlack(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); else perftScore = MinimaxBlack(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); } if (debugSearchDepthResults && pTime != 1L) { int tNpS = Convert.ToInt32((double)evalCount * 10_000_000d /(double)(pTime - tTimestamp + globalTimer.ElapsedTicks)); int tSearchEval = perftScore; int timeForSearchSoFar = (int)((pTime - tTimestamp + globalTimer.ElapsedTicks) /10000d); Move tBestMove = transpositionTable[zobristKey].bestMove; SNAPSHOT_WRITLINE_REPLACEMENT((tSearchEval >= 0 ? "+": "") + tSearchEval); SNAPSHOT_WRITLINE_REPLACEMENT(" " + tBestMove + "  ["); SNAPSHOT_WRITLINE_REPLACEMENT("Depth = " + pDepth + ", "); SNAPSHOT_WRITLINE_REPLACEMENT("Evals = " + GetThreeDigitSeperatedInteger(evalCount) + ", "); SNAPSHOT_WRITLINE_REPLACEMENT("Time = " + GetThreeDigitSeperatedInteger(timeForSearchSoFar) + "ms, "); SNAPSHOT_WRITLINE_REPLACEMENT("NpS = " + GetThreeDigitSeperatedInteger(tNpS) + "]"); } pDepth++; } while (globalTimer.ElapsedTicks < tTimestamp && pDepth < 179); depths += pDepth - 1; BOT_MAIN.depthsSearched += pDepth - 1; BOT_MAIN.searchesFinished++; BOT_MAIN.evaluationsMade += evalCount; curSearchZobristKeyLine = tZobristKeyLine; return perftScore; } private int MinimaxWhite(int pPly, int pAlpha, int pBeta, int pDepth, int pRepetitionHistoryPly, int pCheckingSquare, Move pLastMove) { if (IsDrawByRepetition(pRepetitionHistoryPly - 4)) return 0; if ((pDepth <= 0 && pCheckingSquare == -1) || pDepth < CHECK_EXTENSION_LENGTH) return QuiescenceWhite(pPly, pAlpha, pBeta, pDepth - 1, pCheckingSquare, pLastMove); List<Move> moveOptionList = new List<Move>(); Move bestMove = NULL_MOVE; if (pLastMove.isPromotion && pLastMove.isCapture && pLastMove.startPos % 8 == pCheckingSquare % 8 && pLastMove.startPos == whiteKingSquare + 8 && (pLastMove.promotionType == 4 || pLastMove.promotionType == 5)) GetLegalWhiteMovesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalWhiteMoves(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tWhiteKingSquare = whiteKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1, curEval = BLACK_CHECKMATE_VAL - pDepth; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = true; double[] moveSortingArray = new double[molc]; int[] moveSortingArrayIndexes = new int[molc], thisSearchMoveSortingArrayForTransposEntry = new int[molc]; transpositionTable.TryGetValue(zobristKey, out TranspositionEntry transposEntry); if (transposEntry == null) { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; } } else { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove == transposEntry.bestMove) moveSortingArray[m] = BESTMOVE_SORT_VAL; else if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; if (transposEntry.moveGenOrderedEvalLength > m) moveSortingArray[m] -= transposEntry.moveGenOrderedEvals[m]; } } Array.Sort(moveSortingArray, moveSortingArrayIndexes); for (int m = 0; m < molc; m++) { int tActualIndex = moveSortingArrayIndexes[m]; Move curMove = moveOptionList[tActualIndex]; if (debugSortResults && pDepth == curSubSearchDepth) { SNAPSHOT_WRITLINE_REPLACEMENT(moveSortingArray[m] + " | "+ curMove); } int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; whitePieceBitboard = tWPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesWhite[tStartPos, tPieceType] ^ pieceHashesWhite[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 0: blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 1: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 2: blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 3: whiteKingSquare = tEndPos; if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 4: blackPieceBitboard = tBPB; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 5: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[whiteKingSquare = tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = curMove.enPassantOption]; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 11: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; whiteKingSquare = tEndPos; blackPieceBitboard = tBPB; pieceTypeArray[curMove.rochadeEndPos] = 4; pieceTypeArray[curMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesWhite[curMove.rochadeStartPos, 4] ^ pieceHashesWhite[curMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | curMove.rochadeEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << curMove.rochadeEndPos)) tCheckPos = curMove.rochadeEndPos; break; case 12: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesBlack[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 13: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; zobristKey ^= pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, curMove.promotionType]; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; case 14: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, tPTI] ^ pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, curMove.promotionType]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } curSearchZobristKeyLine[pRepetitionHistoryPly] = zobristKey; int tEval = MinimaxBlack(pPly + 1, pAlpha, pBeta, pDepth - 1, pRepetitionHistoryPly + 1, tCheckPos, curMove); thisSearchMoveSortingArrayForTransposEntry[tActualIndex] = tEval; pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 3: whiteKingSquare = tWhiteKingSquare; break; case 7: whiteKingSquare = tWhiteKingSquare; break; case 10: enPassantSquare = 65; break; case 11: whiteKingSquare = tWhiteKingSquare; pieceTypeArray[curMove.rochadeStartPos] = 4; pieceTypeArray[curMove.rochadeEndPos] = 0; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 13: pieceTypeArray[tStartPos] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval > curEval) { bestMove = curMove; curEval = tEval; } if (pAlpha < curEval) pAlpha = curEval; if (curEval >= pBeta) { if (!curMove.isCapture) { killerMoveHeuristic[curMove.moveHash] = true; if (pDepth > 0) historyHeuristic[curMove.moveHash] += pDepth * pDepth; } break; } } isWhiteToMove = true; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; if (molc == 0 && pCheckingSquare == 0) curEval = 0; if (!transpositionTable.ContainsKey(zobristKey)) transpositionTable.Add(zobristKey, new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry)); else transpositionTable[zobristKey] = new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry); return curEval; } private int QuiescenceWhite(int pPly, int pAlpha, int pBeta, int pDepth, int pCheckingSquare, Move pLastMove) { int standPat = TexelEvaluate(); if (standPat >= pBeta || pDepth < MAX_QUIESCENCE_TOTAL_LENGTH) return pBeta; if (standPat > pAlpha) pAlpha = standPat; List<Move> moveOptionList = new List<Move>(); if (pLastMove.isPromotion && pLastMove.isCapture && pLastMove.startPos % 8 == pCheckingSquare % 8 && pLastMove.startPos == whiteKingSquare + 8 && (pLastMove.promotionType == 4 || pLastMove.promotionType == 5)) GetLegalWhiteCapturesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalWhiteCaptures(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tWhiteKingSquare = whiteKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = true; for (int m = 0; m < molc; m++) { Move curMove = moveOptionList[m]; int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; whitePieceBitboard = tWPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesWhite[tStartPos, tPieceType] ^ pieceHashesWhite[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 5: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[whiteKingSquare = tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 12: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesBlack[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 14: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, tPTI] ^ pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, curMove.promotionType]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } int tEval = QuiescenceBlack(pPly + 1, pAlpha, pBeta, pDepth - 1, tCheckPos, curMove); pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 7: whiteKingSquare = tWhiteKingSquare; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval >= pBeta) return pBeta; if (pAlpha < tEval) pAlpha = tEval; } isWhiteToMove = true; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; return pAlpha; } private int MinimaxBlack(int pPly, int pAlpha, int pBeta, int pDepth, int pRepetitionHistoryPly, int pCheckingSquare, Move pLastMove) { if (IsDrawByRepetition(pRepetitionHistoryPly - 4)) return 0; if ((pDepth <= 0 && pCheckingSquare == -1) || pDepth < CHECK_EXTENSION_LENGTH) return QuiescenceBlack(pPly, pAlpha, pBeta, pDepth - 1, pCheckingSquare, pLastMove); List<Move> moveOptionList = new List<Move>(); Move bestMove = NULL_MOVE; if (pLastMove.isPromotion && pLastMove.isCapture && pLastMove.startPos % 8 == pCheckingSquare % 8 && pLastMove.startPos == blackKingSquare - 8 && (pLastMove.promotionType == 4 || pLastMove.promotionType == 5)) GetLegalBlackMovesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalBlackMoves(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tBlackKingSquare = blackKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1, curEval = WHITE_CHECKMATE_VAL + pDepth; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = false; double[] moveSortingArray = new double[molc]; int[] moveSortingArrayIndexes = new int[molc], thisSearchMoveSortingArrayForTransposEntry = new int[molc]; transpositionTable.TryGetValue(zobristKey, out TranspositionEntry transposEntry); if (transposEntry == null) { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; } } else { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove == transposEntry.bestMove) moveSortingArray[m] = BESTMOVE_SORT_VAL; else if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; if (transposEntry.moveGenOrderedEvalLength > m) moveSortingArray[m] -= transposEntry.moveGenOrderedEvals[m]; } } Array.Sort(moveSortingArray, moveSortingArrayIndexes); for (int m = 0; m < molc; m++) { int tActualIndex = moveSortingArrayIndexes[m]; Move curMove = moveOptionList[tActualIndex]; if (debugSortResults && pDepth == curSearchDepth) { SNAPSHOT_WRITLINE_REPLACEMENT("=== " + moveSortingArray[m] + " | "+ curMove); } int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; blackPieceBitboard = tBPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesBlack[tStartPos, tPieceType] ^ pieceHashesBlack[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 0: whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 1: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 2: whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 3: blackKingSquare = tEndPos; if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 4: whitePieceBitboard = tWPB; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 5: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[blackKingSquare = tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = curMove.enPassantOption]; whitePieceBitboard = tWPB; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 11: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; blackKingSquare = tEndPos; whitePieceBitboard = tWPB; pieceTypeArray[curMove.rochadeEndPos] = 4; pieceTypeArray[curMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesBlack[curMove.rochadeStartPos, 4] ^ pieceHashesBlack[curMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | curMove.rochadeEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << curMove.rochadeEndPos)) tCheckPos = curMove.rochadeEndPos; break; case 12: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesWhite[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 13: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, curMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; case 14: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } zobristKey ^= pieceHashesWhite[tEndPos, tPTI] ^ pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, curMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } curSearchZobristKeyLine[pRepetitionHistoryPly] = zobristKey; int tEval = MinimaxWhite(pPly + 1, pAlpha, pBeta, pDepth - 1, pRepetitionHistoryPly + 1, tCheckPos, curMove); thisSearchMoveSortingArrayForTransposEntry[tActualIndex] = tEval; pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 3: blackKingSquare = tBlackKingSquare; break; case 7: blackKingSquare = tBlackKingSquare; break; case 10: enPassantSquare = 65; break; case 11: blackKingSquare = tBlackKingSquare; pieceTypeArray[curMove.rochadeStartPos] = 4; pieceTypeArray[curMove.rochadeEndPos] = 0; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 13: pieceTypeArray[tStartPos] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval < curEval) { bestMove = curMove; curEval = tEval; } if (pBeta > curEval) pBeta = curEval; if (curEval <= pAlpha) { if (!curMove.isCapture) { killerMoveHeuristic[curMove.moveHash] = true; if (pDepth > 0) historyHeuristic[curMove.moveHash] += pDepth * pDepth; } break; } } isWhiteToMove = false; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; if (molc == 0 && pCheckingSquare == 0) curEval = 0; if (!transpositionTable.ContainsKey(zobristKey)) transpositionTable.Add(zobristKey, new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry)); else transpositionTable[zobristKey] = new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry); return curEval; } private int QuiescenceBlack(int pPly, int pAlpha, int pBeta, int pDepth, int pCheckingSquare, Move pLastMove) { int standPat = TexelEvaluate(); if (standPat <= pAlpha || pDepth < MAX_QUIESCENCE_TOTAL_LENGTH) return pAlpha; if (standPat < pBeta) pBeta = standPat; List<Move> moveOptionList = new List<Move>(); if (pLastMove.isPromotion && pLastMove.isCapture && pLastMove.startPos % 8 == pCheckingSquare % 8 && pLastMove.startPos == blackKingSquare - 8 && (pLastMove.promotionType == 4 || pLastMove.promotionType == 5)) GetLegalBlackCapturesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalBlackCaptures(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tBlackKingSquare = blackKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = false; for (int m = 0; m < molc; m++) { Move curMove = moveOptionList[m]; int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; blackPieceBitboard = tBPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesBlack[tStartPos, tPieceType] ^ pieceHashesBlack[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 5: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[blackKingSquare = tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 12: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesWhite[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 14: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } zobristKey ^= pieceHashesWhite[tEndPos, tPTI] ^ pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, curMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } int tEval = QuiescenceWhite(pPly + 1, pAlpha, pBeta, pDepth - 1, tCheckPos, curMove); pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 7: blackKingSquare = tBlackKingSquare; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval <= pAlpha) return pAlpha; if (pBeta > tEval) pBeta = tEval; } isWhiteToMove = false; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; return pBeta; } private bool[] killerMoveHeuristic = new bool[262_144]; private int[] historyHeuristic = new int[262_144]; public void ClearHeuristics() { for (int i = 0; i < 262_144; i++) { killerMoveHeuristic[i] = false; historyHeuristic[i] = 0; } } private Dictionary<ulong, TranspositionEntry> transpositionTable = new Dictionary<ulong, TranspositionEntry>(); private int[] pieceEvals = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[,][] piecePositionEvals = new int[33, 14][]; private int evalCount = 0; private int Evaluate() { evalCount++; if (fiftyMoveRuleCounter > 99) return 0; int tEval = 0, tPT, pieceCount = ULONG_OPERATIONS.CountBits(allPieceBitboard); for (int p = 0; p < 64; p++) tEval += pieceEvals[tPT = pieceTypeArray[p] + 7 * ((int)(blackPieceBitboard >> p) & 1)] + piecePositionEvals[pieceCount, tPT][p]; return tEval; } public int GameState(bool pWhiteKingCouldBeAttacked) { if (IsDrawByRepetition(curSearchZobristKeyLine.Length - 5) || fiftyMoveRuleCounter > 99) return 0; int t; List<Move> tMoves = new List<Move>(); GetLegalMoves(ref tMoves); if (pWhiteKingCouldBeAttacked) { t = PreMinimaxCheckCheckWhite(); if (t == -1) return tMoves.Count == 0 ? 0 : 3; else if (tMoves.Count == 0) return -1; } else { t = PreMinimaxCheckCheckBlack(); if (t == -1) return tMoves.Count == 0 ? 0 : 3; else if (tMoves.Count == 0) return 1; } return 3; } private bool IsDrawByRepetition(int pPlyOfFirstPossibleRepeatedPosition) { int tC = 0; for (int i = pPlyOfFirstPossibleRepeatedPosition; i >= 0; i -= 2) { if (curSearchZobristKeyLine[i] == zobristKey) if (++tC == 2) return true; } return false; } private const int RELE_MAX_MOVE_COUNT_PER_GAME = 500; public double ReLePlayGame(int[,][] pEvalPositionValuesWhite, int[,][] pEvalPositionValuesBlack, long thinkingTimePerMove) { int[,][] processedValuesWhite = InitReLeAgent(pEvalPositionValuesWhite), processedValuesBlack = InitReLeAgent(pEvalPositionValuesBlack); int tGS, mc = 0; do { if (IsDrawByRepetition(curSearchZobristKeyLine.Length - 5)) return 0d; piecePositionEvals = isWhiteToMove ? processedValuesWhite : processedValuesBlack; MinimaxRoot(thinkingTimePerMove); if (transpositionTable.Count == 0) { SNAPSHOT_WRITLINE_REPLACEMENT("?!"); return 0d; } PlainMakeMove(transpositionTable[zobristKey].bestMove); tGS = GameState(isWhiteToMove); transpositionTable.Clear(); if (tGS != 3) break; } while (mc++ < RELE_MAX_MOVE_COUNT_PER_GAME); if (tGS == 3 || tGS == 0) return 0d; else if (tGS == 1) return 0.1d * (double)(RELE_MAX_MOVE_COUNT_PER_GAME - mc); return 0.1d * (double)(-RELE_MAX_MOVE_COUNT_PER_GAME + mc); } public int[,][] InitReLeAgent(int[,][] pEvalPositionValues) { return GetInterpolatedProcessedValues(pEvalPositionValues); } private int[,][] GetInterpolatedProcessedValues(int[,][] pEvalPositionValues) { int[,][] processedValues = new int[33, 14][]; for (int i = 0; i < 32; i++) { int ip1 = i + 1; processedValues[ip1, 7] = processedValues[ip1, 0] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; processedValues[ip1, 8] = SwapArrayViewingSide(processedValues[ip1, 1] = MultiplyArraysWithVal(pEvalPositionValues[0, 0], pEvalPositionValues[1, 0], pEvalPositionValues[2, 0], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 9] = SwapArrayViewingSide(processedValues[ip1, 2] = MultiplyArraysWithVal(pEvalPositionValues[0, 1], pEvalPositionValues[1, 1], pEvalPositionValues[2, 1], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 10] = SwapArrayViewingSide(processedValues[ip1, 3] = MultiplyArraysWithVal(pEvalPositionValues[0, 2], pEvalPositionValues[1, 2], pEvalPositionValues[2, 2], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 11] = SwapArrayViewingSide(processedValues[ip1, 4] = MultiplyArraysWithVal(pEvalPositionValues[0, 3], pEvalPositionValues[1, 3], pEvalPositionValues[2, 3], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 12] = SwapArrayViewingSide(processedValues[ip1, 5] = MultiplyArraysWithVal(pEvalPositionValues[0, 4], pEvalPositionValues[1, 4], pEvalPositionValues[2, 4], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 13] = SwapArrayViewingSide(processedValues[ip1, 6] = MultiplyArraysWithVal(pEvalPositionValues[0, 5], pEvalPositionValues[1, 5], pEvalPositionValues[2, 5], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); } return processedValues; } private double[,][] GetInterpolatedProcessedValues(double[,][] pEvalPositionValues) { double[,][] processedValues = new double[33, 14][]; for (int i = 0; i < 32; i++) { int ip1 = i + 1; processedValues[ip1, 7] = processedValues[ip1, 0] = new double[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; processedValues[ip1, 8] = SwapArrayViewingSide(processedValues[ip1, 1] = MultiplyArraysWithVal(pEvalPositionValues[0, 0], pEvalPositionValues[1, 0], pEvalPositionValues[2, 0], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 9] = SwapArrayViewingSide(processedValues[ip1, 2] = MultiplyArraysWithVal(pEvalPositionValues[0, 1], pEvalPositionValues[1, 1], pEvalPositionValues[2, 1], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 10] = SwapArrayViewingSide(processedValues[ip1, 3] = MultiplyArraysWithVal(pEvalPositionValues[0, 2], pEvalPositionValues[1, 2], pEvalPositionValues[2, 2], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 11] = SwapArrayViewingSide(processedValues[ip1, 4] = MultiplyArraysWithVal(pEvalPositionValues[0, 3], pEvalPositionValues[1, 3], pEvalPositionValues[2, 3], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 12] = SwapArrayViewingSide(processedValues[ip1, 5] = MultiplyArraysWithVal(pEvalPositionValues[0, 4], pEvalPositionValues[1, 4], pEvalPositionValues[2, 4], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 13] = SwapArrayViewingSide(processedValues[ip1, 6] = MultiplyArraysWithVal(pEvalPositionValues[0, 5], pEvalPositionValues[1, 5], pEvalPositionValues[2, 5], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); } return processedValues; } private double[] MultiplyArraysWithVal(double[] pArr1, double[] pArr2, double[] pArr3, double pVal1, double pVal2, double pVal3) { int tL = pArr1.Length; double[] rArr = new double[tL]; for (int i = 0; i < tL; i++) { rArr[i] = pArr1[i] * pVal1 + pArr2[i] * pVal2 + pArr3[i] * pVal3; } return rArr; } private int[] MultiplyArraysWithVal(int[] pArr1, int[] pArr2, int[] pArr3, double pVal1, double pVal2, double pVal3) { int tL = pArr1.Length; int[] rArr = new int[tL]; for (int i = 0; i < tL; i++) { rArr[i] = (int)(pArr1[i] * pVal1 + pArr2[i] * pVal2 + pArr3[i] * pVal3); } return rArr; } private int[] SwapArrayViewingSideAndNegate(int[] pArr) { return new int[64] { -pArr[56], -pArr[57], -pArr[58], -pArr[59], -pArr[60], -pArr[61], -pArr[62], -pArr[63], -pArr[48], -pArr[49], -pArr[50], -pArr[51], -pArr[52], -pArr[53], -pArr[54], -pArr[55], -pArr[40], -pArr[41], -pArr[42], -pArr[43], -pArr[44], -pArr[45], -pArr[46], -pArr[47], -pArr[32], -pArr[33], -pArr[34], -pArr[35], -pArr[36], -pArr[37], -pArr[38], -pArr[39], -pArr[24], -pArr[25], -pArr[26], -pArr[27], -pArr[28], -pArr[29], -pArr[30], -pArr[31], -pArr[16], -pArr[17], -pArr[18], -pArr[19], -pArr[20], -pArr[21], -pArr[22], -pArr[23], -pArr[8], -pArr[9], -pArr[10], -pArr[11], -pArr[12], -pArr[13], -pArr[14], -pArr[15], -pArr[0], -pArr[1], -pArr[2], -pArr[3], -pArr[4], -pArr[5], -pArr[6], -pArr[7] }; } private int[] SwapArrayViewingSide(int[] pArr) { return new int[64] { pArr[56], pArr[57], pArr[58], pArr[59], pArr[60], pArr[61], pArr[62], pArr[63], pArr[48], pArr[49], pArr[50], pArr[51], pArr[52], pArr[53], pArr[54], pArr[55], pArr[40], pArr[41], pArr[42], pArr[43], pArr[44], pArr[45], pArr[46], pArr[47], pArr[32], pArr[33], pArr[34], pArr[35], pArr[36], pArr[37], pArr[38], pArr[39], pArr[24], pArr[25], pArr[26], pArr[27], pArr[28], pArr[29], pArr[30], pArr[31], pArr[16], pArr[17], pArr[18], pArr[19], pArr[20], pArr[21], pArr[22], pArr[23], pArr[8], pArr[9], pArr[10], pArr[11], pArr[12], pArr[13], pArr[14], pArr[15], pArr[0], pArr[1], pArr[2], pArr[3], pArr[4], pArr[5], pArr[6], pArr[7] }; } private double[] SwapArrayViewingSide(double[] pArr) { return new double[64] { pArr[56], pArr[57], pArr[58], pArr[59], pArr[60], pArr[61], pArr[62], pArr[63], pArr[48], pArr[49], pArr[50], pArr[51], pArr[52], pArr[53], pArr[54], pArr[55], pArr[40], pArr[41], pArr[42], pArr[43], pArr[44], pArr[45], pArr[46], pArr[47], pArr[32], pArr[33], pArr[34], pArr[35], pArr[36], pArr[37], pArr[38], pArr[39], pArr[24], pArr[25], pArr[26], pArr[27], pArr[28], pArr[29], pArr[30], pArr[31], pArr[16], pArr[17], pArr[18], pArr[19], pArr[20], pArr[21], pArr[22], pArr[23], pArr[8], pArr[9], pArr[10], pArr[11], pArr[12], pArr[13], pArr[14], pArr[15], pArr[0], pArr[1], pArr[2], pArr[3], pArr[4], pArr[5], pArr[6], pArr[7] }; } private int[,][] texelTuningRuntimeVals = new int[33, 14][]; private int[,][] texelTuningVals = new int[3, 6][]; private int[,] texelTuningAdjustIterations = new int[6, 64]; private int[][] texelTuningRuntimePositionalValsV2EG = new int[14][]; private int[][] texelTuningRuntimePositionalValsV2LG = new int[14][]; private int[] texelPieceEvaluationsV2EG = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[] texelPieceEvaluationsV2LG = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[] texelKingSafetyR1EvaluationsEG = new int[9]; private int[] texelKingSafetyR2EvaluationsEG = new int[17]; private int[] texelKingSafetyR1EvaluationsLG = new int[9]; private int[] texelKingSafetyR2EvaluationsLG = new int[17]; private int[] texelKingSafetySREvaluationsPT1EG = new int[12]; private int[] texelKingSafetySREvaluationsPT2EG = new int[12]; private int[] texelKingSafetySREvaluationsPT3EG = new int[12]; private int[] texelKingSafetySREvaluationsPT4EG = new int[12]; private int[] texelKingSafetySREvaluationsPT5EG = new int[12]; private int[] texelKingSafetySREvaluationsPT6EG = new int[12]; private int[] texelKingSafetySREvaluationsPT1LG = new int[12]; private int[] texelKingSafetySREvaluationsPT2LG = new int[12]; private int[] texelKingSafetySREvaluationsPT3LG = new int[12]; private int[] texelKingSafetySREvaluationsPT4LG = new int[12]; private int[] texelKingSafetySREvaluationsPT5LG = new int[12]; private int[] texelKingSafetySREvaluationsPT6LG = new int[12]; private int[,] texelMobilityStraightEG = new int[14, 15], texelMobilityStraightLG = new int[14, 15]; private int[,] texelMobilityDiagonalEG = new int[14, 14], texelMobilityDiagonalLG = new int[14, 14]; private int[] texelPieceEvaluations = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[] blackSidedSquares = new int[64] { 56, 57, 58, 59, 60, 61, 62, 63, 48, 49, 50, 51, 52, 53, 54, 55, 40, 41, 42, 43, 44, 45, 46, 47, 32, 33, 34, 35, 36, 37, 38, 39, 24, 25, 26, 27, 28, 29, 30, 31, 16, 17, 18, 19, 20, 21, 22, 23, 08, 09, 10, 11, 12, 13, 14, 15, 00, 01, 02, 03, 04, 05, 06, 07 }; private int[,] T_Pawns = new int[3, 64] { { 0, 0, 0, 0, 0, 0, 0, 0, 98, 134, 61, 95, 68, 126, 34, -11, -6, 7, 26, 31, 65, 56, 25, -20, -14, 13, 6, 21, 23, 12, 17, -23, -27, -2, -5, 12, 17, 6, 10, -25, -26, -4, -4, -10, 3, 3, 33, -12, -35, -1, -20, -23, -15, 24, 38, -22, 0, 0, 0, 0, 0, 0, 0, 0, } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { 0, 0, 0, 0, 0, 0, 0, 0, 178, 173, 158, 134, 147, 132, 165, 187, 94, 100, 85, 67, 56, 53, 82, 84, 32, 24, 13, 5, -2, 4, 17, 17, 13, 9, -3, -7, -7, -8, 3, -1, 4, 7, -6, 1, 0, -5, -1, -8, 13, 8, 8, 10, 13, 0, 2, -7, 0, 0, 0, 0, 0, 0, 0, 0, } }; private int[,] T_Knights = new int[3, 64] { { -167, -89, -34, -49, 61, -97, -15, -107, -73, -41, 72, 36, 23, 62, 7, -17, -47, 60, 37, 65, 84, 129, 73, 44, -9, 17, 19, 53, 37, 69, 18, 22, -13, 4, 16, 13, 28, 19, 21, -8, -23, -9, 12, 10, 19, 17, 25, -16, -29, -53, -12, -3, -1, 18, -14, -19, -105, -21, -58, -33, -17, -28, -19, -23 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -58, -38, -13, -28, -31, -27, -63, -99, -25, -8, -25, -2, -9, -25, -24, -52, -24, -20, 10, 9, -1, -9, -19, -41, -17, 3, 22, 22, 22, 11, 8, -18, -18, -6, 16, 25, 16, 17, 4, -18, -23, -3, -1, 15, 10, -3, -20, -22, -42, -20, -10, -5, -2, -20, -23, -44, -29, -51, -23, -15, -22, -18, -50, -64 } }; private int[,] T_Bishops = new int[3, 64] { { -29, 4, -82, -37, -25, -42, 7, -8, -26, 16, -18, -13, 30, 59, 18, -47, -16, 37, 43, 40, 35, 50, 37, -2, -4, 5, 19, 50, 37, 37, 7, -2, -6, 13, 13, 26, 34, 12, 10, 4, 0, 15, 15, 15, 14, 27, 18, 10, 4, 15, 16, 0, 7, 21, 33, 1, -33, -3, -14, -21, -13, -12, -39, -21 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -14, -21, -11, -8, -7, -9, -17, -24, -8, -4, 7, -12, -3, -13, -4, -14, 2, -8, 0, -1, -2, 6, 0, 4, -3, 9, 12, 9, 14, 10, 3, 2, -6, 3, 13, 19, 7, 10, -3, -9, -12, -3, 8, 10, 13, 3, -7, -15, -14, -18, -7, -1, 4, -9, -15, -27, -23, -9, -23, -5, -9, -16, -5, -17 } }; private int[,] T_Rooks = new int[3, 64] { { 32, 42, 32, 51, 63, 9, 31, 43, 27, 32, 58, 62, 80, 67, 26, 44, -5, 19, 26, 36, 17, 45, 61, 16, -24, -11, 7, 26, 24, 35, -8, -20, -36, -26, -12, -1, 9, -7, 6, -23, -45, -25, -16, -17, 3, 0, -5, -33, -44, -16, -20, -9, -1, 11, -6, -71, -19, -13, 1, 17, 16, 7, -37, -26 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { 13, 10, 18, 15, 12, 12, 8, 5, 11, 13, 13, 11, -3, 3, 8, 3, 7, 7, 7, 5, 4, -3, -5, -3, 4, 3, 13, 1, 2, 1, -1, 2, 3, 5, 8, 4, -5, -6, -8, -11, -4, 0, -5, -1, -7, -12, -8, -16, -6, -6, 0, 2, -9, -9, -11, -3, -9, 2, 3, -1, -5, -13, 4, -20 } }; private int[,] T_Queens = new int[3, 64] { { -28, 0, 29, 12, 59, 44, 43, 45, -24, -39, -5, 1, -16, 57, 28, 54, -13, -17, 7, 8, 29, 56, 47, 57, -27, -27, -16, -16, -1, 17, -2, 1, -9, -26, -9, -10, -2, -4, 3, -3, -14, 2, -11, -2, -5, 2, 14, 5, -35, -8, 11, 2, 8, 15, -3, 1, -1, -18, -9, 10, -15, -25, -31, -50 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -9, 22, 22, 27, 27, 19, 10, 20, -17, 20, 32, 41, 58, 25, 30, 0, -20, 6, 9, 49, 47, 35, 19, 9, 3, 22, 24, 45, 57, 40, 57, 36, -18, 28, 19, 47, 31, 34, 39, 23, -16, -27, 15, 6, 9, 17, 10, 5, -22, -23, -30, -16, -16, -23, -36, -32, -33, -28, -22, -43, -5, -32, -20, -41 } }; private int[,] T_Kings = new int[3, 64] { { -65, 23, 16, -15, -56, -34, 2, 13, 29, -1, -20, -7, -8, -4, -38, -29, -9, 24, 2, -16, -20, 6, 22, -22, -17, -20, -12, -27, -30, -25, -14, -36, -49, -1, -27, -39, -46, -44, -33, -51, -14, -14, -22, -46, -44, -30, -15, -27, 1, 7, -8, -64, -43, -16, 9, 8, -15, 36, 12, -54, 8, -28, 24, 14 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -74, -35, -18, -18, -11, 15, 4, -17, -12, 17, 14, 17, 17, 38, 23, 11, 10, 17, 23, 15, 20, 45, 44, 13, -8, 22, 24, 27, 26, 33, 26, 3, -18, -4, 21, 24, 27, 23, 9, -11, -19, -3, 11, 21, 23, 16, 7, -9, -27, -11, 4, 13, 14, 4, -5, -17, -53, -34, -21, -11, -28, -14, -24, -43 } }; private int[] paramsLowerLimits = new int[5] { -10000, -10000, -10000, -10000, -10000 }; private int[] paramsUpperLimits = new int[5] { 10000, 10000, 10000, 10000, 10000 }; private List<TLM_ChessGame> threadDataset; private int threadFrom, threadTo; private int[] threadParams; private int customThreadID = 0; private ulong ulAllThreadIDsUnfinished = 0; private double lastCostVal = 0d; private double sumCostVals = 0d; private int costCalculations = 0; private readonly string[] TEXELPRINT_GAMEPARTS = new string[3] { "Early Game: ", "Mid Game: ", "Late Game: "}; private readonly string[] TEXELPRINT_PIECES = new string[6] { "Bauer: ", "Springer: ", "Lufer: ", "Turm: ", "Dame: ", "Knig: "}; private double[] earlyGameMultipliers = new double[33]; private double[] middleGameMultipliers = new double[33]; private double[] lateGameMultipliers = new double[33]; private int[] pieceTypeGameProgressImpact = new int[14] { 0, 0, 1, 1, 2, 4, 0, 0, 0, 1, 1, 2, 4, 0 }; private void PrecalculateMultipliers() { if (BOARD_MANAGER_ID == ENGINE_VALS.PARALLEL_BOARDS - 1) SNAPSHOT_WRITLINE_REPLACEMENT(); for (int i = 0; i < 25; i++) { earlyGameMultipliers[i] = EGMultiplierFunction(i); lateGameMultipliers[i] = LGMultiplierFunction(i); if (BOARD_MANAGER_ID == ENGINE_VALS.PARALLEL_BOARDS - 1) SNAPSHOT_WRITLINE_REPLACEMENT("[" + i + "] "+ earlyGameMultipliers[i] + " | "+ middleGameMultipliers[i] + " | "+ lateGameMultipliers[i]); } } private double MultiplierFunction(double pVal, double pXShift) { double d = Math.Exp(1d /6d * (pVal - pXShift)); return 5 * (d /Math.Pow(d + 1, 2d)); } private double EGMultiplierFunction(double pVal) { return Math.Clamp(1 /16d * (pVal - 4d), 0d, 1d); } private double LGMultiplierFunction(double pVal) { return Math.Clamp(1 /-16d * (pVal - 4d) + 1d, 0d, 1d); } private double EGMultiplierFunction2(double pVal) { return Math.Clamp(1 /32d * pVal, 0d, 1d); } private double LGMultiplierFunction2(double pVal) { return Math.Clamp(1 /-32d * pVal + 1d, 0d, 1d); } private void TuneWithTxtFile(string pTXTName) { List<TLM_ChessGame> gameDataset = new List<TLM_ChessGame>(); string tPath = PathManager.GetTXTPath(pTXTName); string[] tStrs = File.ReadAllLines(tPath); List<string> tGames = new List<string>(); foreach (string s in tStrs) if (s.Contains(';') && s.Replace(" ", "") != "") tGames.Add(s); foreach (string s in tGames) { TLM_ChessGame tGame = CGFF.GetGame(s); LoadFenString(tGame.startFen); foreach (int hMove in tGame.hashedMoves) { List<Move> moveOptionList = new List<Move>(); GetLegalMoves(ref moveOptionList); int tL = moveOptionList.Count; for (int j = 0; j < tL; j++) { Move tMove = moveOptionList[j]; if (tMove.moveHash == hMove) { tGame.actualMoves.Add(tMove); PlainMakeMove(tMove); tL = -1; break; } } if (tL != -1) break; } gameDataset.Add(tGame); } SNAPSHOT_WRITLINE_REPLACEMENT("[TLM TEXEL TUNER] " + tGames.Count + " Games Loaded In!"); BOT_MAIN.curTEXELPARAMS = new int[TEXEL_PARAMS]; BOT_MAIN.ParallelTexelTuning(gameDataset); } private void LoadBestTexelParamsIn() { int[] ttt = new int[778] { 82, 341, 416, 470, 1106, 102, 302, 304, 518, 960, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, -46, 0, -20, 0, 64, -21, -71, 37, 29, 6, 98, 13, 44, 0, -26, -14, -36, -20, 94, 16, 60, 10, -62, -19, -38, -8, -28, 14, -26, -4, -32, -28, -52, 30, 56, -40, -72, -22, 100, 4, -98, -34, 6, -49, 32, -10, 72, 20, 84, -56, -60, -112, 128, -28, 152, 34, 26, -52, 200, -56, 76, 44, -56, -113, -156, 188, -39, 28, 200, -90, -60, -86, 100, -178, -119, -200, 200, 200, -20, -22, -78, -158, -200, 196, 200, -200, -200, -200, 104, 200, 138, -122, 200, 200, 124, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 200, 156, -37, -68, -148, -200, 200, -70, 72, 76, -31, -200, -21, 178, -200, 200, 200, -200, 123, -188, -6, 164, -74, 24, -28, -8, 71, -50, -112, -200, -8, -44, 27, -23, -50, 19, 19, 41, 150, 152, 4, -98, -36, -34, 174, -106, -16, 17, 141, -48, -108, 162, 6, -112, -52, 76, 68, 8, -86, 68, -176, 189, 81, 162, -200, 152, -41, 128, 172, -173, -144, 56, 22, 94, -28, 32, 16, -63, 36, -200, -200, -200, -22, 56, -116, 76, -36, -30, 100, 52, -166, -114, 142, -52, -44, -200, -18, -72, 60, 200, -160, 96, 46, -200, -28, -32, -44, 132, 60, -200, -137, -200, -176, 200, -200, -200, 4, 200, -200, 72, 200, -78, 200, 160, -105, 200, 96, -114, 200, 200, -88, -24, 11, -34, 184, 26, 83, -140, 10, -16, -72, -200, 12, -200, 46, -200, 11, 82, 66, -102, 22, -184, 32, 114, 140, -26, -18, -36, 66, 100, 25, -24, 133, -96, 50, 2, 80, 184, 43, -136, 44, 124, -148, 180, 69, -126, -200, 6, 78, -96, 89, -68, 200, -116, 114, 158, 5, -154, 115, 200, -152, -171, 41, -80, -23, 137, 98, -80, 40, -42, 200, 52, 146, 200, 6, -112, 32, 200, 132, 4, 90, -200, -200, 104, 67, -56, 186, 124, 140, 97, -144, 200, -4, -160, -117, -200, 24, -80, 200, 28, -46, -24, -52, -200, -200, 72, 20, 34, 200, -16, 88, 56, 200, -146, 120, 174, 200, -200, -86, 125, 172, -70, 4, 124, -72, 0, -2, 70, -14, 48, -32, 200, 80, 24, -132, 74, -44, 184, -4, -136, 0, -16, 20, -18, -32, 96, 92, 56, 2, 174, 196, -200, -56, -116, 88, 200, -8, 168, -13, 74, -106, 200, -182, 80, 82, -128, -16, 90, -200, 66, -88, 58, -16, 80, -34, 96, -95, -96, -200, 76, 26, -72, 32, -27, -108, 164, 200, -36, -93, -10, -56, 22, 36, 74, -200, -96, 200, 88, -88, 156, -92, 96, -200, 200, 191, -8, 62, -8, -100, 136, -72, -36, 200, -64, -114, 153, -110, 174, 46, 108, 142, 121, -200, 108, -200, 74, -4, 104, -200, 116, 82, 200, -76, 176, -200, 76, -8, 200, 46, 29, -86, 12, -24, -80, -12, 200, 124, -16, 54, 104, 200, -94, 140, 36, 32, -64, 24, -178, 15, -200, 0, -200, 4, -32, -124, 148, 176, 192, 90, 164, -91, 200, 172, -200, 64, 34, 40, -200, 0, -200, 12, -124, 48, -200, -56, 184, -8, -184, 0, 200, -16, 200, -8, 180, -18, -20, 24, -200, -58, 174, -200, 40, -4, -200, -24, 200, 54, 200, -24, -32, 37, 192, 48, 44, 26, 200, -22, 200, -145, -200, 30, 86, 54, 200, -102, -34, 94, -98, 92, -200, -76, 196, -18, -200, -180, 16, 186, -92, -200, -200, 164, -200, 62, 192, 159, -112, -12, -70, 184, 104, 200, -200, -148, -4, 86, -144, 200, -100, 200, 200, -104, 114, 132, -168, 12, 56, -10, 82, 200, -200, -200, -196, -6, 52, -200, 84, 200, -192, 128, 200, -200, -200, 200, 88, 168, -32, -84, 172, 52, -172, 0, -40, 68, -186, 42, 96, -200, -198, 200, -56, -176, 88, 0, 86, 16, -124, -46, 40, -16, -4, 54, -184, 200, 58, -200, 77, -200, -44, 102, 0, -50, -10, -92, 100, -86, 8, 20, -20, -200, 38, -200, -49, -4, 2, -200, 78, 0, -40, -92, 32, 0, -164, -88, -38, -138, -118, 29, -34, -200, -200, -200, -71, -200, 200, -200, -108, -200, 0, 192, -24, 104, -200, 200, 190, -28, -200, -200, -200, 128, -96, 200, 200, 200, 200, -200, -200, 177, -24, 200, 132, 200, -190, 200, -130, 200, 148, 200, 200, -200, -100, 200, -196, -200, 90, 200, -200, 200, 200, -200, -200, -200, -200, -200, 118, -200, 85, -200, 166, 199, -200 }; SetupTexelEvaluationParams(ttt); } private void SetupTexelEvaluationParams(int[] pParams) { texelPieceEvaluationsV2EG[8] = -(texelPieceEvaluationsV2EG[1] = pParams[0]); texelPieceEvaluationsV2EG[9] = -(texelPieceEvaluationsV2EG[2] = pParams[1]); texelPieceEvaluationsV2EG[10] = -(texelPieceEvaluationsV2EG[3] = pParams[2]); texelPieceEvaluationsV2EG[11] = -(texelPieceEvaluationsV2EG[4] = pParams[3]); texelPieceEvaluationsV2EG[12] = -(texelPieceEvaluationsV2EG[5] = pParams[4]); texelPieceEvaluationsV2LG[8] = -(texelPieceEvaluationsV2LG[1] = pParams[5]); texelPieceEvaluationsV2LG[9] = -(texelPieceEvaluationsV2LG[2] = pParams[6]); texelPieceEvaluationsV2LG[10] = -(texelPieceEvaluationsV2LG[3] = pParams[7]); texelPieceEvaluationsV2LG[11] = -(texelPieceEvaluationsV2LG[4] = pParams[8]); texelPieceEvaluationsV2LG[12] = -(texelPieceEvaluationsV2LG[5] = pParams[9]); int c = 10; for (int p = 1; p < 7; p++) { for (int s = 0; s < 64; s++) { texelTuningRuntimePositionalValsV2EG[p + 7][blackSidedSquares[s]] = -(texelTuningRuntimePositionalValsV2EG[p][s] = pParams[c++]); texelTuningRuntimePositionalValsV2LG[p + 7][blackSidedSquares[s]] = -(texelTuningRuntimePositionalValsV2LG[p][s] = pParams[c++]); } } return; for (int p = 2; p < 7; p++) { for (int a = 0; a < 15; a++) { if (a != 14) { texelMobilityDiagonalEG[p + 7, a] = -(texelMobilityDiagonalEG[p, a] = pParams[c++]); texelMobilityDiagonalLG[p + 7, a] = -(texelMobilityDiagonalLG[p, a] = pParams[c++]); } texelMobilityStraightEG[p + 7, a] = -(texelMobilityStraightEG[p, a] = pParams[c++]); texelMobilityStraightLG[p + 7, a] = -(texelMobilityStraightLG[p, a] = pParams[c++]); } } for (int i = 0; i < 12; i++) { texelKingSafetySREvaluationsPT1EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT2EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT3EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT4EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT5EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT6EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT1LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT2LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT3LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT4LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT5LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT6LG[i] = pParams[c++]; } } private void PrintDefinedTexelParams(int[] pParams) { int c = 0; for (int t = 0; t < 3; t++) { SNAPSHOT_WRITLINE_REPLACEMENT(TEXELPRINT_GAMEPARTS[t]); for (int p = 0; p < 6; p++) { SNAPSHOT_WRITLINE_REPLACEMENT(TEXELPRINT_PIECES[p]); texelTuningVals[t, p] = new int[64]; for (int s = 0; s < 64; s++) { if (s % 8 == 0 && s != 0) SNAPSHOT_WRITLINE_REPLACEMENT(); SNAPSHOT_WRITLINE_REPLACEMENT((texelTuningVals[t, p][s] = pParams[c++]) + ", "); } SNAPSHOT_WRITLINE_REPLACEMENT(); } } piecePositionEvals = GetInterpolatedProcessedValues(texelTuningVals); } public void TLMTuning(List<TLM_ChessGame> pDataset) { int tGameDataSetLen = pDataset.Count; int[,][] tRatio = new int[33, 6][]; int[,][] tTotalMoves = new int[33, 6][]; double[,][] tSummedRatios = new double[33, 6][]; double[,][] tSummedDataAmount = new double[33, 6][]; double[,][] tTuningResults = new double[33, 6][]; for (int t = 1; t < 33; t++) { for (int p = 0; p < 6; p++) { tRatio[t, p] = new int[64]; tTotalMoves[t, p] = new int[64]; tSummedRatios[t, p] = new double[64]; tSummedDataAmount[t, p] = new double[64]; tTuningResults[t, p] = new double[64]; } } for (int j = 0; j < tGameDataSetLen; j++) { TLM_ChessGame tGame = pDataset[j]; int tGR = tGame.gameResult - 1; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count - 5; for (int i = 0; i < tL; i++) { if (tGame.isMoveNonTactical[i]) { int tPieceAmount = ULONG_OPERATIONS.CountBits(allPieceBitboard); for (int s = 0; s < 64; s++) { int tPT = pieceTypeArray[s] - 1; if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, s)) { tTotalMoves[tPieceAmount, tPT][s]++; tRatio[tPieceAmount, tPT][s] += tGR; } else if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, s)) { int b = blackSidedSquares[s]; tTotalMoves[tPieceAmount, tPT][b]++; tRatio[tPieceAmount, tPT][b] += tGR; } } } PlainMakeMove(tGame.actualMoves[i]); } } double[,] allMultipliers = new double[33, 33]; for (int sh = 0; sh < 33; sh++) { for (int i = 0; i < 33; i++) { allMultipliers[sh, i] = MultiplierFunction(i, sh); } } for (int t = 1; t < 33; t++) { for (int p = 0; p < 6; p++) { for (int s = 0; s < 64; s++) { for (int t2 = 1; t2 < 33; t2++) { double cmult = allMultipliers[t, t2]; tSummedRatios[t, p][s] += tRatio[t2, p][s] * cmult; tSummedDataAmount[t, p][s] += tTotalMoves[t2, p][s] * cmult; } tTuningResults[t, p][s] = TTT(tSummedRatios[t, p][s], tSummedDataAmount[t, p][s]); } } } int c = 0; int[] tparams = new int[1152]; for (int t = 1; t < 33; t += 15) { if (t == 31) t = 32; SNAPSHOT_WRITLINE_REPLACEMENT("PieceCount = " + t + ": "); for (int p = 0; p < 6; p++) { SNAPSHOT_WRITLINE_REPLACEMENT(TEXELPRINT_PIECES[p]); for (int s = 0; s < 64; s++) { if (s % 8 == 0 && s != 0) SNAPSHOT_WRITLINE_REPLACEMENT(); SNAPSHOT_WRITLINE_REPLACEMENT((tparams[c++] = (int)(tTuningResults[t, p][s] * 100)).ToString().Replace(",", ".") + "("+ (int)tSummedDataAmount[t, p][s] + ")"+ ", "); } SNAPSHOT_WRITLINE_REPLACEMENT(); } } string tS = "PARAMS: {"; for (int i = 0; i < tparams.Length; i++) tS += tparams[i] + ","; tS = tS.Substring(0, tS.Length - 1) + "}\n"; SNAPSHOT_WRITLINE_REPLACEMENT(tS); TexelTuning(pDataset, tparams); } private double TTT(double d1, double d2) { if (d2 == 0) return 0; return d1 /d2; } public void TexelTuning(List<TLM_ChessGame> pDataset, int[] pCurBestParams) { Stopwatch sw = Stopwatch.StartNew(); string tPath = PathManager.GetTXTPath("OTHER/TEXEL_TUNING"); int paramCount = pCurBestParams.Length; double bestAvrgCost = CalculateAverageTexelCost(pDataset, pCurBestParams); SNAPSHOT_WRITLINE_REPLACEMENT("CUR PARAMS COST: " + bestAvrgCost); int packetSize = Math.Clamp(paramCount /ENGINE_VALS.CPU_CORES, 1, 100000); paramsLowerLimits = new int[paramCount]; paramsUpperLimits = new int[paramCount]; for (int i = 0; i < paramCount; i++) { int lim = i < 10 ? 100000 : 200; paramsLowerLimits[i] = -lim; paramsUpperLimits[i] = lim; } SNAPSHOT_WRITLINE_REPLACEMENT("PARAM-COUNT: " + paramCount); SNAPSHOT_WRITLINE_REPLACEMENT("PACKET-SIZE: " + packetSize); while (packetSize <= paramCount) { BOT_MAIN.TEXELfinished = 0; int lM = 0, tC = 0; ulong tUL = 0ul; for (int m = packetSize; lM < paramCount; m += packetSize) { if (m > paramCount) m = paramCount; tUL = ULONG_OPERATIONS.SetBitToOne(tUL, ++tC); lM = m; } tC = lM = 0; for (int m = packetSize; lM < paramCount; m += packetSize) { if (m > paramCount) m = paramCount; tC++; BOT_MAIN.boardManagers[tC].SetPlayTexelVals(pDataset, lM, m, pCurBestParams, paramsLowerLimits, paramsUpperLimits, tC, tUL); ThreadPool.QueueUserWorkItem(new WaitCallback(BOT_MAIN.boardManagers[tC].TexelTuningThreadedPackage)); lM = m; } packetSize = paramCount + 1; int tmod = 0; while (tC != BOT_MAIN.TEXELfinished) { if (++tmod % 20 == 0) { WriteTexelParamsToTXT(tPath, BOT_MAIN.curTEXELPARAMS); SNAPSHOT_WRITLINE_REPLACEMENT(CalculateAverageTexelCost(pDataset, BOT_MAIN.curTEXELPARAMS) + " | "+ BOT_MAIN.TEXELadjustmentsmade); SNAPSHOT_WRITLINE_REPLACEMENT(ULONG_OPERATIONS.GetBitVisualization(BOT_MAIN.TEXELfinishedwithoutimpovement)); } Thread.Sleep(100); } SNAPSHOT_WRITLINE_REPLACEMENT("One Thread Generation FINISHED! :) :) :)"); pCurBestParams = BOT_MAIN.curTEXELPARAMS; } sw.Stop(); WriteTexelParamsToTXT(tPath, BOT_MAIN.curTEXELPARAMS); SNAPSHOT_WRITLINE_REPLACEMENT("END COST: " + CalculateAverageTexelCost(pDataset, BOT_MAIN.curTEXELPARAMS)); SNAPSHOT_WRITLINE_REPLACEMENT(BOT_MAIN.TEXELadjustmentsmade); SNAPSHOT_WRITLINE_REPLACEMENT(sw.ElapsedMilliseconds); } public void TexelTuningThreadedPackage(object obj) { SNAPSHOT_WRITLINE_REPLACEMENT("Started CThreadID [" + customThreadID + "] which is handling Params ["+ threadFrom + "] - ["+ threadTo + "]"); bool firstIter = true; do { double bestAvrgCost = CalculateAverageTexelCost(threadDataset, threadParams); int adjust_val = firstIter ? 512 : 8; do { adjust_val /= 2; bool improvedAvrgCost = true; while (improvedAvrgCost) { improvedAvrgCost = false; for (int i = threadFrom; i < threadTo; i++) { bool improvedWithThisParam = true; int tadjustval = adjust_val; bool lastTimeMaximized = false, lastTimeMinimized = false; while (improvedWithThisParam) { improvedWithThisParam = false; int[] curParams = (int[])threadParams.Clone(); int paramBefore = curParams[i]; curParams[i] = Math.Clamp(paramBefore + adjust_val, paramsLowerLimits[i], paramsUpperLimits[i]); double curAvrgCost = CalculateAverageTexelCost(threadDataset, curParams); if (curAvrgCost < bestAvrgCost) { improvedAvrgCost = true; improvedWithThisParam = true; SNAPSHOT_WRITLINE_REPLACEMENT("Improved Param [" + i + "] at CThreadID ["+ customThreadID + "]: +"+ adjust_val + " ("+ GetDoublePrecentageString(bestAvrgCost - curAvrgCost) + ")"); bestAvrgCost = curAvrgCost; threadParams = curParams; BOT_MAIN.TEXELadjustmentsmade++; BOT_MAIN.TEXELfinishedwithoutimpovement = ulAllThreadIDsUnfinished; if (lastTimeMaximized) { adjust_val *= 4; lastTimeMaximized = false; } else lastTimeMaximized = true; lastTimeMinimized = false; } else { curParams[i] = Math.Clamp(paramBefore - adjust_val, paramsLowerLimits[i], paramsUpperLimits[i]); curAvrgCost = CalculateAverageTexelCost(threadDataset, curParams); if (curAvrgCost < bestAvrgCost) { improvedAvrgCost = true; improvedWithThisParam = true; SNAPSHOT_WRITLINE_REPLACEMENT("Improved Param [" + i + "] at CThreadID ["+ customThreadID + "]: -"+ adjust_val + " ("+ GetDoublePrecentageString(bestAvrgCost - curAvrgCost) + ")"); bestAvrgCost = curAvrgCost; threadParams = curParams; BOT_MAIN.TEXELadjustmentsmade++; BOT_MAIN.TEXELfinishedwithoutimpovement = ulAllThreadIDsUnfinished; if (lastTimeMinimized) { adjust_val *= 4; lastTimeMinimized = false; } else lastTimeMinimized = true; lastTimeMaximized = false; } } if (adjust_val != 1) adjust_val /= 2; for (int j = threadFrom; j < threadTo; j++) { BOT_MAIN.curTEXELPARAMS[j] = threadParams[j]; } threadParams = (int[])BOT_MAIN.curTEXELPARAMS.Clone(); bestAvrgCost = CalculateAverageTexelCost(threadDataset, threadParams); } adjust_val = tadjustval; } } } while (adjust_val != 1); BOT_MAIN.TEXELfinishedwithoutimpovement = ULONG_OPERATIONS.SetBitToZero(BOT_MAIN.TEXELfinishedwithoutimpovement, customThreadID); SNAPSHOT_WRITLINE_REPLACEMENT("FULLY FINISHED " + customThreadID + ". IMPROVEMENT THREAD PACKAGE CYCLE"); firstIter = false; } while (BOT_MAIN.TEXELfinishedwithoutimpovement != 0); BOT_MAIN.TEXELfinished++; } private void WriteTexelParamsToTXT(string pPath, int[] pParams) { try { string tS = "PARAMS: {"; for (int i = 0; i < pParams.Length; i++) tS += pParams[i] + ","; tS = tS.Substring(0, tS.Length - 1) + "}\n"; File.AppendAllText(pPath, tS); } catch { SNAPSHOT_WRITLINE_REPLACEMENT("Mal wieder TXT zu lange gebraucht um zu aktualisieren."); } } private double costSum = 0d; private int texelCostMovesEvaluated = 0; private double CalculateAverageTexelCost(List<TLM_ChessGame> tDataset, int[] pParams, bool pFullCost = true) { costSum = 0d; texelCostMovesEvaluated = 0; SetupTexelEvaluationParams(pParams); int tGameDataSetLen = tDataset.Count; int start = 0, end = tGameDataSetLen; if (!pFullCost) { end = (start = globalRandom.Next(0, end - 256)) + 256; } for (int j = start; j < end; j++) { TLM_ChessGame tGame = tDataset[j]; double tGR = tGame.gameResult; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count - 5; texelCostMovesEvaluated += tL; for (int i = 0; i < tL; i++) { costSum += TexelCost(tGR - TexelTuningSigmoid(TexelEvaluate())); PlainMakeMove(tGame.actualMoves[i]); } } return costSum /texelCostMovesEvaluated; } private double CalculateAverageTexelCostThreadedVersionLEGACYDOESNTWORK(List<TLM_ChessGame> tDataset, int[] pParams) { Stopwatch sw = Stopwatch.StartNew(); BOT_MAIN.TEXELcostSum = 0d; BOT_MAIN.TEXELfinished = 0; BOT_MAIN.TEXELcostMovesEvaluated = 0; int tGameDataSetLen = tDataset.Count; int gamesPerThread = tGameDataSetLen /ENGINE_VALS.CPU_CORES; for (int i = 0; i < ENGINE_VALS.CPU_CORES - 1; i++) { } for (int i = 0; i < ENGINE_VALS.CPU_CORES - 1; i++) { } while (BOT_MAIN.TEXELfinished != ENGINE_VALS.CPU_CORES) Thread.Sleep(1); sw.Stop(); return BOT_MAIN.TEXELcostSum /BOT_MAIN.TEXELcostMovesEvaluated; } public void SetPlayThroughVals(List<TLM_ChessGame> pDataset, int pFrom, int pTo) { threadDataset = pDataset; threadFrom = pFrom; threadTo = pTo; } public void SetPlayTexelVals(List<TLM_ChessGame> pDataset, int pFrom, int pTo, int[] pTexelParams, int[] pLowerLimits, int[] pUpperLimits, int pThreadID, ulong pUL) { threadDataset = pDataset; threadFrom = pFrom; threadTo = pTo; threadParams = pTexelParams; paramsLowerLimits = pLowerLimits; paramsUpperLimits = pUpperLimits; customThreadID = pThreadID; ulAllThreadIDsUnfinished = pUL; } public void PlayThroughSetOfGames(object obj) { SNAPSHOT_WRITLINE_REPLACEMENT(threadFrom + "->"+ threadTo); int sortedOut = 0; for (int j = threadFrom; j < threadTo; j++) { TLM_ChessGame tGame = threadDataset[j]; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count; for (int i = 0; i < tL; i++) { int tQuietEval = isWhiteToMove ? QuiescenceWhite(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, 0, PreMinimaxCheckCheckWhite(), NULL_MOVE) : QuiescenceBlack(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, 0, PreMinimaxCheckCheckBlack(), NULL_MOVE); bool tB; tGame.isMoveNonTactical.Add(tB = (Evaluate() == tQuietEval && i > 4)); if (!tB) sortedOut++; PlainMakeMove(tGame.actualMoves[i]); } } BOT_MAIN.TEXELsortedout += sortedOut; BOT_MAIN.TEXELfinished++; } public void CalculateAverageTexelCostThreadFunction(object obj) { SetupTexelEvaluationParams(threadParams); double d = 0d; for (int j = threadFrom; j < threadTo; j++) { TLM_ChessGame tGame = threadDataset[j]; double tGR = tGame.gameResult; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count - 5; BOT_MAIN.TEXELcostMovesEvaluated += tL; for (int i = 0; i < tL; i++) { d += TexelCost(tGR - TexelTuningSigmoid(TexelEvaluate())); PlainMakeMove(tGame.actualMoves[i]); } } BOT_MAIN.TEXELcostSum += d; BOT_MAIN.TEXELfinished++; } private void ConsoleWriteLineTuneArray<T>(T[,][] pArr) { for (int j = 0; j < 3; j++) { SNAPSHOT_WRITLINE_REPLACEMENT("{"); for (int k = 0; k < 6; k++) { SNAPSHOT_WRITLINE_REPLACEMENT("{"); for (int s = 0; s < 64; s++) SNAPSHOT_WRITLINE_REPLACEMENT(pArr[j, k][s] + ", "); SNAPSHOT_WRITLINE_REPLACEMENT("\n}"); } SNAPSHOT_WRITLINE_REPLACEMENT("}"); } } private void Tune(string pGameCGFF, double pLearningRate) { TLM_ChessGame tGame = CGFF.GetGame(pGameCGFF); LoadFenString(tGame.startFen); double tDGameResult = tGame.gameResult; foreach (int hMove in tGame.hashedMoves) { Tune(tDGameResult, pLearningRate); List<Move> moveOptionList = new List<Move>(); GetLegalMoves(ref moveOptionList); int tL = moveOptionList.Count; for (int i = 0; i < tL; i++) { Move tMove = moveOptionList[i]; if (tMove.moveHash == hMove) { PlainMakeMove(tMove); tL = -1; break; } } if (tL != -1) break; } } private void Tune(double pGameResult, double pLearningRate) { int tPC = ULONG_OPERATIONS.CountBits(allPieceBitboard); double oneThroughPieceCount = 1d /tPC; double egMult = earlyGameMultipliers[tPC], mgMult = middleGameMultipliers[tPC], lgMult = lateGameMultipliers[tPC]; double tTexelResult = TexelEvaluateF(); double tSigmoidedTexelResult = TexelSigmoid(tTexelResult); double tDif = tSigmoidedTexelResult - pGameResult; double tM = oneThroughPieceCount * TexelCostDerivative(tDif) * TexelSigmoidDerivative(tTexelResult) * pLearningRate; sumCostVals += lastCostVal = TexelCost(tDif); costCalculations++; for (int i = 0; i < 64; i++) { if (ULONG_OPERATIONS.IsBitZero(allPieceBitboard, i)) continue; int tPT = pieceTypeArray[i] - 1, tI = i; if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, i)) tI = blackSidedSquares[i]; texelTuningAdjustIterations[tPT, tI]++; } } private double TexelEvaluateF() { texelTuningRuntimeVals = GetInterpolatedProcessedValues(texelTuningVals); return TexelEvaluate(); } private int TexelEvaluate() { int tEvalEG = 0, tEvalLG = 0, tProgress = 0; ulong[] attkULs = new ulong[14]; for (int p = 0; p < 64; p++) { if (((int)(allPieceBitboard >> p) & 1) == 0) continue; int aPT = pieceTypeArray[p], tPT = aPT + 7 * ((int)(blackPieceBitboard >> p) & 1); tEvalEG += texelTuningRuntimePositionalValsV2EG[tPT][p] + texelPieceEvaluationsV2EG[tPT]; tEvalLG += texelTuningRuntimePositionalValsV2LG[tPT][p] + texelPieceEvaluationsV2LG[tPT]; tProgress += pieceTypeGameProgressImpact[tPT]; } if (tProgress > 24) tProgress = 24; return (int)(earlyGameMultipliers[tProgress] * tEvalEG + lateGameMultipliers[tProgress] * tEvalLG); } private const double TexelK = 0.2; private double TexelTuningSigmoid(double pVal) { return 2d /(1 + Math.Pow(10, -TexelK * pVal /400)); } private double TexelSigmoid(double pVal) { return 2d /(Math.Exp(-0.04d * pVal) + 1d); } private double TexelSigmoidDerivative(double pVal) { double d = Math.Exp(-0.04d * pVal); return 2d * d /(25d * (d + 1d) * (d + 1d)); } private double TexelCost(double pVal) { return pVal * pVal; } private double TexelCostDerivative(double pVal) { return 2 * pVal; } private char[] fenPieces = new char[7] { 'z', 'p', 'n', 'b', 'r', 'q', 'k' }; private string[] squareNames = new string[64] { "a1", "b1", "c1", "d1", "e1", "f1", "g1", "h1", "a2", "b2", "c2", "d2", "e2", "f2", "g2", "h2", "a3", "b3", "c3", "d3", "e3", "f3", "g3", "h3", "a4", "b4", "c4", "d4", "e4", "f4", "g4", "h4", "a5", "b5", "c5", "d5", "e5", "f5", "g5", "h5", "a6", "b6", "c6", "d6", "e6", "f6", "g6", "h6", "a7", "b7", "c7", "d7", "e7", "f7", "g7", "h7", "a8", "b8", "c8", "d8", "e8", "f8", "g8", "h8"}; public string CreateFenString() { string rFEN = ""; for (int i = 7; i >= 0; i--) { int t = 0; for (int j = 0; j < 8; j++) { int sq = i * 8 + j; if (pieceTypeArray[sq] != 0) { if (t != 0) rFEN += t; t = 0; } if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, sq)) { switch (pieceTypeArray[sq]) { case 0: t++; SNAPSHOT_WRITLINE_REPLACEMENT("???"); break; case 1: rFEN += 'P'; break; case 2: rFEN += 'N'; break; case 3: rFEN += 'B'; break; case 4: rFEN += 'R'; break; case 5: rFEN += 'Q'; break; case 6: rFEN += 'K'; break; } } else { switch (pieceTypeArray[sq]) { case 0: t++; break; case 1: rFEN += 'p'; break; case 2: rFEN += 'n'; break; case 3: rFEN += 'b'; break; case 4: rFEN += 'r'; break; case 5: rFEN += 'q'; break; case 6: rFEN += 'k'; break; } } } if (t != 0) rFEN += t; if (i != 0) rFEN += "/"; } rFEN += (isWhiteToMove ? " w": " b"); rFEN += (whiteCastleRightKingSide ? " K": " "); rFEN += (whiteCastleRightQueenSide ? "Q": ""); rFEN += (blackCastleRightKingSide ? "k": ""); rFEN += (blackCastleRightQueenSide ? "q": ""); if (!whiteCastleRightKingSide && !whiteCastleRightQueenSide && !blackCastleRightKingSide && !blackCastleRightQueenSide) rFEN += "-"; if (enPassantSquare < 64) rFEN += " "+ squareNames[enPassantSquare] + " "; else rFEN += " - "; return rFEN + fiftyMoveRuleCounter + " "+ ((happenedHalfMoves - happenedHalfMoves % 2) /2); } public void LoadFenString(string fenStr) { lastMadeMove = NULL_MOVE; zobristKey = 0ul; whitePieceBitboard = blackPieceBitboard = allPieceBitboard = 0ul; for (int i = 0; i < 64; i++) pieceTypeArray[i] = 0; string[] spaceSpl = fenStr.Split(' '); string[] rowSpl = spaceSpl[0].Split('/'); string epstr = spaceSpl[3]; if (epstr == "-") enPassantSquare = 65; else enPassantSquare = (epstr[0] - 'a') + 8 * (epstr[1] - '1'); isWhiteToMove = true; if (spaceSpl[1] == "b") isWhiteToMove = false; if (!isWhiteToMove) zobristKey ^= blackTurnHash; string crstr = spaceSpl[2]; whiteCastleRightKingSide = whiteCastleRightQueenSide = blackCastleRightKingSide = blackCastleRightQueenSide = false; int crStrL = crstr.Length; for (int i = 0; i < crStrL; i++) { switch (crstr[i]) { case 'K': whiteCastleRightKingSide = true; break; case 'Q': whiteCastleRightQueenSide = true; break; case 'k': blackCastleRightKingSide = true; break; case 'q': blackCastleRightQueenSide = true; break; } } fiftyMoveRuleCounter = Convert.ToInt32(spaceSpl[4]); happenedHalfMoves = Convert.ToInt32(spaceSpl[5]) * 2; if (!isWhiteToMove) happenedHalfMoves++; int tSq = 0; for (int i = rowSpl.Length; i-- > 0;) { string tStr = rowSpl[i]; int tStrLen = tStr.Length; for (int c = 0; c < tStrLen; c++) { char tChar = tStr[c]; if (Char.IsDigit(tChar)) tSq += tChar - '0'; else { bool tCol = Char.IsLower(tChar); if (tCol) blackPieceBitboard = ULONG_OPERATIONS.SetBitToOne(blackPieceBitboard, tSq); else whitePieceBitboard = ULONG_OPERATIONS.SetBitToOne(whitePieceBitboard, tSq); if (tChar == 'k') blackKingSquare = tSq; else if (tChar == 'K') whiteKingSquare = tSq; pieceTypeArray[tSq] = Array.IndexOf(fenPieces, Char.ToLower(tChar)); if (tCol) zobristKey ^= pieceHashesBlack[tSq, pieceTypeArray[tSq]]; else zobristKey ^= pieceHashesWhite[tSq, pieceTypeArray[tSq]]; tSq++; } } } if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; zobristKey ^= enPassantSquareHashes[enPassantSquare]; allPieceBitboard = whitePieceBitboard | blackPieceBitboard; if (zobristKey == 16260251586586513106) moveHashList.Clear(); else { moveHashList.Clear(); moveHashList.Add(1); moveHashList.Add(2); moveHashList.Add(3); } } private ulong[,] pieceHashesWhite = new ulong[64, 7], pieceHashesBlack = new ulong[64, 7]; private ulong blackTurnHash, whiteKingSideRochadeRightHash, whiteQueenSideRochadeRightHash, blackKingSideRochadeRightHash, blackQueenSideRochadeRightHash; private ulong[] enPassantSquareHashes = new ulong[66]; private void InitZobrist() { Random rng = new Random(31415926); for (int sq = 0; sq < 64; sq++) { enPassantSquareHashes[sq] = ULONG_OPERATIONS.GetRandomULONG(rng); for (int it = 1; it < 7; it++) { pieceHashesWhite[sq, it] = ULONG_OPERATIONS.GetRandomULONG(rng); pieceHashesBlack[sq, it] = ULONG_OPERATIONS.GetRandomULONG(rng); } } blackTurnHash = ULONG_OPERATIONS.GetRandomULONG(rng); whiteKingSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); whiteQueenSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); blackKingSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); blackQueenSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); } public void SetKnightMasks(ulong[] uls) { knightSquareBitboards = uls; } public void SetKingMasks(ulong[] uls) { kingSquareBitboards = uls; } private Move[,] whiteEnPassantMoves = new Move[64, 64]; private Move[,] blackEnPassantMoves = new Move[64, 64]; private bool[] epValidationArray = new bool[64] { false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true , true , true , true , true , true , true , true, true , true , true , true , true , true , true , true, true , true , true , true , true , true , true , true, true , true , true , true , true , true , true , true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false }; private ulong[] kingSafetyRing1 = new ulong[64], kingSafetyRing2 = new ulong[64]; private ulong[] kingSafetySpecialRingW = new ulong[64], kingSafetySpecialRingB = new ulong[64]; private ulong[] rowPrecalcs = new ulong[8], columnPrecalcs = new ulong[8]; const ulong columnUL = 0x101010101010101, rowUL = 0b11111111; private void PrecalculateKingSafetyBitboards() { for (int i = 0; i < 8; i++) { rowPrecalcs[i] = rowUL << (8 * i); columnPrecalcs[i] = columnUL << i; } for (int i = 0; i < 64; i++) { int tMod = i % 8; int tRow = (i - tMod) /8; ulong tULC = columnPrecalcs[tMod], tULR = rowPrecalcs[tRow]; ulong tULC2 = columnPrecalcs[tMod], tULR2 = rowPrecalcs[tRow]; if (tMod < 7) tULC |= columnPrecalcs[tMod + 1]; if (tMod > 0) tULC |= columnPrecalcs[tMod - 1]; if (tRow < 7) tULR |= rowPrecalcs[tRow + 1]; if (tRow > 0) tULR |= rowPrecalcs[tRow - 1]; if (tMod < 6) tULC2 |= columnPrecalcs[tMod + 2]; if (tMod > 1) tULC2 |= columnPrecalcs[tMod - 2]; if (tRow < 6) tULR2 |= rowPrecalcs[tRow + 2]; if (tRow > 1) tULR2 |= rowPrecalcs[tRow - 2]; tULR2 |= tULR; tULC2 |= tULC; kingSafetyRing1[i] = ULONG_OPERATIONS.SetBitToZero(tULR & tULC, i); kingSafetyRing2[i] = ULONG_OPERATIONS.SetBitsToZero(tULR2 & tULC2, i, i + 1, i - 1, i + 7, i + 8, i + 9, i - 7, i - 8, i - 9); } for (int i = 0; i < 64; i++) { if (i < 56) kingSafetySpecialRingW[i] = ULONG_OPERATIONS.SetBitToZero(kingSafetyRing1[i] | kingSafetyRing1[i + 8], i); else kingSafetySpecialRingW[i] = kingSafetyRing1[i]; if (i > 7) kingSafetySpecialRingB[i] = ULONG_OPERATIONS.SetBitToZero(kingSafetyRing1[i] | kingSafetyRing1[i - 8], i); else kingSafetySpecialRingB[i] = kingSafetyRing1[i]; } } private void PrecalculateEnPassantMoves() { for (int i = 0; i < 64; i++) { if (!epValidationArray[i]) continue; for (int j = 0; j < 64; j++) { if (i == j) continue; if (Math.Abs(i - j) > 9) continue; if (!epValidationArray[j]) continue; whiteEnPassantMoves[i, j] = new Move(false, i, j, j - 8); blackEnPassantMoves[i, j] = new Move(false, i, j, j + 8); } } } private void PawnAttackBitboards() { for (int sq = 0; sq < 64; sq++) { ulong u = 0ul; if (sq % 8 != 0) u = ULONG_OPERATIONS.SetBitToOne(u, sq + 7); if (sq % 8 != 7) u = ULONG_OPERATIONS.SetBitToOne(u, sq + 9); whitePawnAttackSquareBitboards[sq] = u; u = 0ul; if (sq % 8 != 0 && sq - 9 > -1) u = ULONG_OPERATIONS.SetBitToOne(u, sq - 9); if (sq % 8 != 7 && sq - 7 > -1) u = ULONG_OPERATIONS.SetBitToOne(u, sq - 7); blackPawnAttackSquareBitboards[sq] = u; } } private int[] squareConnectivesPrecalculationArray = new int[4096]; public int[] squareConnectivesCrossDirsPrecalculationArray { get; set; } = new int[4096]; private ulong[] squareConnectivesPrecalculationRayArray = new ulong[4096]; private ulong[] squareConnectivesPrecalculationLineArray = new ulong[4096]; private List<Dictionary<ulong, int>> rayCollidingSquareCalculations = new List<Dictionary<ulong, int>>(); private readonly int[] maxIntWithSpecifiedBitcount = new int[8] { 0, 0b1, 0b11, 0b111, 0b1111, 0b11111, 0b111111, 0b1111111 }; private List<ulong> differentRays = new List<ulong>(); private void SquareConnectivesPrecalculations() { for (int square = 0; square < 64; square++) { rayCollidingSquareCalculations.Add(new Dictionary<ulong, int>()); rayCollidingSquareCalculations[square].Add(0ul, square); for (int square2 = 0; square2 < 64; square2++) { if (square == square2) continue; int t = 0, t2 = 0, difSign = Math.Sign(square2 - square), itSq = square, g = 0; ulong tRay = 0ul, tExclRay = 0ul; List<int> tRayInts = new List<int>(); if (difSign == -1) g = 7; if (square % 8 == square2 % 8) { t2 = t = 1; while ((itSq += difSign * 8) < 64 && itSq > -1) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } } else if ((square - square % 8) == (square2 - square2 % 8)) { t = 1; t2 = -1; while ((itSq += difSign) % 8 != g && itSq > -1 && itSq < 64) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } } else { int dif = Math.Abs(square2 - square); if (dif % 7 == 0) { t = 2; t2 = 2; g = (difSign == 1) ? 7 : 0; while ((itSq += difSign * 7) % 8 != g && itSq < 64 && itSq > -1) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } if (ULONG_OPERATIONS.IsBitZero(tRay, square2)) { t2 = t = 0; tRay = 0ul; } } else if (dif % 9 == 0) { t = 2; t2 = -2; if (square == 0 && square2 == 63 || square == 63 && square2 == 0) SNAPSHOT_WRITLINE_REPLACEMENT("!"); while ((itSq += difSign * 9) % 8 != g && itSq < 64 && itSq > -1) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } if (ULONG_OPERATIONS.IsBitZero(tRay, square2)) { t2 = t = 0; tRay = 0ul; } } } if (square == 0 && square2 == 63) { t2 = t = 2; tRayInts.Clear(); tExclRay = tRay = ULONG_OPERATIONS.SetBitsToOne(0ul, 9, 18, 27, 36, 45, 54, 63); tRayInts = new List<int>() { 9, 18, 27, 36, 45, 54, 63 }; } else if (square2 == 0 && square == 63) { t = 2; tRayInts.Clear(); t2 = -2; tExclRay = tRay = ULONG_OPERATIONS.SetBitsToOne(0ul, 0, 9, 18, 27, 36, 45, 54); tRayInts = new List<int>() { 54, 45, 36, 27, 18, 9, 0 }; } if (tRay != 0ul && !differentRays.Contains(tRay)) { differentRays.Add(tRay); int ccount, combI = maxIntWithSpecifiedBitcount[ccount = ULONG_OPERATIONS.CountBits(tRay)]; do { ulong curAllPieceBitboard = 0ul; int solution = square; for (int j = 0; j < ccount; j++) { if (((combI >> j) & 1) == 1) { curAllPieceBitboard = ULONG_OPERATIONS.SetBitToOne(curAllPieceBitboard, tRayInts[j]); if (solution == square) solution = tRayInts[j]; } } rayCollidingSquareCalculations[square].Add(curAllPieceBitboard, solution); } while (--combI != 0); } squareConnectivesPrecalculationArray[square << 6 | square2] = t; squareConnectivesPrecalculationRayArray[square << 6 | square2] = tRay; squareConnectivesCrossDirsPrecalculationArray[square << 6 | square2] = t2; if (t != 0) squareConnectivesPrecalculationLineArray[square << 6 | square2] = (square == 0 && square2 == 63 || square2 == 0 && square == 63) ? tExclRay : ULONG_OPERATIONS.SetBitToOne(tExclRay, square2); if (squareConnectivesPrecalculationLineArray[square << 6 | square2] == 0ul && ULONG_OPERATIONS.IsBitOne(knightSquareBitboards[square], square2)) squareConnectivesPrecalculationLineArray[square << 6 | square2] = 1ul << square2; } differentRays.Clear(); } } public void SNAPSHOT_WRITLINE_REPLACEMENT() { } public void SNAPSHOT_WRITLINE_REPLACEMENT(object pStr) { } private string GetDoublePrecentageString(double pVal) { return ((int)(pVal * 1_000_000) /10_000d) + "%"; } private string ReplaceAllULONGIsBitOne(string pCode) { const string METHOD_NAME = "ULONG_OPERATIONS.IsBitOne"; int METHOD_NAME_LEN = METHOD_NAME.Length, iterations = 0; int pIndex = pCode.IndexOf(METHOD_NAME); while (pIndex != -1 && ++iterations < 10_000) { List<int> paramIndexes = new List<int>(); int openedBracketCount = 1, closedBracketCount = 0, a = METHOD_NAME_LEN + pIndex; string tpCode = pCode.Substring(0, pIndex); paramIndexes.Add(a + 1); while (++a < pCode.Length) { switch (pCode[a]) { case '(': openedBracketCount++; break; case ')': if (++closedBracketCount == openedBracketCount) { pIndex = a; a = int.MaxValue - 5; } break; case ',': if (openedBracketCount - closedBracketCount == 1) paramIndexes.Add(a + 1); break; } } if (openedBracketCount == closedBracketCount && paramIndexes.Count == 2) { tpCode += "((int)("+ pCode.Substring(paramIndexes[0], paramIndexes[1] - paramIndexes[0] - 1) + (pCode[paramIndexes[1]] == ' ' ? " >> (": " >> (") + pCode.Substring(paramIndexes[1], pIndex - paramIndexes[1]) + ")) & 1) == 1"+ pCode.Substring(pIndex + 1, pCode.Length - pIndex - 1); } pIndex = (pCode = tpCode).IndexOf(METHOD_NAME); } SNAPSHOT_WRITLINE_REPLACEMENT(iterations + " ITERATIONS"); return pCode; } private string ReplaceAllULONGIsBitZero(string pCode) { const string METHOD_NAME = "ULONG_OPERATIONS.IsBitZero"; int METHOD_NAME_LEN = METHOD_NAME.Length, iterations = 0; int pIndex = pCode.IndexOf(METHOD_NAME); while (pIndex != -1 && ++iterations < 10_000) { List<int> paramIndexes = new List<int>(); int openedBracketCount = 1, closedBracketCount = 0, a = METHOD_NAME_LEN + pIndex; string tpCode = pCode.Substring(0, pIndex); paramIndexes.Add(a + 1); while (++a < pCode.Length) { switch (pCode[a]) { case '(': openedBracketCount++; break; case ')': if (++closedBracketCount == openedBracketCount) { pIndex = a; a = int.MaxValue - 5; } break; case ',': if (openedBracketCount - closedBracketCount == 1) paramIndexes.Add(a + 1); break; } } if (openedBracketCount == closedBracketCount && paramIndexes.Count == 2) { tpCode += "((int)("+ pCode.Substring(paramIndexes[0], paramIndexes[1] - paramIndexes[0] - 1) + (pCode[paramIndexes[1]] == ' ' ? " >>": " >> ") + pCode.Substring(paramIndexes[1], pIndex - paramIndexes[1]) + ") & 1) == 0"+ pCode.Substring(pIndex + 1, pCode.Length - pIndex - 1); } pIndex = (pCode = tpCode).IndexOf(METHOD_NAME); } SNAPSHOT_WRITLINE_REPLACEMENT(iterations + " ITERATIONS"); return pCode; } private string GetThreeDigitSeperatedInteger(int pInt) { string s = pInt.ToString(), r = s[0].ToString(); int t = s.Length % 3; for (int i = 1; i < s.Length; i++) { if (i % 3 == t) r += "."; r += s[i]; } s = ""; for (int i = 0; i < r.Length; i++) s += r[i]; return s; } public double GetAverageDepth() { return (double)depths /(double)searches; } }
public class SNAPSHOT_V01_00_006 : IBoardManager  { public int TEXEL_PARAMS { get; } = 778; private const int BESTMOVE_SORT_VAL = -2_000_000_000; private const int CAPTURE_SORT_VAL = -1_000_000_000; private const int KILLERMOVE_SORT_VAL = -1000; private readonly int[,] MVVLVA_TABLE = new int[7, 7] { { 0, 0, 0, 0, 0, 0, 0 }, { 0, 1500, 1400, 1300, 1200, 1100, 1000 }, { 0, 3500, 3400, 3300, 3200, 3100, 3000 }, { 0, 4500, 4400, 4300, 4200, 4100, 4000 }, { 0, 5500, 5400, 5300, 5200, 5100, 5000 }, { 0, 9500, 9400, 9300, 9200, 9100, 9000 }, { 0, 0, 0, 0, 0, 0, 0 }}; private int BOARD_MANAGER_ID = -1; private bool debugSearchDepthResults = false; private bool debugSortResults = false; private RookMovement rookMovement; private BishopMovement bishopMovement; private QueenMovement queenMovement; private KnightMovement knightMovement; private KingMovement kingMovement; private WhitePawnMovement whitePawnMovement; private BlackPawnMovement blackPawnMovement; private Rays rays; public List<Move> moveOptionList { get; set; } private int[] pieceTypeArray = new int[64]; public ulong whitePieceBitboard, blackPieceBitboard, allPieceBitboard; private ulong zobristKey; private int whiteKingSquare, blackKingSquare, enPassantSquare = 65, happenedHalfMoves = 0, fiftyMoveRuleCounter = 0; private bool whiteCastleRightKingSide, whiteCastleRightQueenSide, blackCastleRightKingSide, blackCastleRightQueenSide; private bool isWhiteToMove; private const ulong WHITE_KING_ROCHADE = 96, WHITE_QUEEN_ROCHADE = 14, BLACK_KING_ROCHADE = 6917529027641081856, BLACK_QUEEN_ROCHADE = 1008806316530991104, WHITE_QUEEN_ATTK_ROCHADE = 12, BLACK_QUEEN_ATTK_ROCHADE = 864691128455135232; private readonly Move mWHITE_KING_ROCHADE = new Move(4, 6, 7, 5), mWHITE_QUEEN_ROCHADE = new Move(4, 2, 0, 3), mBLACK_KING_ROCHADE = new Move(60, 62, 63, 61), mBLACK_QUEEN_ROCHADE = new Move(60, 58, 56, 59); private ulong[] knightSquareBitboards = new ulong[64]; private ulong[] whitePawnAttackSquareBitboards = new ulong[64]; private ulong[] blackPawnAttackSquareBitboards = new ulong[64]; private ulong[] kingSquareBitboards = new ulong[64]; private bool[,] pieceTypeAbilities = new bool[7, 3] { { false, false, false }, { false, false, false }, { false, false, false }, { false, false, true }, { false, true, false }, { false, true, true }, { false, false, false } }; private List<int> moveHashList = new List<int>(); private ulong[] curSearchZobristKeyLine = Array.Empty<ulong>(); private Stopwatch globalTimer = Stopwatch.StartNew(); private Move lastMadeMove; private int depths, searches; private Random globalRandom = new Random(); public SNAPSHOT_V01_00_006(string fen) { Setup(fen); } public void Setup(string pFen) { Stopwatch setupStopwatch = Stopwatch.StartNew(); BOARD_MANAGER_ID = BOT_MAIN.curBoardManagerID; for (int i = 0; i < 33; i++) for (int j = 0; j < 14; j++) piecePositionEvals[i, j] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; for (int i = 0; i < 33; i++) for (int j = 0; j < 14; j++) texelTuningRuntimeVals[i, j] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; for (int i = 0; i < 3; i++) for (int j = 0; j < 6; j++) texelTuningVals[i, j] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; for (int i = 0; i < 14; i++) { texelTuningRuntimePositionalValsV2EG[i] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; texelTuningRuntimePositionalValsV2LG[i] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; } PrecalculateKingSafetyBitboards(); PrecalculateMultipliers(); GetLowNoisePositionalEvaluation(globalRandom); MinimaxRoot(1L); SetupConsoleWrite("[PRECALCS] Zobrist Hashing"); InitZobrist(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Knight Movement"); knightMovement = new KnightMovement(this); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Square Connectives"); SquareConnectivesPrecalculations(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Pawn Attack Bitboards"); PawnAttackBitboards(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Rays"); rays = new Rays(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); queenMovement = new QueenMovement(this); SetupConsoleWrite("[PRECALCS] Rook Movement"); rookMovement = new RookMovement(this, queenMovement); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Bishop Movement"); bishopMovement = new BishopMovement(this, queenMovement); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] King Movement"); kingMovement = new KingMovement(this); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Pawn Movement"); whitePawnMovement = new WhitePawnMovement(this); blackPawnMovement = new BlackPawnMovement(this); PrecalculateEnPassantMoves(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWriteLine("[DONE]\n\n"); LoadFenString(pFen); LoadBestTexelParamsIn(); setupStopwatch.Stop(); } private void SetupConsoleWriteLine(string pStr) { if (BOT_MAIN.isFirstBoardManagerInitialized) return; SNAPSHOT_WRITLINE_REPLACEMENT(pStr); } private void SetupConsoleWrite(string pStr) { if (BOT_MAIN.isFirstBoardManagerInitialized) return; SNAPSHOT_WRITLINE_REPLACEMENT(pStr); } public void GetLowNoisePositionalEvaluation(System.Random rng) { int[,][] digitArray = new int[3, 6][]; for (int i = 0; i < 3; i++) for (int j = 0; j < 6; j++) digitArray[i, j] = GetRand64IntArray(rng, -5, 6); lowNoisePositionEvals1 = GetInterpolatedProcessedValues(digitArray); int[,][] digitArray2 = new int[3, 6][]; for (int i = 0; i < 3; i++) for (int j = 0; j < 6; j++) digitArray2[i, j] = GetRand64IntArray(rng, -5, 6); lowNoisePositionEvals2 = GetInterpolatedProcessedValues(digitArray2); } private int[] GetRand64IntArray(System.Random rng, int pMin, int pMax) { return new int[64] { rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax) }; } private string GetAIArrayValuesStringRepresentation(int[,][] pArr) { string r = "int[,][] ReLe_AI_RESULT_VALS = new int[3, 6][] {"; for (int i = 0; i < 3; i++) { r += "{"; for (int j = 0; j < 5; j++) { r += GetIntArray64LStringRepresentation(pArr[i, j]) + ","; } r += GetIntArray64LStringRepresentation(pArr[i, 5]) + "},"; } return r.Substring(0, r.Length - 1) + "};"; } private string GetIntArray64LStringRepresentation(int[] p64LArr) { if (p64LArr == null) return ""; string r = "new int[64]{"; for (int i = 0; i < 63; i++) { r += p64LArr[i] + ","; } return r + p64LArr[63] + "}"; } public void TempStuff() { } private string[] gameResultStrings = new string[5] { "Black Has Won!", "Draw!", "White Has Won!", "Non Existant Result!", "Game is Ongoing!"}; private int[,][] lowNoisePositionEvals1, lowNoisePositionEvals2; public void ThreadSelfPlay(object obj) { PlayGameAgainstItself(obj); } public void PlayGameAgainstItself(object obj, string pStartFEN = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1", long tickLimitForEngine = ENGINE_VALS.SELF_PLAY_THINK_TIME) { int ttGState; while (BOT_MAIN.goalGameCount > BOT_MAIN.gamesPlayed) { try { string tGameStr; GetLowNoisePositionalEvaluation(globalRandom); LoadFenString(tGameStr = pStartFEN); tGameStr += ";"; int tGState = 3, tmc = 0; bool lowNoiceDecider = globalRandom.NextDouble() < 0.5d; while (tGState == 3) { piecePositionEvals = lowNoiceDecider ? lowNoisePositionEvals1 : lowNoisePositionEvals2; MinimaxRoot(tickLimitForEngine); Move tM = transpositionTable[zobristKey].bestMove; PlainMakeMove(tM); tGameStr += NuCRe.GetNuCRe(tM.moveHash) + ","; BOT_MAIN.movesPlayed++; tGState = GameState(isWhiteToMove); lowNoiceDecider = !lowNoiceDecider; tmc++; } ttGState = tGState; tGameStr += ttGState + 1; SNAPSHOT_WRITLINE_REPLACEMENT(tGameStr); BOT_MAIN.gamesPlayedResultArray[ttGState + 1]++; BOT_MAIN.gamesPlayed++; BOT_MAIN.selfPlayGameStrings.Add(tGameStr); } catch (Exception tE) { SNAPSHOT_WRITLINE_REPLACEMENT(tE.ToString()); } } } public void PlayGameOnConsoleAgainstHuman(string pStartFEN = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1", bool pHumanPlaysWhite = true, long tickLimitForEngine = 10_000_000L) { debugSearchDepthResults = true; LoadFenString(pStartFEN); if (!(pHumanPlaysWhite ^ isWhiteToMove)) { var pVS = Console.ReadLine(); if (pVS == null) return; Move tm = GetMoveOfString(pVS.ToString()); SNAPSHOT_WRITLINE_REPLACEMENT(tm); PlainMakeMove(tm); } int tGState = 3; while (tGState == 3) { MinimaxRoot(tickLimitForEngine); PlayThroughZobristTree(); Move tM = transpositionTable[zobristKey].bestMove; SNAPSHOT_WRITLINE_REPLACEMENT(tM); SNAPSHOT_WRITLINE_REPLACEMENT(CreateFenString()); PlainMakeMove(tM); tGState = GameState(isWhiteToMove); if (tGState != 3 || tM == NULL_MOVE) break; var pV = ""; tM = NULL_MOVE; do { pV = Console.ReadLine(); if (pV == null) continue; tM = GetMoveOfString(pV.ToString()); SNAPSHOT_WRITLINE_REPLACEMENT(tM); } while (tM == NULL_MOVE); PlainMakeMove(tM); tGState = GameState(isWhiteToMove); } } private void PlayThroughZobristTree() { SetJumpState(); SNAPSHOT_WRITLINE_REPLACEMENT("\n- - - - - - - - - - - - -"); int tC = 1; Dictionary<ulong, bool> usedULs = new Dictionary<ulong, bool>(); while (transpositionTable.TryGetValue(zobristKey, out TranspositionEntry tM)) { if (usedULs.ContainsKey(zobristKey)) { SNAPSHOT_WRITLINE_REPLACEMENT(tC + ": AT LEAST ONE REPETION; REST NOT VISIBLE"); break; } SNAPSHOT_WRITLINE_REPLACEMENT(tC + ": "+ tM.bestMove + " > "); usedULs.Add(zobristKey, true); PlainMakeMove(tM.bestMove); tC++; } SNAPSHOT_WRITLINE_REPLACEMENT("- - - - - - - - - - - - -\n"); LoadJumpState(); } public Move? ReturnNextMove(Move? lastMove, long pThinkingTime) { if (lastMove != null) PlainMakeMove(lastMove); if (GameState(isWhiteToMove) != 3) return null; MinimaxRoot(pThinkingTime); if (!transpositionTable.ContainsKey(zobristKey)) return null; Move tm = transpositionTable[zobristKey].bestMove; PlainMakeMove(tm); return tm; } private int[] jmpSt_pieceTypeArray; private ulong jmpSt_whitePieceBitboard, jmpSt_blackPieceBitboard; private ulong jmpSt_zobristKey; private int jmpSt_whiteKingSquare, jmpSt_blackKingSquare, jmpSt_enPassantSquare, jmpSt_happenedHalfMoves, jmpSt_fiftyMoveRuleCounter; private bool jmpSt_whiteCastleRightKingSide, jmpSt_whiteCastleRightQueenSide, jmpSt_blackCastleRightKingSide, jmpSt_blackCastleRightQueenSide; private bool jmpSt_isWhiteToMove; private ulong[] jmpSt_curSearchZobristKeyLine; private int[] jmpSt_moveHashList; public void LoadJumpState() { pieceTypeArray = (int[])jmpSt_pieceTypeArray.Clone(); whitePieceBitboard = jmpSt_whitePieceBitboard; blackPieceBitboard = jmpSt_blackPieceBitboard; zobristKey = jmpSt_zobristKey; whiteKingSquare = jmpSt_whiteKingSquare; blackKingSquare = jmpSt_blackKingSquare; enPassantSquare = jmpSt_enPassantSquare; happenedHalfMoves = jmpSt_happenedHalfMoves; fiftyMoveRuleCounter = jmpSt_fiftyMoveRuleCounter; whiteCastleRightKingSide = jmpSt_whiteCastleRightKingSide; whiteCastleRightQueenSide = jmpSt_whiteCastleRightQueenSide; blackCastleRightKingSide = jmpSt_blackCastleRightKingSide; blackCastleRightQueenSide = jmpSt_blackCastleRightQueenSide; isWhiteToMove = jmpSt_isWhiteToMove; curSearchZobristKeyLine = (ulong[])jmpSt_curSearchZobristKeyLine.Clone(); allPieceBitboard = blackPieceBitboard | whitePieceBitboard; moveHashList = jmpSt_moveHashList.ToList(); } public void SetJumpState() { jmpSt_pieceTypeArray = (int[])pieceTypeArray.Clone(); jmpSt_whitePieceBitboard = whitePieceBitboard; jmpSt_blackPieceBitboard = blackPieceBitboard; jmpSt_zobristKey = zobristKey; jmpSt_whiteKingSquare = whiteKingSquare; jmpSt_blackKingSquare = blackKingSquare; jmpSt_enPassantSquare = enPassantSquare; jmpSt_happenedHalfMoves = happenedHalfMoves; jmpSt_fiftyMoveRuleCounter = fiftyMoveRuleCounter; jmpSt_whiteCastleRightKingSide = whiteCastleRightKingSide; jmpSt_whiteCastleRightQueenSide = whiteCastleRightQueenSide; jmpSt_blackCastleRightKingSide = blackCastleRightKingSide; jmpSt_blackCastleRightQueenSide = blackCastleRightQueenSide; jmpSt_isWhiteToMove = isWhiteToMove; jmpSt_curSearchZobristKeyLine = (ulong[])curSearchZobristKeyLine.Clone(); jmpSt_moveHashList = moveHashList.ToArray(); } private int PreMinimaxCheckCheckWhite() { ulong bitShiftedKingPos = 1ul << whiteKingSquare; int curR = -1; for (int p = 0; p < 64; p++) { if (ULONG_OPERATIONS.IsBitZero(blackPieceBitboard, p)) continue; int tPT; switch (tPT = pieceTypeArray[p]) { case 1: if ((bitShiftedKingPos & blackPawnAttackSquareBitboards[p]) != 0ul) return p; break; case 2: if ((bitShiftedKingPos & knightSquareBitboards[p]) != 0ul) return p; break; case 6: break; default: if ((squareConnectivesPrecalculationLineArray[whiteKingSquare << 6 | p] & allPieceBitboard) == (1ul << p) && pieceTypeAbilities[tPT, squareConnectivesPrecalculationArray[whiteKingSquare << 6 | p]]) { if (curR != -1) return -779; curR = p; } break; } } return curR; } private int PreMinimaxCheckCheckBlack() { ulong bitShiftedKingPos = 1ul << blackKingSquare; int curR = -1; for (int p = 0; p < 64; p++) { if (ULONG_OPERATIONS.IsBitZero(whitePieceBitboard, p)) continue; int tPT; switch (tPT = pieceTypeArray[p]) { case 1: if ((bitShiftedKingPos & whitePawnAttackSquareBitboards[p]) != 0ul) return p; break; case 2: if ((bitShiftedKingPos & knightSquareBitboards[p]) != 0ul) return p; break; case 6: break; default: if ((squareConnectivesPrecalculationLineArray[blackKingSquare << 6 | p] & allPieceBitboard) == (1ul << p) && pieceTypeAbilities[tPT, squareConnectivesPrecalculationArray[blackKingSquare << 6 | p]]) { if (curR != -1) return -779; curR = p; } break; } } return curR; } private int LecacyLeafCheckingPieceCheckWhite(int pStartPos, int pEndPos, int pPieceType) { int tI, tPossibleAttackPiece; if (pPieceType == 1) { if (ULONG_OPERATIONS.IsBitOne(blackPawnAttackSquareBitboards[pEndPos], whiteKingSquare)) return pEndPos; } else if (pPieceType == 2) { if (ULONG_OPERATIONS.IsBitOne(knightSquareBitboards[pEndPos], whiteKingSquare)) return pEndPos; } else if (pPieceType != 6) { tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | pEndPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; } tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | pStartPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; return -1; } private int LecacyLeafCheckingPieceCheckBlack(int pStartPos, int pEndPos, int pPieceType) { int tI, tPossibleAttackPiece; if (pPieceType == 1) { if (ULONG_OPERATIONS.IsBitOne(whitePawnAttackSquareBitboards[pEndPos], blackKingSquare)) return pEndPos; } else if (pPieceType == 2) { if (ULONG_OPERATIONS.IsBitOne(knightSquareBitboards[pEndPos], blackKingSquare)) return pEndPos; } else if (pPieceType != 6) { tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | pEndPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; } tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | pStartPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; return -1; } public void GetLegalMoves(ref List<Move> pMoveList) { int attk; if (isWhiteToMove) { attk = PreMinimaxCheckCheckWhite(); if (attk == -779) GetLegalWhiteMovesSpecialDoubleCheckCase(ref pMoveList); else GetLegalWhiteMoves(attk, ref pMoveList); } else { attk = PreMinimaxCheckCheckBlack(); if (attk == -779) GetLegalBlackMovesSpecialDoubleCheckCase(ref pMoveList); else GetLegalBlackMoves(attk, ref pMoveList); } } private void GetLegalWhiteMoves(int pCheckingPieceSquare, ref List<Move> pMoveList) { if (pCheckingPieceSquare == -779) { GetLegalWhiteMovesSpecialDoubleCheckCase(ref pMoveList); return; } moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= blackPawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, whiteKingSquare); if (curCheckCount == 0) { if (whiteCastleRightKingSide && ((allPieceBitboard | oppAttkBitboard) & WHITE_KING_ROCHADE) == 0ul) pMoveList.Add(mWHITE_KING_ROCHADE); if (whiteCastleRightQueenSide && (allPieceBitboard & WHITE_QUEEN_ROCHADE | oppAttkBitboard & WHITE_QUEEN_ATTK_ROCHADE) == 0ul) pMoveList.Add(mWHITE_QUEEN_ROCHADE); if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, whitePieceBitboard, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[whiteKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare + 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, whitePieceBitboard, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveList(whiteKingSquare, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalWhiteCaptures(int pCheckingPieceSquare, ref List<Move> pMoveList) { if (pCheckingPieceSquare == -779) { GetLegalWhiteCapturesSpecialDoubleCheckCase(ref pMoveList); return; } moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= blackPawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, whiteKingSquare); if (curCheckCount == 0) { if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & blackPieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[whiteKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare + 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & blackPieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveListOnlyCaptures(whiteKingSquare, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalWhiteMovesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= blackPawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveList(whiteKingSquare, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalWhiteCapturesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= blackPawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveListOnlyCaptures(whiteKingSquare, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalBlackMoves(int pCheckingPieceSquare, ref List<Move> pMoveList) { if (pCheckingPieceSquare == -779) { GetLegalBlackMovesSpecialDoubleCheckCase(ref pMoveList); return; } moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= whitePawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, blackKingSquare); if (curCheckCount == 0) { if (blackCastleRightKingSide && ((allPieceBitboard | oppAttkBitboard) & BLACK_KING_ROCHADE) == 0ul) pMoveList.Add(mBLACK_KING_ROCHADE); if (blackCastleRightQueenSide && (allPieceBitboard & BLACK_QUEEN_ROCHADE | oppAttkBitboard & BLACK_QUEEN_ATTK_ROCHADE) == 0ul) pMoveList.Add(mBLACK_QUEEN_ROCHADE); if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveList(p, blackKingSquare, blackPieceBitboard, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[blackKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare - 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveList(p, blackKingSquare, blackPieceBitboard, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveList(blackKingSquare, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); } private void GetLegalBlackCaptures(int pCheckingPieceSquare, ref List<Move> pMoveList) { if (pCheckingPieceSquare == -779) { GetLegalBlackCapturesSpecialDoubleCheckCase(ref pMoveList); return; } moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= whitePawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, blackKingSquare); if (curCheckCount == 0) { if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & whitePieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[blackKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare - 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & whitePieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveListOnlyCaptures(blackKingSquare, ~oppAttkBitboard & whitePieceBitboard); } private void GetLegalBlackMovesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= whitePawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveList(blackKingSquare, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); } private void GetLegalBlackCapturesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= whitePawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveListOnlyCaptures(blackKingSquare, ~oppAttkBitboard & whitePieceBitboard); } public Move GetMoveOfString(string pMove) { int tSP, tEP; string[] tSpl = pMove.Split(','); if (Char.IsNumber(pMove[0])) { tSP = Convert.ToInt32(tSpl[0]); tEP = Convert.ToInt32(tSpl[1]); } else { tSP = SQUARES.NumberNotation(tSpl[0]); tEP = SQUARES.NumberNotation(tSpl[1]); } int tPT = pieceTypeArray[tSP]; bool tIC = ULONG_OPERATIONS.IsBitOne(allPieceBitboard, tEP), tIEP = enPassantSquare == tEP && tPT == 1; if (tSpl.Length == 3) return new Move(tSP, tEP, tPT, Convert.ToInt32(tSpl[2]), tIC); if (tIEP) return new Move(true, tSP, tEP, isWhiteToMove ? tEP - 8 : tEP + 8); if (tPT == 1 && Math.Abs(tSP - tEP) > 11) return new Move(tSP, tEP, 1, false, isWhiteToMove ? tSP + 8 : tSP - 8); if (tPT == 6 && (Math.Abs(tSP - tEP) == 2 || Math.Abs(tSP - tEP) == 3)) { if (isWhiteToMove) return tEP == 6 ? mWHITE_KING_ROCHADE : mWHITE_QUEEN_ROCHADE; return tEP == 62 ? mBLACK_KING_ROCHADE : mBLACK_QUEEN_ROCHADE; } return new Move(tSP, tEP, tPT, tIC); } public void PlainMakeMove(string pMoveName) { PlainMakeMove(GetMoveOfString(pMoveName)); } public void PlainMakeMove(Move pMove) { lastMadeMove = pMove; if (isWhiteToMove) WhiteMakeMove(pMove); else BlackMakeMove(pMove); } public void WhiteMakeMove(Move pMove) { int tEndPos = pMove.endPos, tStartPos = pMove.startPos, tPieceType = pMove.pieceType, tPTI = pieceTypeArray[tEndPos]; fiftyMoveRuleCounter++; whitePieceBitboard ^= pMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey ^= blackTurnHash ^ enPassantSquareHashes[enPassantSquare] ^ pieceHashesWhite[tStartPos, tPieceType] ^ pieceHashesWhite[tEndPos, tPieceType]; enPassantSquare = 65; isWhiteToMove = false; switch (pMove.moveTypeID) { case 0: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 1: fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 2: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 3: whiteKingSquare = tEndPos; if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 4: if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 5: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 6: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 7: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[whiteKingSquare = tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 8: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 9: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = pMove.enPassantOption]; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 11: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; whiteKingSquare = tEndPos; pieceTypeArray[pMove.rochadeEndPos] = 4; pieceTypeArray[pMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesWhite[pMove.rochadeStartPos, 4] ^ pieceHashesWhite[pMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 12: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[pMove.enPassantOption] = 0; zobristKey ^= pieceHashesBlack[pMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 13: fiftyMoveRuleCounter = 0; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; zobristKey ^= pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, pMove.promotionType]; break; case 14: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, tPTI] ^ pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, pMove.promotionType]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; } moveHashList.Add(pMove.moveHash); if (pMove.isCapture || tPieceType == 1) { curSearchZobristKeyLine = Array.Empty<ulong>(); return; } ulong[] u = new ulong[(tPTI = curSearchZobristKeyLine.Length) + 1]; for (int i = tPTI; i-- > 0;) u[i] = curSearchZobristKeyLine[i]; u[tPTI] = zobristKey; curSearchZobristKeyLine = u; } public void BlackMakeMove(Move pMove) { int tEndPos = pMove.endPos, tStartPos = pMove.startPos, tPieceType = pMove.pieceType, tPTI = pieceTypeArray[tEndPos]; fiftyMoveRuleCounter++; blackPieceBitboard ^= pMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey ^= blackTurnHash ^ enPassantSquareHashes[enPassantSquare] ^ pieceHashesBlack[tStartPos, tPieceType] ^ pieceHashesBlack[tEndPos, tPieceType]; enPassantSquare = 65; isWhiteToMove = true; switch (pMove.moveTypeID) { case 0: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 1: fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 2: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 3: blackKingSquare = tEndPos; if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 4: if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 5: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 6: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 7: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[blackKingSquare = tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 8: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 9: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = pMove.enPassantOption]; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 11: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; blackKingSquare = tEndPos; pieceTypeArray[pMove.rochadeEndPos] = 4; pieceTypeArray[pMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesBlack[pMove.rochadeStartPos, 4] ^ pieceHashesBlack[pMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 12: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[pMove.enPassantOption] = 0; zobristKey ^= pieceHashesWhite[pMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 13: fiftyMoveRuleCounter = 0; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, pMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 14: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } zobristKey ^= pieceHashesWhite[tEndPos, tPTI] ^ pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, pMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; } moveHashList.Add(pMove.moveHash); if (pMove.isCapture || tPieceType == 1) { curSearchZobristKeyLine = Array.Empty<ulong>(); return; } ulong[] u = new ulong[(tPTI = curSearchZobristKeyLine.Length) + 1]; for (int i = tPTI; i-- > 0;) u[i] = curSearchZobristKeyLine[i]; u[tPTI] = zobristKey; curSearchZobristKeyLine = u; } public void WhiteUndoMove(Move pMove) { } private const int WHITE_CHECKMATE_VAL = 100000, BLACK_CHECKMATE_VAL = -100000, CHECK_EXTENSION_LENGTH = -12, MAX_QUIESCENCE_TOTAL_LENGTH = -32; private readonly Move NULL_MOVE = new Move(0, 0, 0); private int curSearchDepth = 0, curSubSearchDepth = -1; public int MinimaxRoot(long pTime) { evalCount = 0; searches++; int baseLineLen = 0; long tTimestamp = globalTimer.ElapsedTicks + pTime; ClearHeuristics(); transpositionTable.Clear(); ulong[] tZobristKeyLine = Array.Empty<ulong>(); if (curSearchZobristKeyLine != null) { baseLineLen = curSearchZobristKeyLine.Length; tZobristKeyLine = new ulong[baseLineLen]; Array.Copy(curSearchZobristKeyLine, tZobristKeyLine, baseLineLen); } int perftScore, tattk = isWhiteToMove ? PreMinimaxCheckCheckWhite() : PreMinimaxCheckCheckBlack(), pDepth = 1; (string, int) bookMoveTuple = TLMDatabase.SearchForNextBookMove(moveHashList); if (bookMoveTuple.Item2 != 0) { int actualMoveHash = NuCRe.GetNumber(bookMoveTuple.Item1); List<Move> tMoves = new List<Move>(); GetLegalMoves(ref tMoves); int tL = tMoves.Count; for (int i = 0; i < tL; i++) { if (tMoves[i].moveHash == actualMoveHash) { if (debugSearchDepthResults) { SNAPSHOT_WRITLINE_REPLACEMENT("TLM_DB_Count: " + bookMoveTuple.Item2); SNAPSHOT_WRITLINE_REPLACEMENT(">> " + tMoves[i]); } transpositionTable.Add(zobristKey, new TranspositionEntry(tMoves[i], Array.Empty<int>())); return 0; } } } do { curSearchDepth = pDepth; curSubSearchDepth = pDepth - 1; ulong[] completeZobristHistory = new ulong[baseLineLen + pDepth - CHECK_EXTENSION_LENGTH + 1]; for (int i = 0; i < baseLineLen; i++) completeZobristHistory[i] = curSearchZobristKeyLine[i]; curSearchZobristKeyLine = completeZobristHistory; if (isWhiteToMove) { if (tattk == -1) perftScore = MinimaxWhite(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); else perftScore = MinimaxWhite(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); } else { if (tattk == -1) perftScore = MinimaxBlack(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); else perftScore = MinimaxBlack(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); } if (debugSearchDepthResults && pTime != 1L) { int tNpS = Convert.ToInt32((double)evalCount * 10_000_000d /(double)(pTime - tTimestamp + globalTimer.ElapsedTicks)); int tSearchEval = perftScore; int timeForSearchSoFar = (int)((pTime - tTimestamp + globalTimer.ElapsedTicks) /10000d); Move tBestMove = transpositionTable[zobristKey].bestMove; SNAPSHOT_WRITLINE_REPLACEMENT((tSearchEval >= 0 ? "+": "") + tSearchEval); SNAPSHOT_WRITLINE_REPLACEMENT(" " + tBestMove + "  ["); SNAPSHOT_WRITLINE_REPLACEMENT("Depth = " + pDepth + ", "); SNAPSHOT_WRITLINE_REPLACEMENT("Evals = " + GetThreeDigitSeperatedInteger(evalCount) + ", "); SNAPSHOT_WRITLINE_REPLACEMENT("Time = " + GetThreeDigitSeperatedInteger(timeForSearchSoFar) + "ms, "); SNAPSHOT_WRITLINE_REPLACEMENT("NpS = " + GetThreeDigitSeperatedInteger(tNpS) + "]"); } pDepth++; } while (globalTimer.ElapsedTicks < tTimestamp && pDepth < 179); depths += pDepth - 1; BOT_MAIN.depthsSearched += pDepth - 1; BOT_MAIN.searchesFinished++; BOT_MAIN.evaluationsMade += evalCount; curSearchZobristKeyLine = tZobristKeyLine; return perftScore; } private int MinimaxWhite(int pPly, int pAlpha, int pBeta, int pDepth, int pRepetitionHistoryPly, int pCheckingSquare, Move pLastMove) { if (IsDrawByRepetition(pRepetitionHistoryPly - 4)) return 0; if ((pDepth <= 0 && pCheckingSquare == -1) || pDepth < CHECK_EXTENSION_LENGTH) return QuiescenceWhite(pPly, pAlpha, pBeta, pDepth - 1, pCheckingSquare, pLastMove); List<Move> moveOptionList = new List<Move>(); Move bestMove = NULL_MOVE; if (pLastMove.isPromotion && pLastMove.isCapture && pLastMove.startPos % 8 == pCheckingSquare % 8 && pLastMove.startPos == whiteKingSquare + 8 && (pLastMove.promotionType == 4 || pLastMove.promotionType == 5)) GetLegalWhiteMovesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalWhiteMoves(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tWhiteKingSquare = whiteKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1, curEval = BLACK_CHECKMATE_VAL - pDepth; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = true; double[] moveSortingArray = new double[molc]; int[] moveSortingArrayIndexes = new int[molc], thisSearchMoveSortingArrayForTransposEntry = new int[molc]; transpositionTable.TryGetValue(zobristKey, out TranspositionEntry transposEntry); if (transposEntry == null) { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; } } else { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove == transposEntry.bestMove) moveSortingArray[m] = BESTMOVE_SORT_VAL; else if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; if (transposEntry.moveGenOrderedEvalLength > m) moveSortingArray[m] -= transposEntry.moveGenOrderedEvals[m]; } } Array.Sort(moveSortingArray, moveSortingArrayIndexes); for (int m = 0; m < molc; m++) { int tActualIndex = moveSortingArrayIndexes[m]; Move curMove = moveOptionList[tActualIndex]; if (debugSortResults && pDepth == curSubSearchDepth) { SNAPSHOT_WRITLINE_REPLACEMENT(moveSortingArray[m] + " | "+ curMove); } int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; whitePieceBitboard = tWPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesWhite[tStartPos, tPieceType] ^ pieceHashesWhite[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 0: blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 1: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 2: blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 3: whiteKingSquare = tEndPos; if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 4: blackPieceBitboard = tBPB; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 5: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[whiteKingSquare = tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = curMove.enPassantOption]; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 11: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; whiteKingSquare = tEndPos; blackPieceBitboard = tBPB; pieceTypeArray[curMove.rochadeEndPos] = 4; pieceTypeArray[curMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesWhite[curMove.rochadeStartPos, 4] ^ pieceHashesWhite[curMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | curMove.rochadeEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << curMove.rochadeEndPos)) tCheckPos = curMove.rochadeEndPos; break; case 12: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesBlack[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 13: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; zobristKey ^= pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, curMove.promotionType]; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; case 14: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, tPTI] ^ pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, curMove.promotionType]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } curSearchZobristKeyLine[pRepetitionHistoryPly] = zobristKey; int tEval = MinimaxBlack(pPly + 1, pAlpha, pBeta, pDepth - 1, pRepetitionHistoryPly + 1, tCheckPos, curMove); thisSearchMoveSortingArrayForTransposEntry[tActualIndex] = tEval; pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 3: whiteKingSquare = tWhiteKingSquare; break; case 7: whiteKingSquare = tWhiteKingSquare; break; case 10: enPassantSquare = 65; break; case 11: whiteKingSquare = tWhiteKingSquare; pieceTypeArray[curMove.rochadeStartPos] = 4; pieceTypeArray[curMove.rochadeEndPos] = 0; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 13: pieceTypeArray[tStartPos] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval > curEval) { bestMove = curMove; curEval = tEval; } if (pAlpha < curEval) pAlpha = curEval; if (curEval >= pBeta) { if (!curMove.isCapture) { killerMoveHeuristic[curMove.moveHash] = true; if (pDepth > 0) historyHeuristic[curMove.moveHash] += pDepth * pDepth; } break; } } isWhiteToMove = true; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; if (molc == 0 && pCheckingSquare == 0) curEval = 0; if (!transpositionTable.ContainsKey(zobristKey)) transpositionTable.Add(zobristKey, new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry)); else transpositionTable[zobristKey] = new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry); return curEval; } private int QuiescenceWhite(int pPly, int pAlpha, int pBeta, int pDepth, int pCheckingSquare, Move pLastMove) { int standPat = TexelEvaluate(); if (standPat >= pBeta || pDepth < MAX_QUIESCENCE_TOTAL_LENGTH) return pBeta; if (standPat > pAlpha) pAlpha = standPat; List<Move> moveOptionList = new List<Move>(); if (pLastMove.isPromotion && pLastMove.isCapture && pLastMove.startPos % 8 == pCheckingSquare % 8 && pLastMove.startPos == whiteKingSquare + 8 && (pLastMove.promotionType == 4 || pLastMove.promotionType == 5)) GetLegalWhiteCapturesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalWhiteCaptures(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tWhiteKingSquare = whiteKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = true; for (int m = 0; m < molc; m++) { Move curMove = moveOptionList[m]; int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; whitePieceBitboard = tWPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesWhite[tStartPos, tPieceType] ^ pieceHashesWhite[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 5: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[whiteKingSquare = tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 12: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesBlack[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 14: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, tPTI] ^ pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, curMove.promotionType]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } int tEval = QuiescenceBlack(pPly + 1, pAlpha, pBeta, pDepth - 1, tCheckPos, curMove); pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 7: whiteKingSquare = tWhiteKingSquare; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval >= pBeta) return pBeta; if (pAlpha < tEval) pAlpha = tEval; } isWhiteToMove = true; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; return pAlpha; } private int MinimaxBlack(int pPly, int pAlpha, int pBeta, int pDepth, int pRepetitionHistoryPly, int pCheckingSquare, Move pLastMove) { if (IsDrawByRepetition(pRepetitionHistoryPly - 4)) return 0; if ((pDepth <= 0 && pCheckingSquare == -1) || pDepth < CHECK_EXTENSION_LENGTH) return QuiescenceBlack(pPly, pAlpha, pBeta, pDepth - 1, pCheckingSquare, pLastMove); List<Move> moveOptionList = new List<Move>(); Move bestMove = NULL_MOVE; if (pLastMove.isPromotion && pLastMove.isCapture && pLastMove.startPos % 8 == pCheckingSquare % 8 && pLastMove.startPos == blackKingSquare - 8 && (pLastMove.promotionType == 4 || pLastMove.promotionType == 5)) GetLegalBlackMovesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalBlackMoves(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tBlackKingSquare = blackKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1, curEval = WHITE_CHECKMATE_VAL + pDepth; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = false; double[] moveSortingArray = new double[molc]; int[] moveSortingArrayIndexes = new int[molc], thisSearchMoveSortingArrayForTransposEntry = new int[molc]; transpositionTable.TryGetValue(zobristKey, out TranspositionEntry transposEntry); if (transposEntry == null) { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; } } else { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove == transposEntry.bestMove) moveSortingArray[m] = BESTMOVE_SORT_VAL; else if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; if (transposEntry.moveGenOrderedEvalLength > m) moveSortingArray[m] -= transposEntry.moveGenOrderedEvals[m]; } } Array.Sort(moveSortingArray, moveSortingArrayIndexes); for (int m = 0; m < molc; m++) { int tActualIndex = moveSortingArrayIndexes[m]; Move curMove = moveOptionList[tActualIndex]; if (debugSortResults && pDepth == curSearchDepth) { SNAPSHOT_WRITLINE_REPLACEMENT("=== " + moveSortingArray[m] + " | "+ curMove); } int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; blackPieceBitboard = tBPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesBlack[tStartPos, tPieceType] ^ pieceHashesBlack[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 0: whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 1: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 2: whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 3: blackKingSquare = tEndPos; if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 4: whitePieceBitboard = tWPB; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 5: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[blackKingSquare = tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = curMove.enPassantOption]; whitePieceBitboard = tWPB; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 11: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; blackKingSquare = tEndPos; whitePieceBitboard = tWPB; pieceTypeArray[curMove.rochadeEndPos] = 4; pieceTypeArray[curMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesBlack[curMove.rochadeStartPos, 4] ^ pieceHashesBlack[curMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | curMove.rochadeEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << curMove.rochadeEndPos)) tCheckPos = curMove.rochadeEndPos; break; case 12: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesWhite[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 13: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, curMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; case 14: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } zobristKey ^= pieceHashesWhite[tEndPos, tPTI] ^ pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, curMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } curSearchZobristKeyLine[pRepetitionHistoryPly] = zobristKey; int tEval = MinimaxWhite(pPly + 1, pAlpha, pBeta, pDepth - 1, pRepetitionHistoryPly + 1, tCheckPos, curMove); thisSearchMoveSortingArrayForTransposEntry[tActualIndex] = tEval; pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 3: blackKingSquare = tBlackKingSquare; break; case 7: blackKingSquare = tBlackKingSquare; break; case 10: enPassantSquare = 65; break; case 11: blackKingSquare = tBlackKingSquare; pieceTypeArray[curMove.rochadeStartPos] = 4; pieceTypeArray[curMove.rochadeEndPos] = 0; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 13: pieceTypeArray[tStartPos] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval < curEval) { bestMove = curMove; curEval = tEval; } if (pBeta > curEval) pBeta = curEval; if (curEval <= pAlpha) { if (!curMove.isCapture) { killerMoveHeuristic[curMove.moveHash] = true; if (pDepth > 0) historyHeuristic[curMove.moveHash] += pDepth * pDepth; } break; } } isWhiteToMove = false; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; if (molc == 0 && pCheckingSquare == 0) curEval = 0; if (!transpositionTable.ContainsKey(zobristKey)) transpositionTable.Add(zobristKey, new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry)); else transpositionTable[zobristKey] = new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry); return curEval; } private int QuiescenceBlack(int pPly, int pAlpha, int pBeta, int pDepth, int pCheckingSquare, Move pLastMove) { int standPat = TexelEvaluate(); if (standPat <= pAlpha || pDepth < MAX_QUIESCENCE_TOTAL_LENGTH) return pAlpha; if (standPat < pBeta) pBeta = standPat; List<Move> moveOptionList = new List<Move>(); if (pLastMove.isPromotion && pLastMove.isCapture && pLastMove.startPos % 8 == pCheckingSquare % 8 && pLastMove.startPos == blackKingSquare - 8 && (pLastMove.promotionType == 4 || pLastMove.promotionType == 5)) GetLegalBlackCapturesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalBlackCaptures(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tBlackKingSquare = blackKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = false; for (int m = 0; m < molc; m++) { Move curMove = moveOptionList[m]; int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; blackPieceBitboard = tBPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesBlack[tStartPos, tPieceType] ^ pieceHashesBlack[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 5: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[blackKingSquare = tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 12: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesWhite[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 14: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } zobristKey ^= pieceHashesWhite[tEndPos, tPTI] ^ pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, curMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } int tEval = QuiescenceWhite(pPly + 1, pAlpha, pBeta, pDepth - 1, tCheckPos, curMove); pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 7: blackKingSquare = tBlackKingSquare; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval <= pAlpha) return pAlpha; if (pBeta > tEval) pBeta = tEval; } isWhiteToMove = false; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; return pBeta; } private bool[] killerMoveHeuristic = new bool[262_144]; private int[] historyHeuristic = new int[262_144]; public void ClearHeuristics() { for (int i = 0; i < 262_144; i++) { killerMoveHeuristic[i] = false; historyHeuristic[i] = 0; } } private Dictionary<ulong, TranspositionEntry> transpositionTable = new Dictionary<ulong, TranspositionEntry>(); private int[] pieceEvals = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[,][] piecePositionEvals = new int[33, 14][]; private int evalCount = 0; private int Evaluate() { evalCount++; if (fiftyMoveRuleCounter > 99) return 0; int tEval = 0, tPT, pieceCount = ULONG_OPERATIONS.CountBits(allPieceBitboard); for (int p = 0; p < 64; p++) tEval += pieceEvals[tPT = pieceTypeArray[p] + 7 * ((int)(blackPieceBitboard >> p) & 1)] + piecePositionEvals[pieceCount, tPT][p]; return tEval; } public int GameState(bool pWhiteKingCouldBeAttacked) { if (IsDrawByRepetition(curSearchZobristKeyLine.Length - 5) || fiftyMoveRuleCounter > 99) return 0; int t; List<Move> tMoves = new List<Move>(); GetLegalMoves(ref tMoves); if (pWhiteKingCouldBeAttacked) { t = PreMinimaxCheckCheckWhite(); if (t == -1) return tMoves.Count == 0 ? 0 : 3; else if (tMoves.Count == 0) return -1; } else { t = PreMinimaxCheckCheckBlack(); if (t == -1) return tMoves.Count == 0 ? 0 : 3; else if (tMoves.Count == 0) return 1; } return 3; } private bool IsDrawByRepetition(int pPlyOfFirstPossibleRepeatedPosition) { int tC = 0; for (int i = pPlyOfFirstPossibleRepeatedPosition; i >= 0; i -= 2) { if (curSearchZobristKeyLine[i] == zobristKey) if (++tC == 2) return true; } return false; } private const int RELE_MAX_MOVE_COUNT_PER_GAME = 500; public double ReLePlayGame(int[,][] pEvalPositionValuesWhite, int[,][] pEvalPositionValuesBlack, long thinkingTimePerMove) { int[,][] processedValuesWhite = InitReLeAgent(pEvalPositionValuesWhite), processedValuesBlack = InitReLeAgent(pEvalPositionValuesBlack); int tGS, mc = 0; do { if (IsDrawByRepetition(curSearchZobristKeyLine.Length - 5)) return 0d; piecePositionEvals = isWhiteToMove ? processedValuesWhite : processedValuesBlack; MinimaxRoot(thinkingTimePerMove); if (transpositionTable.Count == 0) { SNAPSHOT_WRITLINE_REPLACEMENT("?!"); return 0d; } PlainMakeMove(transpositionTable[zobristKey].bestMove); tGS = GameState(isWhiteToMove); transpositionTable.Clear(); if (tGS != 3) break; } while (mc++ < RELE_MAX_MOVE_COUNT_PER_GAME); if (tGS == 3 || tGS == 0) return 0d; else if (tGS == 1) return 0.1d * (double)(RELE_MAX_MOVE_COUNT_PER_GAME - mc); return 0.1d * (double)(-RELE_MAX_MOVE_COUNT_PER_GAME + mc); } public int[,][] InitReLeAgent(int[,][] pEvalPositionValues) { return GetInterpolatedProcessedValues(pEvalPositionValues); } private int[,][] GetInterpolatedProcessedValues(int[,][] pEvalPositionValues) { int[,][] processedValues = new int[33, 14][]; for (int i = 0; i < 32; i++) { int ip1 = i + 1; processedValues[ip1, 7] = processedValues[ip1, 0] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; processedValues[ip1, 8] = SwapArrayViewingSide(processedValues[ip1, 1] = MultiplyArraysWithVal(pEvalPositionValues[0, 0], pEvalPositionValues[1, 0], pEvalPositionValues[2, 0], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 9] = SwapArrayViewingSide(processedValues[ip1, 2] = MultiplyArraysWithVal(pEvalPositionValues[0, 1], pEvalPositionValues[1, 1], pEvalPositionValues[2, 1], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 10] = SwapArrayViewingSide(processedValues[ip1, 3] = MultiplyArraysWithVal(pEvalPositionValues[0, 2], pEvalPositionValues[1, 2], pEvalPositionValues[2, 2], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 11] = SwapArrayViewingSide(processedValues[ip1, 4] = MultiplyArraysWithVal(pEvalPositionValues[0, 3], pEvalPositionValues[1, 3], pEvalPositionValues[2, 3], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 12] = SwapArrayViewingSide(processedValues[ip1, 5] = MultiplyArraysWithVal(pEvalPositionValues[0, 4], pEvalPositionValues[1, 4], pEvalPositionValues[2, 4], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 13] = SwapArrayViewingSide(processedValues[ip1, 6] = MultiplyArraysWithVal(pEvalPositionValues[0, 5], pEvalPositionValues[1, 5], pEvalPositionValues[2, 5], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); } return processedValues; } private double[,][] GetInterpolatedProcessedValues(double[,][] pEvalPositionValues) { double[,][] processedValues = new double[33, 14][]; for (int i = 0; i < 32; i++) { int ip1 = i + 1; processedValues[ip1, 7] = processedValues[ip1, 0] = new double[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; processedValues[ip1, 8] = SwapArrayViewingSide(processedValues[ip1, 1] = MultiplyArraysWithVal(pEvalPositionValues[0, 0], pEvalPositionValues[1, 0], pEvalPositionValues[2, 0], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 9] = SwapArrayViewingSide(processedValues[ip1, 2] = MultiplyArraysWithVal(pEvalPositionValues[0, 1], pEvalPositionValues[1, 1], pEvalPositionValues[2, 1], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 10] = SwapArrayViewingSide(processedValues[ip1, 3] = MultiplyArraysWithVal(pEvalPositionValues[0, 2], pEvalPositionValues[1, 2], pEvalPositionValues[2, 2], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 11] = SwapArrayViewingSide(processedValues[ip1, 4] = MultiplyArraysWithVal(pEvalPositionValues[0, 3], pEvalPositionValues[1, 3], pEvalPositionValues[2, 3], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 12] = SwapArrayViewingSide(processedValues[ip1, 5] = MultiplyArraysWithVal(pEvalPositionValues[0, 4], pEvalPositionValues[1, 4], pEvalPositionValues[2, 4], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 13] = SwapArrayViewingSide(processedValues[ip1, 6] = MultiplyArraysWithVal(pEvalPositionValues[0, 5], pEvalPositionValues[1, 5], pEvalPositionValues[2, 5], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); } return processedValues; } private double[] MultiplyArraysWithVal(double[] pArr1, double[] pArr2, double[] pArr3, double pVal1, double pVal2, double pVal3) { int tL = pArr1.Length; double[] rArr = new double[tL]; for (int i = 0; i < tL; i++) { rArr[i] = pArr1[i] * pVal1 + pArr2[i] * pVal2 + pArr3[i] * pVal3; } return rArr; } private int[] MultiplyArraysWithVal(int[] pArr1, int[] pArr2, int[] pArr3, double pVal1, double pVal2, double pVal3) { int tL = pArr1.Length; int[] rArr = new int[tL]; for (int i = 0; i < tL; i++) { rArr[i] = (int)(pArr1[i] * pVal1 + pArr2[i] * pVal2 + pArr3[i] * pVal3); } return rArr; } private int[] SwapArrayViewingSideAndNegate(int[] pArr) { return new int[64] { -pArr[56], -pArr[57], -pArr[58], -pArr[59], -pArr[60], -pArr[61], -pArr[62], -pArr[63], -pArr[48], -pArr[49], -pArr[50], -pArr[51], -pArr[52], -pArr[53], -pArr[54], -pArr[55], -pArr[40], -pArr[41], -pArr[42], -pArr[43], -pArr[44], -pArr[45], -pArr[46], -pArr[47], -pArr[32], -pArr[33], -pArr[34], -pArr[35], -pArr[36], -pArr[37], -pArr[38], -pArr[39], -pArr[24], -pArr[25], -pArr[26], -pArr[27], -pArr[28], -pArr[29], -pArr[30], -pArr[31], -pArr[16], -pArr[17], -pArr[18], -pArr[19], -pArr[20], -pArr[21], -pArr[22], -pArr[23], -pArr[8], -pArr[9], -pArr[10], -pArr[11], -pArr[12], -pArr[13], -pArr[14], -pArr[15], -pArr[0], -pArr[1], -pArr[2], -pArr[3], -pArr[4], -pArr[5], -pArr[6], -pArr[7] }; } private int[] SwapArrayViewingSide(int[] pArr) { return new int[64] { pArr[56], pArr[57], pArr[58], pArr[59], pArr[60], pArr[61], pArr[62], pArr[63], pArr[48], pArr[49], pArr[50], pArr[51], pArr[52], pArr[53], pArr[54], pArr[55], pArr[40], pArr[41], pArr[42], pArr[43], pArr[44], pArr[45], pArr[46], pArr[47], pArr[32], pArr[33], pArr[34], pArr[35], pArr[36], pArr[37], pArr[38], pArr[39], pArr[24], pArr[25], pArr[26], pArr[27], pArr[28], pArr[29], pArr[30], pArr[31], pArr[16], pArr[17], pArr[18], pArr[19], pArr[20], pArr[21], pArr[22], pArr[23], pArr[8], pArr[9], pArr[10], pArr[11], pArr[12], pArr[13], pArr[14], pArr[15], pArr[0], pArr[1], pArr[2], pArr[3], pArr[4], pArr[5], pArr[6], pArr[7] }; } private double[] SwapArrayViewingSide(double[] pArr) { return new double[64] { pArr[56], pArr[57], pArr[58], pArr[59], pArr[60], pArr[61], pArr[62], pArr[63], pArr[48], pArr[49], pArr[50], pArr[51], pArr[52], pArr[53], pArr[54], pArr[55], pArr[40], pArr[41], pArr[42], pArr[43], pArr[44], pArr[45], pArr[46], pArr[47], pArr[32], pArr[33], pArr[34], pArr[35], pArr[36], pArr[37], pArr[38], pArr[39], pArr[24], pArr[25], pArr[26], pArr[27], pArr[28], pArr[29], pArr[30], pArr[31], pArr[16], pArr[17], pArr[18], pArr[19], pArr[20], pArr[21], pArr[22], pArr[23], pArr[8], pArr[9], pArr[10], pArr[11], pArr[12], pArr[13], pArr[14], pArr[15], pArr[0], pArr[1], pArr[2], pArr[3], pArr[4], pArr[5], pArr[6], pArr[7] }; } private int[,][] texelTuningRuntimeVals = new int[33, 14][]; private int[,][] texelTuningVals = new int[3, 6][]; private int[,] texelTuningAdjustIterations = new int[6, 64]; private int[][] texelTuningRuntimePositionalValsV2EG = new int[14][]; private int[][] texelTuningRuntimePositionalValsV2LG = new int[14][]; private int[] texelPieceEvaluationsV2EG = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[] texelPieceEvaluationsV2LG = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[] texelKingSafetyR1EvaluationsEG = new int[9]; private int[] texelKingSafetyR2EvaluationsEG = new int[17]; private int[] texelKingSafetyR1EvaluationsLG = new int[9]; private int[] texelKingSafetyR2EvaluationsLG = new int[17]; private int[] texelKingSafetySREvaluationsPT1EG = new int[12]; private int[] texelKingSafetySREvaluationsPT2EG = new int[12]; private int[] texelKingSafetySREvaluationsPT3EG = new int[12]; private int[] texelKingSafetySREvaluationsPT4EG = new int[12]; private int[] texelKingSafetySREvaluationsPT5EG = new int[12]; private int[] texelKingSafetySREvaluationsPT6EG = new int[12]; private int[] texelKingSafetySREvaluationsPT1LG = new int[12]; private int[] texelKingSafetySREvaluationsPT2LG = new int[12]; private int[] texelKingSafetySREvaluationsPT3LG = new int[12]; private int[] texelKingSafetySREvaluationsPT4LG = new int[12]; private int[] texelKingSafetySREvaluationsPT5LG = new int[12]; private int[] texelKingSafetySREvaluationsPT6LG = new int[12]; private int[,] texelMobilityStraightEG = new int[14, 15], texelMobilityStraightLG = new int[14, 15]; private int[,] texelMobilityDiagonalEG = new int[14, 14], texelMobilityDiagonalLG = new int[14, 14]; private int[] texelPieceEvaluations = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[] blackSidedSquares = new int[64] { 56, 57, 58, 59, 60, 61, 62, 63, 48, 49, 50, 51, 52, 53, 54, 55, 40, 41, 42, 43, 44, 45, 46, 47, 32, 33, 34, 35, 36, 37, 38, 39, 24, 25, 26, 27, 28, 29, 30, 31, 16, 17, 18, 19, 20, 21, 22, 23, 08, 09, 10, 11, 12, 13, 14, 15, 00, 01, 02, 03, 04, 05, 06, 07 }; private int[,] T_Pawns = new int[3, 64] { { 0, 0, 0, 0, 0, 0, 0, 0, 98, 134, 61, 95, 68, 126, 34, -11, -6, 7, 26, 31, 65, 56, 25, -20, -14, 13, 6, 21, 23, 12, 17, -23, -27, -2, -5, 12, 17, 6, 10, -25, -26, -4, -4, -10, 3, 3, 33, -12, -35, -1, -20, -23, -15, 24, 38, -22, 0, 0, 0, 0, 0, 0, 0, 0, } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { 0, 0, 0, 0, 0, 0, 0, 0, 178, 173, 158, 134, 147, 132, 165, 187, 94, 100, 85, 67, 56, 53, 82, 84, 32, 24, 13, 5, -2, 4, 17, 17, 13, 9, -3, -7, -7, -8, 3, -1, 4, 7, -6, 1, 0, -5, -1, -8, 13, 8, 8, 10, 13, 0, 2, -7, 0, 0, 0, 0, 0, 0, 0, 0, } }; private int[,] T_Knights = new int[3, 64] { { -167, -89, -34, -49, 61, -97, -15, -107, -73, -41, 72, 36, 23, 62, 7, -17, -47, 60, 37, 65, 84, 129, 73, 44, -9, 17, 19, 53, 37, 69, 18, 22, -13, 4, 16, 13, 28, 19, 21, -8, -23, -9, 12, 10, 19, 17, 25, -16, -29, -53, -12, -3, -1, 18, -14, -19, -105, -21, -58, -33, -17, -28, -19, -23 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -58, -38, -13, -28, -31, -27, -63, -99, -25, -8, -25, -2, -9, -25, -24, -52, -24, -20, 10, 9, -1, -9, -19, -41, -17, 3, 22, 22, 22, 11, 8, -18, -18, -6, 16, 25, 16, 17, 4, -18, -23, -3, -1, 15, 10, -3, -20, -22, -42, -20, -10, -5, -2, -20, -23, -44, -29, -51, -23, -15, -22, -18, -50, -64 } }; private int[,] T_Bishops = new int[3, 64] { { -29, 4, -82, -37, -25, -42, 7, -8, -26, 16, -18, -13, 30, 59, 18, -47, -16, 37, 43, 40, 35, 50, 37, -2, -4, 5, 19, 50, 37, 37, 7, -2, -6, 13, 13, 26, 34, 12, 10, 4, 0, 15, 15, 15, 14, 27, 18, 10, 4, 15, 16, 0, 7, 21, 33, 1, -33, -3, -14, -21, -13, -12, -39, -21 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -14, -21, -11, -8, -7, -9, -17, -24, -8, -4, 7, -12, -3, -13, -4, -14, 2, -8, 0, -1, -2, 6, 0, 4, -3, 9, 12, 9, 14, 10, 3, 2, -6, 3, 13, 19, 7, 10, -3, -9, -12, -3, 8, 10, 13, 3, -7, -15, -14, -18, -7, -1, 4, -9, -15, -27, -23, -9, -23, -5, -9, -16, -5, -17 } }; private int[,] T_Rooks = new int[3, 64] { { 32, 42, 32, 51, 63, 9, 31, 43, 27, 32, 58, 62, 80, 67, 26, 44, -5, 19, 26, 36, 17, 45, 61, 16, -24, -11, 7, 26, 24, 35, -8, -20, -36, -26, -12, -1, 9, -7, 6, -23, -45, -25, -16, -17, 3, 0, -5, -33, -44, -16, -20, -9, -1, 11, -6, -71, -19, -13, 1, 17, 16, 7, -37, -26 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { 13, 10, 18, 15, 12, 12, 8, 5, 11, 13, 13, 11, -3, 3, 8, 3, 7, 7, 7, 5, 4, -3, -5, -3, 4, 3, 13, 1, 2, 1, -1, 2, 3, 5, 8, 4, -5, -6, -8, -11, -4, 0, -5, -1, -7, -12, -8, -16, -6, -6, 0, 2, -9, -9, -11, -3, -9, 2, 3, -1, -5, -13, 4, -20 } }; private int[,] T_Queens = new int[3, 64] { { -28, 0, 29, 12, 59, 44, 43, 45, -24, -39, -5, 1, -16, 57, 28, 54, -13, -17, 7, 8, 29, 56, 47, 57, -27, -27, -16, -16, -1, 17, -2, 1, -9, -26, -9, -10, -2, -4, 3, -3, -14, 2, -11, -2, -5, 2, 14, 5, -35, -8, 11, 2, 8, 15, -3, 1, -1, -18, -9, 10, -15, -25, -31, -50 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -9, 22, 22, 27, 27, 19, 10, 20, -17, 20, 32, 41, 58, 25, 30, 0, -20, 6, 9, 49, 47, 35, 19, 9, 3, 22, 24, 45, 57, 40, 57, 36, -18, 28, 19, 47, 31, 34, 39, 23, -16, -27, 15, 6, 9, 17, 10, 5, -22, -23, -30, -16, -16, -23, -36, -32, -33, -28, -22, -43, -5, -32, -20, -41 } }; private int[,] T_Kings = new int[3, 64] { { -65, 23, 16, -15, -56, -34, 2, 13, 29, -1, -20, -7, -8, -4, -38, -29, -9, 24, 2, -16, -20, 6, 22, -22, -17, -20, -12, -27, -30, -25, -14, -36, -49, -1, -27, -39, -46, -44, -33, -51, -14, -14, -22, -46, -44, -30, -15, -27, 1, 7, -8, -64, -43, -16, 9, 8, -15, 36, 12, -54, 8, -28, 24, 14 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -74, -35, -18, -18, -11, 15, 4, -17, -12, 17, 14, 17, 17, 38, 23, 11, 10, 17, 23, 15, 20, 45, 44, 13, -8, 22, 24, 27, 26, 33, 26, 3, -18, -4, 21, 24, 27, 23, 9, -11, -19, -3, 11, 21, 23, 16, 7, -9, -27, -11, 4, 13, 14, 4, -5, -17, -53, -34, -21, -11, -28, -14, -24, -43 } }; private int[] paramsLowerLimits = new int[5] { -10000, -10000, -10000, -10000, -10000 }; private int[] paramsUpperLimits = new int[5] { 10000, 10000, 10000, 10000, 10000 }; private List<TLM_ChessGame> threadDataset; private int threadFrom, threadTo; private int[] threadParams; private int customThreadID = 0; private ulong ulAllThreadIDsUnfinished = 0; private double lastCostVal = 0d; private double sumCostVals = 0d; private int costCalculations = 0; private readonly string[] TEXELPRINT_GAMEPARTS = new string[3] { "Early Game: ", "Mid Game: ", "Late Game: "}; private readonly string[] TEXELPRINT_PIECES = new string[6] { "Bauer: ", "Springer: ", "Lufer: ", "Turm: ", "Dame: ", "Knig: "}; private double[] earlyGameMultipliers = new double[33]; private double[] middleGameMultipliers = new double[33]; private double[] lateGameMultipliers = new double[33]; private int[] pieceTypeGameProgressImpact = new int[14] { 0, 0, 1, 1, 2, 4, 0, 0, 0, 1, 1, 2, 4, 0 }; private void PrecalculateMultipliers() { if (BOARD_MANAGER_ID == ENGINE_VALS.PARALLEL_BOARDS - 1) SNAPSHOT_WRITLINE_REPLACEMENT(); for (int i = 0; i < 25; i++) { earlyGameMultipliers[i] = EGMultiplierFunction(i); lateGameMultipliers[i] = LGMultiplierFunction(i); if (BOARD_MANAGER_ID == ENGINE_VALS.PARALLEL_BOARDS - 1) SNAPSHOT_WRITLINE_REPLACEMENT("[" + i + "] "+ earlyGameMultipliers[i] + " | "+ middleGameMultipliers[i] + " | "+ lateGameMultipliers[i]); } } private double MultiplierFunction(double pVal, double pXShift) { double d = Math.Exp(1d /6d * (pVal - pXShift)); return 5 * (d /Math.Pow(d + 1, 2d)); } private double EGMultiplierFunction(double pVal) { return Math.Clamp(1 /16d * (pVal - 4d), 0d, 1d); } private double LGMultiplierFunction(double pVal) { return Math.Clamp(1 /-16d * (pVal - 4d) + 1d, 0d, 1d); } private double EGMultiplierFunction2(double pVal) { return Math.Clamp(1 /32d * pVal, 0d, 1d); } private double LGMultiplierFunction2(double pVal) { return Math.Clamp(1 /-32d * pVal + 1d, 0d, 1d); } private void TuneWithTxtFile(string pTXTName) { List<TLM_ChessGame> gameDataset = new List<TLM_ChessGame>(); string tPath = PathManager.GetTXTPath(pTXTName); string[] tStrs = File.ReadAllLines(tPath); List<string> tGames = new List<string>(); foreach (string s in tStrs) if (s.Contains(';') && s.Replace(" ", "") != "") tGames.Add(s); foreach (string s in tGames) { TLM_ChessGame tGame = CGFF.GetGame(s); LoadFenString(tGame.startFen); foreach (int hMove in tGame.hashedMoves) { List<Move> moveOptionList = new List<Move>(); GetLegalMoves(ref moveOptionList); int tL = moveOptionList.Count; for (int j = 0; j < tL; j++) { Move tMove = moveOptionList[j]; if (tMove.moveHash == hMove) { tGame.actualMoves.Add(tMove); PlainMakeMove(tMove); tL = -1; break; } } if (tL != -1) break; } gameDataset.Add(tGame); } SNAPSHOT_WRITLINE_REPLACEMENT("[TLM TEXEL TUNER] " + tGames.Count + " Games Loaded In!"); BOT_MAIN.curTEXELPARAMS = new int[TEXEL_PARAMS]; BOT_MAIN.ParallelTexelTuning(gameDataset); } private void LoadBestTexelParamsIn() { int[] ttt = new int[778]; ttt[0] = 82; ttt[1] = 341; ttt[2] = 416; ttt[3] = 470; ttt[4] = 1106; ttt[5] = 102; ttt[6] = 302; ttt[7] = 304; ttt[8] = 518; ttt[9] = 960; SetupTexelEvaluationParams(ttt); } private void SetupTexelEvaluationParams(int[] pParams) { texelPieceEvaluationsV2EG[8] = -(texelPieceEvaluationsV2EG[1] = pParams[0]); texelPieceEvaluationsV2EG[9] = -(texelPieceEvaluationsV2EG[2] = pParams[1]); texelPieceEvaluationsV2EG[10] = -(texelPieceEvaluationsV2EG[3] = pParams[2]); texelPieceEvaluationsV2EG[11] = -(texelPieceEvaluationsV2EG[4] = pParams[3]); texelPieceEvaluationsV2EG[12] = -(texelPieceEvaluationsV2EG[5] = pParams[4]); texelPieceEvaluationsV2LG[8] = -(texelPieceEvaluationsV2LG[1] = pParams[5]); texelPieceEvaluationsV2LG[9] = -(texelPieceEvaluationsV2LG[2] = pParams[6]); texelPieceEvaluationsV2LG[10] = -(texelPieceEvaluationsV2LG[3] = pParams[7]); texelPieceEvaluationsV2LG[11] = -(texelPieceEvaluationsV2LG[4] = pParams[8]); texelPieceEvaluationsV2LG[12] = -(texelPieceEvaluationsV2LG[5] = pParams[9]); int c = 10; for (int p = 1; p < 7; p++) { for (int s = 0; s < 64; s++) { texelTuningRuntimePositionalValsV2EG[p + 7][blackSidedSquares[s]] = -(texelTuningRuntimePositionalValsV2EG[p][s] = pParams[c++]); texelTuningRuntimePositionalValsV2LG[p + 7][blackSidedSquares[s]] = -(texelTuningRuntimePositionalValsV2LG[p][s] = pParams[c++]); } } return; for (int p = 2; p < 7; p++) { for (int a = 0; a < 15; a++) { if (a != 14) { texelMobilityDiagonalEG[p + 7, a] = -(texelMobilityDiagonalEG[p, a] = pParams[c++]); texelMobilityDiagonalLG[p + 7, a] = -(texelMobilityDiagonalLG[p, a] = pParams[c++]); } texelMobilityStraightEG[p + 7, a] = -(texelMobilityStraightEG[p, a] = pParams[c++]); texelMobilityStraightLG[p + 7, a] = -(texelMobilityStraightLG[p, a] = pParams[c++]); } } for (int i = 0; i < 12; i++) { texelKingSafetySREvaluationsPT1EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT2EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT3EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT4EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT5EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT6EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT1LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT2LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT3LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT4LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT5LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT6LG[i] = pParams[c++]; } } private void PrintDefinedTexelParams(int[] pParams) { int c = 0; for (int t = 0; t < 3; t++) { SNAPSHOT_WRITLINE_REPLACEMENT(TEXELPRINT_GAMEPARTS[t]); for (int p = 0; p < 6; p++) { SNAPSHOT_WRITLINE_REPLACEMENT(TEXELPRINT_PIECES[p]); texelTuningVals[t, p] = new int[64]; for (int s = 0; s < 64; s++) { if (s % 8 == 0 && s != 0) SNAPSHOT_WRITLINE_REPLACEMENT(); SNAPSHOT_WRITLINE_REPLACEMENT((texelTuningVals[t, p][s] = pParams[c++]) + ", "); } SNAPSHOT_WRITLINE_REPLACEMENT(); } } piecePositionEvals = GetInterpolatedProcessedValues(texelTuningVals); } public void TLMTuning(List<TLM_ChessGame> pDataset) { int tGameDataSetLen = pDataset.Count; int[,][] tRatio = new int[33, 6][]; int[,][] tTotalMoves = new int[33, 6][]; double[,][] tSummedRatios = new double[33, 6][]; double[,][] tSummedDataAmount = new double[33, 6][]; double[,][] tTuningResults = new double[33, 6][]; for (int t = 1; t < 33; t++) { for (int p = 0; p < 6; p++) { tRatio[t, p] = new int[64]; tTotalMoves[t, p] = new int[64]; tSummedRatios[t, p] = new double[64]; tSummedDataAmount[t, p] = new double[64]; tTuningResults[t, p] = new double[64]; } } for (int j = 0; j < tGameDataSetLen; j++) { TLM_ChessGame tGame = pDataset[j]; int tGR = tGame.gameResult - 1; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count - 5; for (int i = 0; i < tL; i++) { if (tGame.isMoveNonTactical[i]) { int tPieceAmount = ULONG_OPERATIONS.CountBits(allPieceBitboard); for (int s = 0; s < 64; s++) { int tPT = pieceTypeArray[s] - 1; if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, s)) { tTotalMoves[tPieceAmount, tPT][s]++; tRatio[tPieceAmount, tPT][s] += tGR; } else if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, s)) { int b = blackSidedSquares[s]; tTotalMoves[tPieceAmount, tPT][b]++; tRatio[tPieceAmount, tPT][b] += tGR; } } } PlainMakeMove(tGame.actualMoves[i]); } } double[,] allMultipliers = new double[33, 33]; for (int sh = 0; sh < 33; sh++) { for (int i = 0; i < 33; i++) { allMultipliers[sh, i] = MultiplierFunction(i, sh); } } for (int t = 1; t < 33; t++) { for (int p = 0; p < 6; p++) { for (int s = 0; s < 64; s++) { for (int t2 = 1; t2 < 33; t2++) { double cmult = allMultipliers[t, t2]; tSummedRatios[t, p][s] += tRatio[t2, p][s] * cmult; tSummedDataAmount[t, p][s] += tTotalMoves[t2, p][s] * cmult; } tTuningResults[t, p][s] = TTT(tSummedRatios[t, p][s], tSummedDataAmount[t, p][s]); } } } int c = 0; int[] tparams = new int[1152]; for (int t = 1; t < 33; t += 15) { if (t == 31) t = 32; SNAPSHOT_WRITLINE_REPLACEMENT("PieceCount = " + t + ": "); for (int p = 0; p < 6; p++) { SNAPSHOT_WRITLINE_REPLACEMENT(TEXELPRINT_PIECES[p]); for (int s = 0; s < 64; s++) { if (s % 8 == 0 && s != 0) SNAPSHOT_WRITLINE_REPLACEMENT(); SNAPSHOT_WRITLINE_REPLACEMENT((tparams[c++] = (int)(tTuningResults[t, p][s] * 100)).ToString().Replace(",", ".") + "("+ (int)tSummedDataAmount[t, p][s] + ")"+ ", "); } SNAPSHOT_WRITLINE_REPLACEMENT(); } } string tS = "PARAMS: {"; for (int i = 0; i < tparams.Length; i++) tS += tparams[i] + ","; tS = tS.Substring(0, tS.Length - 1) + "}\n"; SNAPSHOT_WRITLINE_REPLACEMENT(tS); TexelTuning(pDataset, tparams); } private double TTT(double d1, double d2) { if (d2 == 0) return 0; return d1 /d2; } public void TexelTuning(List<TLM_ChessGame> pDataset, int[] pCurBestParams) { Stopwatch sw = Stopwatch.StartNew(); string tPath = PathManager.GetTXTPath("OTHER/TEXEL_TUNING"); int paramCount = pCurBestParams.Length; double bestAvrgCost = CalculateAverageTexelCost(pDataset, pCurBestParams); SNAPSHOT_WRITLINE_REPLACEMENT("CUR PARAMS COST: " + bestAvrgCost); int packetSize = Math.Clamp(paramCount /ENGINE_VALS.CPU_CORES, 1, 100000); paramsLowerLimits = new int[paramCount]; paramsUpperLimits = new int[paramCount]; for (int i = 0; i < paramCount; i++) { int lim = i < 10 ? 100000 : 200; paramsLowerLimits[i] = -lim; paramsUpperLimits[i] = lim; } SNAPSHOT_WRITLINE_REPLACEMENT("PARAM-COUNT: " + paramCount); SNAPSHOT_WRITLINE_REPLACEMENT("PACKET-SIZE: " + packetSize); while (packetSize <= paramCount) { BOT_MAIN.TEXELfinished = 0; int lM = 0, tC = 0; ulong tUL = 0ul; for (int m = packetSize; lM < paramCount; m += packetSize) { if (m > paramCount) m = paramCount; tUL = ULONG_OPERATIONS.SetBitToOne(tUL, ++tC); lM = m; } tC = lM = 0; for (int m = packetSize; lM < paramCount; m += packetSize) { if (m > paramCount) m = paramCount; tC++; BOT_MAIN.boardManagers[tC].SetPlayTexelVals(pDataset, lM, m, pCurBestParams, paramsLowerLimits, paramsUpperLimits, tC, tUL); ThreadPool.QueueUserWorkItem(new WaitCallback(BOT_MAIN.boardManagers[tC].TexelTuningThreadedPackage)); lM = m; } packetSize = paramCount + 1; int tmod = 0; while (tC != BOT_MAIN.TEXELfinished) { if (++tmod % 20 == 0) { WriteTexelParamsToTXT(tPath, BOT_MAIN.curTEXELPARAMS); SNAPSHOT_WRITLINE_REPLACEMENT(CalculateAverageTexelCost(pDataset, BOT_MAIN.curTEXELPARAMS) + " | "+ BOT_MAIN.TEXELadjustmentsmade); SNAPSHOT_WRITLINE_REPLACEMENT(ULONG_OPERATIONS.GetBitVisualization(BOT_MAIN.TEXELfinishedwithoutimpovement)); } Thread.Sleep(100); } SNAPSHOT_WRITLINE_REPLACEMENT("One Thread Generation FINISHED! :) :) :)"); pCurBestParams = BOT_MAIN.curTEXELPARAMS; } sw.Stop(); WriteTexelParamsToTXT(tPath, BOT_MAIN.curTEXELPARAMS); SNAPSHOT_WRITLINE_REPLACEMENT("END COST: " + CalculateAverageTexelCost(pDataset, BOT_MAIN.curTEXELPARAMS)); SNAPSHOT_WRITLINE_REPLACEMENT(BOT_MAIN.TEXELadjustmentsmade); SNAPSHOT_WRITLINE_REPLACEMENT(sw.ElapsedMilliseconds); } public void TexelTuningThreadedPackage(object obj) { SNAPSHOT_WRITLINE_REPLACEMENT("Started CThreadID [" + customThreadID + "] which is handling Params ["+ threadFrom + "] - ["+ threadTo + "]"); bool firstIter = true; do { double bestAvrgCost = CalculateAverageTexelCost(threadDataset, threadParams); int adjust_val = firstIter ? 512 : 8; do { adjust_val /= 2; bool improvedAvrgCost = true; while (improvedAvrgCost) { improvedAvrgCost = false; for (int i = threadFrom; i < threadTo; i++) { bool improvedWithThisParam = true; int tadjustval = adjust_val; bool lastTimeMaximized = false, lastTimeMinimized = false; while (improvedWithThisParam) { improvedWithThisParam = false; int[] curParams = (int[])threadParams.Clone(); int paramBefore = curParams[i]; curParams[i] = Math.Clamp(paramBefore + adjust_val, paramsLowerLimits[i], paramsUpperLimits[i]); double curAvrgCost = CalculateAverageTexelCost(threadDataset, curParams); if (curAvrgCost < bestAvrgCost) { improvedAvrgCost = true; improvedWithThisParam = true; SNAPSHOT_WRITLINE_REPLACEMENT("Improved Param [" + i + "] at CThreadID ["+ customThreadID + "]: +"+ adjust_val + " ("+ GetDoublePrecentageString(bestAvrgCost - curAvrgCost) + ")"); bestAvrgCost = curAvrgCost; threadParams = curParams; BOT_MAIN.TEXELadjustmentsmade++; BOT_MAIN.TEXELfinishedwithoutimpovement = ulAllThreadIDsUnfinished; if (lastTimeMaximized) { adjust_val *= 4; lastTimeMaximized = false; } else lastTimeMaximized = true; lastTimeMinimized = false; } else { curParams[i] = Math.Clamp(paramBefore - adjust_val, paramsLowerLimits[i], paramsUpperLimits[i]); curAvrgCost = CalculateAverageTexelCost(threadDataset, curParams); if (curAvrgCost < bestAvrgCost) { improvedAvrgCost = true; improvedWithThisParam = true; SNAPSHOT_WRITLINE_REPLACEMENT("Improved Param [" + i + "] at CThreadID ["+ customThreadID + "]: -"+ adjust_val + " ("+ GetDoublePrecentageString(bestAvrgCost - curAvrgCost) + ")"); bestAvrgCost = curAvrgCost; threadParams = curParams; BOT_MAIN.TEXELadjustmentsmade++; BOT_MAIN.TEXELfinishedwithoutimpovement = ulAllThreadIDsUnfinished; if (lastTimeMinimized) { adjust_val *= 4; lastTimeMinimized = false; } else lastTimeMinimized = true; lastTimeMaximized = false; } } if (adjust_val != 1) adjust_val /= 2; for (int j = threadFrom; j < threadTo; j++) { BOT_MAIN.curTEXELPARAMS[j] = threadParams[j]; } threadParams = (int[])BOT_MAIN.curTEXELPARAMS.Clone(); bestAvrgCost = CalculateAverageTexelCost(threadDataset, threadParams); } adjust_val = tadjustval; } } } while (adjust_val != 1); BOT_MAIN.TEXELfinishedwithoutimpovement = ULONG_OPERATIONS.SetBitToZero(BOT_MAIN.TEXELfinishedwithoutimpovement, customThreadID); SNAPSHOT_WRITLINE_REPLACEMENT("FULLY FINISHED " + customThreadID + ". IMPROVEMENT THREAD PACKAGE CYCLE"); firstIter = false; } while (BOT_MAIN.TEXELfinishedwithoutimpovement != 0); BOT_MAIN.TEXELfinished++; } private void WriteTexelParamsToTXT(string pPath, int[] pParams) { try { string tS = "PARAMS: {"; for (int i = 0; i < pParams.Length; i++) tS += pParams[i] + ","; tS = tS.Substring(0, tS.Length - 1) + "}\n"; File.AppendAllText(pPath, tS); } catch { SNAPSHOT_WRITLINE_REPLACEMENT("Mal wieder TXT zu lange gebraucht um zu aktualisieren."); } } private double costSum = 0d; private int texelCostMovesEvaluated = 0; private double CalculateAverageTexelCost(List<TLM_ChessGame> tDataset, int[] pParams, bool pFullCost = true) { costSum = 0d; texelCostMovesEvaluated = 0; SetupTexelEvaluationParams(pParams); int tGameDataSetLen = tDataset.Count; int start = 0, end = tGameDataSetLen; if (!pFullCost) { end = (start = globalRandom.Next(0, end - 256)) + 256; } for (int j = start; j < end; j++) { TLM_ChessGame tGame = tDataset[j]; double tGR = tGame.gameResult; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count - 5; texelCostMovesEvaluated += tL; for (int i = 0; i < tL; i++) { costSum += TexelCost(tGR - TexelTuningSigmoid(TexelEvaluate())); PlainMakeMove(tGame.actualMoves[i]); } } return costSum /texelCostMovesEvaluated; } private double CalculateAverageTexelCostThreadedVersionLEGACYDOESNTWORK(List<TLM_ChessGame> tDataset, int[] pParams) { Stopwatch sw = Stopwatch.StartNew(); BOT_MAIN.TEXELcostSum = 0d; BOT_MAIN.TEXELfinished = 0; BOT_MAIN.TEXELcostMovesEvaluated = 0; int tGameDataSetLen = tDataset.Count; int gamesPerThread = tGameDataSetLen /ENGINE_VALS.CPU_CORES; for (int i = 0; i < ENGINE_VALS.CPU_CORES - 1; i++) { } for (int i = 0; i < ENGINE_VALS.CPU_CORES - 1; i++) { } while (BOT_MAIN.TEXELfinished != ENGINE_VALS.CPU_CORES) Thread.Sleep(1); sw.Stop(); return BOT_MAIN.TEXELcostSum /BOT_MAIN.TEXELcostMovesEvaluated; } public void SetPlayThroughVals(List<TLM_ChessGame> pDataset, int pFrom, int pTo) { threadDataset = pDataset; threadFrom = pFrom; threadTo = pTo; } public void SetPlayTexelVals(List<TLM_ChessGame> pDataset, int pFrom, int pTo, int[] pTexelParams, int[] pLowerLimits, int[] pUpperLimits, int pThreadID, ulong pUL) { threadDataset = pDataset; threadFrom = pFrom; threadTo = pTo; threadParams = pTexelParams; paramsLowerLimits = pLowerLimits; paramsUpperLimits = pUpperLimits; customThreadID = pThreadID; ulAllThreadIDsUnfinished = pUL; } public void PlayThroughSetOfGames(object obj) { SNAPSHOT_WRITLINE_REPLACEMENT(threadFrom + "->"+ threadTo); int sortedOut = 0; for (int j = threadFrom; j < threadTo; j++) { TLM_ChessGame tGame = threadDataset[j]; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count; for (int i = 0; i < tL; i++) { int tQuietEval = isWhiteToMove ? QuiescenceWhite(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, 0, PreMinimaxCheckCheckWhite(), NULL_MOVE) : QuiescenceBlack(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, 0, PreMinimaxCheckCheckBlack(), NULL_MOVE); bool tB; tGame.isMoveNonTactical.Add(tB = (Evaluate() == tQuietEval && i > 4)); if (!tB) sortedOut++; PlainMakeMove(tGame.actualMoves[i]); } } BOT_MAIN.TEXELsortedout += sortedOut; BOT_MAIN.TEXELfinished++; } public void CalculateAverageTexelCostThreadFunction(object obj) { SetupTexelEvaluationParams(threadParams); double d = 0d; for (int j = threadFrom; j < threadTo; j++) { TLM_ChessGame tGame = threadDataset[j]; double tGR = tGame.gameResult; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count - 5; BOT_MAIN.TEXELcostMovesEvaluated += tL; for (int i = 0; i < tL; i++) { d += TexelCost(tGR - TexelTuningSigmoid(TexelEvaluate())); PlainMakeMove(tGame.actualMoves[i]); } } BOT_MAIN.TEXELcostSum += d; BOT_MAIN.TEXELfinished++; } private void ConsoleWriteLineTuneArray<T>(T[,][] pArr) { for (int j = 0; j < 3; j++) { SNAPSHOT_WRITLINE_REPLACEMENT("{"); for (int k = 0; k < 6; k++) { SNAPSHOT_WRITLINE_REPLACEMENT("{"); for (int s = 0; s < 64; s++) SNAPSHOT_WRITLINE_REPLACEMENT(pArr[j, k][s] + ", "); SNAPSHOT_WRITLINE_REPLACEMENT("\n}"); } SNAPSHOT_WRITLINE_REPLACEMENT("}"); } } private void Tune(string pGameCGFF, double pLearningRate) { TLM_ChessGame tGame = CGFF.GetGame(pGameCGFF); LoadFenString(tGame.startFen); double tDGameResult = tGame.gameResult; foreach (int hMove in tGame.hashedMoves) { Tune(tDGameResult, pLearningRate); List<Move> moveOptionList = new List<Move>(); GetLegalMoves(ref moveOptionList); int tL = moveOptionList.Count; for (int i = 0; i < tL; i++) { Move tMove = moveOptionList[i]; if (tMove.moveHash == hMove) { PlainMakeMove(tMove); tL = -1; break; } } if (tL != -1) break; } } private void Tune(double pGameResult, double pLearningRate) { int tPC = ULONG_OPERATIONS.CountBits(allPieceBitboard); double oneThroughPieceCount = 1d /tPC; double egMult = earlyGameMultipliers[tPC], mgMult = middleGameMultipliers[tPC], lgMult = lateGameMultipliers[tPC]; double tTexelResult = TexelEvaluateF(); double tSigmoidedTexelResult = TexelSigmoid(tTexelResult); double tDif = tSigmoidedTexelResult - pGameResult; double tM = oneThroughPieceCount * TexelCostDerivative(tDif) * TexelSigmoidDerivative(tTexelResult) * pLearningRate; sumCostVals += lastCostVal = TexelCost(tDif); costCalculations++; for (int i = 0; i < 64; i++) { if (ULONG_OPERATIONS.IsBitZero(allPieceBitboard, i)) continue; int tPT = pieceTypeArray[i] - 1, tI = i; if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, i)) tI = blackSidedSquares[i]; texelTuningAdjustIterations[tPT, tI]++; } } private double TexelEvaluateF() { texelTuningRuntimeVals = GetInterpolatedProcessedValues(texelTuningVals); return TexelEvaluate(); } private int TexelEvaluate() { int tEvalEG = 0, tEvalLG = 0, tProgress = 0; ulong[] attkULs = new ulong[14]; for (int p = 0; p < 64; p++) { if (((int)(allPieceBitboard >> p) & 1) == 0) continue; int aPT = pieceTypeArray[p], tPT = aPT + 7 * ((int)(blackPieceBitboard >> p) & 1); tEvalEG += texelTuningRuntimePositionalValsV2EG[tPT][p] + texelPieceEvaluationsV2EG[tPT]; tEvalLG += texelTuningRuntimePositionalValsV2LG[tPT][p] + texelPieceEvaluationsV2LG[tPT]; tProgress += pieceTypeGameProgressImpact[tPT]; } if (tProgress > 24) tProgress = 24; return (int)(earlyGameMultipliers[tProgress] * tEvalEG + lateGameMultipliers[tProgress] * tEvalLG); } private const double TexelK = 0.2; private double TexelTuningSigmoid(double pVal) { return 2d /(1 + Math.Pow(10, -TexelK * pVal /400)); } private double TexelSigmoid(double pVal) { return 2d /(Math.Exp(-0.04d * pVal) + 1d); } private double TexelSigmoidDerivative(double pVal) { double d = Math.Exp(-0.04d * pVal); return 2d * d /(25d * (d + 1d) * (d + 1d)); } private double TexelCost(double pVal) { return pVal * pVal; } private double TexelCostDerivative(double pVal) { return 2 * pVal; } private char[] fenPieces = new char[7] { 'z', 'p', 'n', 'b', 'r', 'q', 'k' }; private string[] squareNames = new string[64] { "a1", "b1", "c1", "d1", "e1", "f1", "g1", "h1", "a2", "b2", "c2", "d2", "e2", "f2", "g2", "h2", "a3", "b3", "c3", "d3", "e3", "f3", "g3", "h3", "a4", "b4", "c4", "d4", "e4", "f4", "g4", "h4", "a5", "b5", "c5", "d5", "e5", "f5", "g5", "h5", "a6", "b6", "c6", "d6", "e6", "f6", "g6", "h6", "a7", "b7", "c7", "d7", "e7", "f7", "g7", "h7", "a8", "b8", "c8", "d8", "e8", "f8", "g8", "h8"}; public string CreateFenString() { string rFEN = ""; for (int i = 7; i >= 0; i--) { int t = 0; for (int j = 0; j < 8; j++) { int sq = i * 8 + j; if (pieceTypeArray[sq] != 0) { if (t != 0) rFEN += t; t = 0; } if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, sq)) { switch (pieceTypeArray[sq]) { case 0: t++; SNAPSHOT_WRITLINE_REPLACEMENT("???"); break; case 1: rFEN += 'P'; break; case 2: rFEN += 'N'; break; case 3: rFEN += 'B'; break; case 4: rFEN += 'R'; break; case 5: rFEN += 'Q'; break; case 6: rFEN += 'K'; break; } } else { switch (pieceTypeArray[sq]) { case 0: t++; break; case 1: rFEN += 'p'; break; case 2: rFEN += 'n'; break; case 3: rFEN += 'b'; break; case 4: rFEN += 'r'; break; case 5: rFEN += 'q'; break; case 6: rFEN += 'k'; break; } } } if (t != 0) rFEN += t; if (i != 0) rFEN += "/"; } rFEN += (isWhiteToMove ? " w": " b"); rFEN += (whiteCastleRightKingSide ? " K": " "); rFEN += (whiteCastleRightQueenSide ? "Q": ""); rFEN += (blackCastleRightKingSide ? "k": ""); rFEN += (blackCastleRightQueenSide ? "q": ""); if (!whiteCastleRightKingSide && !whiteCastleRightQueenSide && !blackCastleRightKingSide && !blackCastleRightQueenSide) rFEN += "-"; if (enPassantSquare < 64) rFEN += " "+ squareNames[enPassantSquare] + " "; else rFEN += " - "; return rFEN + fiftyMoveRuleCounter + " "+ ((happenedHalfMoves - happenedHalfMoves % 2) /2); } public void LoadFenString(string fenStr) { lastMadeMove = NULL_MOVE; zobristKey = 0ul; whitePieceBitboard = blackPieceBitboard = allPieceBitboard = 0ul; for (int i = 0; i < 64; i++) pieceTypeArray[i] = 0; string[] spaceSpl = fenStr.Split(' '); string[] rowSpl = spaceSpl[0].Split('/'); string epstr = spaceSpl[3]; if (epstr == "-") enPassantSquare = 65; else enPassantSquare = (epstr[0] - 'a') + 8 * (epstr[1] - '1'); isWhiteToMove = true; if (spaceSpl[1] == "b") isWhiteToMove = false; if (!isWhiteToMove) zobristKey ^= blackTurnHash; string crstr = spaceSpl[2]; whiteCastleRightKingSide = whiteCastleRightQueenSide = blackCastleRightKingSide = blackCastleRightQueenSide = false; int crStrL = crstr.Length; for (int i = 0; i < crStrL; i++) { switch (crstr[i]) { case 'K': whiteCastleRightKingSide = true; break; case 'Q': whiteCastleRightQueenSide = true; break; case 'k': blackCastleRightKingSide = true; break; case 'q': blackCastleRightQueenSide = true; break; } } fiftyMoveRuleCounter = Convert.ToInt32(spaceSpl[4]); happenedHalfMoves = Convert.ToInt32(spaceSpl[5]) * 2; if (!isWhiteToMove) happenedHalfMoves++; int tSq = 0; for (int i = rowSpl.Length; i-- > 0;) { string tStr = rowSpl[i]; int tStrLen = tStr.Length; for (int c = 0; c < tStrLen; c++) { char tChar = tStr[c]; if (Char.IsDigit(tChar)) tSq += tChar - '0'; else { bool tCol = Char.IsLower(tChar); if (tCol) blackPieceBitboard = ULONG_OPERATIONS.SetBitToOne(blackPieceBitboard, tSq); else whitePieceBitboard = ULONG_OPERATIONS.SetBitToOne(whitePieceBitboard, tSq); if (tChar == 'k') blackKingSquare = tSq; else if (tChar == 'K') whiteKingSquare = tSq; pieceTypeArray[tSq] = Array.IndexOf(fenPieces, Char.ToLower(tChar)); if (tCol) zobristKey ^= pieceHashesBlack[tSq, pieceTypeArray[tSq]]; else zobristKey ^= pieceHashesWhite[tSq, pieceTypeArray[tSq]]; tSq++; } } } if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; zobristKey ^= enPassantSquareHashes[enPassantSquare]; allPieceBitboard = whitePieceBitboard | blackPieceBitboard; if (zobristKey == 16260251586586513106) moveHashList.Clear(); else { moveHashList.Clear(); moveHashList.Add(1); moveHashList.Add(2); moveHashList.Add(3); } } private ulong[,] pieceHashesWhite = new ulong[64, 7], pieceHashesBlack = new ulong[64, 7]; private ulong blackTurnHash, whiteKingSideRochadeRightHash, whiteQueenSideRochadeRightHash, blackKingSideRochadeRightHash, blackQueenSideRochadeRightHash; private ulong[] enPassantSquareHashes = new ulong[66]; private void InitZobrist() { Random rng = new Random(31415926); for (int sq = 0; sq < 64; sq++) { enPassantSquareHashes[sq] = ULONG_OPERATIONS.GetRandomULONG(rng); for (int it = 1; it < 7; it++) { pieceHashesWhite[sq, it] = ULONG_OPERATIONS.GetRandomULONG(rng); pieceHashesBlack[sq, it] = ULONG_OPERATIONS.GetRandomULONG(rng); } } blackTurnHash = ULONG_OPERATIONS.GetRandomULONG(rng); whiteKingSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); whiteQueenSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); blackKingSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); blackQueenSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); } public void SetKnightMasks(ulong[] uls) { knightSquareBitboards = uls; } public void SetKingMasks(ulong[] uls) { kingSquareBitboards = uls; } private Move[,] whiteEnPassantMoves = new Move[64, 64]; private Move[,] blackEnPassantMoves = new Move[64, 64]; private bool[] epValidationArray = new bool[64] { false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true , true , true , true , true , true , true , true, true , true , true , true , true , true , true , true, true , true , true , true , true , true , true , true, true , true , true , true , true , true , true , true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false }; private ulong[] kingSafetyRing1 = new ulong[64], kingSafetyRing2 = new ulong[64]; private ulong[] kingSafetySpecialRingW = new ulong[64], kingSafetySpecialRingB = new ulong[64]; private ulong[] rowPrecalcs = new ulong[8], columnPrecalcs = new ulong[8]; const ulong columnUL = 0x101010101010101, rowUL = 0b11111111; private void PrecalculateKingSafetyBitboards() { for (int i = 0; i < 8; i++) { rowPrecalcs[i] = rowUL << (8 * i); columnPrecalcs[i] = columnUL << i; } for (int i = 0; i < 64; i++) { int tMod = i % 8; int tRow = (i - tMod) /8; ulong tULC = columnPrecalcs[tMod], tULR = rowPrecalcs[tRow]; ulong tULC2 = columnPrecalcs[tMod], tULR2 = rowPrecalcs[tRow]; if (tMod < 7) tULC |= columnPrecalcs[tMod + 1]; if (tMod > 0) tULC |= columnPrecalcs[tMod - 1]; if (tRow < 7) tULR |= rowPrecalcs[tRow + 1]; if (tRow > 0) tULR |= rowPrecalcs[tRow - 1]; if (tMod < 6) tULC2 |= columnPrecalcs[tMod + 2]; if (tMod > 1) tULC2 |= columnPrecalcs[tMod - 2]; if (tRow < 6) tULR2 |= rowPrecalcs[tRow + 2]; if (tRow > 1) tULR2 |= rowPrecalcs[tRow - 2]; tULR2 |= tULR; tULC2 |= tULC; kingSafetyRing1[i] = ULONG_OPERATIONS.SetBitToZero(tULR & tULC, i); kingSafetyRing2[i] = ULONG_OPERATIONS.SetBitsToZero(tULR2 & tULC2, i, i + 1, i - 1, i + 7, i + 8, i + 9, i - 7, i - 8, i - 9); } for (int i = 0; i < 64; i++) { if (i < 56) kingSafetySpecialRingW[i] = ULONG_OPERATIONS.SetBitToZero(kingSafetyRing1[i] | kingSafetyRing1[i + 8], i); else kingSafetySpecialRingW[i] = kingSafetyRing1[i]; if (i > 7) kingSafetySpecialRingB[i] = ULONG_OPERATIONS.SetBitToZero(kingSafetyRing1[i] | kingSafetyRing1[i - 8], i); else kingSafetySpecialRingB[i] = kingSafetyRing1[i]; } } private void PrecalculateEnPassantMoves() { for (int i = 0; i < 64; i++) { if (!epValidationArray[i]) continue; for (int j = 0; j < 64; j++) { if (i == j) continue; if (Math.Abs(i - j) > 9) continue; if (!epValidationArray[j]) continue; whiteEnPassantMoves[i, j] = new Move(false, i, j, j - 8); blackEnPassantMoves[i, j] = new Move(false, i, j, j + 8); } } } private void PawnAttackBitboards() { for (int sq = 0; sq < 64; sq++) { ulong u = 0ul; if (sq % 8 != 0) u = ULONG_OPERATIONS.SetBitToOne(u, sq + 7); if (sq % 8 != 7) u = ULONG_OPERATIONS.SetBitToOne(u, sq + 9); whitePawnAttackSquareBitboards[sq] = u; u = 0ul; if (sq % 8 != 0 && sq - 9 > -1) u = ULONG_OPERATIONS.SetBitToOne(u, sq - 9); if (sq % 8 != 7 && sq - 7 > -1) u = ULONG_OPERATIONS.SetBitToOne(u, sq - 7); blackPawnAttackSquareBitboards[sq] = u; } } private int[] squareConnectivesPrecalculationArray = new int[4096]; public int[] squareConnectivesCrossDirsPrecalculationArray { get; set; } = new int[4096]; private ulong[] squareConnectivesPrecalculationRayArray = new ulong[4096]; private ulong[] squareConnectivesPrecalculationLineArray = new ulong[4096]; private List<Dictionary<ulong, int>> rayCollidingSquareCalculations = new List<Dictionary<ulong, int>>(); private readonly int[] maxIntWithSpecifiedBitcount = new int[8] { 0, 0b1, 0b11, 0b111, 0b1111, 0b11111, 0b111111, 0b1111111 }; private List<ulong> differentRays = new List<ulong>(); private void SquareConnectivesPrecalculations() { for (int square = 0; square < 64; square++) { rayCollidingSquareCalculations.Add(new Dictionary<ulong, int>()); rayCollidingSquareCalculations[square].Add(0ul, square); for (int square2 = 0; square2 < 64; square2++) { if (square == square2) continue; int t = 0, t2 = 0, difSign = Math.Sign(square2 - square), itSq = square, g = 0; ulong tRay = 0ul, tExclRay = 0ul; List<int> tRayInts = new List<int>(); if (difSign == -1) g = 7; if (square % 8 == square2 % 8) { t2 = t = 1; while ((itSq += difSign * 8) < 64 && itSq > -1) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } } else if ((square - square % 8) == (square2 - square2 % 8)) { t = 1; t2 = -1; while ((itSq += difSign) % 8 != g && itSq > -1 && itSq < 64) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } } else { int dif = Math.Abs(square2 - square); if (dif % 7 == 0) { t = 2; t2 = 2; g = (difSign == 1) ? 7 : 0; while ((itSq += difSign * 7) % 8 != g && itSq < 64 && itSq > -1) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } if (ULONG_OPERATIONS.IsBitZero(tRay, square2)) { t2 = t = 0; tRay = 0ul; } } else if (dif % 9 == 0) { t = 2; t2 = -2; if (square == 0 && square2 == 63 || square == 63 && square2 == 0) SNAPSHOT_WRITLINE_REPLACEMENT("!"); while ((itSq += difSign * 9) % 8 != g && itSq < 64 && itSq > -1) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } if (ULONG_OPERATIONS.IsBitZero(tRay, square2)) { t2 = t = 0; tRay = 0ul; } } } if (square == 0 && square2 == 63) { t2 = t = 2; tRayInts.Clear(); tExclRay = tRay = ULONG_OPERATIONS.SetBitsToOne(0ul, 9, 18, 27, 36, 45, 54, 63); tRayInts = new List<int>() { 9, 18, 27, 36, 45, 54, 63 }; } else if (square2 == 0 && square == 63) { t = 2; tRayInts.Clear(); t2 = -2; tExclRay = tRay = ULONG_OPERATIONS.SetBitsToOne(0ul, 0, 9, 18, 27, 36, 45, 54); tRayInts = new List<int>() { 54, 45, 36, 27, 18, 9, 0 }; } if (tRay != 0ul && !differentRays.Contains(tRay)) { differentRays.Add(tRay); int ccount, combI = maxIntWithSpecifiedBitcount[ccount = ULONG_OPERATIONS.CountBits(tRay)]; do { ulong curAllPieceBitboard = 0ul; int solution = square; for (int j = 0; j < ccount; j++) { if (((combI >> j) & 1) == 1) { curAllPieceBitboard = ULONG_OPERATIONS.SetBitToOne(curAllPieceBitboard, tRayInts[j]); if (solution == square) solution = tRayInts[j]; } } rayCollidingSquareCalculations[square].Add(curAllPieceBitboard, solution); } while (--combI != 0); } squareConnectivesPrecalculationArray[square << 6 | square2] = t; squareConnectivesPrecalculationRayArray[square << 6 | square2] = tRay; squareConnectivesCrossDirsPrecalculationArray[square << 6 | square2] = t2; if (t != 0) squareConnectivesPrecalculationLineArray[square << 6 | square2] = (square == 0 && square2 == 63 || square2 == 0 && square == 63) ? tExclRay : ULONG_OPERATIONS.SetBitToOne(tExclRay, square2); if (squareConnectivesPrecalculationLineArray[square << 6 | square2] == 0ul && ULONG_OPERATIONS.IsBitOne(knightSquareBitboards[square], square2)) squareConnectivesPrecalculationLineArray[square << 6 | square2] = 1ul << square2; } differentRays.Clear(); } } public void SNAPSHOT_WRITLINE_REPLACEMENT() { } public void SNAPSHOT_WRITLINE_REPLACEMENT(object pStr) { } private string GetDoublePrecentageString(double pVal) { return ((int)(pVal * 1_000_000) /10_000d) + "%"; } private string ReplaceAllULONGIsBitOne(string pCode) { const string METHOD_NAME = "ULONG_OPERATIONS.IsBitOne"; int METHOD_NAME_LEN = METHOD_NAME.Length, iterations = 0; int pIndex = pCode.IndexOf(METHOD_NAME); while (pIndex != -1 && ++iterations < 10_000) { List<int> paramIndexes = new List<int>(); int openedBracketCount = 1, closedBracketCount = 0, a = METHOD_NAME_LEN + pIndex; string tpCode = pCode.Substring(0, pIndex); paramIndexes.Add(a + 1); while (++a < pCode.Length) { switch (pCode[a]) { case '(': openedBracketCount++; break; case ')': if (++closedBracketCount == openedBracketCount) { pIndex = a; a = int.MaxValue - 5; } break; case ',': if (openedBracketCount - closedBracketCount == 1) paramIndexes.Add(a + 1); break; } } if (openedBracketCount == closedBracketCount && paramIndexes.Count == 2) { tpCode += "((int)("+ pCode.Substring(paramIndexes[0], paramIndexes[1] - paramIndexes[0] - 1) + (pCode[paramIndexes[1]] == ' ' ? " >> (": " >> (") + pCode.Substring(paramIndexes[1], pIndex - paramIndexes[1]) + ")) & 1) == 1"+ pCode.Substring(pIndex + 1, pCode.Length - pIndex - 1); } pIndex = (pCode = tpCode).IndexOf(METHOD_NAME); } SNAPSHOT_WRITLINE_REPLACEMENT(iterations + " ITERATIONS"); return pCode; } private string ReplaceAllULONGIsBitZero(string pCode) { const string METHOD_NAME = "ULONG_OPERATIONS.IsBitZero"; int METHOD_NAME_LEN = METHOD_NAME.Length, iterations = 0; int pIndex = pCode.IndexOf(METHOD_NAME); while (pIndex != -1 && ++iterations < 10_000) { List<int> paramIndexes = new List<int>(); int openedBracketCount = 1, closedBracketCount = 0, a = METHOD_NAME_LEN + pIndex; string tpCode = pCode.Substring(0, pIndex); paramIndexes.Add(a + 1); while (++a < pCode.Length) { switch (pCode[a]) { case '(': openedBracketCount++; break; case ')': if (++closedBracketCount == openedBracketCount) { pIndex = a; a = int.MaxValue - 5; } break; case ',': if (openedBracketCount - closedBracketCount == 1) paramIndexes.Add(a + 1); break; } } if (openedBracketCount == closedBracketCount && paramIndexes.Count == 2) { tpCode += "((int)("+ pCode.Substring(paramIndexes[0], paramIndexes[1] - paramIndexes[0] - 1) + (pCode[paramIndexes[1]] == ' ' ? " >>": " >> ") + pCode.Substring(paramIndexes[1], pIndex - paramIndexes[1]) + ") & 1) == 0"+ pCode.Substring(pIndex + 1, pCode.Length - pIndex - 1); } pIndex = (pCode = tpCode).IndexOf(METHOD_NAME); } SNAPSHOT_WRITLINE_REPLACEMENT(iterations + " ITERATIONS"); return pCode; } private string GetThreeDigitSeperatedInteger(int pInt) { string s = pInt.ToString(), r = s[0].ToString(); int t = s.Length % 3; for (int i = 1; i < s.Length; i++) { if (i % 3 == t) r += "."; r += s[i]; } s = ""; for (int i = 0; i < r.Length; i++) s += r[i]; return s; } public double GetAverageDepth() { return (double)depths /(double)searches; } }
public class SNAPSHOT_V01_00_007 : IBoardManager  { public int TEXEL_PARAMS { get; } = 778; private const int BESTMOVE_SORT_VAL = -2_000_000_000; private const int CAPTURE_SORT_VAL = -1_000_000_000; private const int KILLERMOVE_SORT_VAL = -1000; private readonly int[,] MVVLVA_TABLE = new int[7, 7] { { 0, 0, 0, 0, 0, 0, 0 }, { 0, 1500, 1400, 1300, 1200, 1100, 1000 }, { 0, 3500, 3400, 3300, 3200, 3100, 3000 }, { 0, 4500, 4400, 4300, 4200, 4100, 4000 }, { 0, 5500, 5400, 5300, 5200, 5100, 5000 }, { 0, 9500, 9400, 9300, 9200, 9100, 9000 }, { 0, 0, 0, 0, 0, 0, 0 }}; private int BOARD_MANAGER_ID = -1; private bool debugSearchDepthResults = false; private bool debugSortResults = false; private RookMovement rookMovement; private BishopMovement bishopMovement; private QueenMovement queenMovement; private KnightMovement knightMovement; private KingMovement kingMovement; private WhitePawnMovement whitePawnMovement; private BlackPawnMovement blackPawnMovement; private Rays rays; public List<Move> moveOptionList { get; set; } private int[] pieceTypeArray = new int[64]; public ulong whitePieceBitboard, blackPieceBitboard, allPieceBitboard; private ulong zobristKey; private int whiteKingSquare, blackKingSquare, enPassantSquare = 65, happenedHalfMoves = 0, fiftyMoveRuleCounter = 0; private bool whiteCastleRightKingSide, whiteCastleRightQueenSide, blackCastleRightKingSide, blackCastleRightQueenSide; private bool isWhiteToMove; private const ulong WHITE_KING_ROCHADE = 96, WHITE_QUEEN_ROCHADE = 14, BLACK_KING_ROCHADE = 6917529027641081856, BLACK_QUEEN_ROCHADE = 1008806316530991104, WHITE_QUEEN_ATTK_ROCHADE = 12, BLACK_QUEEN_ATTK_ROCHADE = 864691128455135232; private readonly Move mWHITE_KING_ROCHADE = new Move(4, 6, 7, 5), mWHITE_QUEEN_ROCHADE = new Move(4, 2, 0, 3), mBLACK_KING_ROCHADE = new Move(60, 62, 63, 61), mBLACK_QUEEN_ROCHADE = new Move(60, 58, 56, 59); private ulong[] knightSquareBitboards = new ulong[64]; private ulong[] whitePawnAttackSquareBitboards = new ulong[64]; private ulong[] blackPawnAttackSquareBitboards = new ulong[64]; private ulong[] kingSquareBitboards = new ulong[64]; private bool[,] pieceTypeAbilities = new bool[7, 3] { { false, false, false }, { false, false, false }, { false, false, false }, { false, false, true }, { false, true, false }, { false, true, true }, { false, false, false } }; private List<int> moveHashList = new List<int>(); private ulong[] curSearchZobristKeyLine = Array.Empty<ulong>(); private Move[] debugMoveList = new Move[128]; private Stopwatch globalTimer = Stopwatch.StartNew(); private Move lastMadeMove; private int depths, searches; private Random globalRandom = new Random(); public SNAPSHOT_V01_00_007(string fen) { Setup(fen); } public void Setup(string pFen) { Stopwatch setupStopwatch = Stopwatch.StartNew(); BOARD_MANAGER_ID = BOT_MAIN.curBoardManagerID; for (int i = 0; i < 33; i++) for (int j = 0; j < 14; j++) piecePositionEvals[i, j] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; for (int i = 0; i < 33; i++) for (int j = 0; j < 14; j++) texelTuningRuntimeVals[i, j] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; for (int i = 0; i < 3; i++) for (int j = 0; j < 6; j++) texelTuningVals[i, j] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; for (int i = 0; i < 14; i++) { texelTuningRuntimePositionalValsV2EG[i] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; texelTuningRuntimePositionalValsV2LG[i] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; } PrecalculateKingSafetyBitboards(); PrecalculateMultipliers(); GetLowNoisePositionalEvaluation(globalRandom); MinimaxRoot(1L); SetupConsoleWrite("[PRECALCS] Zobrist Hashing"); InitZobrist(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Knight Movement"); knightMovement = new KnightMovement(this); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Square Connectives"); SquareConnectivesPrecalculations(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Pawn Attack Bitboards"); PawnAttackBitboards(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Rays"); rays = new Rays(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); queenMovement = new QueenMovement(this); SetupConsoleWrite("[PRECALCS] Rook Movement"); rookMovement = new RookMovement(this, queenMovement); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Bishop Movement"); bishopMovement = new BishopMovement(this, queenMovement); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] King Movement"); kingMovement = new KingMovement(this); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Pawn Movement"); whitePawnMovement = new WhitePawnMovement(this); blackPawnMovement = new BlackPawnMovement(this); PrecalculateEnPassantMoves(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWriteLine("[DONE]\n\n"); LoadFenString(pFen); LoadBestTexelParamsIn(); setupStopwatch.Stop(); } private void SetupConsoleWriteLine(string pStr) { if (BOT_MAIN.isFirstBoardManagerInitialized) return; SNAPSHOT_WRITLINE_REPLACEMENT(pStr); } private void SetupConsoleWrite(string pStr) { if (BOT_MAIN.isFirstBoardManagerInitialized) return; SNAPSHOT_WRITLINE_REPLACEMENT(pStr); } public void GetLowNoisePositionalEvaluation(System.Random rng) { int[,][] digitArray = new int[3, 6][]; for (int i = 0; i < 3; i++) for (int j = 0; j < 6; j++) digitArray[i, j] = GetRand64IntArray(rng, -5, 6); lowNoisePositionEvals1 = GetInterpolatedProcessedValues(digitArray); int[,][] digitArray2 = new int[3, 6][]; for (int i = 0; i < 3; i++) for (int j = 0; j < 6; j++) digitArray2[i, j] = GetRand64IntArray(rng, -5, 6); lowNoisePositionEvals2 = GetInterpolatedProcessedValues(digitArray2); } private int[] GetRand64IntArray(System.Random rng, int pMin, int pMax) { return new int[64] { rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax) }; } private string GetAIArrayValuesStringRepresentation(int[,][] pArr) { string r = "int[,][] ReLe_AI_RESULT_VALS = new int[3, 6][] {"; for (int i = 0; i < 3; i++) { r += "{"; for (int j = 0; j < 5; j++) { r += GetIntArray64LStringRepresentation(pArr[i, j]) + ","; } r += GetIntArray64LStringRepresentation(pArr[i, 5]) + "},"; } return r.Substring(0, r.Length - 1) + "};"; } private string GetIntArray64LStringRepresentation(int[] p64LArr) { if (p64LArr == null) return ""; string r = "new int[64]{"; for (int i = 0; i < 63; i++) { r += p64LArr[i] + ","; } return r + p64LArr[63] + "}"; } public void TempStuff() { } private string[] gameResultStrings = new string[5] { "Black Has Won!", "Draw!", "White Has Won!", "Non Existant Result!", "Game is Ongoing!"}; private int[,][] lowNoisePositionEvals1, lowNoisePositionEvals2; public void ThreadSelfPlay(object obj) { PlayGameAgainstItself(obj); } public void PlayGameAgainstItself(object obj, string pStartFEN = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1", long tickLimitForEngine = ENGINE_VALS.SELF_PLAY_THINK_TIME) { int ttGState; while (BOT_MAIN.goalGameCount > BOT_MAIN.gamesPlayed) { try { string tGameStr; GetLowNoisePositionalEvaluation(globalRandom); LoadFenString(tGameStr = pStartFEN); tGameStr += ";"; int tGState = 3, tmc = 0; bool lowNoiceDecider = globalRandom.NextDouble() < 0.5d; while (tGState == 3) { piecePositionEvals = lowNoiceDecider ? lowNoisePositionEvals1 : lowNoisePositionEvals2; MinimaxRoot(tickLimitForEngine); Move tM = transpositionTable[zobristKey].bestMove; PlainMakeMove(tM); tGameStr += NuCRe.GetNuCRe(tM.moveHash) + ","; BOT_MAIN.movesPlayed++; tGState = GameState(isWhiteToMove); lowNoiceDecider = !lowNoiceDecider; tmc++; } ttGState = tGState; tGameStr += ttGState + 1; SNAPSHOT_WRITLINE_REPLACEMENT(tGameStr); BOT_MAIN.gamesPlayedResultArray[ttGState + 1]++; BOT_MAIN.gamesPlayed++; BOT_MAIN.selfPlayGameStrings.Add(tGameStr); } catch (Exception tE) { SNAPSHOT_WRITLINE_REPLACEMENT(tE.ToString()); } } } public void PlayGameOnConsoleAgainstHuman(string pStartFEN = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1", bool pHumanPlaysWhite = true, long tickLimitForEngine = 10_000_000L) { debugSearchDepthResults = true; LoadFenString(pStartFEN); if (!(pHumanPlaysWhite ^ isWhiteToMove)) { var pVS = Console.ReadLine(); if (pVS == null) return; Move tm = GetMoveOfString(pVS.ToString()); SNAPSHOT_WRITLINE_REPLACEMENT(tm); PlainMakeMove(tm); } int tGState = 3; while (tGState == 3) { MinimaxRoot(tickLimitForEngine); PlayThroughZobristTree(); Move tM = transpositionTable[zobristKey].bestMove; SNAPSHOT_WRITLINE_REPLACEMENT(tM); SNAPSHOT_WRITLINE_REPLACEMENT(CreateFenString()); PlainMakeMove(tM); tGState = GameState(isWhiteToMove); if (tGState != 3 || tM == NULL_MOVE) break; var pV = ""; tM = NULL_MOVE; do { pV = Console.ReadLine(); if (pV == null) continue; tM = GetMoveOfString(pV.ToString()); SNAPSHOT_WRITLINE_REPLACEMENT(tM); } while (tM == NULL_MOVE); PlainMakeMove(tM); tGState = GameState(isWhiteToMove); } } private void PlayThroughZobristTree() { SetJumpState(); SNAPSHOT_WRITLINE_REPLACEMENT("\n- - - - - - - - - - - - -"); int tC = 1; Dictionary<ulong, bool> usedULs = new Dictionary<ulong, bool>(); while (transpositionTable.TryGetValue(zobristKey, out TranspositionEntry tM)) { if (usedULs.ContainsKey(zobristKey)) { SNAPSHOT_WRITLINE_REPLACEMENT(tC + ": AT LEAST ONE REPETION; REST NOT VISIBLE"); break; } SNAPSHOT_WRITLINE_REPLACEMENT(tC + ": "+ tM.bestMove + " > "); usedULs.Add(zobristKey, true); PlainMakeMove(tM.bestMove); tC++; } SNAPSHOT_WRITLINE_REPLACEMENT("- - - - - - - - - - - - -\n"); LoadJumpState(); } public Move? ReturnNextMove(Move? lastMove, long pThinkingTime) { if (lastMove != null) PlainMakeMove(lastMove); if (GameState(isWhiteToMove) != 3) return null; MinimaxRoot(pThinkingTime); if (!transpositionTable.ContainsKey(zobristKey)) return null; Move tm = transpositionTable[zobristKey].bestMove; PlainMakeMove(tm); return tm; } private int[] jmpSt_pieceTypeArray; private ulong jmpSt_whitePieceBitboard, jmpSt_blackPieceBitboard; private ulong jmpSt_zobristKey; private int jmpSt_whiteKingSquare, jmpSt_blackKingSquare, jmpSt_enPassantSquare, jmpSt_happenedHalfMoves, jmpSt_fiftyMoveRuleCounter; private bool jmpSt_whiteCastleRightKingSide, jmpSt_whiteCastleRightQueenSide, jmpSt_blackCastleRightKingSide, jmpSt_blackCastleRightQueenSide; private bool jmpSt_isWhiteToMove; private ulong[] jmpSt_curSearchZobristKeyLine; private int[] jmpSt_moveHashList; public void LoadJumpState() { pieceTypeArray = (int[])jmpSt_pieceTypeArray.Clone(); whitePieceBitboard = jmpSt_whitePieceBitboard; blackPieceBitboard = jmpSt_blackPieceBitboard; zobristKey = jmpSt_zobristKey; whiteKingSquare = jmpSt_whiteKingSquare; blackKingSquare = jmpSt_blackKingSquare; enPassantSquare = jmpSt_enPassantSquare; happenedHalfMoves = jmpSt_happenedHalfMoves; fiftyMoveRuleCounter = jmpSt_fiftyMoveRuleCounter; whiteCastleRightKingSide = jmpSt_whiteCastleRightKingSide; whiteCastleRightQueenSide = jmpSt_whiteCastleRightQueenSide; blackCastleRightKingSide = jmpSt_blackCastleRightKingSide; blackCastleRightQueenSide = jmpSt_blackCastleRightQueenSide; isWhiteToMove = jmpSt_isWhiteToMove; curSearchZobristKeyLine = (ulong[])jmpSt_curSearchZobristKeyLine.Clone(); allPieceBitboard = blackPieceBitboard | whitePieceBitboard; moveHashList = jmpSt_moveHashList.ToList(); } public void SetJumpState() { jmpSt_pieceTypeArray = (int[])pieceTypeArray.Clone(); jmpSt_whitePieceBitboard = whitePieceBitboard; jmpSt_blackPieceBitboard = blackPieceBitboard; jmpSt_zobristKey = zobristKey; jmpSt_whiteKingSquare = whiteKingSquare; jmpSt_blackKingSquare = blackKingSquare; jmpSt_enPassantSquare = enPassantSquare; jmpSt_happenedHalfMoves = happenedHalfMoves; jmpSt_fiftyMoveRuleCounter = fiftyMoveRuleCounter; jmpSt_whiteCastleRightKingSide = whiteCastleRightKingSide; jmpSt_whiteCastleRightQueenSide = whiteCastleRightQueenSide; jmpSt_blackCastleRightKingSide = blackCastleRightKingSide; jmpSt_blackCastleRightQueenSide = blackCastleRightQueenSide; jmpSt_isWhiteToMove = isWhiteToMove; jmpSt_curSearchZobristKeyLine = (ulong[])curSearchZobristKeyLine.Clone(); jmpSt_moveHashList = moveHashList.ToArray(); } private int PreMinimaxCheckCheckWhite() { ulong bitShiftedKingPos = 1ul << whiteKingSquare; int curR = -1; for (int p = 0; p < 64; p++) { if (ULONG_OPERATIONS.IsBitZero(blackPieceBitboard, p)) continue; int tPT; switch (tPT = pieceTypeArray[p]) { case 1: if ((bitShiftedKingPos & blackPawnAttackSquareBitboards[p]) != 0ul) return p; break; case 2: if ((bitShiftedKingPos & knightSquareBitboards[p]) != 0ul) return p; break; case 6: break; default: if ((squareConnectivesPrecalculationLineArray[whiteKingSquare << 6 | p] & allPieceBitboard) == (1ul << p) && pieceTypeAbilities[tPT, squareConnectivesPrecalculationArray[whiteKingSquare << 6 | p]]) { if (curR != -1) return -779; curR = p; } break; } } return curR; } private int PreMinimaxCheckCheckBlack() { ulong bitShiftedKingPos = 1ul << blackKingSquare; int curR = -1; for (int p = 0; p < 64; p++) { if (ULONG_OPERATIONS.IsBitZero(whitePieceBitboard, p)) continue; int tPT; switch (tPT = pieceTypeArray[p]) { case 1: if ((bitShiftedKingPos & whitePawnAttackSquareBitboards[p]) != 0ul) return p; break; case 2: if ((bitShiftedKingPos & knightSquareBitboards[p]) != 0ul) return p; break; case 6: break; default: if ((squareConnectivesPrecalculationLineArray[blackKingSquare << 6 | p] & allPieceBitboard) == (1ul << p) && pieceTypeAbilities[tPT, squareConnectivesPrecalculationArray[blackKingSquare << 6 | p]]) { if (curR != -1) return -779; curR = p; } break; } } return curR; } private int LecacyLeafCheckingPieceCheckWhite(int pStartPos, int pEndPos, int pPieceType) { int tI, tPossibleAttackPiece; if (pPieceType == 1) { if (ULONG_OPERATIONS.IsBitOne(blackPawnAttackSquareBitboards[pEndPos], whiteKingSquare)) return pEndPos; } else if (pPieceType == 2) { if (ULONG_OPERATIONS.IsBitOne(knightSquareBitboards[pEndPos], whiteKingSquare)) return pEndPos; } else if (pPieceType != 6) { tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | pEndPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; } tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | pStartPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; return -1; } private int LecacyLeafCheckingPieceCheckBlack(int pStartPos, int pEndPos, int pPieceType) { int tI, tPossibleAttackPiece; if (pPieceType == 1) { if (ULONG_OPERATIONS.IsBitOne(whitePawnAttackSquareBitboards[pEndPos], blackKingSquare)) return pEndPos; } else if (pPieceType == 2) { if (ULONG_OPERATIONS.IsBitOne(knightSquareBitboards[pEndPos], blackKingSquare)) return pEndPos; } else if (pPieceType != 6) { tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | pEndPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; } tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | pStartPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; return -1; } public void GetLegalMoves(ref List<Move> pMoveList) { int attk; if (isWhiteToMove) { attk = PreMinimaxCheckCheckWhite(); if (attk == -779) GetLegalWhiteMovesSpecialDoubleCheckCase(ref pMoveList); else GetLegalWhiteMoves(attk, ref pMoveList); } else { attk = PreMinimaxCheckCheckBlack(); if (attk == -779) GetLegalBlackMovesSpecialDoubleCheckCase(ref pMoveList); else GetLegalBlackMoves(attk, ref pMoveList); } } private void GetLegalWhiteMoves(int pCheckingPieceSquare, ref List<Move> pMoveList) { if (pCheckingPieceSquare == -779) { GetLegalWhiteMovesSpecialDoubleCheckCase(ref pMoveList); return; } moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= blackPawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, whiteKingSquare); if (curCheckCount == 0) { if (whiteCastleRightKingSide && ((allPieceBitboard | oppAttkBitboard) & WHITE_KING_ROCHADE) == 0ul) pMoveList.Add(mWHITE_KING_ROCHADE); if (whiteCastleRightQueenSide && (allPieceBitboard & WHITE_QUEEN_ROCHADE | oppAttkBitboard & WHITE_QUEEN_ATTK_ROCHADE) == 0ul) pMoveList.Add(mWHITE_QUEEN_ROCHADE); if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, whitePieceBitboard, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[whiteKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare + 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, whitePieceBitboard, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveList(whiteKingSquare, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalWhiteCaptures(int pCheckingPieceSquare, ref List<Move> pMoveList) { if (pCheckingPieceSquare == -779) { GetLegalWhiteCapturesSpecialDoubleCheckCase(ref pMoveList); return; } moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= blackPawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, whiteKingSquare); if (curCheckCount == 0) { if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & blackPieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[whiteKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare + 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & blackPieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveListOnlyCaptures(whiteKingSquare, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalWhiteMovesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= blackPawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveList(whiteKingSquare, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalWhiteCapturesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= blackPawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveListOnlyCaptures(whiteKingSquare, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalBlackMoves(int pCheckingPieceSquare, ref List<Move> pMoveList) { if (pCheckingPieceSquare == -779) { GetLegalBlackMovesSpecialDoubleCheckCase(ref pMoveList); return; } moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= whitePawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, blackKingSquare); if (curCheckCount == 0) { if (blackCastleRightKingSide && ((allPieceBitboard | oppAttkBitboard) & BLACK_KING_ROCHADE) == 0ul) pMoveList.Add(mBLACK_KING_ROCHADE); if (blackCastleRightQueenSide && (allPieceBitboard & BLACK_QUEEN_ROCHADE | oppAttkBitboard & BLACK_QUEEN_ATTK_ROCHADE) == 0ul) pMoveList.Add(mBLACK_QUEEN_ROCHADE); if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveList(p, blackKingSquare, blackPieceBitboard, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[blackKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare - 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveList(p, blackKingSquare, blackPieceBitboard, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveList(blackKingSquare, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); } private void GetLegalBlackCaptures(int pCheckingPieceSquare, ref List<Move> pMoveList) { if (pCheckingPieceSquare == -779) { GetLegalBlackCapturesSpecialDoubleCheckCase(ref pMoveList); return; } moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= whitePawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, blackKingSquare); if (curCheckCount == 0) { if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & whitePieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[blackKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare - 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & whitePieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveListOnlyCaptures(blackKingSquare, ~oppAttkBitboard & whitePieceBitboard); } private void GetLegalBlackMovesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= whitePawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveList(blackKingSquare, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); } private void GetLegalBlackCapturesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= whitePawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveListOnlyCaptures(blackKingSquare, ~oppAttkBitboard & whitePieceBitboard); } public Move GetMoveOfString(string pMove) { int tSP, tEP; string[] tSpl = pMove.Split(','); if (Char.IsNumber(pMove[0])) { tSP = Convert.ToInt32(tSpl[0]); tEP = Convert.ToInt32(tSpl[1]); } else { tSP = SQUARES.NumberNotation(tSpl[0]); tEP = SQUARES.NumberNotation(tSpl[1]); } int tPT = pieceTypeArray[tSP]; bool tIC = ULONG_OPERATIONS.IsBitOne(allPieceBitboard, tEP), tIEP = enPassantSquare == tEP && tPT == 1; if (tSpl.Length == 3) return new Move(tSP, tEP, tPT, Convert.ToInt32(tSpl[2]), tIC); if (tIEP) return new Move(true, tSP, tEP, isWhiteToMove ? tEP - 8 : tEP + 8); if (tPT == 1 && Math.Abs(tSP - tEP) > 11) return new Move(tSP, tEP, 1, false, isWhiteToMove ? tSP + 8 : tSP - 8); if (tPT == 6 && (Math.Abs(tSP - tEP) == 2 || Math.Abs(tSP - tEP) == 3)) { if (isWhiteToMove) return tEP == 6 ? mWHITE_KING_ROCHADE : mWHITE_QUEEN_ROCHADE; return tEP == 62 ? mBLACK_KING_ROCHADE : mBLACK_QUEEN_ROCHADE; } return new Move(tSP, tEP, tPT, tIC); } public void PlainMakeMove(string pMoveName) { PlainMakeMove(GetMoveOfString(pMoveName)); } public void PlainMakeMove(Move pMove) { lastMadeMove = pMove; if (isWhiteToMove) WhiteMakeMove(pMove); else BlackMakeMove(pMove); } public void WhiteMakeMove(Move pMove) { int tEndPos = pMove.endPos, tStartPos = pMove.startPos, tPieceType = pMove.pieceType, tPTI = pieceTypeArray[tEndPos]; fiftyMoveRuleCounter++; whitePieceBitboard ^= pMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey ^= blackTurnHash ^ enPassantSquareHashes[enPassantSquare] ^ pieceHashesWhite[tStartPos, tPieceType] ^ pieceHashesWhite[tEndPos, tPieceType]; enPassantSquare = 65; isWhiteToMove = false; switch (pMove.moveTypeID) { case 0: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 1: fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 2: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 3: whiteKingSquare = tEndPos; if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 4: if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 5: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 6: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 7: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[whiteKingSquare = tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 8: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 9: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = pMove.enPassantOption]; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 11: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; whiteKingSquare = tEndPos; pieceTypeArray[pMove.rochadeEndPos] = 4; pieceTypeArray[pMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesWhite[pMove.rochadeStartPos, 4] ^ pieceHashesWhite[pMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 12: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[pMove.enPassantOption] = 0; zobristKey ^= pieceHashesBlack[pMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 13: fiftyMoveRuleCounter = 0; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; zobristKey ^= pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, pMove.promotionType]; break; case 14: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, tPTI] ^ pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, pMove.promotionType]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; } moveHashList.Add(pMove.moveHash); if (pMove.isCapture || tPieceType == 1) { curSearchZobristKeyLine = Array.Empty<ulong>(); return; } ulong[] u = new ulong[(tPTI = curSearchZobristKeyLine.Length) + 1]; for (int i = tPTI; i-- > 0;) u[i] = curSearchZobristKeyLine[i]; u[tPTI] = zobristKey; curSearchZobristKeyLine = u; } public void BlackMakeMove(Move pMove) { int tEndPos = pMove.endPos, tStartPos = pMove.startPos, tPieceType = pMove.pieceType, tPTI = pieceTypeArray[tEndPos]; fiftyMoveRuleCounter++; blackPieceBitboard ^= pMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey ^= blackTurnHash ^ enPassantSquareHashes[enPassantSquare] ^ pieceHashesBlack[tStartPos, tPieceType] ^ pieceHashesBlack[tEndPos, tPieceType]; enPassantSquare = 65; isWhiteToMove = true; switch (pMove.moveTypeID) { case 0: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 1: fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 2: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 3: blackKingSquare = tEndPos; if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 4: if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 5: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 6: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 7: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[blackKingSquare = tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 8: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 9: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = pMove.enPassantOption]; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 11: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; blackKingSquare = tEndPos; pieceTypeArray[pMove.rochadeEndPos] = 4; pieceTypeArray[pMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesBlack[pMove.rochadeStartPos, 4] ^ pieceHashesBlack[pMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 12: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[pMove.enPassantOption] = 0; zobristKey ^= pieceHashesWhite[pMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 13: fiftyMoveRuleCounter = 0; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, pMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 14: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } zobristKey ^= pieceHashesWhite[tEndPos, tPTI] ^ pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, pMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; } moveHashList.Add(pMove.moveHash); if (pMove.isCapture || tPieceType == 1) { curSearchZobristKeyLine = Array.Empty<ulong>(); return; } ulong[] u = new ulong[(tPTI = curSearchZobristKeyLine.Length) + 1]; for (int i = tPTI; i-- > 0;) u[i] = curSearchZobristKeyLine[i]; u[tPTI] = zobristKey; curSearchZobristKeyLine = u; } public void WhiteUndoMove(Move pMove) { } private const int WHITE_CHECKMATE_VAL = 100000, BLACK_CHECKMATE_VAL = -100000, CHECK_EXTENSION_LENGTH = -12, MAX_QUIESCENCE_TOTAL_LENGTH = -32; private readonly Move NULL_MOVE = new Move(0, 0, 0); private int curSearchDepth = 0, curSubSearchDepth = -1; public int MinimaxRoot(long pTime) { evalCount = 0; searches++; int baseLineLen = 0; long tTimestamp = globalTimer.ElapsedTicks + pTime; ClearHeuristics(); transpositionTable.Clear(); ulong[] tZobristKeyLine = Array.Empty<ulong>(); if (curSearchZobristKeyLine != null) { baseLineLen = curSearchZobristKeyLine.Length; tZobristKeyLine = new ulong[baseLineLen]; Array.Copy(curSearchZobristKeyLine, tZobristKeyLine, baseLineLen); } int perftScore, tattk = isWhiteToMove ? PreMinimaxCheckCheckWhite() : PreMinimaxCheckCheckBlack(), pDepth = 1; (string, int) bookMoveTuple = TLMDatabase.SearchForNextBookMove(moveHashList); if (bookMoveTuple.Item2 != 0) { int actualMoveHash = NuCRe.GetNumber(bookMoveTuple.Item1); List<Move> tMoves = new List<Move>(); GetLegalMoves(ref tMoves); int tL = tMoves.Count; for (int i = 0; i < tL; i++) { if (tMoves[i].moveHash == actualMoveHash) { if (debugSearchDepthResults) { SNAPSHOT_WRITLINE_REPLACEMENT("TLM_DB_Count: " + bookMoveTuple.Item2); SNAPSHOT_WRITLINE_REPLACEMENT(">> " + tMoves[i]); } transpositionTable.Add(zobristKey, new TranspositionEntry(tMoves[i], Array.Empty<int>())); return 0; } } } do { curSearchDepth = pDepth; curSubSearchDepth = pDepth - 1; ulong[] completeZobristHistory = new ulong[baseLineLen + pDepth - CHECK_EXTENSION_LENGTH + 1]; for (int i = 0; i < baseLineLen; i++) completeZobristHistory[i] = curSearchZobristKeyLine[i]; curSearchZobristKeyLine = completeZobristHistory; if (isWhiteToMove) { if (tattk == -1) perftScore = MinimaxWhite(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); else perftScore = MinimaxWhite(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); } else { if (tattk == -1) perftScore = MinimaxBlack(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); else perftScore = MinimaxBlack(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); } if (debugSearchDepthResults && pTime != 1L) { int tNpS = Convert.ToInt32((double)evalCount * 10_000_000d /(double)(pTime - tTimestamp + globalTimer.ElapsedTicks)); int tSearchEval = perftScore; int timeForSearchSoFar = (int)((pTime - tTimestamp + globalTimer.ElapsedTicks) /10000d); Move tBestMove = transpositionTable[zobristKey].bestMove; SNAPSHOT_WRITLINE_REPLACEMENT((tSearchEval >= 0 ? "+": "") + tSearchEval); SNAPSHOT_WRITLINE_REPLACEMENT(" " + tBestMove + "  ["); SNAPSHOT_WRITLINE_REPLACEMENT("Depth = " + pDepth + ", "); SNAPSHOT_WRITLINE_REPLACEMENT("Evals = " + GetThreeDigitSeperatedInteger(evalCount) + ", "); SNAPSHOT_WRITLINE_REPLACEMENT("Time = " + GetThreeDigitSeperatedInteger(timeForSearchSoFar) + "ms, "); SNAPSHOT_WRITLINE_REPLACEMENT("NpS = " + GetThreeDigitSeperatedInteger(tNpS) + "]"); } pDepth++; } while (globalTimer.ElapsedTicks < tTimestamp && pDepth < 179); depths += pDepth - 1; BOT_MAIN.depthsSearched += pDepth - 1; BOT_MAIN.searchesFinished++; BOT_MAIN.evaluationsMade += evalCount; curSearchZobristKeyLine = tZobristKeyLine; return perftScore; } private int MinimaxWhite(int pPly, int pAlpha, int pBeta, int pDepth, int pRepetitionHistoryPly, int pCheckingSquare, Move pLastMove) { if (IsDrawByRepetition(pRepetitionHistoryPly - 4)) return 0; if ((pDepth <= 0 && pCheckingSquare == -1) || pDepth < CHECK_EXTENSION_LENGTH) return QuiescenceWhite(pPly, pAlpha, pBeta, pDepth - 1, pCheckingSquare, pLastMove); List<Move> moveOptionList = new List<Move>(); Move bestMove = NULL_MOVE; if (pLastMove.isPromotion && pLastMove.isCapture && pLastMove.startPos % 8 == pCheckingSquare % 8 && pLastMove.startPos == whiteKingSquare + 8 && (pLastMove.promotionType == 4 || pLastMove.promotionType == 5)) GetLegalWhiteMovesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalWhiteMoves(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tWhiteKingSquare = whiteKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1, curEval = BLACK_CHECKMATE_VAL - pDepth; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = true; double[] moveSortingArray = new double[molc]; int[] moveSortingArrayIndexes = new int[molc], thisSearchMoveSortingArrayForTransposEntry = new int[molc]; transpositionTable.TryGetValue(zobristKey, out TranspositionEntry transposEntry); if (transposEntry == null) { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; } } else { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove == transposEntry.bestMove) moveSortingArray[m] = BESTMOVE_SORT_VAL; else if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; if (transposEntry.moveGenOrderedEvalLength > m) moveSortingArray[m] -= transposEntry.moveGenOrderedEvals[m]; } } Array.Sort(moveSortingArray, moveSortingArrayIndexes); for (int m = 0; m < molc; m++) { int tActualIndex = moveSortingArrayIndexes[m]; Move curMove = moveOptionList[tActualIndex]; if (debugSortResults && pDepth == curSubSearchDepth) { SNAPSHOT_WRITLINE_REPLACEMENT(moveSortingArray[m] + " | "+ curMove); } int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; whitePieceBitboard = tWPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesWhite[tStartPos, tPieceType] ^ pieceHashesWhite[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 0: blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 1: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 2: blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 3: whiteKingSquare = tEndPos; if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 4: blackPieceBitboard = tBPB; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 5: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[whiteKingSquare = tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = curMove.enPassantOption]; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 11: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; whiteKingSquare = tEndPos; blackPieceBitboard = tBPB; pieceTypeArray[curMove.rochadeEndPos] = 4; pieceTypeArray[curMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesWhite[curMove.rochadeStartPos, 4] ^ pieceHashesWhite[curMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | curMove.rochadeEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << curMove.rochadeEndPos)) tCheckPos = curMove.rochadeEndPos; break; case 12: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesBlack[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 13: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; zobristKey ^= pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, curMove.promotionType]; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; case 14: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, tPTI] ^ pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, curMove.promotionType]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } curSearchZobristKeyLine[pRepetitionHistoryPly] = zobristKey; debugMoveList[pPly] = curMove; int tEval = MinimaxBlack(pPly + 1, pAlpha, pBeta, pDepth - 1, pRepetitionHistoryPly + 1, tCheckPos, curMove); thisSearchMoveSortingArrayForTransposEntry[tActualIndex] = tEval; pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 3: whiteKingSquare = tWhiteKingSquare; break; case 7: whiteKingSquare = tWhiteKingSquare; break; case 10: enPassantSquare = 65; break; case 11: whiteKingSquare = tWhiteKingSquare; pieceTypeArray[curMove.rochadeStartPos] = 4; pieceTypeArray[curMove.rochadeEndPos] = 0; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 13: pieceTypeArray[tStartPos] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval > curEval) { bestMove = curMove; curEval = tEval; } if (pAlpha < curEval) pAlpha = curEval; if (curEval >= pBeta) { if (!curMove.isCapture) { killerMoveHeuristic[curMove.moveHash] = true; if (pDepth > 0) historyHeuristic[curMove.moveHash] += pDepth * pDepth; } break; } } isWhiteToMove = true; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; if (molc == 0 && pCheckingSquare == -1) curEval = 0; if (!transpositionTable.ContainsKey(zobristKey)) transpositionTable.Add(zobristKey, new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry)); else transpositionTable[zobristKey] = new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry); return curEval; } private int QuiescenceWhite(int pPly, int pAlpha, int pBeta, int pDepth, int pCheckingSquare, Move pLastMove) { int standPat = TexelEvaluate(); if (standPat >= pBeta || pDepth < MAX_QUIESCENCE_TOTAL_LENGTH) return pBeta; if (standPat > pAlpha) pAlpha = standPat; List<Move> moveOptionList = new List<Move>(); if (pLastMove.isPromotion && pLastMove.isCapture && pLastMove.startPos % 8 == pCheckingSquare % 8 && pLastMove.startPos == whiteKingSquare + 8 && (pLastMove.promotionType == 4 || pLastMove.promotionType == 5)) GetLegalWhiteCapturesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalWhiteCaptures(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tWhiteKingSquare = whiteKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = true; for (int m = 0; m < molc; m++) { Move curMove = moveOptionList[m]; int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; whitePieceBitboard = tWPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesWhite[tStartPos, tPieceType] ^ pieceHashesWhite[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 5: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[whiteKingSquare = tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 12: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesBlack[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 14: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, tPTI] ^ pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, curMove.promotionType]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } debugMoveList[pPly] = curMove; int tEval = QuiescenceBlack(pPly + 1, pAlpha, pBeta, pDepth - 1, tCheckPos, curMove); pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 7: whiteKingSquare = tWhiteKingSquare; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval >= pBeta) return pBeta; if (pAlpha < tEval) pAlpha = tEval; } isWhiteToMove = true; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; return pAlpha; } private int MinimaxBlack(int pPly, int pAlpha, int pBeta, int pDepth, int pRepetitionHistoryPly, int pCheckingSquare, Move pLastMove) { if (IsDrawByRepetition(pRepetitionHistoryPly - 4)) return 0; if ((pDepth <= 0 && pCheckingSquare == -1) || pDepth < CHECK_EXTENSION_LENGTH) return QuiescenceBlack(pPly, pAlpha, pBeta, pDepth - 1, pCheckingSquare, pLastMove); List<Move> moveOptionList = new List<Move>(); Move bestMove = NULL_MOVE; if (pLastMove.isPromotion && pLastMove.isCapture && pLastMove.startPos % 8 == pCheckingSquare % 8 && pLastMove.startPos == blackKingSquare - 8 && (pLastMove.promotionType == 4 || pLastMove.promotionType == 5)) GetLegalBlackMovesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalBlackMoves(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tBlackKingSquare = blackKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1, curEval = WHITE_CHECKMATE_VAL + pDepth; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = false; double[] moveSortingArray = new double[molc]; int[] moveSortingArrayIndexes = new int[molc], thisSearchMoveSortingArrayForTransposEntry = new int[molc]; transpositionTable.TryGetValue(zobristKey, out TranspositionEntry transposEntry); if (transposEntry == null) { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; } } else { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove == transposEntry.bestMove) moveSortingArray[m] = BESTMOVE_SORT_VAL; else if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; if (transposEntry.moveGenOrderedEvalLength > m) moveSortingArray[m] -= transposEntry.moveGenOrderedEvals[m]; } } Array.Sort(moveSortingArray, moveSortingArrayIndexes); for (int m = 0; m < molc; m++) { int tActualIndex = moveSortingArrayIndexes[m]; Move curMove = moveOptionList[tActualIndex]; if (debugSortResults && pDepth == curSearchDepth) { SNAPSHOT_WRITLINE_REPLACEMENT("=== " + moveSortingArray[m] + " | "+ curMove); } int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; blackPieceBitboard = tBPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesBlack[tStartPos, tPieceType] ^ pieceHashesBlack[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 0: whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 1: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 2: whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 3: blackKingSquare = tEndPos; if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 4: whitePieceBitboard = tWPB; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 5: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[blackKingSquare = tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = curMove.enPassantOption]; whitePieceBitboard = tWPB; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 11: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; blackKingSquare = tEndPos; whitePieceBitboard = tWPB; pieceTypeArray[curMove.rochadeEndPos] = 4; pieceTypeArray[curMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesBlack[curMove.rochadeStartPos, 4] ^ pieceHashesBlack[curMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | curMove.rochadeEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << curMove.rochadeEndPos)) tCheckPos = curMove.rochadeEndPos; break; case 12: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesWhite[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 13: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, curMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; case 14: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } zobristKey ^= pieceHashesWhite[tEndPos, tPTI] ^ pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, curMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } curSearchZobristKeyLine[pRepetitionHistoryPly] = zobristKey; debugMoveList[pPly] = curMove; int tEval = MinimaxWhite(pPly + 1, pAlpha, pBeta, pDepth - 1, pRepetitionHistoryPly + 1, tCheckPos, curMove); thisSearchMoveSortingArrayForTransposEntry[tActualIndex] = tEval; pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 3: blackKingSquare = tBlackKingSquare; break; case 7: blackKingSquare = tBlackKingSquare; break; case 10: enPassantSquare = 65; break; case 11: blackKingSquare = tBlackKingSquare; pieceTypeArray[curMove.rochadeStartPos] = 4; pieceTypeArray[curMove.rochadeEndPos] = 0; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 13: pieceTypeArray[tStartPos] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval < curEval) { bestMove = curMove; curEval = tEval; } if (pBeta > curEval) pBeta = curEval; if (curEval <= pAlpha) { if (!curMove.isCapture) { killerMoveHeuristic[curMove.moveHash] = true; if (pDepth > 0) historyHeuristic[curMove.moveHash] += pDepth * pDepth; } break; } } isWhiteToMove = false; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; if (molc == 0 && pCheckingSquare == -1) curEval = 0; if (!transpositionTable.ContainsKey(zobristKey)) transpositionTable.Add(zobristKey, new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry)); else transpositionTable[zobristKey] = new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry); return curEval; } private int QuiescenceBlack(int pPly, int pAlpha, int pBeta, int pDepth, int pCheckingSquare, Move pLastMove) { int standPat = TexelEvaluate(); if (standPat <= pAlpha || pDepth < MAX_QUIESCENCE_TOTAL_LENGTH) return pAlpha; if (standPat < pBeta) pBeta = standPat; List<Move> moveOptionList = new List<Move>(); if (pLastMove.isPromotion && pLastMove.isCapture && pLastMove.startPos % 8 == pCheckingSquare % 8 && pLastMove.startPos == blackKingSquare - 8 && (pLastMove.promotionType == 4 || pLastMove.promotionType == 5)) GetLegalBlackCapturesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalBlackCaptures(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tBlackKingSquare = blackKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = false; for (int m = 0; m < molc; m++) { Move curMove = moveOptionList[m]; int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; blackPieceBitboard = tBPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesBlack[tStartPos, tPieceType] ^ pieceHashesBlack[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 5: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[blackKingSquare = tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 12: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesWhite[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 14: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } zobristKey ^= pieceHashesWhite[tEndPos, tPTI] ^ pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, curMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } debugMoveList[pPly] = curMove; int tEval = QuiescenceWhite(pPly + 1, pAlpha, pBeta, pDepth - 1, tCheckPos, curMove); pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 7: blackKingSquare = tBlackKingSquare; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval <= pAlpha) return pAlpha; if (pBeta > tEval) pBeta = tEval; } isWhiteToMove = false; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; return pBeta; } private bool[] killerMoveHeuristic = new bool[262_144]; private int[] historyHeuristic = new int[262_144]; public void ClearHeuristics() { for (int i = 0; i < 262_144; i++) { killerMoveHeuristic[i] = false; historyHeuristic[i] = 0; } } private Dictionary<ulong, TranspositionEntry> transpositionTable = new Dictionary<ulong, TranspositionEntry>(); private int[] pieceEvals = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[,][] piecePositionEvals = new int[33, 14][]; private int evalCount = 0; private int Evaluate() { evalCount++; if (fiftyMoveRuleCounter > 99) return 0; int tEval = 0, tPT, pieceCount = ULONG_OPERATIONS.CountBits(allPieceBitboard); for (int p = 0; p < 64; p++) tEval += pieceEvals[tPT = pieceTypeArray[p] + 7 * ((int)(blackPieceBitboard >> p) & 1)] + piecePositionEvals[pieceCount, tPT][p]; return tEval; } public int GameState(bool pWhiteKingCouldBeAttacked) { if (IsDrawByRepetition(curSearchZobristKeyLine.Length - 5) || fiftyMoveRuleCounter > 99) return 0; int t; List<Move> tMoves = new List<Move>(); GetLegalMoves(ref tMoves); if (pWhiteKingCouldBeAttacked) { t = PreMinimaxCheckCheckWhite(); if (t == -1) return tMoves.Count == 0 ? 0 : 3; else if (tMoves.Count == 0) return -1; } else { t = PreMinimaxCheckCheckBlack(); if (t == -1) return tMoves.Count == 0 ? 0 : 3; else if (tMoves.Count == 0) return 1; } return 3; } private bool IsDrawByRepetition(int pPlyOfFirstPossibleRepeatedPosition) { int tC = 0; for (int i = pPlyOfFirstPossibleRepeatedPosition; i >= 0; i -= 2) { if (curSearchZobristKeyLine[i] == zobristKey) if (++tC == 2) return true; } return false; } private const int RELE_MAX_MOVE_COUNT_PER_GAME = 500; public double ReLePlayGame(int[,][] pEvalPositionValuesWhite, int[,][] pEvalPositionValuesBlack, long thinkingTimePerMove) { int[,][] processedValuesWhite = InitReLeAgent(pEvalPositionValuesWhite), processedValuesBlack = InitReLeAgent(pEvalPositionValuesBlack); int tGS, mc = 0; do { if (IsDrawByRepetition(curSearchZobristKeyLine.Length - 5)) return 0d; piecePositionEvals = isWhiteToMove ? processedValuesWhite : processedValuesBlack; MinimaxRoot(thinkingTimePerMove); if (transpositionTable.Count == 0) { SNAPSHOT_WRITLINE_REPLACEMENT("?!"); return 0d; } PlainMakeMove(transpositionTable[zobristKey].bestMove); tGS = GameState(isWhiteToMove); transpositionTable.Clear(); if (tGS != 3) break; } while (mc++ < RELE_MAX_MOVE_COUNT_PER_GAME); if (tGS == 3 || tGS == 0) return 0d; else if (tGS == 1) return 0.1d * (double)(RELE_MAX_MOVE_COUNT_PER_GAME - mc); return 0.1d * (double)(-RELE_MAX_MOVE_COUNT_PER_GAME + mc); } public int[,][] InitReLeAgent(int[,][] pEvalPositionValues) { return GetInterpolatedProcessedValues(pEvalPositionValues); } private int[,][] GetInterpolatedProcessedValues(int[,][] pEvalPositionValues) { int[,][] processedValues = new int[33, 14][]; for (int i = 0; i < 32; i++) { int ip1 = i + 1; processedValues[ip1, 7] = processedValues[ip1, 0] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; processedValues[ip1, 8] = SwapArrayViewingSide(processedValues[ip1, 1] = MultiplyArraysWithVal(pEvalPositionValues[0, 0], pEvalPositionValues[1, 0], pEvalPositionValues[2, 0], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 9] = SwapArrayViewingSide(processedValues[ip1, 2] = MultiplyArraysWithVal(pEvalPositionValues[0, 1], pEvalPositionValues[1, 1], pEvalPositionValues[2, 1], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 10] = SwapArrayViewingSide(processedValues[ip1, 3] = MultiplyArraysWithVal(pEvalPositionValues[0, 2], pEvalPositionValues[1, 2], pEvalPositionValues[2, 2], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 11] = SwapArrayViewingSide(processedValues[ip1, 4] = MultiplyArraysWithVal(pEvalPositionValues[0, 3], pEvalPositionValues[1, 3], pEvalPositionValues[2, 3], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 12] = SwapArrayViewingSide(processedValues[ip1, 5] = MultiplyArraysWithVal(pEvalPositionValues[0, 4], pEvalPositionValues[1, 4], pEvalPositionValues[2, 4], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 13] = SwapArrayViewingSide(processedValues[ip1, 6] = MultiplyArraysWithVal(pEvalPositionValues[0, 5], pEvalPositionValues[1, 5], pEvalPositionValues[2, 5], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); } return processedValues; } private double[,][] GetInterpolatedProcessedValues(double[,][] pEvalPositionValues) { double[,][] processedValues = new double[33, 14][]; for (int i = 0; i < 32; i++) { int ip1 = i + 1; processedValues[ip1, 7] = processedValues[ip1, 0] = new double[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; processedValues[ip1, 8] = SwapArrayViewingSide(processedValues[ip1, 1] = MultiplyArraysWithVal(pEvalPositionValues[0, 0], pEvalPositionValues[1, 0], pEvalPositionValues[2, 0], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 9] = SwapArrayViewingSide(processedValues[ip1, 2] = MultiplyArraysWithVal(pEvalPositionValues[0, 1], pEvalPositionValues[1, 1], pEvalPositionValues[2, 1], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 10] = SwapArrayViewingSide(processedValues[ip1, 3] = MultiplyArraysWithVal(pEvalPositionValues[0, 2], pEvalPositionValues[1, 2], pEvalPositionValues[2, 2], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 11] = SwapArrayViewingSide(processedValues[ip1, 4] = MultiplyArraysWithVal(pEvalPositionValues[0, 3], pEvalPositionValues[1, 3], pEvalPositionValues[2, 3], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 12] = SwapArrayViewingSide(processedValues[ip1, 5] = MultiplyArraysWithVal(pEvalPositionValues[0, 4], pEvalPositionValues[1, 4], pEvalPositionValues[2, 4], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 13] = SwapArrayViewingSide(processedValues[ip1, 6] = MultiplyArraysWithVal(pEvalPositionValues[0, 5], pEvalPositionValues[1, 5], pEvalPositionValues[2, 5], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); } return processedValues; } private double[] MultiplyArraysWithVal(double[] pArr1, double[] pArr2, double[] pArr3, double pVal1, double pVal2, double pVal3) { int tL = pArr1.Length; double[] rArr = new double[tL]; for (int i = 0; i < tL; i++) { rArr[i] = pArr1[i] * pVal1 + pArr2[i] * pVal2 + pArr3[i] * pVal3; } return rArr; } private int[] MultiplyArraysWithVal(int[] pArr1, int[] pArr2, int[] pArr3, double pVal1, double pVal2, double pVal3) { int tL = pArr1.Length; int[] rArr = new int[tL]; for (int i = 0; i < tL; i++) { rArr[i] = (int)(pArr1[i] * pVal1 + pArr2[i] * pVal2 + pArr3[i] * pVal3); } return rArr; } private int[] SwapArrayViewingSideAndNegate(int[] pArr) { return new int[64] { -pArr[56], -pArr[57], -pArr[58], -pArr[59], -pArr[60], -pArr[61], -pArr[62], -pArr[63], -pArr[48], -pArr[49], -pArr[50], -pArr[51], -pArr[52], -pArr[53], -pArr[54], -pArr[55], -pArr[40], -pArr[41], -pArr[42], -pArr[43], -pArr[44], -pArr[45], -pArr[46], -pArr[47], -pArr[32], -pArr[33], -pArr[34], -pArr[35], -pArr[36], -pArr[37], -pArr[38], -pArr[39], -pArr[24], -pArr[25], -pArr[26], -pArr[27], -pArr[28], -pArr[29], -pArr[30], -pArr[31], -pArr[16], -pArr[17], -pArr[18], -pArr[19], -pArr[20], -pArr[21], -pArr[22], -pArr[23], -pArr[8], -pArr[9], -pArr[10], -pArr[11], -pArr[12], -pArr[13], -pArr[14], -pArr[15], -pArr[0], -pArr[1], -pArr[2], -pArr[3], -pArr[4], -pArr[5], -pArr[6], -pArr[7] }; } private int[] SwapArrayViewingSide(int[] pArr) { return new int[64] { pArr[56], pArr[57], pArr[58], pArr[59], pArr[60], pArr[61], pArr[62], pArr[63], pArr[48], pArr[49], pArr[50], pArr[51], pArr[52], pArr[53], pArr[54], pArr[55], pArr[40], pArr[41], pArr[42], pArr[43], pArr[44], pArr[45], pArr[46], pArr[47], pArr[32], pArr[33], pArr[34], pArr[35], pArr[36], pArr[37], pArr[38], pArr[39], pArr[24], pArr[25], pArr[26], pArr[27], pArr[28], pArr[29], pArr[30], pArr[31], pArr[16], pArr[17], pArr[18], pArr[19], pArr[20], pArr[21], pArr[22], pArr[23], pArr[8], pArr[9], pArr[10], pArr[11], pArr[12], pArr[13], pArr[14], pArr[15], pArr[0], pArr[1], pArr[2], pArr[3], pArr[4], pArr[5], pArr[6], pArr[7] }; } private double[] SwapArrayViewingSide(double[] pArr) { return new double[64] { pArr[56], pArr[57], pArr[58], pArr[59], pArr[60], pArr[61], pArr[62], pArr[63], pArr[48], pArr[49], pArr[50], pArr[51], pArr[52], pArr[53], pArr[54], pArr[55], pArr[40], pArr[41], pArr[42], pArr[43], pArr[44], pArr[45], pArr[46], pArr[47], pArr[32], pArr[33], pArr[34], pArr[35], pArr[36], pArr[37], pArr[38], pArr[39], pArr[24], pArr[25], pArr[26], pArr[27], pArr[28], pArr[29], pArr[30], pArr[31], pArr[16], pArr[17], pArr[18], pArr[19], pArr[20], pArr[21], pArr[22], pArr[23], pArr[8], pArr[9], pArr[10], pArr[11], pArr[12], pArr[13], pArr[14], pArr[15], pArr[0], pArr[1], pArr[2], pArr[3], pArr[4], pArr[5], pArr[6], pArr[7] }; } private int[,][] texelTuningRuntimeVals = new int[33, 14][]; private int[,][] texelTuningVals = new int[3, 6][]; private int[,] texelTuningAdjustIterations = new int[6, 64]; private int[][] texelTuningRuntimePositionalValsV2EG = new int[14][]; private int[][] texelTuningRuntimePositionalValsV2LG = new int[14][]; private int[] texelPieceEvaluationsV2EG = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[] texelPieceEvaluationsV2LG = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[] texelKingSafetyR1EvaluationsEG = new int[9]; private int[] texelKingSafetyR2EvaluationsEG = new int[17]; private int[] texelKingSafetyR1EvaluationsLG = new int[9]; private int[] texelKingSafetyR2EvaluationsLG = new int[17]; private int[] texelKingSafetySREvaluationsPT1EG = new int[12]; private int[] texelKingSafetySREvaluationsPT2EG = new int[12]; private int[] texelKingSafetySREvaluationsPT3EG = new int[12]; private int[] texelKingSafetySREvaluationsPT4EG = new int[12]; private int[] texelKingSafetySREvaluationsPT5EG = new int[12]; private int[] texelKingSafetySREvaluationsPT6EG = new int[12]; private int[] texelKingSafetySREvaluationsPT1LG = new int[12]; private int[] texelKingSafetySREvaluationsPT2LG = new int[12]; private int[] texelKingSafetySREvaluationsPT3LG = new int[12]; private int[] texelKingSafetySREvaluationsPT4LG = new int[12]; private int[] texelKingSafetySREvaluationsPT5LG = new int[12]; private int[] texelKingSafetySREvaluationsPT6LG = new int[12]; private int[,] texelMobilityStraightEG = new int[14, 15], texelMobilityStraightLG = new int[14, 15]; private int[,] texelMobilityDiagonalEG = new int[14, 14], texelMobilityDiagonalLG = new int[14, 14]; private int[] texelPieceEvaluations = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[] blackSidedSquares = new int[64] { 56, 57, 58, 59, 60, 61, 62, 63, 48, 49, 50, 51, 52, 53, 54, 55, 40, 41, 42, 43, 44, 45, 46, 47, 32, 33, 34, 35, 36, 37, 38, 39, 24, 25, 26, 27, 28, 29, 30, 31, 16, 17, 18, 19, 20, 21, 22, 23, 08, 09, 10, 11, 12, 13, 14, 15, 00, 01, 02, 03, 04, 05, 06, 07 }; private int[,] T_Pawns = new int[3, 64] { { 0, 0, 0, 0, 0, 0, 0, 0, 98, 134, 61, 95, 68, 126, 34, -11, -6, 7, 26, 31, 65, 56, 25, -20, -14, 13, 6, 21, 23, 12, 17, -23, -27, -2, -5, 12, 17, 6, 10, -25, -26, -4, -4, -10, 3, 3, 33, -12, -35, -1, -20, -23, -15, 24, 38, -22, 0, 0, 0, 0, 0, 0, 0, 0, } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { 0, 0, 0, 0, 0, 0, 0, 0, 178, 173, 158, 134, 147, 132, 165, 187, 94, 100, 85, 67, 56, 53, 82, 84, 32, 24, 13, 5, -2, 4, 17, 17, 13, 9, -3, -7, -7, -8, 3, -1, 4, 7, -6, 1, 0, -5, -1, -8, 13, 8, 8, 10, 13, 0, 2, -7, 0, 0, 0, 0, 0, 0, 0, 0, } }; private int[,] T_Knights = new int[3, 64] { { -167, -89, -34, -49, 61, -97, -15, -107, -73, -41, 72, 36, 23, 62, 7, -17, -47, 60, 37, 65, 84, 129, 73, 44, -9, 17, 19, 53, 37, 69, 18, 22, -13, 4, 16, 13, 28, 19, 21, -8, -23, -9, 12, 10, 19, 17, 25, -16, -29, -53, -12, -3, -1, 18, -14, -19, -105, -21, -58, -33, -17, -28, -19, -23 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -58, -38, -13, -28, -31, -27, -63, -99, -25, -8, -25, -2, -9, -25, -24, -52, -24, -20, 10, 9, -1, -9, -19, -41, -17, 3, 22, 22, 22, 11, 8, -18, -18, -6, 16, 25, 16, 17, 4, -18, -23, -3, -1, 15, 10, -3, -20, -22, -42, -20, -10, -5, -2, -20, -23, -44, -29, -51, -23, -15, -22, -18, -50, -64 } }; private int[,] T_Bishops = new int[3, 64] { { -29, 4, -82, -37, -25, -42, 7, -8, -26, 16, -18, -13, 30, 59, 18, -47, -16, 37, 43, 40, 35, 50, 37, -2, -4, 5, 19, 50, 37, 37, 7, -2, -6, 13, 13, 26, 34, 12, 10, 4, 0, 15, 15, 15, 14, 27, 18, 10, 4, 15, 16, 0, 7, 21, 33, 1, -33, -3, -14, -21, -13, -12, -39, -21 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -14, -21, -11, -8, -7, -9, -17, -24, -8, -4, 7, -12, -3, -13, -4, -14, 2, -8, 0, -1, -2, 6, 0, 4, -3, 9, 12, 9, 14, 10, 3, 2, -6, 3, 13, 19, 7, 10, -3, -9, -12, -3, 8, 10, 13, 3, -7, -15, -14, -18, -7, -1, 4, -9, -15, -27, -23, -9, -23, -5, -9, -16, -5, -17 } }; private int[,] T_Rooks = new int[3, 64] { { 32, 42, 32, 51, 63, 9, 31, 43, 27, 32, 58, 62, 80, 67, 26, 44, -5, 19, 26, 36, 17, 45, 61, 16, -24, -11, 7, 26, 24, 35, -8, -20, -36, -26, -12, -1, 9, -7, 6, -23, -45, -25, -16, -17, 3, 0, -5, -33, -44, -16, -20, -9, -1, 11, -6, -71, -19, -13, 1, 17, 16, 7, -37, -26 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { 13, 10, 18, 15, 12, 12, 8, 5, 11, 13, 13, 11, -3, 3, 8, 3, 7, 7, 7, 5, 4, -3, -5, -3, 4, 3, 13, 1, 2, 1, -1, 2, 3, 5, 8, 4, -5, -6, -8, -11, -4, 0, -5, -1, -7, -12, -8, -16, -6, -6, 0, 2, -9, -9, -11, -3, -9, 2, 3, -1, -5, -13, 4, -20 } }; private int[,] T_Queens = new int[3, 64] { { -28, 0, 29, 12, 59, 44, 43, 45, -24, -39, -5, 1, -16, 57, 28, 54, -13, -17, 7, 8, 29, 56, 47, 57, -27, -27, -16, -16, -1, 17, -2, 1, -9, -26, -9, -10, -2, -4, 3, -3, -14, 2, -11, -2, -5, 2, 14, 5, -35, -8, 11, 2, 8, 15, -3, 1, -1, -18, -9, 10, -15, -25, -31, -50 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -9, 22, 22, 27, 27, 19, 10, 20, -17, 20, 32, 41, 58, 25, 30, 0, -20, 6, 9, 49, 47, 35, 19, 9, 3, 22, 24, 45, 57, 40, 57, 36, -18, 28, 19, 47, 31, 34, 39, 23, -16, -27, 15, 6, 9, 17, 10, 5, -22, -23, -30, -16, -16, -23, -36, -32, -33, -28, -22, -43, -5, -32, -20, -41 } }; private int[,] T_Kings = new int[3, 64] { { -65, 23, 16, -15, -56, -34, 2, 13, 29, -1, -20, -7, -8, -4, -38, -29, -9, 24, 2, -16, -20, 6, 22, -22, -17, -20, -12, -27, -30, -25, -14, -36, -49, -1, -27, -39, -46, -44, -33, -51, -14, -14, -22, -46, -44, -30, -15, -27, 1, 7, -8, -64, -43, -16, 9, 8, -15, 36, 12, -54, 8, -28, 24, 14 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -74, -35, -18, -18, -11, 15, 4, -17, -12, 17, 14, 17, 17, 38, 23, 11, 10, 17, 23, 15, 20, 45, 44, 13, -8, 22, 24, 27, 26, 33, 26, 3, -18, -4, 21, 24, 27, 23, 9, -11, -19, -3, 11, 21, 23, 16, 7, -9, -27, -11, 4, 13, 14, 4, -5, -17, -53, -34, -21, -11, -28, -14, -24, -43 } }; private int[] paramsLowerLimits = new int[5] { -10000, -10000, -10000, -10000, -10000 }; private int[] paramsUpperLimits = new int[5] { 10000, 10000, 10000, 10000, 10000 }; private List<TLM_ChessGame> threadDataset; private int threadFrom, threadTo; private int[] threadParams; private int customThreadID = 0; private ulong ulAllThreadIDsUnfinished = 0; private double lastCostVal = 0d; private double sumCostVals = 0d; private int costCalculations = 0; private readonly string[] TEXELPRINT_GAMEPARTS = new string[3] { "Early Game: ", "Mid Game: ", "Late Game: "}; private readonly string[] TEXELPRINT_PIECES = new string[6] { "Bauer: ", "Springer: ", "Lufer: ", "Turm: ", "Dame: ", "Knig: "}; private double[] earlyGameMultipliers = new double[33]; private double[] middleGameMultipliers = new double[33]; private double[] lateGameMultipliers = new double[33]; private int[] pieceTypeGameProgressImpact = new int[14] { 0, 0, 1, 1, 2, 4, 0, 0, 0, 1, 1, 2, 4, 0 }; private void PrecalculateMultipliers() { if (BOARD_MANAGER_ID == ENGINE_VALS.PARALLEL_BOARDS - 1) SNAPSHOT_WRITLINE_REPLACEMENT(); for (int i = 0; i < 25; i++) { earlyGameMultipliers[i] = EGMultiplierFunction(i); lateGameMultipliers[i] = LGMultiplierFunction(i); if (BOARD_MANAGER_ID == ENGINE_VALS.PARALLEL_BOARDS - 1) SNAPSHOT_WRITLINE_REPLACEMENT("[" + i + "] "+ earlyGameMultipliers[i] + " | "+ middleGameMultipliers[i] + " | "+ lateGameMultipliers[i]); } } private double MultiplierFunction(double pVal, double pXShift) { double d = Math.Exp(1d /6d * (pVal - pXShift)); return 5 * (d /Math.Pow(d + 1, 2d)); } private double EGMultiplierFunction(double pVal) { return Math.Clamp(1 /16d * (pVal - 4d), 0d, 1d); } private double LGMultiplierFunction(double pVal) { return Math.Clamp(1 /-16d * (pVal - 4d) + 1d, 0d, 1d); } private double EGMultiplierFunction2(double pVal) { return Math.Clamp(1 /32d * pVal, 0d, 1d); } private double LGMultiplierFunction2(double pVal) { return Math.Clamp(1 /-32d * pVal + 1d, 0d, 1d); } private void TuneWithTxtFile(string pTXTName) { List<TLM_ChessGame> gameDataset = new List<TLM_ChessGame>(); string tPath = PathManager.GetTXTPath(pTXTName); string[] tStrs = File.ReadAllLines(tPath); List<string> tGames = new List<string>(); foreach (string s in tStrs) if (s.Contains(';') && s.Replace(" ", "") != "") tGames.Add(s); foreach (string s in tGames) { TLM_ChessGame tGame = CGFF.GetGame(s); LoadFenString(tGame.startFen); foreach (int hMove in tGame.hashedMoves) { List<Move> moveOptionList = new List<Move>(); GetLegalMoves(ref moveOptionList); int tL = moveOptionList.Count; for (int j = 0; j < tL; j++) { Move tMove = moveOptionList[j]; if (tMove.moveHash == hMove) { tGame.actualMoves.Add(tMove); PlainMakeMove(tMove); tL = -1; break; } } if (tL != -1) break; } gameDataset.Add(tGame); } SNAPSHOT_WRITLINE_REPLACEMENT("[TLM TEXEL TUNER] " + tGames.Count + " Games Loaded In!"); BOT_MAIN.curTEXELPARAMS = new int[TEXEL_PARAMS]; BOT_MAIN.ParallelTexelTuning(gameDataset); } private void LoadBestTexelParamsIn() { int[] ttt = new int[778]; ttt[0] = 82; ttt[1] = 341; ttt[2] = 416; ttt[3] = 470; ttt[4] = 1106; ttt[5] = 102; ttt[6] = 302; ttt[7] = 304; ttt[8] = 518; ttt[9] = 960; SetupTexelEvaluationParams(ttt); } private void SetupTexelEvaluationParams(int[] pParams) { texelPieceEvaluationsV2EG[8] = -(texelPieceEvaluationsV2EG[1] = pParams[0]); texelPieceEvaluationsV2EG[9] = -(texelPieceEvaluationsV2EG[2] = pParams[1]); texelPieceEvaluationsV2EG[10] = -(texelPieceEvaluationsV2EG[3] = pParams[2]); texelPieceEvaluationsV2EG[11] = -(texelPieceEvaluationsV2EG[4] = pParams[3]); texelPieceEvaluationsV2EG[12] = -(texelPieceEvaluationsV2EG[5] = pParams[4]); texelPieceEvaluationsV2LG[8] = -(texelPieceEvaluationsV2LG[1] = pParams[5]); texelPieceEvaluationsV2LG[9] = -(texelPieceEvaluationsV2LG[2] = pParams[6]); texelPieceEvaluationsV2LG[10] = -(texelPieceEvaluationsV2LG[3] = pParams[7]); texelPieceEvaluationsV2LG[11] = -(texelPieceEvaluationsV2LG[4] = pParams[8]); texelPieceEvaluationsV2LG[12] = -(texelPieceEvaluationsV2LG[5] = pParams[9]); int c = 10; for (int p = 1; p < 7; p++) { for (int s = 0; s < 64; s++) { texelTuningRuntimePositionalValsV2EG[p + 7][blackSidedSquares[s]] = -(texelTuningRuntimePositionalValsV2EG[p][s] = pParams[c++]); texelTuningRuntimePositionalValsV2LG[p + 7][blackSidedSquares[s]] = -(texelTuningRuntimePositionalValsV2LG[p][s] = pParams[c++]); } } return; for (int p = 2; p < 7; p++) { for (int a = 0; a < 15; a++) { if (a != 14) { texelMobilityDiagonalEG[p + 7, a] = -(texelMobilityDiagonalEG[p, a] = pParams[c++]); texelMobilityDiagonalLG[p + 7, a] = -(texelMobilityDiagonalLG[p, a] = pParams[c++]); } texelMobilityStraightEG[p + 7, a] = -(texelMobilityStraightEG[p, a] = pParams[c++]); texelMobilityStraightLG[p + 7, a] = -(texelMobilityStraightLG[p, a] = pParams[c++]); } } for (int i = 0; i < 12; i++) { texelKingSafetySREvaluationsPT1EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT2EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT3EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT4EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT5EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT6EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT1LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT2LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT3LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT4LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT5LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT6LG[i] = pParams[c++]; } } private void PrintDefinedTexelParams(int[] pParams) { int c = 0; for (int t = 0; t < 3; t++) { SNAPSHOT_WRITLINE_REPLACEMENT(TEXELPRINT_GAMEPARTS[t]); for (int p = 0; p < 6; p++) { SNAPSHOT_WRITLINE_REPLACEMENT(TEXELPRINT_PIECES[p]); texelTuningVals[t, p] = new int[64]; for (int s = 0; s < 64; s++) { if (s % 8 == 0 && s != 0) SNAPSHOT_WRITLINE_REPLACEMENT(); SNAPSHOT_WRITLINE_REPLACEMENT((texelTuningVals[t, p][s] = pParams[c++]) + ", "); } SNAPSHOT_WRITLINE_REPLACEMENT(); } } piecePositionEvals = GetInterpolatedProcessedValues(texelTuningVals); } public void TLMTuning(List<TLM_ChessGame> pDataset) { int tGameDataSetLen = pDataset.Count; int[,][] tRatio = new int[33, 6][]; int[,][] tTotalMoves = new int[33, 6][]; double[,][] tSummedRatios = new double[33, 6][]; double[,][] tSummedDataAmount = new double[33, 6][]; double[,][] tTuningResults = new double[33, 6][]; for (int t = 1; t < 33; t++) { for (int p = 0; p < 6; p++) { tRatio[t, p] = new int[64]; tTotalMoves[t, p] = new int[64]; tSummedRatios[t, p] = new double[64]; tSummedDataAmount[t, p] = new double[64]; tTuningResults[t, p] = new double[64]; } } for (int j = 0; j < tGameDataSetLen; j++) { TLM_ChessGame tGame = pDataset[j]; int tGR = tGame.gameResult - 1; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count - 5; for (int i = 0; i < tL; i++) { if (tGame.isMoveNonTactical[i]) { int tPieceAmount = ULONG_OPERATIONS.CountBits(allPieceBitboard); for (int s = 0; s < 64; s++) { int tPT = pieceTypeArray[s] - 1; if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, s)) { tTotalMoves[tPieceAmount, tPT][s]++; tRatio[tPieceAmount, tPT][s] += tGR; } else if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, s)) { int b = blackSidedSquares[s]; tTotalMoves[tPieceAmount, tPT][b]++; tRatio[tPieceAmount, tPT][b] += tGR; } } } PlainMakeMove(tGame.actualMoves[i]); } } double[,] allMultipliers = new double[33, 33]; for (int sh = 0; sh < 33; sh++) { for (int i = 0; i < 33; i++) { allMultipliers[sh, i] = MultiplierFunction(i, sh); } } for (int t = 1; t < 33; t++) { for (int p = 0; p < 6; p++) { for (int s = 0; s < 64; s++) { for (int t2 = 1; t2 < 33; t2++) { double cmult = allMultipliers[t, t2]; tSummedRatios[t, p][s] += tRatio[t2, p][s] * cmult; tSummedDataAmount[t, p][s] += tTotalMoves[t2, p][s] * cmult; } tTuningResults[t, p][s] = TTT(tSummedRatios[t, p][s], tSummedDataAmount[t, p][s]); } } } int c = 0; int[] tparams = new int[1152]; for (int t = 1; t < 33; t += 15) { if (t == 31) t = 32; SNAPSHOT_WRITLINE_REPLACEMENT("PieceCount = " + t + ": "); for (int p = 0; p < 6; p++) { SNAPSHOT_WRITLINE_REPLACEMENT(TEXELPRINT_PIECES[p]); for (int s = 0; s < 64; s++) { if (s % 8 == 0 && s != 0) SNAPSHOT_WRITLINE_REPLACEMENT(); SNAPSHOT_WRITLINE_REPLACEMENT((tparams[c++] = (int)(tTuningResults[t, p][s] * 100)).ToString().Replace(",", ".") + "("+ (int)tSummedDataAmount[t, p][s] + ")"+ ", "); } SNAPSHOT_WRITLINE_REPLACEMENT(); } } string tS = "PARAMS: {"; for (int i = 0; i < tparams.Length; i++) tS += tparams[i] + ","; tS = tS.Substring(0, tS.Length - 1) + "}\n"; SNAPSHOT_WRITLINE_REPLACEMENT(tS); TexelTuning(pDataset, tparams); } private double TTT(double d1, double d2) { if (d2 == 0) return 0; return d1 /d2; } public void TexelTuning(List<TLM_ChessGame> pDataset, int[] pCurBestParams) { Stopwatch sw = Stopwatch.StartNew(); string tPath = PathManager.GetTXTPath("OTHER/TEXEL_TUNING"); int paramCount = pCurBestParams.Length; double bestAvrgCost = CalculateAverageTexelCost(pDataset, pCurBestParams); SNAPSHOT_WRITLINE_REPLACEMENT("CUR PARAMS COST: " + bestAvrgCost); int packetSize = Math.Clamp(paramCount /ENGINE_VALS.CPU_CORES, 1, 100000); paramsLowerLimits = new int[paramCount]; paramsUpperLimits = new int[paramCount]; for (int i = 0; i < paramCount; i++) { int lim = i < 10 ? 100000 : 200; paramsLowerLimits[i] = -lim; paramsUpperLimits[i] = lim; } SNAPSHOT_WRITLINE_REPLACEMENT("PARAM-COUNT: " + paramCount); SNAPSHOT_WRITLINE_REPLACEMENT("PACKET-SIZE: " + packetSize); while (packetSize <= paramCount) { BOT_MAIN.TEXELfinished = 0; int lM = 0, tC = 0; ulong tUL = 0ul; for (int m = packetSize; lM < paramCount; m += packetSize) { if (m > paramCount) m = paramCount; tUL = ULONG_OPERATIONS.SetBitToOne(tUL, ++tC); lM = m; } tC = lM = 0; for (int m = packetSize; lM < paramCount; m += packetSize) { if (m > paramCount) m = paramCount; tC++; BOT_MAIN.boardManagers[tC].SetPlayTexelVals(pDataset, lM, m, pCurBestParams, paramsLowerLimits, paramsUpperLimits, tC, tUL); ThreadPool.QueueUserWorkItem(new WaitCallback(BOT_MAIN.boardManagers[tC].TexelTuningThreadedPackage)); lM = m; } packetSize = paramCount + 1; int tmod = 0; while (tC != BOT_MAIN.TEXELfinished) { if (++tmod % 20 == 0) { WriteTexelParamsToTXT(tPath, BOT_MAIN.curTEXELPARAMS); SNAPSHOT_WRITLINE_REPLACEMENT(CalculateAverageTexelCost(pDataset, BOT_MAIN.curTEXELPARAMS) + " | "+ BOT_MAIN.TEXELadjustmentsmade); SNAPSHOT_WRITLINE_REPLACEMENT(ULONG_OPERATIONS.GetBitVisualization(BOT_MAIN.TEXELfinishedwithoutimpovement)); } Thread.Sleep(100); } SNAPSHOT_WRITLINE_REPLACEMENT("One Thread Generation FINISHED! :) :) :)"); pCurBestParams = BOT_MAIN.curTEXELPARAMS; } sw.Stop(); WriteTexelParamsToTXT(tPath, BOT_MAIN.curTEXELPARAMS); SNAPSHOT_WRITLINE_REPLACEMENT("END COST: " + CalculateAverageTexelCost(pDataset, BOT_MAIN.curTEXELPARAMS)); SNAPSHOT_WRITLINE_REPLACEMENT(BOT_MAIN.TEXELadjustmentsmade); SNAPSHOT_WRITLINE_REPLACEMENT(sw.ElapsedMilliseconds); } public void TexelTuningThreadedPackage(object obj) { SNAPSHOT_WRITLINE_REPLACEMENT("Started CThreadID [" + customThreadID + "] which is handling Params ["+ threadFrom + "] - ["+ threadTo + "]"); bool firstIter = true; do { double bestAvrgCost = CalculateAverageTexelCost(threadDataset, threadParams); int adjust_val = firstIter ? 512 : 8; do { adjust_val /= 2; bool improvedAvrgCost = true; while (improvedAvrgCost) { improvedAvrgCost = false; for (int i = threadFrom; i < threadTo; i++) { bool improvedWithThisParam = true; int tadjustval = adjust_val; bool lastTimeMaximized = false, lastTimeMinimized = false; while (improvedWithThisParam) { improvedWithThisParam = false; int[] curParams = (int[])threadParams.Clone(); int paramBefore = curParams[i]; curParams[i] = Math.Clamp(paramBefore + adjust_val, paramsLowerLimits[i], paramsUpperLimits[i]); double curAvrgCost = CalculateAverageTexelCost(threadDataset, curParams); if (curAvrgCost < bestAvrgCost) { improvedAvrgCost = true; improvedWithThisParam = true; SNAPSHOT_WRITLINE_REPLACEMENT("Improved Param [" + i + "] at CThreadID ["+ customThreadID + "]: +"+ adjust_val + " ("+ GetDoublePrecentageString(bestAvrgCost - curAvrgCost) + ")"); bestAvrgCost = curAvrgCost; threadParams = curParams; BOT_MAIN.TEXELadjustmentsmade++; BOT_MAIN.TEXELfinishedwithoutimpovement = ulAllThreadIDsUnfinished; if (lastTimeMaximized) { adjust_val *= 4; lastTimeMaximized = false; } else lastTimeMaximized = true; lastTimeMinimized = false; } else { curParams[i] = Math.Clamp(paramBefore - adjust_val, paramsLowerLimits[i], paramsUpperLimits[i]); curAvrgCost = CalculateAverageTexelCost(threadDataset, curParams); if (curAvrgCost < bestAvrgCost) { improvedAvrgCost = true; improvedWithThisParam = true; SNAPSHOT_WRITLINE_REPLACEMENT("Improved Param [" + i + "] at CThreadID ["+ customThreadID + "]: -"+ adjust_val + " ("+ GetDoublePrecentageString(bestAvrgCost - curAvrgCost) + ")"); bestAvrgCost = curAvrgCost; threadParams = curParams; BOT_MAIN.TEXELadjustmentsmade++; BOT_MAIN.TEXELfinishedwithoutimpovement = ulAllThreadIDsUnfinished; if (lastTimeMinimized) { adjust_val *= 4; lastTimeMinimized = false; } else lastTimeMinimized = true; lastTimeMaximized = false; } } if (adjust_val != 1) adjust_val /= 2; for (int j = threadFrom; j < threadTo; j++) { BOT_MAIN.curTEXELPARAMS[j] = threadParams[j]; } threadParams = (int[])BOT_MAIN.curTEXELPARAMS.Clone(); bestAvrgCost = CalculateAverageTexelCost(threadDataset, threadParams); } adjust_val = tadjustval; } } } while (adjust_val != 1); BOT_MAIN.TEXELfinishedwithoutimpovement = ULONG_OPERATIONS.SetBitToZero(BOT_MAIN.TEXELfinishedwithoutimpovement, customThreadID); SNAPSHOT_WRITLINE_REPLACEMENT("FULLY FINISHED " + customThreadID + ". IMPROVEMENT THREAD PACKAGE CYCLE"); firstIter = false; } while (BOT_MAIN.TEXELfinishedwithoutimpovement != 0); BOT_MAIN.TEXELfinished++; } private void WriteTexelParamsToTXT(string pPath, int[] pParams) { try { string tS = "PARAMS: {"; for (int i = 0; i < pParams.Length; i++) tS += pParams[i] + ","; tS = tS.Substring(0, tS.Length - 1) + "}\n"; File.AppendAllText(pPath, tS); } catch { SNAPSHOT_WRITLINE_REPLACEMENT("Mal wieder TXT zu lange gebraucht um zu aktualisieren."); } } private double costSum = 0d; private int texelCostMovesEvaluated = 0; private double CalculateAverageTexelCost(List<TLM_ChessGame> tDataset, int[] pParams, bool pFullCost = true) { costSum = 0d; texelCostMovesEvaluated = 0; SetupTexelEvaluationParams(pParams); int tGameDataSetLen = tDataset.Count; int start = 0, end = tGameDataSetLen; if (!pFullCost) { end = (start = globalRandom.Next(0, end - 256)) + 256; } for (int j = start; j < end; j++) { TLM_ChessGame tGame = tDataset[j]; double tGR = tGame.gameResult; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count - 5; texelCostMovesEvaluated += tL; for (int i = 0; i < tL; i++) { costSum += TexelCost(tGR - TexelTuningSigmoid(TexelEvaluate())); PlainMakeMove(tGame.actualMoves[i]); } } return costSum /texelCostMovesEvaluated; } private double CalculateAverageTexelCostThreadedVersionLEGACYDOESNTWORK(List<TLM_ChessGame> tDataset, int[] pParams) { Stopwatch sw = Stopwatch.StartNew(); BOT_MAIN.TEXELcostSum = 0d; BOT_MAIN.TEXELfinished = 0; BOT_MAIN.TEXELcostMovesEvaluated = 0; int tGameDataSetLen = tDataset.Count; int gamesPerThread = tGameDataSetLen /ENGINE_VALS.CPU_CORES; for (int i = 0; i < ENGINE_VALS.CPU_CORES - 1; i++) { } for (int i = 0; i < ENGINE_VALS.CPU_CORES - 1; i++) { } while (BOT_MAIN.TEXELfinished != ENGINE_VALS.CPU_CORES) Thread.Sleep(1); sw.Stop(); return BOT_MAIN.TEXELcostSum /BOT_MAIN.TEXELcostMovesEvaluated; } public void SetPlayThroughVals(List<TLM_ChessGame> pDataset, int pFrom, int pTo) { threadDataset = pDataset; threadFrom = pFrom; threadTo = pTo; } public void SetPlayTexelVals(List<TLM_ChessGame> pDataset, int pFrom, int pTo, int[] pTexelParams, int[] pLowerLimits, int[] pUpperLimits, int pThreadID, ulong pUL) { threadDataset = pDataset; threadFrom = pFrom; threadTo = pTo; threadParams = pTexelParams; paramsLowerLimits = pLowerLimits; paramsUpperLimits = pUpperLimits; customThreadID = pThreadID; ulAllThreadIDsUnfinished = pUL; } public void PlayThroughSetOfGames(object obj) { SNAPSHOT_WRITLINE_REPLACEMENT(threadFrom + "->"+ threadTo); int sortedOut = 0; for (int j = threadFrom; j < threadTo; j++) { TLM_ChessGame tGame = threadDataset[j]; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count; for (int i = 0; i < tL; i++) { int tQuietEval = isWhiteToMove ? QuiescenceWhite(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, 0, PreMinimaxCheckCheckWhite(), NULL_MOVE) : QuiescenceBlack(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, 0, PreMinimaxCheckCheckBlack(), NULL_MOVE); bool tB; tGame.isMoveNonTactical.Add(tB = (Evaluate() == tQuietEval && i > 4)); if (!tB) sortedOut++; PlainMakeMove(tGame.actualMoves[i]); } } BOT_MAIN.TEXELsortedout += sortedOut; BOT_MAIN.TEXELfinished++; } public void CalculateAverageTexelCostThreadFunction(object obj) { SetupTexelEvaluationParams(threadParams); double d = 0d; for (int j = threadFrom; j < threadTo; j++) { TLM_ChessGame tGame = threadDataset[j]; double tGR = tGame.gameResult; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count - 5; BOT_MAIN.TEXELcostMovesEvaluated += tL; for (int i = 0; i < tL; i++) { d += TexelCost(tGR - TexelTuningSigmoid(TexelEvaluate())); PlainMakeMove(tGame.actualMoves[i]); } } BOT_MAIN.TEXELcostSum += d; BOT_MAIN.TEXELfinished++; } private void ConsoleWriteLineTuneArray<T>(T[,][] pArr) { for (int j = 0; j < 3; j++) { SNAPSHOT_WRITLINE_REPLACEMENT("{"); for (int k = 0; k < 6; k++) { SNAPSHOT_WRITLINE_REPLACEMENT("{"); for (int s = 0; s < 64; s++) SNAPSHOT_WRITLINE_REPLACEMENT(pArr[j, k][s] + ", "); SNAPSHOT_WRITLINE_REPLACEMENT("\n}"); } SNAPSHOT_WRITLINE_REPLACEMENT("}"); } } private void Tune(string pGameCGFF, double pLearningRate) { TLM_ChessGame tGame = CGFF.GetGame(pGameCGFF); LoadFenString(tGame.startFen); double tDGameResult = tGame.gameResult; foreach (int hMove in tGame.hashedMoves) { Tune(tDGameResult, pLearningRate); List<Move> moveOptionList = new List<Move>(); GetLegalMoves(ref moveOptionList); int tL = moveOptionList.Count; for (int i = 0; i < tL; i++) { Move tMove = moveOptionList[i]; if (tMove.moveHash == hMove) { PlainMakeMove(tMove); tL = -1; break; } } if (tL != -1) break; } } private void Tune(double pGameResult, double pLearningRate) { int tPC = ULONG_OPERATIONS.CountBits(allPieceBitboard); double oneThroughPieceCount = 1d /tPC; double egMult = earlyGameMultipliers[tPC], mgMult = middleGameMultipliers[tPC], lgMult = lateGameMultipliers[tPC]; double tTexelResult = TexelEvaluateF(); double tSigmoidedTexelResult = TexelSigmoid(tTexelResult); double tDif = tSigmoidedTexelResult - pGameResult; double tM = oneThroughPieceCount * TexelCostDerivative(tDif) * TexelSigmoidDerivative(tTexelResult) * pLearningRate; sumCostVals += lastCostVal = TexelCost(tDif); costCalculations++; for (int i = 0; i < 64; i++) { if (ULONG_OPERATIONS.IsBitZero(allPieceBitboard, i)) continue; int tPT = pieceTypeArray[i] - 1, tI = i; if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, i)) tI = blackSidedSquares[i]; texelTuningAdjustIterations[tPT, tI]++; } } private double TexelEvaluateF() { texelTuningRuntimeVals = GetInterpolatedProcessedValues(texelTuningVals); return TexelEvaluate(); } private int TexelEvaluate() { int tEvalEG = 0, tEvalLG = 0, tProgress = 0; ulong[] attkULs = new ulong[14]; for (int p = 0; p < 64; p++) { if (((int)(allPieceBitboard >> p) & 1) == 0) continue; int aPT = pieceTypeArray[p], tPT = aPT + 7 * ((int)(blackPieceBitboard >> p) & 1); tEvalEG += texelTuningRuntimePositionalValsV2EG[tPT][p] + texelPieceEvaluationsV2EG[tPT]; tEvalLG += texelTuningRuntimePositionalValsV2LG[tPT][p] + texelPieceEvaluationsV2LG[tPT]; tProgress += pieceTypeGameProgressImpact[tPT]; } if (tProgress > 24) tProgress = 24; return (int)(earlyGameMultipliers[tProgress] * tEvalEG + lateGameMultipliers[tProgress] * tEvalLG); } private const double TexelK = 0.2; private double TexelTuningSigmoid(double pVal) { return 2d /(1 + Math.Pow(10, -TexelK * pVal /400)); } private double TexelSigmoid(double pVal) { return 2d /(Math.Exp(-0.04d * pVal) + 1d); } private double TexelSigmoidDerivative(double pVal) { double d = Math.Exp(-0.04d * pVal); return 2d * d /(25d * (d + 1d) * (d + 1d)); } private double TexelCost(double pVal) { return pVal * pVal; } private double TexelCostDerivative(double pVal) { return 2 * pVal; } private char[] fenPieces = new char[7] { 'z', 'p', 'n', 'b', 'r', 'q', 'k' }; private string[] squareNames = new string[64] { "a1", "b1", "c1", "d1", "e1", "f1", "g1", "h1", "a2", "b2", "c2", "d2", "e2", "f2", "g2", "h2", "a3", "b3", "c3", "d3", "e3", "f3", "g3", "h3", "a4", "b4", "c4", "d4", "e4", "f4", "g4", "h4", "a5", "b5", "c5", "d5", "e5", "f5", "g5", "h5", "a6", "b6", "c6", "d6", "e6", "f6", "g6", "h6", "a7", "b7", "c7", "d7", "e7", "f7", "g7", "h7", "a8", "b8", "c8", "d8", "e8", "f8", "g8", "h8"}; public string CreateFenString() { string rFEN = ""; for (int i = 7; i >= 0; i--) { int t = 0; for (int j = 0; j < 8; j++) { int sq = i * 8 + j; if (pieceTypeArray[sq] != 0) { if (t != 0) rFEN += t; t = 0; } if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, sq)) { switch (pieceTypeArray[sq]) { case 0: t++; SNAPSHOT_WRITLINE_REPLACEMENT("???"); break; case 1: rFEN += 'P'; break; case 2: rFEN += 'N'; break; case 3: rFEN += 'B'; break; case 4: rFEN += 'R'; break; case 5: rFEN += 'Q'; break; case 6: rFEN += 'K'; break; } } else { switch (pieceTypeArray[sq]) { case 0: t++; break; case 1: rFEN += 'p'; break; case 2: rFEN += 'n'; break; case 3: rFEN += 'b'; break; case 4: rFEN += 'r'; break; case 5: rFEN += 'q'; break; case 6: rFEN += 'k'; break; } } } if (t != 0) rFEN += t; if (i != 0) rFEN += "/"; } rFEN += (isWhiteToMove ? " w": " b"); rFEN += (whiteCastleRightKingSide ? " K": " "); rFEN += (whiteCastleRightQueenSide ? "Q": ""); rFEN += (blackCastleRightKingSide ? "k": ""); rFEN += (blackCastleRightQueenSide ? "q": ""); if (!whiteCastleRightKingSide && !whiteCastleRightQueenSide && !blackCastleRightKingSide && !blackCastleRightQueenSide) rFEN += "-"; if (enPassantSquare < 64) rFEN += " "+ squareNames[enPassantSquare] + " "; else rFEN += " - "; return rFEN + fiftyMoveRuleCounter + " "+ ((happenedHalfMoves - happenedHalfMoves % 2) /2); } public void LoadFenString(string fenStr) { lastMadeMove = NULL_MOVE; zobristKey = 0ul; whitePieceBitboard = blackPieceBitboard = allPieceBitboard = 0ul; for (int i = 0; i < 64; i++) pieceTypeArray[i] = 0; string[] spaceSpl = fenStr.Split(' '); string[] rowSpl = spaceSpl[0].Split('/'); string epstr = spaceSpl[3]; if (epstr == "-") enPassantSquare = 65; else enPassantSquare = (epstr[0] - 'a') + 8 * (epstr[1] - '1'); isWhiteToMove = true; if (spaceSpl[1] == "b") isWhiteToMove = false; if (!isWhiteToMove) zobristKey ^= blackTurnHash; string crstr = spaceSpl[2]; whiteCastleRightKingSide = whiteCastleRightQueenSide = blackCastleRightKingSide = blackCastleRightQueenSide = false; int crStrL = crstr.Length; for (int i = 0; i < crStrL; i++) { switch (crstr[i]) { case 'K': whiteCastleRightKingSide = true; break; case 'Q': whiteCastleRightQueenSide = true; break; case 'k': blackCastleRightKingSide = true; break; case 'q': blackCastleRightQueenSide = true; break; } } fiftyMoveRuleCounter = Convert.ToInt32(spaceSpl[4]); happenedHalfMoves = Convert.ToInt32(spaceSpl[5]) * 2; if (!isWhiteToMove) happenedHalfMoves++; int tSq = 0; for (int i = rowSpl.Length; i-- > 0;) { string tStr = rowSpl[i]; int tStrLen = tStr.Length; for (int c = 0; c < tStrLen; c++) { char tChar = tStr[c]; if (Char.IsDigit(tChar)) tSq += tChar - '0'; else { bool tCol = Char.IsLower(tChar); if (tCol) blackPieceBitboard = ULONG_OPERATIONS.SetBitToOne(blackPieceBitboard, tSq); else whitePieceBitboard = ULONG_OPERATIONS.SetBitToOne(whitePieceBitboard, tSq); if (tChar == 'k') blackKingSquare = tSq; else if (tChar == 'K') whiteKingSquare = tSq; pieceTypeArray[tSq] = Array.IndexOf(fenPieces, Char.ToLower(tChar)); if (tCol) zobristKey ^= pieceHashesBlack[tSq, pieceTypeArray[tSq]]; else zobristKey ^= pieceHashesWhite[tSq, pieceTypeArray[tSq]]; tSq++; } } } if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; zobristKey ^= enPassantSquareHashes[enPassantSquare]; allPieceBitboard = whitePieceBitboard | blackPieceBitboard; if (zobristKey == 16260251586586513106) moveHashList.Clear(); else { moveHashList.Clear(); moveHashList.Add(1); moveHashList.Add(2); moveHashList.Add(3); } } private ulong[,] pieceHashesWhite = new ulong[64, 7], pieceHashesBlack = new ulong[64, 7]; private ulong blackTurnHash, whiteKingSideRochadeRightHash, whiteQueenSideRochadeRightHash, blackKingSideRochadeRightHash, blackQueenSideRochadeRightHash; private ulong[] enPassantSquareHashes = new ulong[66]; private Dictionary<ulong, int> singleCheckCaseBackup = new Dictionary<ulong, int>(); private void InitZobrist() { Random rng = new Random(31415926); for (int sq = 0; sq < 64; sq++) { enPassantSquareHashes[sq] = ULONG_OPERATIONS.GetRandomULONG(rng); for (int it = 1; it < 7; it++) { pieceHashesWhite[sq, it] = ULONG_OPERATIONS.GetRandomULONG(rng); pieceHashesBlack[sq, it] = ULONG_OPERATIONS.GetRandomULONG(rng); } } blackTurnHash = ULONG_OPERATIONS.GetRandomULONG(rng); whiteKingSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); whiteQueenSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); blackKingSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); blackQueenSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); } public void SetKnightMasks(ulong[] uls) { knightSquareBitboards = uls; } public void SetKingMasks(ulong[] uls) { kingSquareBitboards = uls; } private Move[,] whiteEnPassantMoves = new Move[64, 64]; private Move[,] blackEnPassantMoves = new Move[64, 64]; private bool[] epValidationArray = new bool[64] { false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true , true , true , true , true , true , true , true, true , true , true , true , true , true , true , true, true , true , true , true , true , true , true , true, true , true , true , true , true , true , true , true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false }; private ulong[] kingSafetyRing1 = new ulong[64], kingSafetyRing2 = new ulong[64]; private ulong[] kingSafetySpecialRingW = new ulong[64], kingSafetySpecialRingB = new ulong[64]; private ulong[] rowPrecalcs = new ulong[8], columnPrecalcs = new ulong[8]; const ulong columnUL = 0x101010101010101, rowUL = 0b11111111; private void PrecalculateKingSafetyBitboards() { for (int i = 0; i < 8; i++) { rowPrecalcs[i] = rowUL << (8 * i); columnPrecalcs[i] = columnUL << i; } for (int i = 0; i < 64; i++) { int tMod = i % 8; int tRow = (i - tMod) /8; ulong tULC = columnPrecalcs[tMod], tULR = rowPrecalcs[tRow]; ulong tULC2 = columnPrecalcs[tMod], tULR2 = rowPrecalcs[tRow]; if (tMod < 7) tULC |= columnPrecalcs[tMod + 1]; if (tMod > 0) tULC |= columnPrecalcs[tMod - 1]; if (tRow < 7) tULR |= rowPrecalcs[tRow + 1]; if (tRow > 0) tULR |= rowPrecalcs[tRow - 1]; if (tMod < 6) tULC2 |= columnPrecalcs[tMod + 2]; if (tMod > 1) tULC2 |= columnPrecalcs[tMod - 2]; if (tRow < 6) tULR2 |= rowPrecalcs[tRow + 2]; if (tRow > 1) tULR2 |= rowPrecalcs[tRow - 2]; tULR2 |= tULR; tULC2 |= tULC; kingSafetyRing1[i] = ULONG_OPERATIONS.SetBitToZero(tULR & tULC, i); kingSafetyRing2[i] = ULONG_OPERATIONS.SetBitsToZero(tULR2 & tULC2, i, i + 1, i - 1, i + 7, i + 8, i + 9, i - 7, i - 8, i - 9); } for (int i = 0; i < 64; i++) { if (i < 56) kingSafetySpecialRingW[i] = ULONG_OPERATIONS.SetBitToZero(kingSafetyRing1[i] | kingSafetyRing1[i + 8], i); else kingSafetySpecialRingW[i] = kingSafetyRing1[i]; if (i > 7) kingSafetySpecialRingB[i] = ULONG_OPERATIONS.SetBitToZero(kingSafetyRing1[i] | kingSafetyRing1[i - 8], i); else kingSafetySpecialRingB[i] = kingSafetyRing1[i]; } } private void PrecalculateEnPassantMoves() { for (int i = 0; i < 64; i++) { if (!epValidationArray[i]) continue; for (int j = 0; j < 64; j++) { if (i == j) continue; if (Math.Abs(i - j) > 9) continue; if (!epValidationArray[j]) continue; whiteEnPassantMoves[i, j] = new Move(false, i, j, j - 8); blackEnPassantMoves[i, j] = new Move(false, i, j, j + 8); } } } private void PawnAttackBitboards() { for (int sq = 0; sq < 64; sq++) { ulong u = 0ul; if (sq % 8 != 0) u = ULONG_OPERATIONS.SetBitToOne(u, sq + 7); if (sq % 8 != 7) u = ULONG_OPERATIONS.SetBitToOne(u, sq + 9); whitePawnAttackSquareBitboards[sq] = u; u = 0ul; if (sq % 8 != 0 && sq - 9 > -1) u = ULONG_OPERATIONS.SetBitToOne(u, sq - 9); if (sq % 8 != 7 && sq - 7 > -1) u = ULONG_OPERATIONS.SetBitToOne(u, sq - 7); blackPawnAttackSquareBitboards[sq] = u; } } private int[] squareConnectivesPrecalculationArray = new int[4096]; public int[] squareConnectivesCrossDirsPrecalculationArray { get; set; } = new int[4096]; private ulong[] squareConnectivesPrecalculationRayArray = new ulong[4096]; private ulong[] squareConnectivesPrecalculationLineArray = new ulong[4096]; private List<Dictionary<ulong, int>> rayCollidingSquareCalculations = new List<Dictionary<ulong, int>>(); private readonly int[] maxIntWithSpecifiedBitcount = new int[8] { 0, 0b1, 0b11, 0b111, 0b1111, 0b11111, 0b111111, 0b1111111 }; private List<ulong> differentRays = new List<ulong>(); private void SquareConnectivesPrecalculations() { for (int square = 0; square < 64; square++) { rayCollidingSquareCalculations.Add(new Dictionary<ulong, int>()); rayCollidingSquareCalculations[square].Add(0ul, square); for (int square2 = 0; square2 < 64; square2++) { if (square == square2) continue; int t = 0, t2 = 0, difSign = Math.Sign(square2 - square), itSq = square, g = 0; ulong tRay = 0ul, tExclRay = 0ul; List<int> tRayInts = new List<int>(); if (difSign == -1) g = 7; if (square % 8 == square2 % 8) { t2 = t = 1; while ((itSq += difSign * 8) < 64 && itSq > -1) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } } else if ((square - square % 8) == (square2 - square2 % 8)) { t = 1; t2 = -1; while ((itSq += difSign) % 8 != g && itSq > -1 && itSq < 64) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } } else { int dif = Math.Abs(square2 - square); if (dif % 7 == 0) { t = 2; t2 = 2; g = (difSign == 1) ? 7 : 0; while ((itSq += difSign * 7) % 8 != g && itSq < 64 && itSq > -1) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } if (ULONG_OPERATIONS.IsBitZero(tRay, square2)) { t2 = t = 0; tRay = 0ul; } } else if (dif % 9 == 0) { t = 2; t2 = -2; if (square == 0 && square2 == 63 || square == 63 && square2 == 0) SNAPSHOT_WRITLINE_REPLACEMENT("!"); while ((itSq += difSign * 9) % 8 != g && itSq < 64 && itSq > -1) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } if (ULONG_OPERATIONS.IsBitZero(tRay, square2)) { t2 = t = 0; tRay = 0ul; } } } if (square == 0 && square2 == 63) { t2 = t = 2; tRayInts.Clear(); tExclRay = tRay = ULONG_OPERATIONS.SetBitsToOne(0ul, 9, 18, 27, 36, 45, 54, 63); tRayInts = new List<int>() { 9, 18, 27, 36, 45, 54, 63 }; } else if (square2 == 0 && square == 63) { t = 2; tRayInts.Clear(); t2 = -2; tExclRay = tRay = ULONG_OPERATIONS.SetBitsToOne(0ul, 0, 9, 18, 27, 36, 45, 54); tRayInts = new List<int>() { 54, 45, 36, 27, 18, 9, 0 }; } if (tRay != 0ul && !differentRays.Contains(tRay)) { differentRays.Add(tRay); int ccount, combI = maxIntWithSpecifiedBitcount[ccount = ULONG_OPERATIONS.CountBits(tRay)]; do { ulong curAllPieceBitboard = 0ul; int solution = square; for (int j = 0; j < ccount; j++) { if (((combI >> j) & 1) == 1) { curAllPieceBitboard = ULONG_OPERATIONS.SetBitToOne(curAllPieceBitboard, tRayInts[j]); if (solution == square) solution = tRayInts[j]; } } rayCollidingSquareCalculations[square].Add(curAllPieceBitboard, solution); } while (--combI != 0); } squareConnectivesPrecalculationArray[square << 6 | square2] = t; squareConnectivesPrecalculationRayArray[square << 6 | square2] = tRay; squareConnectivesCrossDirsPrecalculationArray[square << 6 | square2] = t2; if (t != 0) squareConnectivesPrecalculationLineArray[square << 6 | square2] = (square == 0 && square2 == 63 || square2 == 0 && square == 63) ? tExclRay : ULONG_OPERATIONS.SetBitToOne(tExclRay, square2); if (squareConnectivesPrecalculationLineArray[square << 6 | square2] == 0ul && ULONG_OPERATIONS.IsBitOne(knightSquareBitboards[square], square2)) squareConnectivesPrecalculationLineArray[square << 6 | square2] = 1ul << square2; } differentRays.Clear(); } } public void SNAPSHOT_WRITLINE_REPLACEMENT() { } public void SNAPSHOT_WRITLINE_REPLACEMENT(object pStr) { } private string GetDoublePrecentageString(double pVal) { return ((int)(pVal * 1_000_000) /10_000d) + "%"; } private string ReplaceAllULONGIsBitOne(string pCode) { const string METHOD_NAME = "ULONG_OPERATIONS.IsBitOne"; int METHOD_NAME_LEN = METHOD_NAME.Length, iterations = 0; int pIndex = pCode.IndexOf(METHOD_NAME); while (pIndex != -1 && ++iterations < 10_000) { List<int> paramIndexes = new List<int>(); int openedBracketCount = 1, closedBracketCount = 0, a = METHOD_NAME_LEN + pIndex; string tpCode = pCode.Substring(0, pIndex); paramIndexes.Add(a + 1); while (++a < pCode.Length) { switch (pCode[a]) { case '(': openedBracketCount++; break; case ')': if (++closedBracketCount == openedBracketCount) { pIndex = a; a = int.MaxValue - 5; } break; case ',': if (openedBracketCount - closedBracketCount == 1) paramIndexes.Add(a + 1); break; } } if (openedBracketCount == closedBracketCount && paramIndexes.Count == 2) { tpCode += "((int)("+ pCode.Substring(paramIndexes[0], paramIndexes[1] - paramIndexes[0] - 1) + (pCode[paramIndexes[1]] == ' ' ? " >> (": " >> (") + pCode.Substring(paramIndexes[1], pIndex - paramIndexes[1]) + ")) & 1) == 1"+ pCode.Substring(pIndex + 1, pCode.Length - pIndex - 1); } pIndex = (pCode = tpCode).IndexOf(METHOD_NAME); } SNAPSHOT_WRITLINE_REPLACEMENT(iterations + " ITERATIONS"); return pCode; } private string ReplaceAllULONGIsBitZero(string pCode) { const string METHOD_NAME = "ULONG_OPERATIONS.IsBitZero"; int METHOD_NAME_LEN = METHOD_NAME.Length, iterations = 0; int pIndex = pCode.IndexOf(METHOD_NAME); while (pIndex != -1 && ++iterations < 10_000) { List<int> paramIndexes = new List<int>(); int openedBracketCount = 1, closedBracketCount = 0, a = METHOD_NAME_LEN + pIndex; string tpCode = pCode.Substring(0, pIndex); paramIndexes.Add(a + 1); while (++a < pCode.Length) { switch (pCode[a]) { case '(': openedBracketCount++; break; case ')': if (++closedBracketCount == openedBracketCount) { pIndex = a; a = int.MaxValue - 5; } break; case ',': if (openedBracketCount - closedBracketCount == 1) paramIndexes.Add(a + 1); break; } } if (openedBracketCount == closedBracketCount && paramIndexes.Count == 2) { tpCode += "((int)("+ pCode.Substring(paramIndexes[0], paramIndexes[1] - paramIndexes[0] - 1) + (pCode[paramIndexes[1]] == ' ' ? " >>": " >> ") + pCode.Substring(paramIndexes[1], pIndex - paramIndexes[1]) + ") & 1) == 0"+ pCode.Substring(pIndex + 1, pCode.Length - pIndex - 1); } pIndex = (pCode = tpCode).IndexOf(METHOD_NAME); } SNAPSHOT_WRITLINE_REPLACEMENT(iterations + " ITERATIONS"); return pCode; } private string GetThreeDigitSeperatedInteger(int pInt) { string s = pInt.ToString(), r = s[0].ToString(); int t = s.Length % 3; for (int i = 1; i < s.Length; i++) { if (i % 3 == t) r += "."; r += s[i]; } s = ""; for (int i = 0; i < r.Length; i++) s += r[i]; return s; } public double GetAverageDepth() { return (double)depths /(double)searches; } }
public class SNAPSHOT_V01_00_008 : IBoardManager  { public int TEXEL_PARAMS { get; } = 778; private const int BESTMOVE_SORT_VAL = -2_000_000_000; private const int CAPTURE_SORT_VAL = -1_000_000_000; private const int KILLERMOVE_SORT_VAL = -1000; private readonly int[,] MVVLVA_TABLE = new int[7, 7] { { 0, 0, 0, 0, 0, 0, 0 }, { 0, 1500, 1400, 1300, 1200, 1100, 1000 }, { 0, 3500, 3400, 3300, 3200, 3100, 3000 }, { 0, 4500, 4400, 4300, 4200, 4100, 4000 }, { 0, 5500, 5400, 5300, 5200, 5100, 5000 }, { 0, 9500, 9400, 9300, 9200, 9100, 9000 }, { 0, 0, 0, 0, 0, 0, 0 }}; private int BOARD_MANAGER_ID = -1; private bool debugSearchDepthResults = false; private bool debugSortResults = false; private RookMovement rookMovement; private BishopMovement bishopMovement; private QueenMovement queenMovement; private KnightMovement knightMovement; private KingMovement kingMovement; private WhitePawnMovement whitePawnMovement; private BlackPawnMovement blackPawnMovement; private Rays rays; public List<Move> moveOptionList { get; set; } private int[] pieceTypeArray = new int[64]; public ulong whitePieceBitboard, blackPieceBitboard, allPieceBitboard; private ulong zobristKey; private int whiteKingSquare, blackKingSquare, enPassantSquare = 65, happenedHalfMoves = 0, fiftyMoveRuleCounter = 0; private bool whiteCastleRightKingSide, whiteCastleRightQueenSide, blackCastleRightKingSide, blackCastleRightQueenSide; private bool isWhiteToMove; private const ulong WHITE_KING_ROCHADE = 96, WHITE_QUEEN_ROCHADE = 14, BLACK_KING_ROCHADE = 6917529027641081856, BLACK_QUEEN_ROCHADE = 1008806316530991104, WHITE_QUEEN_ATTK_ROCHADE = 12, BLACK_QUEEN_ATTK_ROCHADE = 864691128455135232; private readonly Move mWHITE_KING_ROCHADE = new Move(4, 6, 7, 5), mWHITE_QUEEN_ROCHADE = new Move(4, 2, 0, 3), mBLACK_KING_ROCHADE = new Move(60, 62, 63, 61), mBLACK_QUEEN_ROCHADE = new Move(60, 58, 56, 59); private ulong[] knightSquareBitboards = new ulong[64]; private ulong[] whitePawnAttackSquareBitboards = new ulong[64]; private ulong[] blackPawnAttackSquareBitboards = new ulong[64]; private ulong[] kingSquareBitboards = new ulong[64]; private bool[,] pieceTypeAbilities = new bool[7, 3] { { false, false, false }, { false, false, false }, { false, false, false }, { false, false, true }, { false, true, false }, { false, true, true }, { false, false, false } }; private List<int> moveHashList = new List<int>(); private ulong[] curSearchZobristKeyLine = Array.Empty<ulong>(); private Move[] debugMoveList = new Move[128]; private Stopwatch globalTimer = Stopwatch.StartNew(); private Move lastMadeMove; private int depths, searches; private Random globalRandom = new Random(); public SNAPSHOT_V01_00_008(string fen) { Setup(fen); } public void Setup(string pFen) { Stopwatch setupStopwatch = Stopwatch.StartNew(); BOARD_MANAGER_ID = BOT_MAIN.curBoardManagerID; for (int i = 0; i < 33; i++) for (int j = 0; j < 14; j++) piecePositionEvals[i, j] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; for (int i = 0; i < 33; i++) for (int j = 0; j < 14; j++) texelTuningRuntimeVals[i, j] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; for (int i = 0; i < 3; i++) for (int j = 0; j < 6; j++) texelTuningVals[i, j] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; for (int i = 0; i < 14; i++) { texelTuningRuntimePositionalValsV2EG[i] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; texelTuningRuntimePositionalValsV2LG[i] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; } PrecalculateKingSafetyBitboards(); PrecalculateMultipliers(); GetLowNoisePositionalEvaluation(globalRandom); MinimaxRoot(1L); SetupConsoleWrite("[PRECALCS] Zobrist Hashing"); InitZobrist(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Knight Movement"); knightMovement = new KnightMovement(this); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Square Connectives"); SquareConnectivesPrecalculations(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Pawn Attack Bitboards"); PawnAttackBitboards(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Rays"); rays = new Rays(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); queenMovement = new QueenMovement(this); SetupConsoleWrite("[PRECALCS] Rook Movement"); rookMovement = new RookMovement(this, queenMovement); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Bishop Movement"); bishopMovement = new BishopMovement(this, queenMovement); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] King Movement"); kingMovement = new KingMovement(this); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Pawn Movement"); whitePawnMovement = new WhitePawnMovement(this); blackPawnMovement = new BlackPawnMovement(this); PrecalculateEnPassantMoves(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWriteLine("[DONE]\n\n"); LoadFenString(pFen); LoadBestTexelParamsIn(); setupStopwatch.Stop(); } private void SetupConsoleWriteLine(string pStr) { if (BOT_MAIN.isFirstBoardManagerInitialized) return; SNAPSHOT_WRITLINE_REPLACEMENT(pStr); } private void SetupConsoleWrite(string pStr) { if (BOT_MAIN.isFirstBoardManagerInitialized) return; SNAPSHOT_WRITLINE_REPLACEMENT(pStr); } public void GetLowNoisePositionalEvaluation(System.Random rng) { int[,][] digitArray = new int[3, 6][]; for (int i = 0; i < 3; i++) for (int j = 0; j < 6; j++) digitArray[i, j] = GetRand64IntArray(rng, -5, 6); lowNoisePositionEvals1 = GetInterpolatedProcessedValues(digitArray); int[,][] digitArray2 = new int[3, 6][]; for (int i = 0; i < 3; i++) for (int j = 0; j < 6; j++) digitArray2[i, j] = GetRand64IntArray(rng, -5, 6); lowNoisePositionEvals2 = GetInterpolatedProcessedValues(digitArray2); } private int[] GetRand64IntArray(System.Random rng, int pMin, int pMax) { return new int[64] { rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax) }; } private string GetAIArrayValuesStringRepresentation(int[,][] pArr) { string r = "int[,][] ReLe_AI_RESULT_VALS = new int[3, 6][] {"; for (int i = 0; i < 3; i++) { r += "{"; for (int j = 0; j < 5; j++) { r += GetIntArray64LStringRepresentation(pArr[i, j]) + ","; } r += GetIntArray64LStringRepresentation(pArr[i, 5]) + "},"; } return r.Substring(0, r.Length - 1) + "};"; } private string GetIntArray64LStringRepresentation(int[] p64LArr) { if (p64LArr == null) return ""; string r = "new int[64]{"; for (int i = 0; i < 63; i++) { r += p64LArr[i] + ","; } return r + p64LArr[63] + "}"; } public void TempStuff() { } private string[] gameResultStrings = new string[5] { "Black Has Won!", "Draw!", "White Has Won!", "Non Existant Result!", "Game is Ongoing!"}; private int[,][] lowNoisePositionEvals1, lowNoisePositionEvals2; public void ThreadSelfPlay(object obj) { PlayGameAgainstItself(obj); } public void PlayGameAgainstItself(object obj, string pStartFEN = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1", long tickLimitForEngine = ENGINE_VALS.SELF_PLAY_THINK_TIME) { int ttGState; while (BOT_MAIN.goalGameCount > BOT_MAIN.gamesPlayed) { try { string tGameStr; GetLowNoisePositionalEvaluation(globalRandom); LoadFenString(tGameStr = pStartFEN); tGameStr += ";"; int tGState = 3, tmc = 0; bool lowNoiceDecider = globalRandom.NextDouble() < 0.5d; while (tGState == 3) { piecePositionEvals = lowNoiceDecider ? lowNoisePositionEvals1 : lowNoisePositionEvals2; MinimaxRoot(tickLimitForEngine); Move tM = transpositionTable[zobristKey].bestMove; PlainMakeMove(tM); tGameStr += NuCRe.GetNuCRe(tM.moveHash) + ","; BOT_MAIN.movesPlayed++; tGState = GameState(isWhiteToMove); lowNoiceDecider = !lowNoiceDecider; tmc++; } ttGState = tGState; tGameStr += ttGState + 1; SNAPSHOT_WRITLINE_REPLACEMENT(tGameStr); BOT_MAIN.gamesPlayedResultArray[ttGState + 1]++; BOT_MAIN.gamesPlayed++; BOT_MAIN.selfPlayGameStrings.Add(tGameStr); } catch (Exception tE) { SNAPSHOT_WRITLINE_REPLACEMENT(tE.ToString()); } } } public void PlayGameOnConsoleAgainstHuman(string pStartFEN = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1", bool pHumanPlaysWhite = true, long tickLimitForEngine = 10_000_000L) { debugSearchDepthResults = true; LoadFenString(pStartFEN); if (!(pHumanPlaysWhite ^ isWhiteToMove)) { var pVS = Console.ReadLine(); if (pVS == null) return; Move tm = GetMoveOfString(pVS.ToString()); SNAPSHOT_WRITLINE_REPLACEMENT(tm); PlainMakeMove(tm); } int tGState = 3; while (tGState == 3) { MinimaxRoot(tickLimitForEngine); PlayThroughZobristTree(); Move tM = transpositionTable[zobristKey].bestMove; SNAPSHOT_WRITLINE_REPLACEMENT(tM); SNAPSHOT_WRITLINE_REPLACEMENT(CreateFenString()); PlainMakeMove(tM); tGState = GameState(isWhiteToMove); if (tGState != 3 || tM == NULL_MOVE) break; var pV = ""; tM = NULL_MOVE; do { pV = Console.ReadLine(); if (pV == null) continue; tM = GetMoveOfString(pV.ToString()); SNAPSHOT_WRITLINE_REPLACEMENT(tM); } while (tM == NULL_MOVE); PlainMakeMove(tM); tGState = GameState(isWhiteToMove); } } private void PlayThroughZobristTree() { SetJumpState(); SNAPSHOT_WRITLINE_REPLACEMENT("\n- - - - - - - - - - - - -"); int tC = 1; Dictionary<ulong, bool> usedULs = new Dictionary<ulong, bool>(); while (transpositionTable.TryGetValue(zobristKey, out TranspositionEntry tM)) { if (usedULs.ContainsKey(zobristKey)) { SNAPSHOT_WRITLINE_REPLACEMENT(tC + ": AT LEAST ONE REPETION; REST NOT VISIBLE"); break; } SNAPSHOT_WRITLINE_REPLACEMENT(tC + ": "+ tM.bestMove + " > "); usedULs.Add(zobristKey, true); PlainMakeMove(tM.bestMove); tC++; } SNAPSHOT_WRITLINE_REPLACEMENT("- - - - - - - - - - - - -\n"); LoadJumpState(); } public Move? ReturnNextMove(Move? lastMove, long pThinkingTime) { if (lastMove != null) PlainMakeMove(lastMove); if (GameState(isWhiteToMove) != 3) return null; MinimaxRoot(pThinkingTime); if (!transpositionTable.ContainsKey(zobristKey)) return null; Move tm = transpositionTable[zobristKey].bestMove; PlainMakeMove(tm); return tm; } private int[] jmpSt_pieceTypeArray; private ulong jmpSt_whitePieceBitboard, jmpSt_blackPieceBitboard; private ulong jmpSt_zobristKey; private int jmpSt_whiteKingSquare, jmpSt_blackKingSquare, jmpSt_enPassantSquare, jmpSt_happenedHalfMoves, jmpSt_fiftyMoveRuleCounter; private bool jmpSt_whiteCastleRightKingSide, jmpSt_whiteCastleRightQueenSide, jmpSt_blackCastleRightKingSide, jmpSt_blackCastleRightQueenSide; private bool jmpSt_isWhiteToMove; private ulong[] jmpSt_curSearchZobristKeyLine; private int[] jmpSt_moveHashList; public void LoadJumpState() { pieceTypeArray = (int[])jmpSt_pieceTypeArray.Clone(); whitePieceBitboard = jmpSt_whitePieceBitboard; blackPieceBitboard = jmpSt_blackPieceBitboard; zobristKey = jmpSt_zobristKey; whiteKingSquare = jmpSt_whiteKingSquare; blackKingSquare = jmpSt_blackKingSquare; enPassantSquare = jmpSt_enPassantSquare; happenedHalfMoves = jmpSt_happenedHalfMoves; fiftyMoveRuleCounter = jmpSt_fiftyMoveRuleCounter; whiteCastleRightKingSide = jmpSt_whiteCastleRightKingSide; whiteCastleRightQueenSide = jmpSt_whiteCastleRightQueenSide; blackCastleRightKingSide = jmpSt_blackCastleRightKingSide; blackCastleRightQueenSide = jmpSt_blackCastleRightQueenSide; isWhiteToMove = jmpSt_isWhiteToMove; curSearchZobristKeyLine = (ulong[])jmpSt_curSearchZobristKeyLine.Clone(); allPieceBitboard = blackPieceBitboard | whitePieceBitboard; moveHashList = jmpSt_moveHashList.ToList(); } public void SetJumpState() { jmpSt_pieceTypeArray = (int[])pieceTypeArray.Clone(); jmpSt_whitePieceBitboard = whitePieceBitboard; jmpSt_blackPieceBitboard = blackPieceBitboard; jmpSt_zobristKey = zobristKey; jmpSt_whiteKingSquare = whiteKingSquare; jmpSt_blackKingSquare = blackKingSquare; jmpSt_enPassantSquare = enPassantSquare; jmpSt_happenedHalfMoves = happenedHalfMoves; jmpSt_fiftyMoveRuleCounter = fiftyMoveRuleCounter; jmpSt_whiteCastleRightKingSide = whiteCastleRightKingSide; jmpSt_whiteCastleRightQueenSide = whiteCastleRightQueenSide; jmpSt_blackCastleRightKingSide = blackCastleRightKingSide; jmpSt_blackCastleRightQueenSide = blackCastleRightQueenSide; jmpSt_isWhiteToMove = isWhiteToMove; jmpSt_curSearchZobristKeyLine = (ulong[])curSearchZobristKeyLine.Clone(); jmpSt_moveHashList = moveHashList.ToArray(); } private int PreMinimaxCheckCheckWhite() { ulong bitShiftedKingPos = 1ul << whiteKingSquare; int curR = -1; for (int p = 0; p < 64; p++) { if (ULONG_OPERATIONS.IsBitZero(blackPieceBitboard, p)) continue; int tPT; switch (tPT = pieceTypeArray[p]) { case 1: if ((bitShiftedKingPos & blackPawnAttackSquareBitboards[p]) != 0ul) return p; break; case 2: if ((bitShiftedKingPos & knightSquareBitboards[p]) != 0ul) return p; break; case 6: break; default: if ((squareConnectivesPrecalculationLineArray[whiteKingSquare << 6 | p] & allPieceBitboard) == (1ul << p) && pieceTypeAbilities[tPT, squareConnectivesPrecalculationArray[whiteKingSquare << 6 | p]]) { if (curR != -1) return -779; curR = p; } break; } } return curR; } private int PreMinimaxCheckCheckBlack() { ulong bitShiftedKingPos = 1ul << blackKingSquare; int curR = -1; for (int p = 0; p < 64; p++) { if (ULONG_OPERATIONS.IsBitZero(whitePieceBitboard, p)) continue; int tPT; switch (tPT = pieceTypeArray[p]) { case 1: if ((bitShiftedKingPos & whitePawnAttackSquareBitboards[p]) != 0ul) return p; break; case 2: if ((bitShiftedKingPos & knightSquareBitboards[p]) != 0ul) return p; break; case 6: break; default: if ((squareConnectivesPrecalculationLineArray[blackKingSquare << 6 | p] & allPieceBitboard) == (1ul << p) && pieceTypeAbilities[tPT, squareConnectivesPrecalculationArray[blackKingSquare << 6 | p]]) { if (curR != -1) return -779; curR = p; } break; } } return curR; } private int LecacyLeafCheckingPieceCheckWhite(int pStartPos, int pEndPos, int pPieceType) { int tI, tPossibleAttackPiece; if (pPieceType == 1) { if (ULONG_OPERATIONS.IsBitOne(blackPawnAttackSquareBitboards[pEndPos], whiteKingSquare)) return pEndPos; } else if (pPieceType == 2) { if (ULONG_OPERATIONS.IsBitOne(knightSquareBitboards[pEndPos], whiteKingSquare)) return pEndPos; } else if (pPieceType != 6) { tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | pEndPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; } tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | pStartPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; return -1; } private int LecacyLeafCheckingPieceCheckBlack(int pStartPos, int pEndPos, int pPieceType) { int tI, tPossibleAttackPiece; if (pPieceType == 1) { if (ULONG_OPERATIONS.IsBitOne(whitePawnAttackSquareBitboards[pEndPos], blackKingSquare)) return pEndPos; } else if (pPieceType == 2) { if (ULONG_OPERATIONS.IsBitOne(knightSquareBitboards[pEndPos], blackKingSquare)) return pEndPos; } else if (pPieceType != 6) { tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | pEndPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; } tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | pStartPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; return -1; } public void GetLegalMoves(ref List<Move> pMoveList) { int attk; if (isWhiteToMove) { attk = PreMinimaxCheckCheckWhite(); if (attk == -779) GetLegalWhiteMovesSpecialDoubleCheckCase(ref pMoveList); else GetLegalWhiteMoves(attk, ref pMoveList); } else { attk = PreMinimaxCheckCheckBlack(); if (attk == -779) GetLegalBlackMovesSpecialDoubleCheckCase(ref pMoveList); else GetLegalBlackMoves(attk, ref pMoveList); } } private void GetLegalWhiteMoves(int pCheckingPieceSquare, ref List<Move> pMoveList) { if (pCheckingPieceSquare == -779) { GetLegalWhiteMovesSpecialDoubleCheckCase(ref pMoveList); return; } moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= blackPawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, whiteKingSquare); if (curCheckCount == 0) { if (whiteCastleRightKingSide && ((allPieceBitboard | oppAttkBitboard) & WHITE_KING_ROCHADE) == 0ul) pMoveList.Add(mWHITE_KING_ROCHADE); if (whiteCastleRightQueenSide && (allPieceBitboard & WHITE_QUEEN_ROCHADE | oppAttkBitboard & WHITE_QUEEN_ATTK_ROCHADE) == 0ul) pMoveList.Add(mWHITE_QUEEN_ROCHADE); if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, whitePieceBitboard, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[whiteKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare + 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, whitePieceBitboard, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveList(whiteKingSquare, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalWhiteCaptures(int pCheckingPieceSquare, ref List<Move> pMoveList) { if (pCheckingPieceSquare == -779) { GetLegalWhiteCapturesSpecialDoubleCheckCase(ref pMoveList); return; } moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= blackPawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, whiteKingSquare); if (curCheckCount == 0) { if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & blackPieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[whiteKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare + 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & blackPieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveListOnlyCaptures(whiteKingSquare, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalWhiteMovesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= blackPawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveList(whiteKingSquare, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalWhiteCapturesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= blackPawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveListOnlyCaptures(whiteKingSquare, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalBlackMoves(int pCheckingPieceSquare, ref List<Move> pMoveList) { if (pCheckingPieceSquare == -779) { GetLegalBlackMovesSpecialDoubleCheckCase(ref pMoveList); return; } moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= whitePawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, blackKingSquare); if (curCheckCount == 0) { if (blackCastleRightKingSide && ((allPieceBitboard | oppAttkBitboard) & BLACK_KING_ROCHADE) == 0ul) pMoveList.Add(mBLACK_KING_ROCHADE); if (blackCastleRightQueenSide && (allPieceBitboard & BLACK_QUEEN_ROCHADE | oppAttkBitboard & BLACK_QUEEN_ATTK_ROCHADE) == 0ul) pMoveList.Add(mBLACK_QUEEN_ROCHADE); if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveList(p, blackKingSquare, blackPieceBitboard, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[blackKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare - 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveList(p, blackKingSquare, blackPieceBitboard, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveList(blackKingSquare, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); } private void GetLegalBlackCaptures(int pCheckingPieceSquare, ref List<Move> pMoveList) { if (pCheckingPieceSquare == -779) { GetLegalBlackCapturesSpecialDoubleCheckCase(ref pMoveList); return; } moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= whitePawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, blackKingSquare); if (curCheckCount == 0) { if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & whitePieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[blackKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare - 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & whitePieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveListOnlyCaptures(blackKingSquare, ~oppAttkBitboard & whitePieceBitboard); } private void GetLegalBlackMovesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= whitePawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveList(blackKingSquare, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); } private void GetLegalBlackCapturesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= whitePawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveListOnlyCaptures(blackKingSquare, ~oppAttkBitboard & whitePieceBitboard); } public Move GetMoveOfString(string pMove) { int tSP, tEP; string[] tSpl = pMove.Split(','); if (Char.IsNumber(pMove[0])) { tSP = Convert.ToInt32(tSpl[0]); tEP = Convert.ToInt32(tSpl[1]); } else { tSP = SQUARES.NumberNotation(tSpl[0]); tEP = SQUARES.NumberNotation(tSpl[1]); } int tPT = pieceTypeArray[tSP]; bool tIC = ULONG_OPERATIONS.IsBitOne(allPieceBitboard, tEP), tIEP = enPassantSquare == tEP && tPT == 1; if (tSpl.Length == 3) return new Move(tSP, tEP, tPT, Convert.ToInt32(tSpl[2]), tIC); if (tIEP) return new Move(true, tSP, tEP, isWhiteToMove ? tEP - 8 : tEP + 8); if (tPT == 1 && Math.Abs(tSP - tEP) > 11) return new Move(tSP, tEP, 1, false, isWhiteToMove ? tSP + 8 : tSP - 8); if (tPT == 6 && (Math.Abs(tSP - tEP) == 2 || Math.Abs(tSP - tEP) == 3)) { if (isWhiteToMove) return tEP == 6 ? mWHITE_KING_ROCHADE : mWHITE_QUEEN_ROCHADE; return tEP == 62 ? mBLACK_KING_ROCHADE : mBLACK_QUEEN_ROCHADE; } return new Move(tSP, tEP, tPT, tIC); } public void PlainMakeMove(string pMoveName) { PlainMakeMove(GetMoveOfString(pMoveName)); } public void PlainMakeMove(Move pMove) { lastMadeMove = pMove; if (isWhiteToMove) WhiteMakeMove(pMove); else BlackMakeMove(pMove); } public void WhiteMakeMove(Move pMove) { int tEndPos = pMove.endPos, tStartPos = pMove.startPos, tPieceType = pMove.pieceType, tPTI = pieceTypeArray[tEndPos]; fiftyMoveRuleCounter++; whitePieceBitboard ^= pMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey ^= blackTurnHash ^ enPassantSquareHashes[enPassantSquare] ^ pieceHashesWhite[tStartPos, tPieceType] ^ pieceHashesWhite[tEndPos, tPieceType]; enPassantSquare = 65; isWhiteToMove = false; switch (pMove.moveTypeID) { case 0: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 1: fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 2: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 3: whiteKingSquare = tEndPos; if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 4: if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 5: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 6: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 7: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[whiteKingSquare = tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 8: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 9: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = pMove.enPassantOption]; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 11: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; whiteKingSquare = tEndPos; pieceTypeArray[pMove.rochadeEndPos] = 4; pieceTypeArray[pMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesWhite[pMove.rochadeStartPos, 4] ^ pieceHashesWhite[pMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 12: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[pMove.enPassantOption] = 0; zobristKey ^= pieceHashesBlack[pMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 13: fiftyMoveRuleCounter = 0; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; zobristKey ^= pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, pMove.promotionType]; break; case 14: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, tPTI] ^ pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, pMove.promotionType]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; } moveHashList.Add(pMove.moveHash); if (pMove.isCapture || tPieceType == 1) { curSearchZobristKeyLine = Array.Empty<ulong>(); return; } ulong[] u = new ulong[(tPTI = curSearchZobristKeyLine.Length) + 1]; for (int i = tPTI; i-- > 0;) u[i] = curSearchZobristKeyLine[i]; u[tPTI] = zobristKey; curSearchZobristKeyLine = u; } public void BlackMakeMove(Move pMove) { int tEndPos = pMove.endPos, tStartPos = pMove.startPos, tPieceType = pMove.pieceType, tPTI = pieceTypeArray[tEndPos]; fiftyMoveRuleCounter++; blackPieceBitboard ^= pMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey ^= blackTurnHash ^ enPassantSquareHashes[enPassantSquare] ^ pieceHashesBlack[tStartPos, tPieceType] ^ pieceHashesBlack[tEndPos, tPieceType]; enPassantSquare = 65; isWhiteToMove = true; switch (pMove.moveTypeID) { case 0: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 1: fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 2: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 3: blackKingSquare = tEndPos; if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 4: if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 5: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 6: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 7: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[blackKingSquare = tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 8: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 9: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = pMove.enPassantOption]; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 11: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; blackKingSquare = tEndPos; pieceTypeArray[pMove.rochadeEndPos] = 4; pieceTypeArray[pMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesBlack[pMove.rochadeStartPos, 4] ^ pieceHashesBlack[pMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 12: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[pMove.enPassantOption] = 0; zobristKey ^= pieceHashesWhite[pMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 13: fiftyMoveRuleCounter = 0; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, pMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 14: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } zobristKey ^= pieceHashesWhite[tEndPos, tPTI] ^ pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, pMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; } moveHashList.Add(pMove.moveHash); if (pMove.isCapture || tPieceType == 1) { curSearchZobristKeyLine = Array.Empty<ulong>(); return; } ulong[] u = new ulong[(tPTI = curSearchZobristKeyLine.Length) + 1]; for (int i = tPTI; i-- > 0;) u[i] = curSearchZobristKeyLine[i]; u[tPTI] = zobristKey; curSearchZobristKeyLine = u; } public void WhiteUndoMove(Move pMove) { } private const int WHITE_CHECKMATE_VAL = 100000, BLACK_CHECKMATE_VAL = -100000, CHECK_EXTENSION_LENGTH = -12, MAX_QUIESCENCE_TOTAL_LENGTH = -32; private readonly Move NULL_MOVE = new Move(0, 0, 0); private int curSearchDepth = 0, curSubSearchDepth = -1; public int MinimaxRoot(long pTime) { evalCount = 0; searches++; int baseLineLen = 0; long tTimestamp = globalTimer.ElapsedTicks + pTime; ClearHeuristics(); transpositionTable.Clear(); ulong[] tZobristKeyLine = Array.Empty<ulong>(); if (curSearchZobristKeyLine != null) { baseLineLen = curSearchZobristKeyLine.Length; tZobristKeyLine = new ulong[baseLineLen]; Array.Copy(curSearchZobristKeyLine, tZobristKeyLine, baseLineLen); } int perftScore, tattk = isWhiteToMove ? PreMinimaxCheckCheckWhite() : PreMinimaxCheckCheckBlack(), pDepth = 1; (string, int) bookMoveTuple = TLMDatabase.SearchForNextBookMove(moveHashList); if (bookMoveTuple.Item2 != 0) { int actualMoveHash = NuCRe.GetNumber(bookMoveTuple.Item1); List<Move> tMoves = new List<Move>(); GetLegalMoves(ref tMoves); int tL = tMoves.Count; for (int i = 0; i < tL; i++) { if (tMoves[i].moveHash == actualMoveHash) { if (debugSearchDepthResults) { SNAPSHOT_WRITLINE_REPLACEMENT("TLM_DB_Count: " + bookMoveTuple.Item2); SNAPSHOT_WRITLINE_REPLACEMENT(">> " + tMoves[i]); } transpositionTable.Add(zobristKey, new TranspositionEntry(tMoves[i], Array.Empty<int>())); return 0; } } } do { curSearchDepth = pDepth; curSubSearchDepth = pDepth - 1; ulong[] completeZobristHistory = new ulong[baseLineLen + pDepth - CHECK_EXTENSION_LENGTH + 1]; for (int i = 0; i < baseLineLen; i++) completeZobristHistory[i] = curSearchZobristKeyLine[i]; curSearchZobristKeyLine = completeZobristHistory; if (isWhiteToMove) { if (tattk == -1) perftScore = MinimaxWhite(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); else perftScore = MinimaxWhite(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); } else { if (tattk == -1) perftScore = MinimaxBlack(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); else perftScore = MinimaxBlack(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); } if (debugSearchDepthResults && pTime != 1L) { int tNpS = Convert.ToInt32((double)evalCount * 10_000_000d /(double)(pTime - tTimestamp + globalTimer.ElapsedTicks)); int tSearchEval = perftScore; int timeForSearchSoFar = (int)((pTime - tTimestamp + globalTimer.ElapsedTicks) /10000d); Move tBestMove = transpositionTable[zobristKey].bestMove; SNAPSHOT_WRITLINE_REPLACEMENT((tSearchEval >= 0 ? "+": "") + tSearchEval); SNAPSHOT_WRITLINE_REPLACEMENT(" " + tBestMove + "  ["); SNAPSHOT_WRITLINE_REPLACEMENT("Depth = " + pDepth + ", "); SNAPSHOT_WRITLINE_REPLACEMENT("Evals = " + GetThreeDigitSeperatedInteger(evalCount) + ", "); SNAPSHOT_WRITLINE_REPLACEMENT("Time = " + GetThreeDigitSeperatedInteger(timeForSearchSoFar) + "ms, "); SNAPSHOT_WRITLINE_REPLACEMENT("NpS = " + GetThreeDigitSeperatedInteger(tNpS) + "]"); } pDepth++; } while (globalTimer.ElapsedTicks < tTimestamp && pDepth < 179); depths += pDepth - 1; BOT_MAIN.depthsSearched += pDepth - 1; BOT_MAIN.searchesFinished++; BOT_MAIN.evaluationsMade += evalCount; curSearchZobristKeyLine = tZobristKeyLine; return perftScore; } private int MinimaxWhite(int pPly, int pAlpha, int pBeta, int pDepth, int pRepetitionHistoryPly, int pCheckingSquare, Move pLastMove) { if (IsDrawByRepetition(pRepetitionHistoryPly - 4)) return 0; if ((pDepth <= 0 && pCheckingSquare == -1) || pDepth < CHECK_EXTENSION_LENGTH) return QuiescenceWhite(pPly, pAlpha, pBeta, pDepth - 1, pCheckingSquare, pLastMove); List<Move> moveOptionList = new List<Move>(); Move bestMove = NULL_MOVE; if (pLastMove.isPromotion && pLastMove.isCapture && pLastMove.startPos % 8 == pCheckingSquare % 8 && pLastMove.startPos == whiteKingSquare + 8 && (pLastMove.promotionType == 4 || pLastMove.promotionType == 5)) GetLegalWhiteMovesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalWhiteMoves(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tWhiteKingSquare = whiteKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1, curEval = BLACK_CHECKMATE_VAL - pDepth; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = true; double[] moveSortingArray = new double[molc]; int[] moveSortingArrayIndexes = new int[molc], thisSearchMoveSortingArrayForTransposEntry = new int[molc]; transpositionTable.TryGetValue(zobristKey, out TranspositionEntry transposEntry); if (transposEntry == null) { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; } } else { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove == transposEntry.bestMove) moveSortingArray[m] = BESTMOVE_SORT_VAL; else if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; if (transposEntry.moveGenOrderedEvalLength > m) moveSortingArray[m] -= transposEntry.moveGenOrderedEvals[m]; } } Array.Sort(moveSortingArray, moveSortingArrayIndexes); for (int m = 0; m < molc; m++) { int tActualIndex = moveSortingArrayIndexes[m]; Move curMove = moveOptionList[tActualIndex]; if (debugSortResults && pDepth == curSubSearchDepth) { SNAPSHOT_WRITLINE_REPLACEMENT(moveSortingArray[m] + " | "+ curMove); } int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; whitePieceBitboard = tWPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesWhite[tStartPos, tPieceType] ^ pieceHashesWhite[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 0: blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 1: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 2: blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 3: whiteKingSquare = tEndPos; if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 4: blackPieceBitboard = tBPB; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 5: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[whiteKingSquare = tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = curMove.enPassantOption]; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 11: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; whiteKingSquare = tEndPos; blackPieceBitboard = tBPB; pieceTypeArray[curMove.rochadeEndPos] = 4; pieceTypeArray[curMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesWhite[curMove.rochadeStartPos, 4] ^ pieceHashesWhite[curMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | curMove.rochadeEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << curMove.rochadeEndPos)) tCheckPos = curMove.rochadeEndPos; break; case 12: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesBlack[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 13: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; zobristKey ^= pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, curMove.promotionType]; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; case 14: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, tPTI] ^ pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, curMove.promotionType]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } curSearchZobristKeyLine[pRepetitionHistoryPly] = zobristKey; debugMoveList[pPly] = curMove; int tEval = MinimaxBlack(pPly + 1, pAlpha, pBeta, pDepth - 1, pRepetitionHistoryPly + 1, tCheckPos, curMove); thisSearchMoveSortingArrayForTransposEntry[tActualIndex] = tEval; pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 3: whiteKingSquare = tWhiteKingSquare; break; case 7: whiteKingSquare = tWhiteKingSquare; break; case 10: enPassantSquare = 65; break; case 11: whiteKingSquare = tWhiteKingSquare; pieceTypeArray[curMove.rochadeStartPos] = 4; pieceTypeArray[curMove.rochadeEndPos] = 0; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 13: pieceTypeArray[tStartPos] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval > curEval) { bestMove = curMove; curEval = tEval; } if (pAlpha < curEval) pAlpha = curEval; if (curEval >= pBeta) { if (!curMove.isCapture) { killerMoveHeuristic[curMove.moveHash] = true; if (pDepth > 0) historyHeuristic[curMove.moveHash] += pDepth * pDepth; } break; } } isWhiteToMove = true; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; if (molc == 0 && pCheckingSquare == -1) curEval = 0; if (!transpositionTable.ContainsKey(zobristKey)) transpositionTable.Add(zobristKey, new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry)); else transpositionTable[zobristKey] = new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry); return curEval; } private int QuiescenceWhite(int pPly, int pAlpha, int pBeta, int pDepth, int pCheckingSquare, Move pLastMove) { int standPat = TexelEvaluate(); if (standPat >= pBeta || pDepth < MAX_QUIESCENCE_TOTAL_LENGTH) return pBeta; if (standPat > pAlpha) pAlpha = standPat; List<Move> moveOptionList = new List<Move>(); if (pLastMove.isPromotion && pLastMove.isCapture && pLastMove.startPos % 8 == pCheckingSquare % 8 && pLastMove.startPos == whiteKingSquare + 8 && (pLastMove.promotionType == 4 || pLastMove.promotionType == 5)) GetLegalWhiteCapturesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalWhiteCaptures(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tWhiteKingSquare = whiteKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = true; for (int m = 0; m < molc; m++) { Move curMove = moveOptionList[m]; int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; whitePieceBitboard = tWPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesWhite[tStartPos, tPieceType] ^ pieceHashesWhite[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 5: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[whiteKingSquare = tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 12: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesBlack[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 14: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, tPTI] ^ pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, curMove.promotionType]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } debugMoveList[pPly] = curMove; int tEval = QuiescenceBlack(pPly + 1, pAlpha, pBeta, pDepth - 1, tCheckPos, curMove); pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 7: whiteKingSquare = tWhiteKingSquare; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval >= pBeta) return pBeta; if (pAlpha < tEval) pAlpha = tEval; } isWhiteToMove = true; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; return pAlpha; } private int MinimaxBlack(int pPly, int pAlpha, int pBeta, int pDepth, int pRepetitionHistoryPly, int pCheckingSquare, Move pLastMove) { if (IsDrawByRepetition(pRepetitionHistoryPly - 4)) return 0; if ((pDepth <= 0 && pCheckingSquare == -1) || pDepth < CHECK_EXTENSION_LENGTH) return QuiescenceBlack(pPly, pAlpha, pBeta, pDepth - 1, pCheckingSquare, pLastMove); List<Move> moveOptionList = new List<Move>(); Move bestMove = NULL_MOVE; if (pLastMove.isPromotion && pLastMove.isCapture && pLastMove.startPos % 8 == pCheckingSquare % 8 && pLastMove.startPos == blackKingSquare - 8 && (pLastMove.promotionType == 4 || pLastMove.promotionType == 5)) GetLegalBlackMovesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalBlackMoves(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tBlackKingSquare = blackKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1, curEval = WHITE_CHECKMATE_VAL + pDepth; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = false; double[] moveSortingArray = new double[molc]; int[] moveSortingArrayIndexes = new int[molc], thisSearchMoveSortingArrayForTransposEntry = new int[molc]; transpositionTable.TryGetValue(zobristKey, out TranspositionEntry transposEntry); if (transposEntry == null) { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; } } else { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove == transposEntry.bestMove) moveSortingArray[m] = BESTMOVE_SORT_VAL; else if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; if (transposEntry.moveGenOrderedEvalLength > m) moveSortingArray[m] -= transposEntry.moveGenOrderedEvals[m]; } } Array.Sort(moveSortingArray, moveSortingArrayIndexes); for (int m = 0; m < molc; m++) { int tActualIndex = moveSortingArrayIndexes[m]; Move curMove = moveOptionList[tActualIndex]; if (debugSortResults && pDepth == curSearchDepth) { SNAPSHOT_WRITLINE_REPLACEMENT("=== " + moveSortingArray[m] + " | "+ curMove); } int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; blackPieceBitboard = tBPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesBlack[tStartPos, tPieceType] ^ pieceHashesBlack[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 0: whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 1: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 2: whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 3: blackKingSquare = tEndPos; if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 4: whitePieceBitboard = tWPB; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 5: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[blackKingSquare = tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = curMove.enPassantOption]; whitePieceBitboard = tWPB; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 11: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; blackKingSquare = tEndPos; whitePieceBitboard = tWPB; pieceTypeArray[curMove.rochadeEndPos] = 4; pieceTypeArray[curMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesBlack[curMove.rochadeStartPos, 4] ^ pieceHashesBlack[curMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | curMove.rochadeEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << curMove.rochadeEndPos)) tCheckPos = curMove.rochadeEndPos; break; case 12: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesWhite[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 13: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, curMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; case 14: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } zobristKey ^= pieceHashesWhite[tEndPos, tPTI] ^ pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, curMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } curSearchZobristKeyLine[pRepetitionHistoryPly] = zobristKey; debugMoveList[pPly] = curMove; int tEval = MinimaxWhite(pPly + 1, pAlpha, pBeta, pDepth - 1, pRepetitionHistoryPly + 1, tCheckPos, curMove); thisSearchMoveSortingArrayForTransposEntry[tActualIndex] = tEval; pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 3: blackKingSquare = tBlackKingSquare; break; case 7: blackKingSquare = tBlackKingSquare; break; case 10: enPassantSquare = 65; break; case 11: blackKingSquare = tBlackKingSquare; pieceTypeArray[curMove.rochadeStartPos] = 4; pieceTypeArray[curMove.rochadeEndPos] = 0; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 13: pieceTypeArray[tStartPos] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval < curEval) { bestMove = curMove; curEval = tEval; } if (pBeta > curEval) pBeta = curEval; if (curEval <= pAlpha) { if (!curMove.isCapture) { killerMoveHeuristic[curMove.moveHash] = true; if (pDepth > 0) historyHeuristic[curMove.moveHash] += pDepth * pDepth; } break; } } isWhiteToMove = false; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; if (molc == 0 && pCheckingSquare == -1) curEval = 0; if (!transpositionTable.ContainsKey(zobristKey)) transpositionTable.Add(zobristKey, new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry)); else transpositionTable[zobristKey] = new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry); return curEval; } private int QuiescenceBlack(int pPly, int pAlpha, int pBeta, int pDepth, int pCheckingSquare, Move pLastMove) { int standPat = TexelEvaluate(); if (standPat <= pAlpha || pDepth < MAX_QUIESCENCE_TOTAL_LENGTH) return pAlpha; if (standPat < pBeta) pBeta = standPat; List<Move> moveOptionList = new List<Move>(); if (pLastMove.isPromotion && pLastMove.isCapture && pLastMove.startPos % 8 == pCheckingSquare % 8 && pLastMove.startPos == blackKingSquare - 8 && (pLastMove.promotionType == 4 || pLastMove.promotionType == 5)) GetLegalBlackCapturesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalBlackCaptures(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tBlackKingSquare = blackKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = false; for (int m = 0; m < molc; m++) { Move curMove = moveOptionList[m]; int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; blackPieceBitboard = tBPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesBlack[tStartPos, tPieceType] ^ pieceHashesBlack[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 5: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[blackKingSquare = tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 12: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesWhite[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 14: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } zobristKey ^= pieceHashesWhite[tEndPos, tPTI] ^ pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, curMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } debugMoveList[pPly] = curMove; int tEval = QuiescenceWhite(pPly + 1, pAlpha, pBeta, pDepth - 1, tCheckPos, curMove); pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 7: blackKingSquare = tBlackKingSquare; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval <= pAlpha) return pAlpha; if (pBeta > tEval) pBeta = tEval; } isWhiteToMove = false; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; return pBeta; } private bool[] killerMoveHeuristic = new bool[262_144]; private int[] historyHeuristic = new int[262_144]; public void ClearHeuristics() { for (int i = 0; i < 262_144; i++) { killerMoveHeuristic[i] = false; historyHeuristic[i] = 0; } } private Dictionary<ulong, TranspositionEntry> transpositionTable = new Dictionary<ulong, TranspositionEntry>(); private int[] pieceEvals = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[,][] piecePositionEvals = new int[33, 14][]; private int evalCount = 0; private int Evaluate() { evalCount++; if (fiftyMoveRuleCounter > 99) return 0; int tEval = 0, tPT, pieceCount = ULONG_OPERATIONS.CountBits(allPieceBitboard); for (int p = 0; p < 64; p++) tEval += pieceEvals[tPT = pieceTypeArray[p] + 7 * ((int)(blackPieceBitboard >> p) & 1)] + piecePositionEvals[pieceCount, tPT][p]; return tEval; } public int GameState(bool pWhiteKingCouldBeAttacked) { if (IsDrawByRepetition(curSearchZobristKeyLine.Length - 5) || fiftyMoveRuleCounter > 99) return 0; int t; List<Move> tMoves = new List<Move>(); GetLegalMoves(ref tMoves); if (pWhiteKingCouldBeAttacked) { t = PreMinimaxCheckCheckWhite(); if (t == -1) return tMoves.Count == 0 ? 0 : 3; else if (tMoves.Count == 0) return -1; } else { t = PreMinimaxCheckCheckBlack(); if (t == -1) return tMoves.Count == 0 ? 0 : 3; else if (tMoves.Count == 0) return 1; } return 3; } private bool IsDrawByRepetition(int pPlyOfFirstPossibleRepeatedPosition) { int tC = 0; for (int i = pPlyOfFirstPossibleRepeatedPosition; i >= 0; i -= 2) { if (curSearchZobristKeyLine[i] == zobristKey) if (++tC == 2) return true; } return false; } private const int RELE_MAX_MOVE_COUNT_PER_GAME = 500; public double ReLePlayGame(int[,][] pEvalPositionValuesWhite, int[,][] pEvalPositionValuesBlack, long thinkingTimePerMove) { int[,][] processedValuesWhite = InitReLeAgent(pEvalPositionValuesWhite), processedValuesBlack = InitReLeAgent(pEvalPositionValuesBlack); int tGS, mc = 0; do { if (IsDrawByRepetition(curSearchZobristKeyLine.Length - 5)) return 0d; piecePositionEvals = isWhiteToMove ? processedValuesWhite : processedValuesBlack; MinimaxRoot(thinkingTimePerMove); if (transpositionTable.Count == 0) { SNAPSHOT_WRITLINE_REPLACEMENT("?!"); return 0d; } PlainMakeMove(transpositionTable[zobristKey].bestMove); tGS = GameState(isWhiteToMove); transpositionTable.Clear(); if (tGS != 3) break; } while (mc++ < RELE_MAX_MOVE_COUNT_PER_GAME); if (tGS == 3 || tGS == 0) return 0d; else if (tGS == 1) return 0.1d * (double)(RELE_MAX_MOVE_COUNT_PER_GAME - mc); return 0.1d * (double)(-RELE_MAX_MOVE_COUNT_PER_GAME + mc); } public int[,][] InitReLeAgent(int[,][] pEvalPositionValues) { return GetInterpolatedProcessedValues(pEvalPositionValues); } private int[,][] GetInterpolatedProcessedValues(int[,][] pEvalPositionValues) { int[,][] processedValues = new int[33, 14][]; for (int i = 0; i < 32; i++) { int ip1 = i + 1; processedValues[ip1, 7] = processedValues[ip1, 0] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; processedValues[ip1, 8] = SwapArrayViewingSide(processedValues[ip1, 1] = MultiplyArraysWithVal(pEvalPositionValues[0, 0], pEvalPositionValues[1, 0], pEvalPositionValues[2, 0], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 9] = SwapArrayViewingSide(processedValues[ip1, 2] = MultiplyArraysWithVal(pEvalPositionValues[0, 1], pEvalPositionValues[1, 1], pEvalPositionValues[2, 1], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 10] = SwapArrayViewingSide(processedValues[ip1, 3] = MultiplyArraysWithVal(pEvalPositionValues[0, 2], pEvalPositionValues[1, 2], pEvalPositionValues[2, 2], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 11] = SwapArrayViewingSide(processedValues[ip1, 4] = MultiplyArraysWithVal(pEvalPositionValues[0, 3], pEvalPositionValues[1, 3], pEvalPositionValues[2, 3], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 12] = SwapArrayViewingSide(processedValues[ip1, 5] = MultiplyArraysWithVal(pEvalPositionValues[0, 4], pEvalPositionValues[1, 4], pEvalPositionValues[2, 4], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 13] = SwapArrayViewingSide(processedValues[ip1, 6] = MultiplyArraysWithVal(pEvalPositionValues[0, 5], pEvalPositionValues[1, 5], pEvalPositionValues[2, 5], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); } return processedValues; } private double[,][] GetInterpolatedProcessedValues(double[,][] pEvalPositionValues) { double[,][] processedValues = new double[33, 14][]; for (int i = 0; i < 32; i++) { int ip1 = i + 1; processedValues[ip1, 7] = processedValues[ip1, 0] = new double[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; processedValues[ip1, 8] = SwapArrayViewingSide(processedValues[ip1, 1] = MultiplyArraysWithVal(pEvalPositionValues[0, 0], pEvalPositionValues[1, 0], pEvalPositionValues[2, 0], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 9] = SwapArrayViewingSide(processedValues[ip1, 2] = MultiplyArraysWithVal(pEvalPositionValues[0, 1], pEvalPositionValues[1, 1], pEvalPositionValues[2, 1], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 10] = SwapArrayViewingSide(processedValues[ip1, 3] = MultiplyArraysWithVal(pEvalPositionValues[0, 2], pEvalPositionValues[1, 2], pEvalPositionValues[2, 2], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 11] = SwapArrayViewingSide(processedValues[ip1, 4] = MultiplyArraysWithVal(pEvalPositionValues[0, 3], pEvalPositionValues[1, 3], pEvalPositionValues[2, 3], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 12] = SwapArrayViewingSide(processedValues[ip1, 5] = MultiplyArraysWithVal(pEvalPositionValues[0, 4], pEvalPositionValues[1, 4], pEvalPositionValues[2, 4], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 13] = SwapArrayViewingSide(processedValues[ip1, 6] = MultiplyArraysWithVal(pEvalPositionValues[0, 5], pEvalPositionValues[1, 5], pEvalPositionValues[2, 5], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); } return processedValues; } private double[] MultiplyArraysWithVal(double[] pArr1, double[] pArr2, double[] pArr3, double pVal1, double pVal2, double pVal3) { int tL = pArr1.Length; double[] rArr = new double[tL]; for (int i = 0; i < tL; i++) { rArr[i] = pArr1[i] * pVal1 + pArr2[i] * pVal2 + pArr3[i] * pVal3; } return rArr; } private int[] MultiplyArraysWithVal(int[] pArr1, int[] pArr2, int[] pArr3, double pVal1, double pVal2, double pVal3) { int tL = pArr1.Length; int[] rArr = new int[tL]; for (int i = 0; i < tL; i++) { rArr[i] = (int)(pArr1[i] * pVal1 + pArr2[i] * pVal2 + pArr3[i] * pVal3); } return rArr; } private int[] SwapArrayViewingSideAndNegate(int[] pArr) { return new int[64] { -pArr[56], -pArr[57], -pArr[58], -pArr[59], -pArr[60], -pArr[61], -pArr[62], -pArr[63], -pArr[48], -pArr[49], -pArr[50], -pArr[51], -pArr[52], -pArr[53], -pArr[54], -pArr[55], -pArr[40], -pArr[41], -pArr[42], -pArr[43], -pArr[44], -pArr[45], -pArr[46], -pArr[47], -pArr[32], -pArr[33], -pArr[34], -pArr[35], -pArr[36], -pArr[37], -pArr[38], -pArr[39], -pArr[24], -pArr[25], -pArr[26], -pArr[27], -pArr[28], -pArr[29], -pArr[30], -pArr[31], -pArr[16], -pArr[17], -pArr[18], -pArr[19], -pArr[20], -pArr[21], -pArr[22], -pArr[23], -pArr[8], -pArr[9], -pArr[10], -pArr[11], -pArr[12], -pArr[13], -pArr[14], -pArr[15], -pArr[0], -pArr[1], -pArr[2], -pArr[3], -pArr[4], -pArr[5], -pArr[6], -pArr[7] }; } private int[] SwapArrayViewingSide(int[] pArr) { return new int[64] { pArr[56], pArr[57], pArr[58], pArr[59], pArr[60], pArr[61], pArr[62], pArr[63], pArr[48], pArr[49], pArr[50], pArr[51], pArr[52], pArr[53], pArr[54], pArr[55], pArr[40], pArr[41], pArr[42], pArr[43], pArr[44], pArr[45], pArr[46], pArr[47], pArr[32], pArr[33], pArr[34], pArr[35], pArr[36], pArr[37], pArr[38], pArr[39], pArr[24], pArr[25], pArr[26], pArr[27], pArr[28], pArr[29], pArr[30], pArr[31], pArr[16], pArr[17], pArr[18], pArr[19], pArr[20], pArr[21], pArr[22], pArr[23], pArr[8], pArr[9], pArr[10], pArr[11], pArr[12], pArr[13], pArr[14], pArr[15], pArr[0], pArr[1], pArr[2], pArr[3], pArr[4], pArr[5], pArr[6], pArr[7] }; } private double[] SwapArrayViewingSide(double[] pArr) { return new double[64] { pArr[56], pArr[57], pArr[58], pArr[59], pArr[60], pArr[61], pArr[62], pArr[63], pArr[48], pArr[49], pArr[50], pArr[51], pArr[52], pArr[53], pArr[54], pArr[55], pArr[40], pArr[41], pArr[42], pArr[43], pArr[44], pArr[45], pArr[46], pArr[47], pArr[32], pArr[33], pArr[34], pArr[35], pArr[36], pArr[37], pArr[38], pArr[39], pArr[24], pArr[25], pArr[26], pArr[27], pArr[28], pArr[29], pArr[30], pArr[31], pArr[16], pArr[17], pArr[18], pArr[19], pArr[20], pArr[21], pArr[22], pArr[23], pArr[8], pArr[9], pArr[10], pArr[11], pArr[12], pArr[13], pArr[14], pArr[15], pArr[0], pArr[1], pArr[2], pArr[3], pArr[4], pArr[5], pArr[6], pArr[7] }; } private int[,][] texelTuningRuntimeVals = new int[33, 14][]; private int[,][] texelTuningVals = new int[3, 6][]; private int[,] texelTuningAdjustIterations = new int[6, 64]; private int[][] texelTuningRuntimePositionalValsV2EG = new int[14][]; private int[][] texelTuningRuntimePositionalValsV2LG = new int[14][]; private int[] texelPieceEvaluationsV2EG = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[] texelPieceEvaluationsV2LG = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[] texelKingSafetyR1EvaluationsEG = new int[9]; private int[] texelKingSafetyR2EvaluationsEG = new int[17]; private int[] texelKingSafetyR1EvaluationsLG = new int[9]; private int[] texelKingSafetyR2EvaluationsLG = new int[17]; private int[] texelKingSafetySREvaluationsPT1EG = new int[12]; private int[] texelKingSafetySREvaluationsPT2EG = new int[12]; private int[] texelKingSafetySREvaluationsPT3EG = new int[12]; private int[] texelKingSafetySREvaluationsPT4EG = new int[12]; private int[] texelKingSafetySREvaluationsPT5EG = new int[12]; private int[] texelKingSafetySREvaluationsPT6EG = new int[12]; private int[] texelKingSafetySREvaluationsPT1LG = new int[12]; private int[] texelKingSafetySREvaluationsPT2LG = new int[12]; private int[] texelKingSafetySREvaluationsPT3LG = new int[12]; private int[] texelKingSafetySREvaluationsPT4LG = new int[12]; private int[] texelKingSafetySREvaluationsPT5LG = new int[12]; private int[] texelKingSafetySREvaluationsPT6LG = new int[12]; private int[,] texelMobilityStraightEG = new int[14, 15], texelMobilityStraightLG = new int[14, 15]; private int[,] texelMobilityDiagonalEG = new int[14, 14], texelMobilityDiagonalLG = new int[14, 14]; private int[] texelPieceEvaluations = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[] blackSidedSquares = new int[64] { 56, 57, 58, 59, 60, 61, 62, 63, 48, 49, 50, 51, 52, 53, 54, 55, 40, 41, 42, 43, 44, 45, 46, 47, 32, 33, 34, 35, 36, 37, 38, 39, 24, 25, 26, 27, 28, 29, 30, 31, 16, 17, 18, 19, 20, 21, 22, 23, 08, 09, 10, 11, 12, 13, 14, 15, 00, 01, 02, 03, 04, 05, 06, 07 }; private int[,] T_Pawns = new int[3, 64] { { 0, 0, 0, 0, 0, 0, 0, 0, 98, 134, 61, 95, 68, 126, 34, -11, -6, 7, 26, 31, 65, 56, 25, -20, -14, 13, 6, 21, 23, 12, 17, -23, -27, -2, -5, 12, 17, 6, 10, -25, -26, -4, -4, -10, 3, 3, 33, -12, -35, -1, -20, -23, -15, 24, 38, -22, 0, 0, 0, 0, 0, 0, 0, 0, } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { 0, 0, 0, 0, 0, 0, 0, 0, 178, 173, 158, 134, 147, 132, 165, 187, 94, 100, 85, 67, 56, 53, 82, 84, 32, 24, 13, 5, -2, 4, 17, 17, 13, 9, -3, -7, -7, -8, 3, -1, 4, 7, -6, 1, 0, -5, -1, -8, 13, 8, 8, 10, 13, 0, 2, -7, 0, 0, 0, 0, 0, 0, 0, 0, } }; private int[,] T_Knights = new int[3, 64] { { -167, -89, -34, -49, 61, -97, -15, -107, -73, -41, 72, 36, 23, 62, 7, -17, -47, 60, 37, 65, 84, 129, 73, 44, -9, 17, 19, 53, 37, 69, 18, 22, -13, 4, 16, 13, 28, 19, 21, -8, -23, -9, 12, 10, 19, 17, 25, -16, -29, -53, -12, -3, -1, 18, -14, -19, -105, -21, -58, -33, -17, -28, -19, -23 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -58, -38, -13, -28, -31, -27, -63, -99, -25, -8, -25, -2, -9, -25, -24, -52, -24, -20, 10, 9, -1, -9, -19, -41, -17, 3, 22, 22, 22, 11, 8, -18, -18, -6, 16, 25, 16, 17, 4, -18, -23, -3, -1, 15, 10, -3, -20, -22, -42, -20, -10, -5, -2, -20, -23, -44, -29, -51, -23, -15, -22, -18, -50, -64 } }; private int[,] T_Bishops = new int[3, 64] { { -29, 4, -82, -37, -25, -42, 7, -8, -26, 16, -18, -13, 30, 59, 18, -47, -16, 37, 43, 40, 35, 50, 37, -2, -4, 5, 19, 50, 37, 37, 7, -2, -6, 13, 13, 26, 34, 12, 10, 4, 0, 15, 15, 15, 14, 27, 18, 10, 4, 15, 16, 0, 7, 21, 33, 1, -33, -3, -14, -21, -13, -12, -39, -21 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -14, -21, -11, -8, -7, -9, -17, -24, -8, -4, 7, -12, -3, -13, -4, -14, 2, -8, 0, -1, -2, 6, 0, 4, -3, 9, 12, 9, 14, 10, 3, 2, -6, 3, 13, 19, 7, 10, -3, -9, -12, -3, 8, 10, 13, 3, -7, -15, -14, -18, -7, -1, 4, -9, -15, -27, -23, -9, -23, -5, -9, -16, -5, -17 } }; private int[,] T_Rooks = new int[3, 64] { { 32, 42, 32, 51, 63, 9, 31, 43, 27, 32, 58, 62, 80, 67, 26, 44, -5, 19, 26, 36, 17, 45, 61, 16, -24, -11, 7, 26, 24, 35, -8, -20, -36, -26, -12, -1, 9, -7, 6, -23, -45, -25, -16, -17, 3, 0, -5, -33, -44, -16, -20, -9, -1, 11, -6, -71, -19, -13, 1, 17, 16, 7, -37, -26 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { 13, 10, 18, 15, 12, 12, 8, 5, 11, 13, 13, 11, -3, 3, 8, 3, 7, 7, 7, 5, 4, -3, -5, -3, 4, 3, 13, 1, 2, 1, -1, 2, 3, 5, 8, 4, -5, -6, -8, -11, -4, 0, -5, -1, -7, -12, -8, -16, -6, -6, 0, 2, -9, -9, -11, -3, -9, 2, 3, -1, -5, -13, 4, -20 } }; private int[,] T_Queens = new int[3, 64] { { -28, 0, 29, 12, 59, 44, 43, 45, -24, -39, -5, 1, -16, 57, 28, 54, -13, -17, 7, 8, 29, 56, 47, 57, -27, -27, -16, -16, -1, 17, -2, 1, -9, -26, -9, -10, -2, -4, 3, -3, -14, 2, -11, -2, -5, 2, 14, 5, -35, -8, 11, 2, 8, 15, -3, 1, -1, -18, -9, 10, -15, -25, -31, -50 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -9, 22, 22, 27, 27, 19, 10, 20, -17, 20, 32, 41, 58, 25, 30, 0, -20, 6, 9, 49, 47, 35, 19, 9, 3, 22, 24, 45, 57, 40, 57, 36, -18, 28, 19, 47, 31, 34, 39, 23, -16, -27, 15, 6, 9, 17, 10, 5, -22, -23, -30, -16, -16, -23, -36, -32, -33, -28, -22, -43, -5, -32, -20, -41 } }; private int[,] T_Kings = new int[3, 64] { { -65, 23, 16, -15, -56, -34, 2, 13, 29, -1, -20, -7, -8, -4, -38, -29, -9, 24, 2, -16, -20, 6, 22, -22, -17, -20, -12, -27, -30, -25, -14, -36, -49, -1, -27, -39, -46, -44, -33, -51, -14, -14, -22, -46, -44, -30, -15, -27, 1, 7, -8, -64, -43, -16, 9, 8, -15, 36, 12, -54, 8, -28, 24, 14 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -74, -35, -18, -18, -11, 15, 4, -17, -12, 17, 14, 17, 17, 38, 23, 11, 10, 17, 23, 15, 20, 45, 44, 13, -8, 22, 24, 27, 26, 33, 26, 3, -18, -4, 21, 24, 27, 23, 9, -11, -19, -3, 11, 21, 23, 16, 7, -9, -27, -11, 4, 13, 14, 4, -5, -17, -53, -34, -21, -11, -28, -14, -24, -43 } }; private int[] paramsLowerLimits = new int[5] { -10000, -10000, -10000, -10000, -10000 }; private int[] paramsUpperLimits = new int[5] { 10000, 10000, 10000, 10000, 10000 }; private List<TLM_ChessGame> threadDataset; private int threadFrom, threadTo; private int[] threadParams; private int customThreadID = 0; private ulong ulAllThreadIDsUnfinished = 0; private double lastCostVal = 0d; private double sumCostVals = 0d; private int costCalculations = 0; private readonly string[] TEXELPRINT_GAMEPARTS = new string[3] { "Early Game: ", "Mid Game: ", "Late Game: "}; private readonly string[] TEXELPRINT_PIECES = new string[6] { "Bauer: ", "Springer: ", "Lufer: ", "Turm: ", "Dame: ", "Knig: "}; private double[] earlyGameMultipliers = new double[33]; private double[] middleGameMultipliers = new double[33]; private double[] lateGameMultipliers = new double[33]; private int[] pieceTypeGameProgressImpact = new int[14] { 0, 0, 1, 1, 2, 4, 0, 0, 0, 1, 1, 2, 4, 0 }; private void PrecalculateMultipliers() { if (BOARD_MANAGER_ID == ENGINE_VALS.PARALLEL_BOARDS - 1) SNAPSHOT_WRITLINE_REPLACEMENT(); for (int i = 0; i < 25; i++) { earlyGameMultipliers[i] = EGMultiplierFunction(i); lateGameMultipliers[i] = LGMultiplierFunction(i); if (BOARD_MANAGER_ID == ENGINE_VALS.PARALLEL_BOARDS - 1) SNAPSHOT_WRITLINE_REPLACEMENT("[" + i + "] "+ earlyGameMultipliers[i] + " | "+ middleGameMultipliers[i] + " | "+ lateGameMultipliers[i]); } } private double MultiplierFunction(double pVal, double pXShift) { double d = Math.Exp(1d /6d * (pVal - pXShift)); return 5 * (d /Math.Pow(d + 1, 2d)); } private double EGMultiplierFunction(double pVal) { return Math.Clamp(1 /16d * (pVal - 4d), 0d, 1d); } private double LGMultiplierFunction(double pVal) { return Math.Clamp(1 /-16d * (pVal - 4d) + 1d, 0d, 1d); } private double EGMultiplierFunction2(double pVal) { return Math.Clamp(1 /32d * pVal, 0d, 1d); } private double LGMultiplierFunction2(double pVal) { return Math.Clamp(1 /-32d * pVal + 1d, 0d, 1d); } private void TuneWithTxtFile(string pTXTName) { List<TLM_ChessGame> gameDataset = new List<TLM_ChessGame>(); string tPath = PathManager.GetTXTPath(pTXTName); string[] tStrs = File.ReadAllLines(tPath); List<string> tGames = new List<string>(); foreach (string s in tStrs) if (s.Contains(';') && s.Replace(" ", "") != "") tGames.Add(s); foreach (string s in tGames) { TLM_ChessGame tGame = CGFF.GetGame(s); LoadFenString(tGame.startFen); foreach (int hMove in tGame.hashedMoves) { List<Move> moveOptionList = new List<Move>(); GetLegalMoves(ref moveOptionList); int tL = moveOptionList.Count; for (int j = 0; j < tL; j++) { Move tMove = moveOptionList[j]; if (tMove.moveHash == hMove) { tGame.actualMoves.Add(tMove); PlainMakeMove(tMove); tL = -1; break; } } if (tL != -1) break; } gameDataset.Add(tGame); } SNAPSHOT_WRITLINE_REPLACEMENT("[TLM TEXEL TUNER] " + tGames.Count + " Games Loaded In!"); BOT_MAIN.curTEXELPARAMS = new int[TEXEL_PARAMS]; BOT_MAIN.ParallelTexelTuning(gameDataset); } private void LoadBestTexelParamsIn() { int[] ttt = new int[778] { 82, 341, 416, 470, 1106, 102, 302, 304, 518, 960, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, -46, 0, -20, 0, 64, -21, -71, 37, 29, 6, 98, 13, 44, 0, -26, -14, -36, -20, 94, 16, 60, 10, -62, -19, -38, -8, -28, 14, -26, -4, -32, -28, -52, 30, 56, -40, -72, -22, 100, 4, -98, -34, 6, -49, 32, -10, 72, 20, 84, -56, -60, -112, 128, -28, 152, 34, 26, -52, 200, -56, 76, 44, -56, -113, -156, 188, -39, 28, 200, -90, -60, -86, 100, -178, -119, -200, 200, 200, -20, -22, -78, -158, -200, 196, 200, -200, -200, -200, 104, 200, 138, -122, 200, 200, 124, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 200, 156, -37, -68, -148, -200, 200, -70, 72, 76, -31, -200, -21, 178, -200, 200, 200, -200, 123, -188, -6, 164, -74, 24, -28, -8, 71, -50, -112, -200, -8, -44, 27, -23, -50, 19, 19, 41, 150, 152, 4, -98, -36, -34, 174, -106, -16, 17, 141, -48, -108, 162, 6, -112, -52, 76, 68, 8, -86, 68, -176, 189, 81, 162, -200, 152, -41, 128, 172, -173, -144, 56, 22, 94, -28, 32, 16, -63, 36, -200, -200, -200, -22, 56, -116, 76, -36, -30, 100, 52, -166, -114, 142, -52, -44, -200, -18, -72, 60, 200, -160, 96, 46, -200, -28, -32, -44, 132, 60, -200, -137, -200, -176, 200, -200, -200, 4, 200, -200, 72, 200, -78, 200, 160, -105, 200, 96, -114, 200, 200, -88, -24, 11, -34, 184, 26, 83, -140, 10, -16, -72, -200, 12, -200, 46, -200, 11, 82, 66, -102, 22, -184, 32, 114, 140, -26, -18, -36, 66, 100, 25, -24, 133, -96, 50, 2, 80, 184, 43, -136, 44, 124, -148, 180, 69, -126, -200, 6, 78, -96, 89, -68, 200, -116, 114, 158, 5, -154, 115, 200, -152, -171, 41, -80, -23, 137, 98, -80, 40, -42, 200, 52, 146, 200, 6, -112, 32, 200, 132, 4, 90, -200, -200, 104, 67, -56, 186, 124, 140, 97, -144, 200, -4, -160, -117, -200, 24, -80, 200, 28, -46, -24, -52, -200, -200, 72, 20, 34, 200, -16, 88, 56, 200, -146, 120, 174, 200, -200, -86, 125, 172, -70, 4, 124, -72, 0, -2, 70, -14, 48, -32, 200, 80, 24, -132, 74, -44, 184, -4, -136, 0, -16, 20, -18, -32, 96, 92, 56, 2, 174, 196, -200, -56, -116, 88, 200, -8, 168, -13, 74, -106, 200, -182, 80, 82, -128, -16, 90, -200, 66, -88, 58, -16, 80, -34, 96, -95, -96, -200, 76, 26, -72, 32, -27, -108, 164, 200, -36, -93, -10, -56, 22, 36, 74, -200, -96, 200, 88, -88, 156, -92, 96, -200, 200, 191, -8, 62, -8, -100, 136, -72, -36, 200, -64, -114, 153, -110, 174, 46, 108, 142, 121, -200, 108, -200, 74, -4, 104, -200, 116, 82, 200, -76, 176, -200, 76, -8, 200, 46, 29, -86, 12, -24, -80, -12, 200, 124, -16, 54, 104, 200, -94, 140, 36, 32, -64, 24, -178, 15, -200, 0, -200, 4, -32, -124, 148, 176, 192, 90, 164, -91, 200, 172, -200, 64, 34, 40, -200, 0, -200, 12, -124, 48, -200, -56, 184, -8, -184, 0, 200, -16, 200, -8, 180, -18, -20, 24, -200, -58, 174, -200, 40, -4, -200, -24, 200, 54, 200, -24, -32, 37, 192, 48, 44, 26, 200, -22, 200, -145, -200, 30, 86, 54, 200, -102, -34, 94, -98, 92, -200, -76, 196, -18, -200, -180, 16, 186, -92, -200, -200, 164, -200, 62, 192, 159, -112, -12, -70, 184, 104, 200, -200, -148, -4, 86, -144, 200, -100, 200, 200, -104, 114, 132, -168, 12, 56, -10, 82, 200, -200, -200, -196, -6, 52, -200, 84, 200, -192, 128, 200, -200, -200, 200, 88, 168, -32, -84, 172, 52, -172, 0, -40, 68, -186, 42, 96, -200, -198, 200, -56, -176, 88, 0, 86, 16, -124, -46, 40, -16, -4, 54, -184, 200, 58, -200, 77, -200, -44, 102, 0, -50, -10, -92, 100, -86, 8, 20, -20, -200, 38, -200, -49, -4, 2, -200, 78, 0, -40, -92, 32, 0, -164, -88, -38, -138, -118, 29, -34, -200, -200, -200, -71, -200, 200, -200, -108, -200, 0, 192, -24, 104, -200, 200, 190, -28, -200, -200, -200, 128, -96, 200, 200, 200, 200, -200, -200, 177, -24, 200, 132, 200, -190, 200, -130, 200, 148, 200, 200, -200, -100, 200, -196, -200, 90, 200, -200, 200, 200, -200, -200, -200, -200, -200, 118, -200, 85, -200, 166, 199, -200 }; SetupTexelEvaluationParams(ttt); } private void SetupTexelEvaluationParams(int[] pParams) { texelPieceEvaluationsV2EG[8] = -(texelPieceEvaluationsV2EG[1] = pParams[0]); texelPieceEvaluationsV2EG[9] = -(texelPieceEvaluationsV2EG[2] = pParams[1]); texelPieceEvaluationsV2EG[10] = -(texelPieceEvaluationsV2EG[3] = pParams[2]); texelPieceEvaluationsV2EG[11] = -(texelPieceEvaluationsV2EG[4] = pParams[3]); texelPieceEvaluationsV2EG[12] = -(texelPieceEvaluationsV2EG[5] = pParams[4]); texelPieceEvaluationsV2LG[8] = -(texelPieceEvaluationsV2LG[1] = pParams[5]); texelPieceEvaluationsV2LG[9] = -(texelPieceEvaluationsV2LG[2] = pParams[6]); texelPieceEvaluationsV2LG[10] = -(texelPieceEvaluationsV2LG[3] = pParams[7]); texelPieceEvaluationsV2LG[11] = -(texelPieceEvaluationsV2LG[4] = pParams[8]); texelPieceEvaluationsV2LG[12] = -(texelPieceEvaluationsV2LG[5] = pParams[9]); int c = 10; for (int p = 1; p < 7; p++) { for (int s = 0; s < 64; s++) { texelTuningRuntimePositionalValsV2EG[p + 7][blackSidedSquares[s]] = -(texelTuningRuntimePositionalValsV2EG[p][s] = pParams[c++]); texelTuningRuntimePositionalValsV2LG[p + 7][blackSidedSquares[s]] = -(texelTuningRuntimePositionalValsV2LG[p][s] = pParams[c++]); } } return; for (int p = 2; p < 7; p++) { for (int a = 0; a < 15; a++) { if (a != 14) { texelMobilityDiagonalEG[p + 7, a] = -(texelMobilityDiagonalEG[p, a] = pParams[c++]); texelMobilityDiagonalLG[p + 7, a] = -(texelMobilityDiagonalLG[p, a] = pParams[c++]); } texelMobilityStraightEG[p + 7, a] = -(texelMobilityStraightEG[p, a] = pParams[c++]); texelMobilityStraightLG[p + 7, a] = -(texelMobilityStraightLG[p, a] = pParams[c++]); } } for (int i = 0; i < 12; i++) { texelKingSafetySREvaluationsPT1EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT2EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT3EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT4EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT5EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT6EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT1LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT2LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT3LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT4LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT5LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT6LG[i] = pParams[c++]; } } private void PrintDefinedTexelParams(int[] pParams) { int c = 0; for (int t = 0; t < 3; t++) { SNAPSHOT_WRITLINE_REPLACEMENT(TEXELPRINT_GAMEPARTS[t]); for (int p = 0; p < 6; p++) { SNAPSHOT_WRITLINE_REPLACEMENT(TEXELPRINT_PIECES[p]); texelTuningVals[t, p] = new int[64]; for (int s = 0; s < 64; s++) { if (s % 8 == 0 && s != 0) SNAPSHOT_WRITLINE_REPLACEMENT(); SNAPSHOT_WRITLINE_REPLACEMENT((texelTuningVals[t, p][s] = pParams[c++]) + ", "); } SNAPSHOT_WRITLINE_REPLACEMENT(); } } piecePositionEvals = GetInterpolatedProcessedValues(texelTuningVals); } public void TLMTuning(List<TLM_ChessGame> pDataset) { int tGameDataSetLen = pDataset.Count; int[,][] tRatio = new int[33, 6][]; int[,][] tTotalMoves = new int[33, 6][]; double[,][] tSummedRatios = new double[33, 6][]; double[,][] tSummedDataAmount = new double[33, 6][]; double[,][] tTuningResults = new double[33, 6][]; for (int t = 1; t < 33; t++) { for (int p = 0; p < 6; p++) { tRatio[t, p] = new int[64]; tTotalMoves[t, p] = new int[64]; tSummedRatios[t, p] = new double[64]; tSummedDataAmount[t, p] = new double[64]; tTuningResults[t, p] = new double[64]; } } for (int j = 0; j < tGameDataSetLen; j++) { TLM_ChessGame tGame = pDataset[j]; int tGR = tGame.gameResult - 1; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count - 5; for (int i = 0; i < tL; i++) { if (tGame.isMoveNonTactical[i]) { int tPieceAmount = ULONG_OPERATIONS.CountBits(allPieceBitboard); for (int s = 0; s < 64; s++) { int tPT = pieceTypeArray[s] - 1; if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, s)) { tTotalMoves[tPieceAmount, tPT][s]++; tRatio[tPieceAmount, tPT][s] += tGR; } else if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, s)) { int b = blackSidedSquares[s]; tTotalMoves[tPieceAmount, tPT][b]++; tRatio[tPieceAmount, tPT][b] += tGR; } } } PlainMakeMove(tGame.actualMoves[i]); } } double[,] allMultipliers = new double[33, 33]; for (int sh = 0; sh < 33; sh++) { for (int i = 0; i < 33; i++) { allMultipliers[sh, i] = MultiplierFunction(i, sh); } } for (int t = 1; t < 33; t++) { for (int p = 0; p < 6; p++) { for (int s = 0; s < 64; s++) { for (int t2 = 1; t2 < 33; t2++) { double cmult = allMultipliers[t, t2]; tSummedRatios[t, p][s] += tRatio[t2, p][s] * cmult; tSummedDataAmount[t, p][s] += tTotalMoves[t2, p][s] * cmult; } tTuningResults[t, p][s] = TTT(tSummedRatios[t, p][s], tSummedDataAmount[t, p][s]); } } } int c = 0; int[] tparams = new int[1152]; for (int t = 1; t < 33; t += 15) { if (t == 31) t = 32; SNAPSHOT_WRITLINE_REPLACEMENT("PieceCount = " + t + ": "); for (int p = 0; p < 6; p++) { SNAPSHOT_WRITLINE_REPLACEMENT(TEXELPRINT_PIECES[p]); for (int s = 0; s < 64; s++) { if (s % 8 == 0 && s != 0) SNAPSHOT_WRITLINE_REPLACEMENT(); SNAPSHOT_WRITLINE_REPLACEMENT((tparams[c++] = (int)(tTuningResults[t, p][s] * 100)).ToString().Replace(",", ".") + "("+ (int)tSummedDataAmount[t, p][s] + ")"+ ", "); } SNAPSHOT_WRITLINE_REPLACEMENT(); } } string tS = "PARAMS: {"; for (int i = 0; i < tparams.Length; i++) tS += tparams[i] + ","; tS = tS.Substring(0, tS.Length - 1) + "}\n"; SNAPSHOT_WRITLINE_REPLACEMENT(tS); TexelTuning(pDataset, tparams); } private double TTT(double d1, double d2) { if (d2 == 0) return 0; return d1 /d2; } public void TexelTuning(List<TLM_ChessGame> pDataset, int[] pCurBestParams) { Stopwatch sw = Stopwatch.StartNew(); string tPath = PathManager.GetTXTPath("OTHER/TEXEL_TUNING"); int paramCount = pCurBestParams.Length; double bestAvrgCost = CalculateAverageTexelCost(pDataset, pCurBestParams); SNAPSHOT_WRITLINE_REPLACEMENT("CUR PARAMS COST: " + bestAvrgCost); int packetSize = Math.Clamp(paramCount /ENGINE_VALS.CPU_CORES, 1, 100000); paramsLowerLimits = new int[paramCount]; paramsUpperLimits = new int[paramCount]; for (int i = 0; i < paramCount; i++) { int lim = i < 10 ? 100000 : 200; paramsLowerLimits[i] = -lim; paramsUpperLimits[i] = lim; } SNAPSHOT_WRITLINE_REPLACEMENT("PARAM-COUNT: " + paramCount); SNAPSHOT_WRITLINE_REPLACEMENT("PACKET-SIZE: " + packetSize); while (packetSize <= paramCount) { BOT_MAIN.TEXELfinished = 0; int lM = 0, tC = 0; ulong tUL = 0ul; for (int m = packetSize; lM < paramCount; m += packetSize) { if (m > paramCount) m = paramCount; tUL = ULONG_OPERATIONS.SetBitToOne(tUL, ++tC); lM = m; } tC = lM = 0; for (int m = packetSize; lM < paramCount; m += packetSize) { if (m > paramCount) m = paramCount; tC++; BOT_MAIN.boardManagers[tC].SetPlayTexelVals(pDataset, lM, m, pCurBestParams, paramsLowerLimits, paramsUpperLimits, tC, tUL); ThreadPool.QueueUserWorkItem(new WaitCallback(BOT_MAIN.boardManagers[tC].TexelTuningThreadedPackage)); lM = m; } packetSize = paramCount + 1; int tmod = 0; while (tC != BOT_MAIN.TEXELfinished) { if (++tmod % 20 == 0) { WriteTexelParamsToTXT(tPath, BOT_MAIN.curTEXELPARAMS); SNAPSHOT_WRITLINE_REPLACEMENT(CalculateAverageTexelCost(pDataset, BOT_MAIN.curTEXELPARAMS) + " | "+ BOT_MAIN.TEXELadjustmentsmade); SNAPSHOT_WRITLINE_REPLACEMENT(ULONG_OPERATIONS.GetBitVisualization(BOT_MAIN.TEXELfinishedwithoutimpovement)); } Thread.Sleep(100); } SNAPSHOT_WRITLINE_REPLACEMENT("One Thread Generation FINISHED! :) :) :)"); pCurBestParams = BOT_MAIN.curTEXELPARAMS; } sw.Stop(); WriteTexelParamsToTXT(tPath, BOT_MAIN.curTEXELPARAMS); SNAPSHOT_WRITLINE_REPLACEMENT("END COST: " + CalculateAverageTexelCost(pDataset, BOT_MAIN.curTEXELPARAMS)); SNAPSHOT_WRITLINE_REPLACEMENT(BOT_MAIN.TEXELadjustmentsmade); SNAPSHOT_WRITLINE_REPLACEMENT(sw.ElapsedMilliseconds); } public void TexelTuningThreadedPackage(object obj) { SNAPSHOT_WRITLINE_REPLACEMENT("Started CThreadID [" + customThreadID + "] which is handling Params ["+ threadFrom + "] - ["+ threadTo + "]"); bool firstIter = true; do { double bestAvrgCost = CalculateAverageTexelCost(threadDataset, threadParams); int adjust_val = firstIter ? 512 : 8; do { adjust_val /= 2; bool improvedAvrgCost = true; while (improvedAvrgCost) { improvedAvrgCost = false; for (int i = threadFrom; i < threadTo; i++) { bool improvedWithThisParam = true; int tadjustval = adjust_val; bool lastTimeMaximized = false, lastTimeMinimized = false; while (improvedWithThisParam) { improvedWithThisParam = false; int[] curParams = (int[])threadParams.Clone(); int paramBefore = curParams[i]; curParams[i] = Math.Clamp(paramBefore + adjust_val, paramsLowerLimits[i], paramsUpperLimits[i]); double curAvrgCost = CalculateAverageTexelCost(threadDataset, curParams); if (curAvrgCost < bestAvrgCost) { improvedAvrgCost = true; improvedWithThisParam = true; SNAPSHOT_WRITLINE_REPLACEMENT("Improved Param [" + i + "] at CThreadID ["+ customThreadID + "]: +"+ adjust_val + " ("+ GetDoublePrecentageString(bestAvrgCost - curAvrgCost) + ")"); bestAvrgCost = curAvrgCost; threadParams = curParams; BOT_MAIN.TEXELadjustmentsmade++; BOT_MAIN.TEXELfinishedwithoutimpovement = ulAllThreadIDsUnfinished; if (lastTimeMaximized) { adjust_val *= 4; lastTimeMaximized = false; } else lastTimeMaximized = true; lastTimeMinimized = false; } else { curParams[i] = Math.Clamp(paramBefore - adjust_val, paramsLowerLimits[i], paramsUpperLimits[i]); curAvrgCost = CalculateAverageTexelCost(threadDataset, curParams); if (curAvrgCost < bestAvrgCost) { improvedAvrgCost = true; improvedWithThisParam = true; SNAPSHOT_WRITLINE_REPLACEMENT("Improved Param [" + i + "] at CThreadID ["+ customThreadID + "]: -"+ adjust_val + " ("+ GetDoublePrecentageString(bestAvrgCost - curAvrgCost) + ")"); bestAvrgCost = curAvrgCost; threadParams = curParams; BOT_MAIN.TEXELadjustmentsmade++; BOT_MAIN.TEXELfinishedwithoutimpovement = ulAllThreadIDsUnfinished; if (lastTimeMinimized) { adjust_val *= 4; lastTimeMinimized = false; } else lastTimeMinimized = true; lastTimeMaximized = false; } } if (adjust_val != 1) adjust_val /= 2; for (int j = threadFrom; j < threadTo; j++) { BOT_MAIN.curTEXELPARAMS[j] = threadParams[j]; } threadParams = (int[])BOT_MAIN.curTEXELPARAMS.Clone(); bestAvrgCost = CalculateAverageTexelCost(threadDataset, threadParams); } adjust_val = tadjustval; } } } while (adjust_val != 1); BOT_MAIN.TEXELfinishedwithoutimpovement = ULONG_OPERATIONS.SetBitToZero(BOT_MAIN.TEXELfinishedwithoutimpovement, customThreadID); SNAPSHOT_WRITLINE_REPLACEMENT("FULLY FINISHED " + customThreadID + ". IMPROVEMENT THREAD PACKAGE CYCLE"); firstIter = false; } while (BOT_MAIN.TEXELfinishedwithoutimpovement != 0); BOT_MAIN.TEXELfinished++; } private void WriteTexelParamsToTXT(string pPath, int[] pParams) { try { string tS = "PARAMS: {"; for (int i = 0; i < pParams.Length; i++) tS += pParams[i] + ","; tS = tS.Substring(0, tS.Length - 1) + "}\n"; File.AppendAllText(pPath, tS); } catch { SNAPSHOT_WRITLINE_REPLACEMENT("Mal wieder TXT zu lange gebraucht um zu aktualisieren."); } } private double costSum = 0d; private int texelCostMovesEvaluated = 0; private double CalculateAverageTexelCost(List<TLM_ChessGame> tDataset, int[] pParams, bool pFullCost = true) { costSum = 0d; texelCostMovesEvaluated = 0; SetupTexelEvaluationParams(pParams); int tGameDataSetLen = tDataset.Count; int start = 0, end = tGameDataSetLen; if (!pFullCost) { end = (start = globalRandom.Next(0, end - 256)) + 256; } for (int j = start; j < end; j++) { TLM_ChessGame tGame = tDataset[j]; double tGR = tGame.gameResult; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count - 5; texelCostMovesEvaluated += tL; for (int i = 0; i < tL; i++) { costSum += TexelCost(tGR - TexelTuningSigmoid(TexelEvaluate())); PlainMakeMove(tGame.actualMoves[i]); } } return costSum /texelCostMovesEvaluated; } private double CalculateAverageTexelCostThreadedVersionLEGACYDOESNTWORK(List<TLM_ChessGame> tDataset, int[] pParams) { Stopwatch sw = Stopwatch.StartNew(); BOT_MAIN.TEXELcostSum = 0d; BOT_MAIN.TEXELfinished = 0; BOT_MAIN.TEXELcostMovesEvaluated = 0; int tGameDataSetLen = tDataset.Count; int gamesPerThread = tGameDataSetLen /ENGINE_VALS.CPU_CORES; for (int i = 0; i < ENGINE_VALS.CPU_CORES - 1; i++) { } for (int i = 0; i < ENGINE_VALS.CPU_CORES - 1; i++) { } while (BOT_MAIN.TEXELfinished != ENGINE_VALS.CPU_CORES) Thread.Sleep(1); sw.Stop(); return BOT_MAIN.TEXELcostSum /BOT_MAIN.TEXELcostMovesEvaluated; } public void SetPlayThroughVals(List<TLM_ChessGame> pDataset, int pFrom, int pTo) { threadDataset = pDataset; threadFrom = pFrom; threadTo = pTo; } public void SetPlayTexelVals(List<TLM_ChessGame> pDataset, int pFrom, int pTo, int[] pTexelParams, int[] pLowerLimits, int[] pUpperLimits, int pThreadID, ulong pUL) { threadDataset = pDataset; threadFrom = pFrom; threadTo = pTo; threadParams = pTexelParams; paramsLowerLimits = pLowerLimits; paramsUpperLimits = pUpperLimits; customThreadID = pThreadID; ulAllThreadIDsUnfinished = pUL; } public void PlayThroughSetOfGames(object obj) { SNAPSHOT_WRITLINE_REPLACEMENT(threadFrom + "->"+ threadTo); int sortedOut = 0; for (int j = threadFrom; j < threadTo; j++) { TLM_ChessGame tGame = threadDataset[j]; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count; for (int i = 0; i < tL; i++) { int tQuietEval = isWhiteToMove ? QuiescenceWhite(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, 0, PreMinimaxCheckCheckWhite(), NULL_MOVE) : QuiescenceBlack(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, 0, PreMinimaxCheckCheckBlack(), NULL_MOVE); bool tB; tGame.isMoveNonTactical.Add(tB = (Evaluate() == tQuietEval && i > 4)); if (!tB) sortedOut++; PlainMakeMove(tGame.actualMoves[i]); } } BOT_MAIN.TEXELsortedout += sortedOut; BOT_MAIN.TEXELfinished++; } public void CalculateAverageTexelCostThreadFunction(object obj) { SetupTexelEvaluationParams(threadParams); double d = 0d; for (int j = threadFrom; j < threadTo; j++) { TLM_ChessGame tGame = threadDataset[j]; double tGR = tGame.gameResult; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count - 5; BOT_MAIN.TEXELcostMovesEvaluated += tL; for (int i = 0; i < tL; i++) { d += TexelCost(tGR - TexelTuningSigmoid(TexelEvaluate())); PlainMakeMove(tGame.actualMoves[i]); } } BOT_MAIN.TEXELcostSum += d; BOT_MAIN.TEXELfinished++; } private void ConsoleWriteLineTuneArray<T>(T[,][] pArr) { for (int j = 0; j < 3; j++) { SNAPSHOT_WRITLINE_REPLACEMENT("{"); for (int k = 0; k < 6; k++) { SNAPSHOT_WRITLINE_REPLACEMENT("{"); for (int s = 0; s < 64; s++) SNAPSHOT_WRITLINE_REPLACEMENT(pArr[j, k][s] + ", "); SNAPSHOT_WRITLINE_REPLACEMENT("\n}"); } SNAPSHOT_WRITLINE_REPLACEMENT("}"); } } private void Tune(string pGameCGFF, double pLearningRate) { TLM_ChessGame tGame = CGFF.GetGame(pGameCGFF); LoadFenString(tGame.startFen); double tDGameResult = tGame.gameResult; foreach (int hMove in tGame.hashedMoves) { Tune(tDGameResult, pLearningRate); List<Move> moveOptionList = new List<Move>(); GetLegalMoves(ref moveOptionList); int tL = moveOptionList.Count; for (int i = 0; i < tL; i++) { Move tMove = moveOptionList[i]; if (tMove.moveHash == hMove) { PlainMakeMove(tMove); tL = -1; break; } } if (tL != -1) break; } } private void Tune(double pGameResult, double pLearningRate) { int tPC = ULONG_OPERATIONS.CountBits(allPieceBitboard); double oneThroughPieceCount = 1d /tPC; double egMult = earlyGameMultipliers[tPC], mgMult = middleGameMultipliers[tPC], lgMult = lateGameMultipliers[tPC]; double tTexelResult = TexelEvaluateF(); double tSigmoidedTexelResult = TexelSigmoid(tTexelResult); double tDif = tSigmoidedTexelResult - pGameResult; double tM = oneThroughPieceCount * TexelCostDerivative(tDif) * TexelSigmoidDerivative(tTexelResult) * pLearningRate; sumCostVals += lastCostVal = TexelCost(tDif); costCalculations++; for (int i = 0; i < 64; i++) { if (ULONG_OPERATIONS.IsBitZero(allPieceBitboard, i)) continue; int tPT = pieceTypeArray[i] - 1, tI = i; if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, i)) tI = blackSidedSquares[i]; texelTuningAdjustIterations[tPT, tI]++; } } private double TexelEvaluateF() { texelTuningRuntimeVals = GetInterpolatedProcessedValues(texelTuningVals); return TexelEvaluate(); } private int TexelEvaluate() { int tEvalEG = 0, tEvalLG = 0, tProgress = 0; ulong[] attkULs = new ulong[14]; for (int p = 0; p < 64; p++) { if (((int)(allPieceBitboard >> p) & 1) == 0) continue; int aPT = pieceTypeArray[p], tPT = aPT + 7 * ((int)(blackPieceBitboard >> p) & 1); tEvalEG += texelTuningRuntimePositionalValsV2EG[tPT][p] + texelPieceEvaluationsV2EG[tPT]; tEvalLG += texelTuningRuntimePositionalValsV2LG[tPT][p] + texelPieceEvaluationsV2LG[tPT]; tProgress += pieceTypeGameProgressImpact[tPT]; } if (tProgress > 24) tProgress = 24; return (int)(earlyGameMultipliers[tProgress] * tEvalEG + lateGameMultipliers[tProgress] * tEvalLG); } private const double TexelK = 0.2; private double TexelTuningSigmoid(double pVal) { return 2d /(1 + Math.Pow(10, -TexelK * pVal /400)); } private double TexelSigmoid(double pVal) { return 2d /(Math.Exp(-0.04d * pVal) + 1d); } private double TexelSigmoidDerivative(double pVal) { double d = Math.Exp(-0.04d * pVal); return 2d * d /(25d * (d + 1d) * (d + 1d)); } private double TexelCost(double pVal) { return pVal * pVal; } private double TexelCostDerivative(double pVal) { return 2 * pVal; } private char[] fenPieces = new char[7] { 'z', 'p', 'n', 'b', 'r', 'q', 'k' }; private string[] squareNames = new string[64] { "a1", "b1", "c1", "d1", "e1", "f1", "g1", "h1", "a2", "b2", "c2", "d2", "e2", "f2", "g2", "h2", "a3", "b3", "c3", "d3", "e3", "f3", "g3", "h3", "a4", "b4", "c4", "d4", "e4", "f4", "g4", "h4", "a5", "b5", "c5", "d5", "e5", "f5", "g5", "h5", "a6", "b6", "c6", "d6", "e6", "f6", "g6", "h6", "a7", "b7", "c7", "d7", "e7", "f7", "g7", "h7", "a8", "b8", "c8", "d8", "e8", "f8", "g8", "h8"}; public string CreateFenString() { string rFEN = ""; for (int i = 7; i >= 0; i--) { int t = 0; for (int j = 0; j < 8; j++) { int sq = i * 8 + j; if (pieceTypeArray[sq] != 0) { if (t != 0) rFEN += t; t = 0; } if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, sq)) { switch (pieceTypeArray[sq]) { case 0: t++; SNAPSHOT_WRITLINE_REPLACEMENT("???"); break; case 1: rFEN += 'P'; break; case 2: rFEN += 'N'; break; case 3: rFEN += 'B'; break; case 4: rFEN += 'R'; break; case 5: rFEN += 'Q'; break; case 6: rFEN += 'K'; break; } } else { switch (pieceTypeArray[sq]) { case 0: t++; break; case 1: rFEN += 'p'; break; case 2: rFEN += 'n'; break; case 3: rFEN += 'b'; break; case 4: rFEN += 'r'; break; case 5: rFEN += 'q'; break; case 6: rFEN += 'k'; break; } } } if (t != 0) rFEN += t; if (i != 0) rFEN += "/"; } rFEN += (isWhiteToMove ? " w": " b"); rFEN += (whiteCastleRightKingSide ? " K": " "); rFEN += (whiteCastleRightQueenSide ? "Q": ""); rFEN += (blackCastleRightKingSide ? "k": ""); rFEN += (blackCastleRightQueenSide ? "q": ""); if (!whiteCastleRightKingSide && !whiteCastleRightQueenSide && !blackCastleRightKingSide && !blackCastleRightQueenSide) rFEN += "-"; if (enPassantSquare < 64) rFEN += " "+ squareNames[enPassantSquare] + " "; else rFEN += " - "; return rFEN + fiftyMoveRuleCounter + " "+ ((happenedHalfMoves - happenedHalfMoves % 2) /2); } public void LoadFenString(string fenStr) { lastMadeMove = NULL_MOVE; zobristKey = 0ul; whitePieceBitboard = blackPieceBitboard = allPieceBitboard = 0ul; for (int i = 0; i < 64; i++) pieceTypeArray[i] = 0; string[] spaceSpl = fenStr.Split(' '); string[] rowSpl = spaceSpl[0].Split('/'); string epstr = spaceSpl[3]; if (epstr == "-") enPassantSquare = 65; else enPassantSquare = (epstr[0] - 'a') + 8 * (epstr[1] - '1'); isWhiteToMove = true; if (spaceSpl[1] == "b") isWhiteToMove = false; if (!isWhiteToMove) zobristKey ^= blackTurnHash; string crstr = spaceSpl[2]; whiteCastleRightKingSide = whiteCastleRightQueenSide = blackCastleRightKingSide = blackCastleRightQueenSide = false; int crStrL = crstr.Length; for (int i = 0; i < crStrL; i++) { switch (crstr[i]) { case 'K': whiteCastleRightKingSide = true; break; case 'Q': whiteCastleRightQueenSide = true; break; case 'k': blackCastleRightKingSide = true; break; case 'q': blackCastleRightQueenSide = true; break; } } fiftyMoveRuleCounter = Convert.ToInt32(spaceSpl[4]); happenedHalfMoves = Convert.ToInt32(spaceSpl[5]) * 2; if (!isWhiteToMove) happenedHalfMoves++; int tSq = 0; for (int i = rowSpl.Length; i-- > 0;) { string tStr = rowSpl[i]; int tStrLen = tStr.Length; for (int c = 0; c < tStrLen; c++) { char tChar = tStr[c]; if (Char.IsDigit(tChar)) tSq += tChar - '0'; else { bool tCol = Char.IsLower(tChar); if (tCol) blackPieceBitboard = ULONG_OPERATIONS.SetBitToOne(blackPieceBitboard, tSq); else whitePieceBitboard = ULONG_OPERATIONS.SetBitToOne(whitePieceBitboard, tSq); if (tChar == 'k') blackKingSquare = tSq; else if (tChar == 'K') whiteKingSquare = tSq; pieceTypeArray[tSq] = Array.IndexOf(fenPieces, Char.ToLower(tChar)); if (tCol) zobristKey ^= pieceHashesBlack[tSq, pieceTypeArray[tSq]]; else zobristKey ^= pieceHashesWhite[tSq, pieceTypeArray[tSq]]; tSq++; } } } if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; zobristKey ^= enPassantSquareHashes[enPassantSquare]; allPieceBitboard = whitePieceBitboard | blackPieceBitboard; if (zobristKey == 16260251586586513106) moveHashList.Clear(); else { moveHashList.Clear(); moveHashList.Add(1); moveHashList.Add(2); moveHashList.Add(3); } } private ulong[,] pieceHashesWhite = new ulong[64, 7], pieceHashesBlack = new ulong[64, 7]; private ulong blackTurnHash, whiteKingSideRochadeRightHash, whiteQueenSideRochadeRightHash, blackKingSideRochadeRightHash, blackQueenSideRochadeRightHash; private ulong[] enPassantSquareHashes = new ulong[66]; private Dictionary<ulong, int> singleCheckCaseBackup = new Dictionary<ulong, int>(); private void InitZobrist() { Random rng = new Random(31415926); for (int sq = 0; sq < 64; sq++) { enPassantSquareHashes[sq] = ULONG_OPERATIONS.GetRandomULONG(rng); for (int it = 1; it < 7; it++) { pieceHashesWhite[sq, it] = ULONG_OPERATIONS.GetRandomULONG(rng); pieceHashesBlack[sq, it] = ULONG_OPERATIONS.GetRandomULONG(rng); } } blackTurnHash = ULONG_OPERATIONS.GetRandomULONG(rng); whiteKingSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); whiteQueenSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); blackKingSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); blackQueenSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); } public void SetKnightMasks(ulong[] uls) { knightSquareBitboards = uls; } public void SetKingMasks(ulong[] uls) { kingSquareBitboards = uls; } private Move[,] whiteEnPassantMoves = new Move[64, 64]; private Move[,] blackEnPassantMoves = new Move[64, 64]; private bool[] epValidationArray = new bool[64] { false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true , true , true , true , true , true , true , true, true , true , true , true , true , true , true , true, true , true , true , true , true , true , true , true, true , true , true , true , true , true , true , true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false }; private ulong[] kingSafetyRing1 = new ulong[64], kingSafetyRing2 = new ulong[64]; private ulong[] kingSafetySpecialRingW = new ulong[64], kingSafetySpecialRingB = new ulong[64]; private ulong[] rowPrecalcs = new ulong[8], columnPrecalcs = new ulong[8]; const ulong columnUL = 0x101010101010101, rowUL = 0b11111111; private void PrecalculateKingSafetyBitboards() { for (int i = 0; i < 8; i++) { rowPrecalcs[i] = rowUL << (8 * i); columnPrecalcs[i] = columnUL << i; } for (int i = 0; i < 64; i++) { int tMod = i % 8; int tRow = (i - tMod) /8; ulong tULC = columnPrecalcs[tMod], tULR = rowPrecalcs[tRow]; ulong tULC2 = columnPrecalcs[tMod], tULR2 = rowPrecalcs[tRow]; if (tMod < 7) tULC |= columnPrecalcs[tMod + 1]; if (tMod > 0) tULC |= columnPrecalcs[tMod - 1]; if (tRow < 7) tULR |= rowPrecalcs[tRow + 1]; if (tRow > 0) tULR |= rowPrecalcs[tRow - 1]; if (tMod < 6) tULC2 |= columnPrecalcs[tMod + 2]; if (tMod > 1) tULC2 |= columnPrecalcs[tMod - 2]; if (tRow < 6) tULR2 |= rowPrecalcs[tRow + 2]; if (tRow > 1) tULR2 |= rowPrecalcs[tRow - 2]; tULR2 |= tULR; tULC2 |= tULC; kingSafetyRing1[i] = ULONG_OPERATIONS.SetBitToZero(tULR & tULC, i); kingSafetyRing2[i] = ULONG_OPERATIONS.SetBitsToZero(tULR2 & tULC2, i, i + 1, i - 1, i + 7, i + 8, i + 9, i - 7, i - 8, i - 9); } for (int i = 0; i < 64; i++) { if (i < 56) kingSafetySpecialRingW[i] = ULONG_OPERATIONS.SetBitToZero(kingSafetyRing1[i] | kingSafetyRing1[i + 8], i); else kingSafetySpecialRingW[i] = kingSafetyRing1[i]; if (i > 7) kingSafetySpecialRingB[i] = ULONG_OPERATIONS.SetBitToZero(kingSafetyRing1[i] | kingSafetyRing1[i - 8], i); else kingSafetySpecialRingB[i] = kingSafetyRing1[i]; } } private void PrecalculateEnPassantMoves() { for (int i = 0; i < 64; i++) { if (!epValidationArray[i]) continue; for (int j = 0; j < 64; j++) { if (i == j) continue; if (Math.Abs(i - j) > 9) continue; if (!epValidationArray[j]) continue; whiteEnPassantMoves[i, j] = new Move(false, i, j, j - 8); blackEnPassantMoves[i, j] = new Move(false, i, j, j + 8); } } } private void PawnAttackBitboards() { for (int sq = 0; sq < 64; sq++) { ulong u = 0ul; if (sq % 8 != 0) u = ULONG_OPERATIONS.SetBitToOne(u, sq + 7); if (sq % 8 != 7) u = ULONG_OPERATIONS.SetBitToOne(u, sq + 9); whitePawnAttackSquareBitboards[sq] = u; u = 0ul; if (sq % 8 != 0 && sq - 9 > -1) u = ULONG_OPERATIONS.SetBitToOne(u, sq - 9); if (sq % 8 != 7 && sq - 7 > -1) u = ULONG_OPERATIONS.SetBitToOne(u, sq - 7); blackPawnAttackSquareBitboards[sq] = u; } } private int[] squareConnectivesPrecalculationArray = new int[4096]; public int[] squareConnectivesCrossDirsPrecalculationArray { get; set; } = new int[4096]; private ulong[] squareConnectivesPrecalculationRayArray = new ulong[4096]; private ulong[] squareConnectivesPrecalculationLineArray = new ulong[4096]; private List<Dictionary<ulong, int>> rayCollidingSquareCalculations = new List<Dictionary<ulong, int>>(); private readonly int[] maxIntWithSpecifiedBitcount = new int[8] { 0, 0b1, 0b11, 0b111, 0b1111, 0b11111, 0b111111, 0b1111111 }; private List<ulong> differentRays = new List<ulong>(); private void SquareConnectivesPrecalculations() { for (int square = 0; square < 64; square++) { rayCollidingSquareCalculations.Add(new Dictionary<ulong, int>()); rayCollidingSquareCalculations[square].Add(0ul, square); for (int square2 = 0; square2 < 64; square2++) { if (square == square2) continue; int t = 0, t2 = 0, difSign = Math.Sign(square2 - square), itSq = square, g = 0; ulong tRay = 0ul, tExclRay = 0ul; List<int> tRayInts = new List<int>(); if (difSign == -1) g = 7; if (square % 8 == square2 % 8) { t2 = t = 1; while ((itSq += difSign * 8) < 64 && itSq > -1) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } } else if ((square - square % 8) == (square2 - square2 % 8)) { t = 1; t2 = -1; while ((itSq += difSign) % 8 != g && itSq > -1 && itSq < 64) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } } else { int dif = Math.Abs(square2 - square); if (dif % 7 == 0) { t = 2; t2 = 2; g = (difSign == 1) ? 7 : 0; while ((itSq += difSign * 7) % 8 != g && itSq < 64 && itSq > -1) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } if (ULONG_OPERATIONS.IsBitZero(tRay, square2)) { t2 = t = 0; tRay = 0ul; } } else if (dif % 9 == 0) { t = 2; t2 = -2; if (square == 0 && square2 == 63 || square == 63 && square2 == 0) SNAPSHOT_WRITLINE_REPLACEMENT("!"); while ((itSq += difSign * 9) % 8 != g && itSq < 64 && itSq > -1) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } if (ULONG_OPERATIONS.IsBitZero(tRay, square2)) { t2 = t = 0; tRay = 0ul; } } } if (square == 0 && square2 == 63) { t2 = t = 2; tRayInts.Clear(); tExclRay = tRay = ULONG_OPERATIONS.SetBitsToOne(0ul, 9, 18, 27, 36, 45, 54, 63); tRayInts = new List<int>() { 9, 18, 27, 36, 45, 54, 63 }; } else if (square2 == 0 && square == 63) { t = 2; tRayInts.Clear(); t2 = -2; tExclRay = tRay = ULONG_OPERATIONS.SetBitsToOne(0ul, 0, 9, 18, 27, 36, 45, 54); tRayInts = new List<int>() { 54, 45, 36, 27, 18, 9, 0 }; } if (tRay != 0ul && !differentRays.Contains(tRay)) { differentRays.Add(tRay); int ccount, combI = maxIntWithSpecifiedBitcount[ccount = ULONG_OPERATIONS.CountBits(tRay)]; do { ulong curAllPieceBitboard = 0ul; int solution = square; for (int j = 0; j < ccount; j++) { if (((combI >> j) & 1) == 1) { curAllPieceBitboard = ULONG_OPERATIONS.SetBitToOne(curAllPieceBitboard, tRayInts[j]); if (solution == square) solution = tRayInts[j]; } } rayCollidingSquareCalculations[square].Add(curAllPieceBitboard, solution); } while (--combI != 0); } squareConnectivesPrecalculationArray[square << 6 | square2] = t; squareConnectivesPrecalculationRayArray[square << 6 | square2] = tRay; squareConnectivesCrossDirsPrecalculationArray[square << 6 | square2] = t2; if (t != 0) squareConnectivesPrecalculationLineArray[square << 6 | square2] = (square == 0 && square2 == 63 || square2 == 0 && square == 63) ? tExclRay : ULONG_OPERATIONS.SetBitToOne(tExclRay, square2); if (squareConnectivesPrecalculationLineArray[square << 6 | square2] == 0ul && ULONG_OPERATIONS.IsBitOne(knightSquareBitboards[square], square2)) squareConnectivesPrecalculationLineArray[square << 6 | square2] = 1ul << square2; } differentRays.Clear(); } } public void SNAPSHOT_WRITLINE_REPLACEMENT() { } public void SNAPSHOT_WRITLINE_REPLACEMENT(object pStr) { } private string GetDoublePrecentageString(double pVal) { return ((int)(pVal * 1_000_000) /10_000d) + "%"; } private string ReplaceAllULONGIsBitOne(string pCode) { const string METHOD_NAME = "ULONG_OPERATIONS.IsBitOne"; int METHOD_NAME_LEN = METHOD_NAME.Length, iterations = 0; int pIndex = pCode.IndexOf(METHOD_NAME); while (pIndex != -1 && ++iterations < 10_000) { List<int> paramIndexes = new List<int>(); int openedBracketCount = 1, closedBracketCount = 0, a = METHOD_NAME_LEN + pIndex; string tpCode = pCode.Substring(0, pIndex); paramIndexes.Add(a + 1); while (++a < pCode.Length) { switch (pCode[a]) { case '(': openedBracketCount++; break; case ')': if (++closedBracketCount == openedBracketCount) { pIndex = a; a = int.MaxValue - 5; } break; case ',': if (openedBracketCount - closedBracketCount == 1) paramIndexes.Add(a + 1); break; } } if (openedBracketCount == closedBracketCount && paramIndexes.Count == 2) { tpCode += "((int)("+ pCode.Substring(paramIndexes[0], paramIndexes[1] - paramIndexes[0] - 1) + (pCode[paramIndexes[1]] == ' ' ? " >> (": " >> (") + pCode.Substring(paramIndexes[1], pIndex - paramIndexes[1]) + ")) & 1) == 1"+ pCode.Substring(pIndex + 1, pCode.Length - pIndex - 1); } pIndex = (pCode = tpCode).IndexOf(METHOD_NAME); } SNAPSHOT_WRITLINE_REPLACEMENT(iterations + " ITERATIONS"); return pCode; } private string ReplaceAllULONGIsBitZero(string pCode) { const string METHOD_NAME = "ULONG_OPERATIONS.IsBitZero"; int METHOD_NAME_LEN = METHOD_NAME.Length, iterations = 0; int pIndex = pCode.IndexOf(METHOD_NAME); while (pIndex != -1 && ++iterations < 10_000) { List<int> paramIndexes = new List<int>(); int openedBracketCount = 1, closedBracketCount = 0, a = METHOD_NAME_LEN + pIndex; string tpCode = pCode.Substring(0, pIndex); paramIndexes.Add(a + 1); while (++a < pCode.Length) { switch (pCode[a]) { case '(': openedBracketCount++; break; case ')': if (++closedBracketCount == openedBracketCount) { pIndex = a; a = int.MaxValue - 5; } break; case ',': if (openedBracketCount - closedBracketCount == 1) paramIndexes.Add(a + 1); break; } } if (openedBracketCount == closedBracketCount && paramIndexes.Count == 2) { tpCode += "((int)("+ pCode.Substring(paramIndexes[0], paramIndexes[1] - paramIndexes[0] - 1) + (pCode[paramIndexes[1]] == ' ' ? " >>": " >> ") + pCode.Substring(paramIndexes[1], pIndex - paramIndexes[1]) + ") & 1) == 0"+ pCode.Substring(pIndex + 1, pCode.Length - pIndex - 1); } pIndex = (pCode = tpCode).IndexOf(METHOD_NAME); } SNAPSHOT_WRITLINE_REPLACEMENT(iterations + " ITERATIONS"); return pCode; } private string GetThreeDigitSeperatedInteger(int pInt) { string s = pInt.ToString(), r = s[0].ToString(); int t = s.Length % 3; for (int i = 1; i < s.Length; i++) { if (i % 3 == t) r += "."; r += s[i]; } s = ""; for (int i = 0; i < r.Length; i++) s += r[i]; return s; } public double GetAverageDepth() { return (double)depths /(double)searches; } }
public class SNAPSHOT_V01_00_009 : IBoardManager  { public int TEXEL_PARAMS { get; } = 778; private const int BESTMOVE_SORT_VAL = -2_000_000_000; private const int CAPTURE_SORT_VAL = -1_000_000_000; private const int KILLERMOVE_SORT_VAL = -1000; private readonly int[,] MVVLVA_TABLE = new int[7, 7] { { 0, 0, 0, 0, 0, 0, 0 }, { 0, 1500, 1400, 1300, 1200, 1100, 1000 }, { 0, 3500, 3400, 3300, 3200, 3100, 3000 }, { 0, 4500, 4400, 4300, 4200, 4100, 4000 }, { 0, 5500, 5400, 5300, 5200, 5100, 5000 }, { 0, 9500, 9400, 9300, 9200, 9100, 9000 }, { 0, 0, 0, 0, 0, 0, 0 }}; private int BOARD_MANAGER_ID = -1; private bool debugSearchDepthResults = false; private bool debugSortResults = false; private RookMovement rookMovement; private BishopMovement bishopMovement; private QueenMovement queenMovement; private KnightMovement knightMovement; private KingMovement kingMovement; private WhitePawnMovement whitePawnMovement; private BlackPawnMovement blackPawnMovement; private Rays rays; public List<Move> moveOptionList { get; set; } private int[] pieceTypeArray = new int[64]; public ulong whitePieceBitboard, blackPieceBitboard, allPieceBitboard; private ulong zobristKey; private int whiteKingSquare, blackKingSquare, enPassantSquare = 65, happenedHalfMoves = 0, fiftyMoveRuleCounter = 0; private bool whiteCastleRightKingSide, whiteCastleRightQueenSide, blackCastleRightKingSide, blackCastleRightQueenSide; private bool isWhiteToMove; private const ulong WHITE_KING_ROCHADE = 96, WHITE_QUEEN_ROCHADE = 14, BLACK_KING_ROCHADE = 6917529027641081856, BLACK_QUEEN_ROCHADE = 1008806316530991104, WHITE_QUEEN_ATTK_ROCHADE = 12, BLACK_QUEEN_ATTK_ROCHADE = 864691128455135232; private readonly Move mWHITE_KING_ROCHADE = new Move(4, 6, 7, 5), mWHITE_QUEEN_ROCHADE = new Move(4, 2, 0, 3), mBLACK_KING_ROCHADE = new Move(60, 62, 63, 61), mBLACK_QUEEN_ROCHADE = new Move(60, 58, 56, 59); private ulong[] knightSquareBitboards = new ulong[64]; private ulong[] whitePawnAttackSquareBitboards = new ulong[64]; private ulong[] blackPawnAttackSquareBitboards = new ulong[64]; private ulong[] kingSquareBitboards = new ulong[64]; private bool[,] pieceTypeAbilities = new bool[7, 3] { { false, false, false }, { false, false, false }, { false, false, false }, { false, false, true }, { false, true, false }, { false, true, true }, { false, false, false } }; private List<int> moveHashList = new List<int>(); private ulong[] curSearchZobristKeyLine = Array.Empty<ulong>(); private Move[] debugMoveList = new Move[128]; private string debugFEN = ""; private Stopwatch globalTimer = Stopwatch.StartNew(); private Move lastMadeMove; private int depths, searches; private Random globalRandom = new Random(); public SNAPSHOT_V01_00_009(string fen) { Setup(fen); } public void Setup(string pFen) { Stopwatch setupStopwatch = Stopwatch.StartNew(); BOARD_MANAGER_ID = BOT_MAIN.curBoardManagerID; for (int i = 0; i < 33; i++) for (int j = 0; j < 14; j++) piecePositionEvals[i, j] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; for (int i = 0; i < 33; i++) for (int j = 0; j < 14; j++) texelTuningRuntimeVals[i, j] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; for (int i = 0; i < 3; i++) for (int j = 0; j < 6; j++) texelTuningVals[i, j] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; for (int i = 0; i < 14; i++) { texelTuningRuntimePositionalValsV2EG[i] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; texelTuningRuntimePositionalValsV2LG[i] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; } PrecalculateKingSafetyBitboards(); PrecalculateMultipliers(); GetLowNoisePositionalEvaluation(globalRandom); MinimaxRoot(1L); SetupConsoleWrite("[PRECALCS] Zobrist Hashing"); InitZobrist(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Knight Movement"); knightMovement = new KnightMovement(this); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Square Connectives"); SquareConnectivesPrecalculations(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Pawn Attack Bitboards"); PawnAttackBitboards(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Rays"); rays = new Rays(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); queenMovement = new QueenMovement(this); SetupConsoleWrite("[PRECALCS] Rook Movement"); rookMovement = new RookMovement(this, queenMovement); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Bishop Movement"); bishopMovement = new BishopMovement(this, queenMovement); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] King Movement"); kingMovement = new KingMovement(this); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Pawn Movement"); whitePawnMovement = new WhitePawnMovement(this); blackPawnMovement = new BlackPawnMovement(this); PrecalculateEnPassantMoves(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWriteLine("[DONE]\n\n"); LoadFenString(pFen); LoadBestTexelParamsIn(); setupStopwatch.Stop(); } private void SetupConsoleWriteLine(string pStr) { if (BOT_MAIN.isFirstBoardManagerInitialized) return; SNAPSHOT_WRITLINE_REPLACEMENT(pStr); } private void SetupConsoleWrite(string pStr) { if (BOT_MAIN.isFirstBoardManagerInitialized) return; SNAPSHOT_WRITLINE_REPLACEMENT(pStr); } public void GetLowNoisePositionalEvaluation(System.Random rng) { int[,][] digitArray = new int[3, 6][]; for (int i = 0; i < 3; i++) for (int j = 0; j < 6; j++) digitArray[i, j] = GetRand64IntArray(rng, -5, 6); lowNoisePositionEvals1 = GetInterpolatedProcessedValues(digitArray); int[,][] digitArray2 = new int[3, 6][]; for (int i = 0; i < 3; i++) for (int j = 0; j < 6; j++) digitArray2[i, j] = GetRand64IntArray(rng, -5, 6); lowNoisePositionEvals2 = GetInterpolatedProcessedValues(digitArray2); } private int[] GetRand64IntArray(System.Random rng, int pMin, int pMax) { return new int[64] { rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax) }; } private string GetAIArrayValuesStringRepresentation(int[,][] pArr) { string r = "int[,][] ReLe_AI_RESULT_VALS = new int[3, 6][] {"; for (int i = 0; i < 3; i++) { r += "{"; for (int j = 0; j < 5; j++) { r += GetIntArray64LStringRepresentation(pArr[i, j]) + ","; } r += GetIntArray64LStringRepresentation(pArr[i, 5]) + "},"; } return r.Substring(0, r.Length - 1) + "};"; } private string GetIntArray64LStringRepresentation(int[] p64LArr) { if (p64LArr == null) return ""; string r = "new int[64]{"; for (int i = 0; i < 63; i++) { r += p64LArr[i] + ","; } return r + p64LArr[63] + "}"; } public void TempStuff() { } private string[] gameResultStrings = new string[5] { "Black Has Won!", "Draw!", "White Has Won!", "Non Existant Result!", "Game is Ongoing!"}; private int[,][] lowNoisePositionEvals1, lowNoisePositionEvals2; public void ThreadSelfPlay(object obj) { PlayGameAgainstItself(obj); } public void PlayGameAgainstItself(object obj, string pStartFEN = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1", long tickLimitForEngine = ENGINE_VALS.SELF_PLAY_THINK_TIME) { int ttGState; while (BOT_MAIN.goalGameCount > BOT_MAIN.gamesPlayed) { try { string tGameStr; GetLowNoisePositionalEvaluation(globalRandom); LoadFenString(tGameStr = pStartFEN); tGameStr += ";"; int tGState = 3, tmc = 0; bool lowNoiceDecider = globalRandom.NextDouble() < 0.5d; while (tGState == 3) { piecePositionEvals = lowNoiceDecider ? lowNoisePositionEvals1 : lowNoisePositionEvals2; MinimaxRoot(tickLimitForEngine); Move tM = transpositionTable[zobristKey].bestMove; PlainMakeMove(tM); tGameStr += NuCRe.GetNuCRe(tM.moveHash) + ","; BOT_MAIN.movesPlayed++; tGState = GameState(isWhiteToMove); lowNoiceDecider = !lowNoiceDecider; tmc++; } ttGState = tGState; tGameStr += ttGState + 1; SNAPSHOT_WRITLINE_REPLACEMENT(tGameStr); BOT_MAIN.gamesPlayedResultArray[ttGState + 1]++; BOT_MAIN.gamesPlayed++; BOT_MAIN.selfPlayGameStrings.Add(tGameStr); } catch (Exception tE) { SNAPSHOT_WRITLINE_REPLACEMENT(tE.ToString()); } } } public void PlayGameOnConsoleAgainstHuman(string pStartFEN = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1", bool pHumanPlaysWhite = true, long tickLimitForEngine = 10_000_000L) { debugSearchDepthResults = true; LoadFenString(pStartFEN); if (!(pHumanPlaysWhite ^ isWhiteToMove)) { var pVS = Console.ReadLine(); if (pVS == null) return; Move tm = GetMoveOfString(pVS.ToString()); SNAPSHOT_WRITLINE_REPLACEMENT(tm); PlainMakeMove(tm); } int tGState = 3; while (tGState == 3) { MinimaxRoot(tickLimitForEngine); PlayThroughZobristTree(); Move tM = transpositionTable[zobristKey].bestMove; SNAPSHOT_WRITLINE_REPLACEMENT(tM); SNAPSHOT_WRITLINE_REPLACEMENT(CreateFenString()); PlainMakeMove(tM); tGState = GameState(isWhiteToMove); if (tGState != 3 || tM == NULL_MOVE) break; var pV = ""; tM = NULL_MOVE; do { pV = Console.ReadLine(); if (pV == null) continue; tM = GetMoveOfString(pV.ToString()); SNAPSHOT_WRITLINE_REPLACEMENT(tM); } while (tM == NULL_MOVE); PlainMakeMove(tM); tGState = GameState(isWhiteToMove); } } private void PlayThroughZobristTree() { SetJumpState(); SNAPSHOT_WRITLINE_REPLACEMENT("\n- - - - - - - - - - - - -"); int tC = 1; Dictionary<ulong, bool> usedULs = new Dictionary<ulong, bool>(); while (transpositionTable.TryGetValue(zobristKey, out TranspositionEntry tM)) { if (usedULs.ContainsKey(zobristKey)) { SNAPSHOT_WRITLINE_REPLACEMENT(tC + ": AT LEAST ONE REPETION; REST NOT VISIBLE"); break; } SNAPSHOT_WRITLINE_REPLACEMENT(tC + ": "+ tM.bestMove + " > "); usedULs.Add(zobristKey, true); PlainMakeMove(tM.bestMove); tC++; } SNAPSHOT_WRITLINE_REPLACEMENT("- - - - - - - - - - - - -\n"); LoadJumpState(); } public Move? ReturnNextMove(Move? lastMove, long pThinkingTime) { if (lastMove != null) PlainMakeMove(lastMove); if (GameState(isWhiteToMove) != 3) return null; MinimaxRoot(pThinkingTime); if (!transpositionTable.ContainsKey(zobristKey)) return null; Move tm = transpositionTable[zobristKey].bestMove; PlainMakeMove(tm); return tm; } private int[] jmpSt_pieceTypeArray; private ulong jmpSt_whitePieceBitboard, jmpSt_blackPieceBitboard; private ulong jmpSt_zobristKey; private int jmpSt_whiteKingSquare, jmpSt_blackKingSquare, jmpSt_enPassantSquare, jmpSt_happenedHalfMoves, jmpSt_fiftyMoveRuleCounter; private bool jmpSt_whiteCastleRightKingSide, jmpSt_whiteCastleRightQueenSide, jmpSt_blackCastleRightKingSide, jmpSt_blackCastleRightQueenSide; private bool jmpSt_isWhiteToMove; private ulong[] jmpSt_curSearchZobristKeyLine; private int[] jmpSt_moveHashList; public void LoadJumpState() { pieceTypeArray = (int[])jmpSt_pieceTypeArray.Clone(); whitePieceBitboard = jmpSt_whitePieceBitboard; blackPieceBitboard = jmpSt_blackPieceBitboard; zobristKey = jmpSt_zobristKey; whiteKingSquare = jmpSt_whiteKingSquare; blackKingSquare = jmpSt_blackKingSquare; enPassantSquare = jmpSt_enPassantSquare; happenedHalfMoves = jmpSt_happenedHalfMoves; fiftyMoveRuleCounter = jmpSt_fiftyMoveRuleCounter; whiteCastleRightKingSide = jmpSt_whiteCastleRightKingSide; whiteCastleRightQueenSide = jmpSt_whiteCastleRightQueenSide; blackCastleRightKingSide = jmpSt_blackCastleRightKingSide; blackCastleRightQueenSide = jmpSt_blackCastleRightQueenSide; isWhiteToMove = jmpSt_isWhiteToMove; curSearchZobristKeyLine = (ulong[])jmpSt_curSearchZobristKeyLine.Clone(); allPieceBitboard = blackPieceBitboard | whitePieceBitboard; moveHashList = jmpSt_moveHashList.ToList(); } public void SetJumpState() { jmpSt_pieceTypeArray = (int[])pieceTypeArray.Clone(); jmpSt_whitePieceBitboard = whitePieceBitboard; jmpSt_blackPieceBitboard = blackPieceBitboard; jmpSt_zobristKey = zobristKey; jmpSt_whiteKingSquare = whiteKingSquare; jmpSt_blackKingSquare = blackKingSquare; jmpSt_enPassantSquare = enPassantSquare; jmpSt_happenedHalfMoves = happenedHalfMoves; jmpSt_fiftyMoveRuleCounter = fiftyMoveRuleCounter; jmpSt_whiteCastleRightKingSide = whiteCastleRightKingSide; jmpSt_whiteCastleRightQueenSide = whiteCastleRightQueenSide; jmpSt_blackCastleRightKingSide = blackCastleRightKingSide; jmpSt_blackCastleRightQueenSide = blackCastleRightQueenSide; jmpSt_isWhiteToMove = isWhiteToMove; jmpSt_curSearchZobristKeyLine = (ulong[])curSearchZobristKeyLine.Clone(); jmpSt_moveHashList = moveHashList.ToArray(); } private int PreMinimaxCheckCheckWhite() { ulong bitShiftedKingPos = 1ul << whiteKingSquare; int curR = -1; for (int p = 0; p < 64; p++) { if (ULONG_OPERATIONS.IsBitZero(blackPieceBitboard, p)) continue; int tPT; switch (tPT = pieceTypeArray[p]) { case 1: if ((bitShiftedKingPos & blackPawnAttackSquareBitboards[p]) != 0ul) return p; break; case 2: if ((bitShiftedKingPos & knightSquareBitboards[p]) != 0ul) return p; break; case 6: break; default: if ((squareConnectivesPrecalculationLineArray[whiteKingSquare << 6 | p] & allPieceBitboard) == (1ul << p) && pieceTypeAbilities[tPT, squareConnectivesPrecalculationArray[whiteKingSquare << 6 | p]]) { if (curR != -1) return -779; curR = p; } break; } } return curR; } private int PreMinimaxCheckCheckBlack() { ulong bitShiftedKingPos = 1ul << blackKingSquare; int curR = -1; for (int p = 0; p < 64; p++) { if (ULONG_OPERATIONS.IsBitZero(whitePieceBitboard, p)) continue; int tPT; switch (tPT = pieceTypeArray[p]) { case 1: if ((bitShiftedKingPos & whitePawnAttackSquareBitboards[p]) != 0ul) return p; break; case 2: if ((bitShiftedKingPos & knightSquareBitboards[p]) != 0ul) return p; break; case 6: break; default: if ((squareConnectivesPrecalculationLineArray[blackKingSquare << 6 | p] & allPieceBitboard) == (1ul << p) && pieceTypeAbilities[tPT, squareConnectivesPrecalculationArray[blackKingSquare << 6 | p]]) { if (curR != -1) return -779; curR = p; } break; } } return curR; } private int LecacyLeafCheckingPieceCheckWhite(int pStartPos, int pEndPos, int pPieceType) { int tI, tPossibleAttackPiece; if (pPieceType == 1) { if (ULONG_OPERATIONS.IsBitOne(blackPawnAttackSquareBitboards[pEndPos], whiteKingSquare)) return pEndPos; } else if (pPieceType == 2) { if (ULONG_OPERATIONS.IsBitOne(knightSquareBitboards[pEndPos], whiteKingSquare)) return pEndPos; } else if (pPieceType != 6) { tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | pEndPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; } tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | pStartPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; return -1; } private int LecacyLeafCheckingPieceCheckBlack(int pStartPos, int pEndPos, int pPieceType) { int tI, tPossibleAttackPiece; if (pPieceType == 1) { if (ULONG_OPERATIONS.IsBitOne(whitePawnAttackSquareBitboards[pEndPos], blackKingSquare)) return pEndPos; } else if (pPieceType == 2) { if (ULONG_OPERATIONS.IsBitOne(knightSquareBitboards[pEndPos], blackKingSquare)) return pEndPos; } else if (pPieceType != 6) { tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | pEndPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; } tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | pStartPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; return -1; } public void GetLegalMoves(ref List<Move> pMoveList) { int attk; if (isWhiteToMove) { attk = PreMinimaxCheckCheckWhite(); if (attk == -779) GetLegalWhiteMovesSpecialDoubleCheckCase(ref pMoveList); else GetLegalWhiteMoves(attk, ref pMoveList); } else { attk = PreMinimaxCheckCheckBlack(); if (attk == -779) GetLegalBlackMovesSpecialDoubleCheckCase(ref pMoveList); else GetLegalBlackMoves(attk, ref pMoveList); } } private void GetLegalWhiteMoves(int pCheckingPieceSquare, ref List<Move> pMoveList) { if (pCheckingPieceSquare == -779) { GetLegalWhiteMovesSpecialDoubleCheckCase(ref pMoveList); return; } moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= blackPawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, whiteKingSquare); if (curCheckCount == 0) { if (whiteCastleRightKingSide && ((allPieceBitboard | oppAttkBitboard) & WHITE_KING_ROCHADE) == 0ul) pMoveList.Add(mWHITE_KING_ROCHADE); if (whiteCastleRightQueenSide && (allPieceBitboard & WHITE_QUEEN_ROCHADE | oppAttkBitboard & WHITE_QUEEN_ATTK_ROCHADE) == 0ul) pMoveList.Add(mWHITE_QUEEN_ROCHADE); if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, whitePieceBitboard, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[whiteKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare + 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, whitePieceBitboard, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveList(whiteKingSquare, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalWhiteCaptures(int pCheckingPieceSquare, ref List<Move> pMoveList) { if (pCheckingPieceSquare == -779) { GetLegalWhiteCapturesSpecialDoubleCheckCase(ref pMoveList); return; } moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= blackPawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, whiteKingSquare); if (curCheckCount == 0) { if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & blackPieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[whiteKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare + 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & blackPieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveListOnlyCaptures(whiteKingSquare, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalWhiteMovesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= blackPawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveList(whiteKingSquare, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalWhiteCapturesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= blackPawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveListOnlyCaptures(whiteKingSquare, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalBlackMoves(int pCheckingPieceSquare, ref List<Move> pMoveList) { if (pCheckingPieceSquare == -779) { GetLegalBlackMovesSpecialDoubleCheckCase(ref pMoveList); return; } moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= whitePawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, blackKingSquare); if (curCheckCount == 0) { if (blackCastleRightKingSide && ((allPieceBitboard | oppAttkBitboard) & BLACK_KING_ROCHADE) == 0ul) pMoveList.Add(mBLACK_KING_ROCHADE); if (blackCastleRightQueenSide && (allPieceBitboard & BLACK_QUEEN_ROCHADE | oppAttkBitboard & BLACK_QUEEN_ATTK_ROCHADE) == 0ul) pMoveList.Add(mBLACK_QUEEN_ROCHADE); if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveList(p, blackKingSquare, blackPieceBitboard, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[blackKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare - 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveList(p, blackKingSquare, blackPieceBitboard, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveList(blackKingSquare, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); } private void GetLegalBlackCaptures(int pCheckingPieceSquare, ref List<Move> pMoveList) { if (pCheckingPieceSquare == -779) { GetLegalBlackCapturesSpecialDoubleCheckCase(ref pMoveList); return; } moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= whitePawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, blackKingSquare); if (curCheckCount == 0) { if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & whitePieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[blackKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare - 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & whitePieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveListOnlyCaptures(blackKingSquare, ~oppAttkBitboard & whitePieceBitboard); } private void GetLegalBlackMovesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= whitePawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveList(blackKingSquare, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); } private void GetLegalBlackCapturesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= whitePawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveListOnlyCaptures(blackKingSquare, ~oppAttkBitboard & whitePieceBitboard); } public Move GetMoveOfString(string pMove) { int tSP, tEP; string[] tSpl = pMove.Split(','); if (Char.IsNumber(pMove[0])) { tSP = Convert.ToInt32(tSpl[0]); tEP = Convert.ToInt32(tSpl[1]); } else { tSP = SQUARES.NumberNotation(tSpl[0]); tEP = SQUARES.NumberNotation(tSpl[1]); } int tPT = pieceTypeArray[tSP]; bool tIC = ULONG_OPERATIONS.IsBitOne(allPieceBitboard, tEP), tIEP = enPassantSquare == tEP && tPT == 1; if (tSpl.Length == 3) return new Move(tSP, tEP, tPT, Convert.ToInt32(tSpl[2]), tIC); if (tIEP) return new Move(true, tSP, tEP, isWhiteToMove ? tEP - 8 : tEP + 8); if (tPT == 1 && Math.Abs(tSP - tEP) > 11) return new Move(tSP, tEP, 1, false, isWhiteToMove ? tSP + 8 : tSP - 8); if (tPT == 6 && (Math.Abs(tSP - tEP) == 2 || Math.Abs(tSP - tEP) == 3)) { if (isWhiteToMove) return tEP == 6 ? mWHITE_KING_ROCHADE : mWHITE_QUEEN_ROCHADE; return tEP == 62 ? mBLACK_KING_ROCHADE : mBLACK_QUEEN_ROCHADE; } return new Move(tSP, tEP, tPT, tIC); } public void PlainMakeMove(string pMoveName) { PlainMakeMove(GetMoveOfString(pMoveName)); } public void PlainMakeMove(Move pMove) { lastMadeMove = pMove; if (isWhiteToMove) WhiteMakeMove(pMove); else BlackMakeMove(pMove); debugFEN = CreateFenString(); } public void WhiteMakeMove(Move pMove) { int tEndPos = pMove.endPos, tStartPos = pMove.startPos, tPieceType = pMove.pieceType, tPTI = pieceTypeArray[tEndPos]; fiftyMoveRuleCounter++; whitePieceBitboard ^= pMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey ^= blackTurnHash ^ enPassantSquareHashes[enPassantSquare] ^ pieceHashesWhite[tStartPos, tPieceType] ^ pieceHashesWhite[tEndPos, tPieceType]; enPassantSquare = 65; isWhiteToMove = false; switch (pMove.moveTypeID) { case 0: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 1: fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 2: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 3: whiteKingSquare = tEndPos; if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 4: if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 5: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 6: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 7: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[whiteKingSquare = tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 8: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 9: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = pMove.enPassantOption]; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 11: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; whiteKingSquare = tEndPos; pieceTypeArray[pMove.rochadeEndPos] = 4; pieceTypeArray[pMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesWhite[pMove.rochadeStartPos, 4] ^ pieceHashesWhite[pMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 12: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[pMove.enPassantOption] = 0; zobristKey ^= pieceHashesBlack[pMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 13: fiftyMoveRuleCounter = 0; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; zobristKey ^= pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, pMove.promotionType]; break; case 14: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, tPTI] ^ pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, pMove.promotionType]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; } moveHashList.Add(pMove.moveHash); if (pMove.isCapture || tPieceType == 1) { curSearchZobristKeyLine = Array.Empty<ulong>(); return; } ulong[] u = new ulong[(tPTI = curSearchZobristKeyLine.Length) + 1]; for (int i = tPTI; i-- > 0;) u[i] = curSearchZobristKeyLine[i]; u[tPTI] = zobristKey; curSearchZobristKeyLine = u; } public void BlackMakeMove(Move pMove) { int tEndPos = pMove.endPos, tStartPos = pMove.startPos, tPieceType = pMove.pieceType, tPTI = pieceTypeArray[tEndPos]; fiftyMoveRuleCounter++; blackPieceBitboard ^= pMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey ^= blackTurnHash ^ enPassantSquareHashes[enPassantSquare] ^ pieceHashesBlack[tStartPos, tPieceType] ^ pieceHashesBlack[tEndPos, tPieceType]; enPassantSquare = 65; isWhiteToMove = true; switch (pMove.moveTypeID) { case 0: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 1: fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 2: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 3: blackKingSquare = tEndPos; if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 4: if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 5: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 6: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 7: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[blackKingSquare = tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 8: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 9: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = pMove.enPassantOption]; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 11: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; blackKingSquare = tEndPos; pieceTypeArray[pMove.rochadeEndPos] = 4; pieceTypeArray[pMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesBlack[pMove.rochadeStartPos, 4] ^ pieceHashesBlack[pMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 12: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[pMove.enPassantOption] = 0; zobristKey ^= pieceHashesWhite[pMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 13: fiftyMoveRuleCounter = 0; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, pMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 14: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } zobristKey ^= pieceHashesWhite[tEndPos, tPTI] ^ pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, pMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; } moveHashList.Add(pMove.moveHash); if (pMove.isCapture || tPieceType == 1) { curSearchZobristKeyLine = Array.Empty<ulong>(); return; } ulong[] u = new ulong[(tPTI = curSearchZobristKeyLine.Length) + 1]; for (int i = tPTI; i-- > 0;) u[i] = curSearchZobristKeyLine[i]; u[tPTI] = zobristKey; curSearchZobristKeyLine = u; } public void WhiteUndoMove(Move pMove) { } private const int WHITE_CHECKMATE_VAL = 100000, BLACK_CHECKMATE_VAL = -100000, CHECK_EXTENSION_LENGTH = -12, MAX_QUIESCENCE_TOTAL_LENGTH = -32; private readonly Move NULL_MOVE = new Move(0, 0, 0); private int curSearchDepth = 0, curSubSearchDepth = -1; public int MinimaxRoot(long pTime) { evalCount = 0; searches++; int baseLineLen = 0; long tTimestamp = globalTimer.ElapsedTicks + pTime; ClearHeuristics(); transpositionTable.Clear(); ulong[] tZobristKeyLine = Array.Empty<ulong>(); if (curSearchZobristKeyLine != null) { baseLineLen = curSearchZobristKeyLine.Length; tZobristKeyLine = new ulong[baseLineLen]; Array.Copy(curSearchZobristKeyLine, tZobristKeyLine, baseLineLen); } int perftScore, tattk = isWhiteToMove ? PreMinimaxCheckCheckWhite() : PreMinimaxCheckCheckBlack(), pDepth = 1; (string, int) bookMoveTuple = TLMDatabase.SearchForNextBookMove(moveHashList); if (bookMoveTuple.Item2 != 0) { int actualMoveHash = NuCRe.GetNumber(bookMoveTuple.Item1); List<Move> tMoves = new List<Move>(); GetLegalMoves(ref tMoves); int tL = tMoves.Count; for (int i = 0; i < tL; i++) { if (tMoves[i].moveHash == actualMoveHash) { if (debugSearchDepthResults) { SNAPSHOT_WRITLINE_REPLACEMENT("TLM_DB_Count: " + bookMoveTuple.Item2); SNAPSHOT_WRITLINE_REPLACEMENT(">> " + tMoves[i]); } transpositionTable.Add(zobristKey, new TranspositionEntry(tMoves[i], Array.Empty<int>())); return 0; } } } do { curSearchDepth = pDepth; curSubSearchDepth = pDepth - 1; ulong[] completeZobristHistory = new ulong[baseLineLen + pDepth - CHECK_EXTENSION_LENGTH + 1]; for (int i = 0; i < baseLineLen; i++) completeZobristHistory[i] = curSearchZobristKeyLine[i]; curSearchZobristKeyLine = completeZobristHistory; if (isWhiteToMove) { if (tattk == -1) perftScore = MinimaxWhite(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); else perftScore = MinimaxWhite(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); } else { if (tattk == -1) perftScore = MinimaxBlack(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); else perftScore = MinimaxBlack(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); } if (debugSearchDepthResults && pTime != 1L) { int tNpS = Convert.ToInt32((double)evalCount * 10_000_000d /(double)(pTime - tTimestamp + globalTimer.ElapsedTicks)); int tSearchEval = perftScore; int timeForSearchSoFar = (int)((pTime - tTimestamp + globalTimer.ElapsedTicks) /10000d); Move tBestMove = transpositionTable[zobristKey].bestMove; SNAPSHOT_WRITLINE_REPLACEMENT((tSearchEval >= 0 ? "+": "") + tSearchEval); SNAPSHOT_WRITLINE_REPLACEMENT(" " + tBestMove + "  ["); SNAPSHOT_WRITLINE_REPLACEMENT("Depth = " + pDepth + ", "); SNAPSHOT_WRITLINE_REPLACEMENT("Evals = " + GetThreeDigitSeperatedInteger(evalCount) + ", "); SNAPSHOT_WRITLINE_REPLACEMENT("Time = " + GetThreeDigitSeperatedInteger(timeForSearchSoFar) + "ms, "); SNAPSHOT_WRITLINE_REPLACEMENT("NpS = " + GetThreeDigitSeperatedInteger(tNpS) + "]"); } pDepth++; } while (globalTimer.ElapsedTicks < tTimestamp && pDepth < 179); depths += pDepth - 1; BOT_MAIN.depthsSearched += pDepth - 1; BOT_MAIN.searchesFinished++; BOT_MAIN.evaluationsMade += evalCount; curSearchZobristKeyLine = tZobristKeyLine; return perftScore; } private int MinimaxWhite(int pPly, int pAlpha, int pBeta, int pDepth, int pRepetitionHistoryPly, int pCheckingSquare, Move pLastMove) { if (IsDrawByRepetition(pRepetitionHistoryPly - 4)) return 0; if ((pDepth <= 0 && pCheckingSquare == -1) || pDepth < CHECK_EXTENSION_LENGTH) return QuiescenceWhite(pPly, pAlpha, pBeta, pDepth - 1, pCheckingSquare, pLastMove); List<Move> moveOptionList = new List<Move>(); Move bestMove = NULL_MOVE; if (pLastMove.isPromotion && pLastMove.isCapture && pLastMove.startPos % 8 == pCheckingSquare % 8 && pLastMove.startPos == whiteKingSquare + 8 && (pLastMove.promotionType == 4 || pLastMove.promotionType == 5)) GetLegalWhiteMovesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalWhiteMoves(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tWhiteKingSquare = whiteKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1, curEval = BLACK_CHECKMATE_VAL - pDepth; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = true; double[] moveSortingArray = new double[molc]; int[] moveSortingArrayIndexes = new int[molc], thisSearchMoveSortingArrayForTransposEntry = new int[molc]; transpositionTable.TryGetValue(zobristKey, out TranspositionEntry transposEntry); if (transposEntry == null) { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; } } else { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove == transposEntry.bestMove) moveSortingArray[m] = BESTMOVE_SORT_VAL; else if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; if (transposEntry.moveGenOrderedEvalLength > m) moveSortingArray[m] -= transposEntry.moveGenOrderedEvals[m]; } } Array.Sort(moveSortingArray, moveSortingArrayIndexes); for (int m = 0; m < molc; m++) { int tActualIndex = moveSortingArrayIndexes[m]; Move curMove = moveOptionList[tActualIndex]; if (debugSortResults && pDepth == curSubSearchDepth) { SNAPSHOT_WRITLINE_REPLACEMENT(moveSortingArray[m] + " | "+ curMove); } int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; whitePieceBitboard = tWPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesWhite[tStartPos, tPieceType] ^ pieceHashesWhite[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 0: blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 1: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 2: blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 3: whiteKingSquare = tEndPos; if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 4: blackPieceBitboard = tBPB; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 5: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[whiteKingSquare = tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = curMove.enPassantOption]; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 11: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; whiteKingSquare = tEndPos; blackPieceBitboard = tBPB; pieceTypeArray[curMove.rochadeEndPos] = 4; pieceTypeArray[curMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesWhite[curMove.rochadeStartPos, 4] ^ pieceHashesWhite[curMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | curMove.rochadeEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << curMove.rochadeEndPos)) tCheckPos = curMove.rochadeEndPos; break; case 12: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesBlack[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 13: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; zobristKey ^= pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, curMove.promotionType]; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; case 14: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, tPTI] ^ pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, curMove.promotionType]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } curSearchZobristKeyLine[pRepetitionHistoryPly] = zobristKey; debugMoveList[pPly] = curMove; int tEval = MinimaxBlack(pPly + 1, pAlpha, pBeta, pDepth - 1, pRepetitionHistoryPly + 1, tCheckPos, curMove); thisSearchMoveSortingArrayForTransposEntry[tActualIndex] = tEval; pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 3: whiteKingSquare = tWhiteKingSquare; break; case 7: whiteKingSquare = tWhiteKingSquare; break; case 10: enPassantSquare = 65; break; case 11: whiteKingSquare = tWhiteKingSquare; pieceTypeArray[curMove.rochadeStartPos] = 4; pieceTypeArray[curMove.rochadeEndPos] = 0; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 13: pieceTypeArray[tStartPos] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval > curEval) { bestMove = curMove; curEval = tEval; } if (pAlpha < curEval) pAlpha = curEval; if (curEval >= pBeta) { if (!curMove.isCapture) { killerMoveHeuristic[curMove.moveHash] = true; if (pDepth > 0) historyHeuristic[curMove.moveHash] += pDepth * pDepth; } break; } } isWhiteToMove = true; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; if (molc == 0 && pCheckingSquare == -1) curEval = 0; if (!transpositionTable.ContainsKey(zobristKey)) transpositionTable.Add(zobristKey, new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry)); else transpositionTable[zobristKey] = new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry); return curEval; } private int QuiescenceWhite(int pPly, int pAlpha, int pBeta, int pDepth, int pCheckingSquare, Move pLastMove) { int standPat = TexelEvaluate(); if (standPat >= pBeta || pDepth < MAX_QUIESCENCE_TOTAL_LENGTH) return pBeta; if (standPat > pAlpha) pAlpha = standPat; List<Move> moveOptionList = new List<Move>(); if (pLastMove.isPromotion && pLastMove.isCapture && pLastMove.startPos % 8 == pCheckingSquare % 8 && pLastMove.startPos == whiteKingSquare + 8 && (pLastMove.promotionType == 4 || pLastMove.promotionType == 5)) GetLegalWhiteCapturesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalWhiteCaptures(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tWhiteKingSquare = whiteKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = true; for (int m = 0; m < molc; m++) { Move curMove = moveOptionList[m]; int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; whitePieceBitboard = tWPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesWhite[tStartPos, tPieceType] ^ pieceHashesWhite[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 5: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[whiteKingSquare = tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 12: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesBlack[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 14: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, tPTI] ^ pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, curMove.promotionType]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } debugMoveList[pPly] = curMove; int tEval = QuiescenceBlack(pPly + 1, pAlpha, pBeta, pDepth - 1, tCheckPos, curMove); pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 7: whiteKingSquare = tWhiteKingSquare; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval >= pBeta) return pBeta; if (pAlpha < tEval) pAlpha = tEval; } isWhiteToMove = true; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; return pAlpha; } private int MinimaxBlack(int pPly, int pAlpha, int pBeta, int pDepth, int pRepetitionHistoryPly, int pCheckingSquare, Move pLastMove) { if (IsDrawByRepetition(pRepetitionHistoryPly - 4)) return 0; if ((pDepth <= 0 && pCheckingSquare == -1) || pDepth < CHECK_EXTENSION_LENGTH) return QuiescenceBlack(pPly, pAlpha, pBeta, pDepth - 1, pCheckingSquare, pLastMove); List<Move> moveOptionList = new List<Move>(); Move bestMove = NULL_MOVE; if (pLastMove.isPromotion && pLastMove.isCapture && pLastMove.startPos % 8 == pCheckingSquare % 8 && pLastMove.startPos == blackKingSquare - 8 && (pLastMove.promotionType == 4 || pLastMove.promotionType == 5)) GetLegalBlackMovesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalBlackMoves(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tBlackKingSquare = blackKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1, curEval = WHITE_CHECKMATE_VAL + pDepth; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = false; double[] moveSortingArray = new double[molc]; int[] moveSortingArrayIndexes = new int[molc], thisSearchMoveSortingArrayForTransposEntry = new int[molc]; transpositionTable.TryGetValue(zobristKey, out TranspositionEntry transposEntry); if (transposEntry == null) { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; } } else { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove == transposEntry.bestMove) moveSortingArray[m] = BESTMOVE_SORT_VAL; else if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; if (transposEntry.moveGenOrderedEvalLength > m) moveSortingArray[m] -= transposEntry.moveGenOrderedEvals[m]; } } Array.Sort(moveSortingArray, moveSortingArrayIndexes); for (int m = 0; m < molc; m++) { int tActualIndex = moveSortingArrayIndexes[m]; Move curMove = moveOptionList[tActualIndex]; if (debugSortResults && pDepth == curSearchDepth) { SNAPSHOT_WRITLINE_REPLACEMENT("=== " + moveSortingArray[m] + " | "+ curMove); } int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; blackPieceBitboard = tBPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesBlack[tStartPos, tPieceType] ^ pieceHashesBlack[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 0: whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 1: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 2: whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 3: blackKingSquare = tEndPos; if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 4: whitePieceBitboard = tWPB; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 5: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[blackKingSquare = tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = curMove.enPassantOption]; whitePieceBitboard = tWPB; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 11: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; blackKingSquare = tEndPos; whitePieceBitboard = tWPB; pieceTypeArray[curMove.rochadeEndPos] = 4; pieceTypeArray[curMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesBlack[curMove.rochadeStartPos, 4] ^ pieceHashesBlack[curMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | curMove.rochadeEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << curMove.rochadeEndPos)) tCheckPos = curMove.rochadeEndPos; break; case 12: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesWhite[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 13: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, curMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; case 14: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } zobristKey ^= pieceHashesWhite[tEndPos, tPTI] ^ pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, curMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } curSearchZobristKeyLine[pRepetitionHistoryPly] = zobristKey; debugMoveList[pPly] = curMove; int tEval = MinimaxWhite(pPly + 1, pAlpha, pBeta, pDepth - 1, pRepetitionHistoryPly + 1, tCheckPos, curMove); thisSearchMoveSortingArrayForTransposEntry[tActualIndex] = tEval; pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 3: blackKingSquare = tBlackKingSquare; break; case 7: blackKingSquare = tBlackKingSquare; break; case 10: enPassantSquare = 65; break; case 11: blackKingSquare = tBlackKingSquare; pieceTypeArray[curMove.rochadeStartPos] = 4; pieceTypeArray[curMove.rochadeEndPos] = 0; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 13: pieceTypeArray[tStartPos] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval < curEval) { bestMove = curMove; curEval = tEval; } if (pBeta > curEval) pBeta = curEval; if (curEval <= pAlpha) { if (!curMove.isCapture) { killerMoveHeuristic[curMove.moveHash] = true; if (pDepth > 0) historyHeuristic[curMove.moveHash] += pDepth * pDepth; } break; } } isWhiteToMove = false; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; if (molc == 0 && pCheckingSquare == -1) curEval = 0; if (!transpositionTable.ContainsKey(zobristKey)) transpositionTable.Add(zobristKey, new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry)); else transpositionTable[zobristKey] = new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry); return curEval; } private int QuiescenceBlack(int pPly, int pAlpha, int pBeta, int pDepth, int pCheckingSquare, Move pLastMove) { int standPat = TexelEvaluate(); if (standPat <= pAlpha || pDepth < MAX_QUIESCENCE_TOTAL_LENGTH) return pAlpha; if (standPat < pBeta) pBeta = standPat; List<Move> moveOptionList = new List<Move>(); if (pLastMove.isPromotion && pLastMove.isCapture && pLastMove.startPos % 8 == pCheckingSquare % 8 && pLastMove.startPos == blackKingSquare - 8 && (pLastMove.promotionType == 4 || pLastMove.promotionType == 5)) GetLegalBlackCapturesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalBlackCaptures(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tBlackKingSquare = blackKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = false; for (int m = 0; m < molc; m++) { Move curMove = moveOptionList[m]; int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; blackPieceBitboard = tBPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesBlack[tStartPos, tPieceType] ^ pieceHashesBlack[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 5: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[blackKingSquare = tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 12: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesWhite[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 14: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } zobristKey ^= pieceHashesWhite[tEndPos, tPTI] ^ pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, curMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } debugMoveList[pPly] = curMove; int tEval = QuiescenceWhite(pPly + 1, pAlpha, pBeta, pDepth - 1, tCheckPos, curMove); pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 7: blackKingSquare = tBlackKingSquare; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval <= pAlpha) return pAlpha; if (pBeta > tEval) pBeta = tEval; } isWhiteToMove = false; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; return pBeta; } private bool[] killerMoveHeuristic = new bool[262_144]; private int[] historyHeuristic = new int[262_144]; public void ClearHeuristics() { for (int i = 0; i < 262_144; i++) { killerMoveHeuristic[i] = false; historyHeuristic[i] = 0; } } private Dictionary<ulong, TranspositionEntry> transpositionTable = new Dictionary<ulong, TranspositionEntry>(); private int[] pieceEvals = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[,][] piecePositionEvals = new int[33, 14][]; private int evalCount = 0; private int Evaluate() { evalCount++; if (fiftyMoveRuleCounter > 99) return 0; int tEval = 0, tPT, pieceCount = ULONG_OPERATIONS.CountBits(allPieceBitboard); for (int p = 0; p < 64; p++) tEval += pieceEvals[tPT = pieceTypeArray[p] + 7 * ((int)(blackPieceBitboard >> p) & 1)] + piecePositionEvals[pieceCount, tPT][p]; return tEval; } public int GameState(bool pWhiteKingCouldBeAttacked) { if (IsDrawByRepetition(curSearchZobristKeyLine.Length - 5) || fiftyMoveRuleCounter > 99) return 0; int t; List<Move> tMoves = new List<Move>(); GetLegalMoves(ref tMoves); if (pWhiteKingCouldBeAttacked) { t = PreMinimaxCheckCheckWhite(); if (t == -1) return tMoves.Count == 0 ? 0 : 3; else if (tMoves.Count == 0) return -1; } else { t = PreMinimaxCheckCheckBlack(); if (t == -1) return tMoves.Count == 0 ? 0 : 3; else if (tMoves.Count == 0) return 1; } return 3; } private bool IsDrawByRepetition(int pPlyOfFirstPossibleRepeatedPosition) { int tC = 0; for (int i = pPlyOfFirstPossibleRepeatedPosition; i >= 0; i -= 2) { if (curSearchZobristKeyLine[i] == zobristKey) if (++tC == 2) return true; } return false; } private const int RELE_MAX_MOVE_COUNT_PER_GAME = 500; public double ReLePlayGame(int[,][] pEvalPositionValuesWhite, int[,][] pEvalPositionValuesBlack, long thinkingTimePerMove) { int[,][] processedValuesWhite = InitReLeAgent(pEvalPositionValuesWhite), processedValuesBlack = InitReLeAgent(pEvalPositionValuesBlack); int tGS, mc = 0; do { if (IsDrawByRepetition(curSearchZobristKeyLine.Length - 5)) return 0d; piecePositionEvals = isWhiteToMove ? processedValuesWhite : processedValuesBlack; MinimaxRoot(thinkingTimePerMove); if (transpositionTable.Count == 0) { SNAPSHOT_WRITLINE_REPLACEMENT("?!"); return 0d; } PlainMakeMove(transpositionTable[zobristKey].bestMove); tGS = GameState(isWhiteToMove); transpositionTable.Clear(); if (tGS != 3) break; } while (mc++ < RELE_MAX_MOVE_COUNT_PER_GAME); if (tGS == 3 || tGS == 0) return 0d; else if (tGS == 1) return 0.1d * (double)(RELE_MAX_MOVE_COUNT_PER_GAME - mc); return 0.1d * (double)(-RELE_MAX_MOVE_COUNT_PER_GAME + mc); } public int[,][] InitReLeAgent(int[,][] pEvalPositionValues) { return GetInterpolatedProcessedValues(pEvalPositionValues); } private int[,][] GetInterpolatedProcessedValues(int[,][] pEvalPositionValues) { int[,][] processedValues = new int[33, 14][]; for (int i = 0; i < 32; i++) { int ip1 = i + 1; processedValues[ip1, 7] = processedValues[ip1, 0] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; processedValues[ip1, 8] = SwapArrayViewingSide(processedValues[ip1, 1] = MultiplyArraysWithVal(pEvalPositionValues[0, 0], pEvalPositionValues[1, 0], pEvalPositionValues[2, 0], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 9] = SwapArrayViewingSide(processedValues[ip1, 2] = MultiplyArraysWithVal(pEvalPositionValues[0, 1], pEvalPositionValues[1, 1], pEvalPositionValues[2, 1], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 10] = SwapArrayViewingSide(processedValues[ip1, 3] = MultiplyArraysWithVal(pEvalPositionValues[0, 2], pEvalPositionValues[1, 2], pEvalPositionValues[2, 2], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 11] = SwapArrayViewingSide(processedValues[ip1, 4] = MultiplyArraysWithVal(pEvalPositionValues[0, 3], pEvalPositionValues[1, 3], pEvalPositionValues[2, 3], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 12] = SwapArrayViewingSide(processedValues[ip1, 5] = MultiplyArraysWithVal(pEvalPositionValues[0, 4], pEvalPositionValues[1, 4], pEvalPositionValues[2, 4], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 13] = SwapArrayViewingSide(processedValues[ip1, 6] = MultiplyArraysWithVal(pEvalPositionValues[0, 5], pEvalPositionValues[1, 5], pEvalPositionValues[2, 5], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); } return processedValues; } private double[,][] GetInterpolatedProcessedValues(double[,][] pEvalPositionValues) { double[,][] processedValues = new double[33, 14][]; for (int i = 0; i < 32; i++) { int ip1 = i + 1; processedValues[ip1, 7] = processedValues[ip1, 0] = new double[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; processedValues[ip1, 8] = SwapArrayViewingSide(processedValues[ip1, 1] = MultiplyArraysWithVal(pEvalPositionValues[0, 0], pEvalPositionValues[1, 0], pEvalPositionValues[2, 0], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 9] = SwapArrayViewingSide(processedValues[ip1, 2] = MultiplyArraysWithVal(pEvalPositionValues[0, 1], pEvalPositionValues[1, 1], pEvalPositionValues[2, 1], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 10] = SwapArrayViewingSide(processedValues[ip1, 3] = MultiplyArraysWithVal(pEvalPositionValues[0, 2], pEvalPositionValues[1, 2], pEvalPositionValues[2, 2], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 11] = SwapArrayViewingSide(processedValues[ip1, 4] = MultiplyArraysWithVal(pEvalPositionValues[0, 3], pEvalPositionValues[1, 3], pEvalPositionValues[2, 3], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 12] = SwapArrayViewingSide(processedValues[ip1, 5] = MultiplyArraysWithVal(pEvalPositionValues[0, 4], pEvalPositionValues[1, 4], pEvalPositionValues[2, 4], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 13] = SwapArrayViewingSide(processedValues[ip1, 6] = MultiplyArraysWithVal(pEvalPositionValues[0, 5], pEvalPositionValues[1, 5], pEvalPositionValues[2, 5], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); } return processedValues; } private double[] MultiplyArraysWithVal(double[] pArr1, double[] pArr2, double[] pArr3, double pVal1, double pVal2, double pVal3) { int tL = pArr1.Length; double[] rArr = new double[tL]; for (int i = 0; i < tL; i++) { rArr[i] = pArr1[i] * pVal1 + pArr2[i] * pVal2 + pArr3[i] * pVal3; } return rArr; } private int[] MultiplyArraysWithVal(int[] pArr1, int[] pArr2, int[] pArr3, double pVal1, double pVal2, double pVal3) { int tL = pArr1.Length; int[] rArr = new int[tL]; for (int i = 0; i < tL; i++) { rArr[i] = (int)(pArr1[i] * pVal1 + pArr2[i] * pVal2 + pArr3[i] * pVal3); } return rArr; } private int[] SwapArrayViewingSideAndNegate(int[] pArr) { return new int[64] { -pArr[56], -pArr[57], -pArr[58], -pArr[59], -pArr[60], -pArr[61], -pArr[62], -pArr[63], -pArr[48], -pArr[49], -pArr[50], -pArr[51], -pArr[52], -pArr[53], -pArr[54], -pArr[55], -pArr[40], -pArr[41], -pArr[42], -pArr[43], -pArr[44], -pArr[45], -pArr[46], -pArr[47], -pArr[32], -pArr[33], -pArr[34], -pArr[35], -pArr[36], -pArr[37], -pArr[38], -pArr[39], -pArr[24], -pArr[25], -pArr[26], -pArr[27], -pArr[28], -pArr[29], -pArr[30], -pArr[31], -pArr[16], -pArr[17], -pArr[18], -pArr[19], -pArr[20], -pArr[21], -pArr[22], -pArr[23], -pArr[8], -pArr[9], -pArr[10], -pArr[11], -pArr[12], -pArr[13], -pArr[14], -pArr[15], -pArr[0], -pArr[1], -pArr[2], -pArr[3], -pArr[4], -pArr[5], -pArr[6], -pArr[7] }; } private int[] SwapArrayViewingSide(int[] pArr) { return new int[64] { pArr[56], pArr[57], pArr[58], pArr[59], pArr[60], pArr[61], pArr[62], pArr[63], pArr[48], pArr[49], pArr[50], pArr[51], pArr[52], pArr[53], pArr[54], pArr[55], pArr[40], pArr[41], pArr[42], pArr[43], pArr[44], pArr[45], pArr[46], pArr[47], pArr[32], pArr[33], pArr[34], pArr[35], pArr[36], pArr[37], pArr[38], pArr[39], pArr[24], pArr[25], pArr[26], pArr[27], pArr[28], pArr[29], pArr[30], pArr[31], pArr[16], pArr[17], pArr[18], pArr[19], pArr[20], pArr[21], pArr[22], pArr[23], pArr[8], pArr[9], pArr[10], pArr[11], pArr[12], pArr[13], pArr[14], pArr[15], pArr[0], pArr[1], pArr[2], pArr[3], pArr[4], pArr[5], pArr[6], pArr[7] }; } private double[] SwapArrayViewingSide(double[] pArr) { return new double[64] { pArr[56], pArr[57], pArr[58], pArr[59], pArr[60], pArr[61], pArr[62], pArr[63], pArr[48], pArr[49], pArr[50], pArr[51], pArr[52], pArr[53], pArr[54], pArr[55], pArr[40], pArr[41], pArr[42], pArr[43], pArr[44], pArr[45], pArr[46], pArr[47], pArr[32], pArr[33], pArr[34], pArr[35], pArr[36], pArr[37], pArr[38], pArr[39], pArr[24], pArr[25], pArr[26], pArr[27], pArr[28], pArr[29], pArr[30], pArr[31], pArr[16], pArr[17], pArr[18], pArr[19], pArr[20], pArr[21], pArr[22], pArr[23], pArr[8], pArr[9], pArr[10], pArr[11], pArr[12], pArr[13], pArr[14], pArr[15], pArr[0], pArr[1], pArr[2], pArr[3], pArr[4], pArr[5], pArr[6], pArr[7] }; } private int[,][] texelTuningRuntimeVals = new int[33, 14][]; private int[,][] texelTuningVals = new int[3, 6][]; private int[,] texelTuningAdjustIterations = new int[6, 64]; private int[][] texelTuningRuntimePositionalValsV2EG = new int[14][]; private int[][] texelTuningRuntimePositionalValsV2LG = new int[14][]; private int[] texelPieceEvaluationsV2EG = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[] texelPieceEvaluationsV2LG = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[] texelKingSafetyR1EvaluationsEG = new int[9]; private int[] texelKingSafetyR2EvaluationsEG = new int[17]; private int[] texelKingSafetyR1EvaluationsLG = new int[9]; private int[] texelKingSafetyR2EvaluationsLG = new int[17]; private int[] texelKingSafetySREvaluationsPT1EG = new int[12]; private int[] texelKingSafetySREvaluationsPT2EG = new int[12]; private int[] texelKingSafetySREvaluationsPT3EG = new int[12]; private int[] texelKingSafetySREvaluationsPT4EG = new int[12]; private int[] texelKingSafetySREvaluationsPT5EG = new int[12]; private int[] texelKingSafetySREvaluationsPT6EG = new int[12]; private int[] texelKingSafetySREvaluationsPT1LG = new int[12]; private int[] texelKingSafetySREvaluationsPT2LG = new int[12]; private int[] texelKingSafetySREvaluationsPT3LG = new int[12]; private int[] texelKingSafetySREvaluationsPT4LG = new int[12]; private int[] texelKingSafetySREvaluationsPT5LG = new int[12]; private int[] texelKingSafetySREvaluationsPT6LG = new int[12]; private int[,] texelMobilityStraightEG = new int[14, 15], texelMobilityStraightLG = new int[14, 15]; private int[,] texelMobilityDiagonalEG = new int[14, 14], texelMobilityDiagonalLG = new int[14, 14]; private int[] texelPieceEvaluations = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[] blackSidedSquares = new int[64] { 56, 57, 58, 59, 60, 61, 62, 63, 48, 49, 50, 51, 52, 53, 54, 55, 40, 41, 42, 43, 44, 45, 46, 47, 32, 33, 34, 35, 36, 37, 38, 39, 24, 25, 26, 27, 28, 29, 30, 31, 16, 17, 18, 19, 20, 21, 22, 23, 08, 09, 10, 11, 12, 13, 14, 15, 00, 01, 02, 03, 04, 05, 06, 07 }; private int[,] T_Pawns = new int[3, 64] { { 0, 0, 0, 0, 0, 0, 0, 0, 98, 134, 61, 95, 68, 126, 34, -11, -6, 7, 26, 31, 65, 56, 25, -20, -14, 13, 6, 21, 23, 12, 17, -23, -27, -2, -5, 12, 17, 6, 10, -25, -26, -4, -4, -10, 3, 3, 33, -12, -35, -1, -20, -23, -15, 24, 38, -22, 0, 0, 0, 0, 0, 0, 0, 0, } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { 0, 0, 0, 0, 0, 0, 0, 0, 178, 173, 158, 134, 147, 132, 165, 187, 94, 100, 85, 67, 56, 53, 82, 84, 32, 24, 13, 5, -2, 4, 17, 17, 13, 9, -3, -7, -7, -8, 3, -1, 4, 7, -6, 1, 0, -5, -1, -8, 13, 8, 8, 10, 13, 0, 2, -7, 0, 0, 0, 0, 0, 0, 0, 0, } }; private int[,] T_Knights = new int[3, 64] { { -167, -89, -34, -49, 61, -97, -15, -107, -73, -41, 72, 36, 23, 62, 7, -17, -47, 60, 37, 65, 84, 129, 73, 44, -9, 17, 19, 53, 37, 69, 18, 22, -13, 4, 16, 13, 28, 19, 21, -8, -23, -9, 12, 10, 19, 17, 25, -16, -29, -53, -12, -3, -1, 18, -14, -19, -105, -21, -58, -33, -17, -28, -19, -23 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -58, -38, -13, -28, -31, -27, -63, -99, -25, -8, -25, -2, -9, -25, -24, -52, -24, -20, 10, 9, -1, -9, -19, -41, -17, 3, 22, 22, 22, 11, 8, -18, -18, -6, 16, 25, 16, 17, 4, -18, -23, -3, -1, 15, 10, -3, -20, -22, -42, -20, -10, -5, -2, -20, -23, -44, -29, -51, -23, -15, -22, -18, -50, -64 } }; private int[,] T_Bishops = new int[3, 64] { { -29, 4, -82, -37, -25, -42, 7, -8, -26, 16, -18, -13, 30, 59, 18, -47, -16, 37, 43, 40, 35, 50, 37, -2, -4, 5, 19, 50, 37, 37, 7, -2, -6, 13, 13, 26, 34, 12, 10, 4, 0, 15, 15, 15, 14, 27, 18, 10, 4, 15, 16, 0, 7, 21, 33, 1, -33, -3, -14, -21, -13, -12, -39, -21 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -14, -21, -11, -8, -7, -9, -17, -24, -8, -4, 7, -12, -3, -13, -4, -14, 2, -8, 0, -1, -2, 6, 0, 4, -3, 9, 12, 9, 14, 10, 3, 2, -6, 3, 13, 19, 7, 10, -3, -9, -12, -3, 8, 10, 13, 3, -7, -15, -14, -18, -7, -1, 4, -9, -15, -27, -23, -9, -23, -5, -9, -16, -5, -17 } }; private int[,] T_Rooks = new int[3, 64] { { 32, 42, 32, 51, 63, 9, 31, 43, 27, 32, 58, 62, 80, 67, 26, 44, -5, 19, 26, 36, 17, 45, 61, 16, -24, -11, 7, 26, 24, 35, -8, -20, -36, -26, -12, -1, 9, -7, 6, -23, -45, -25, -16, -17, 3, 0, -5, -33, -44, -16, -20, -9, -1, 11, -6, -71, -19, -13, 1, 17, 16, 7, -37, -26 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { 13, 10, 18, 15, 12, 12, 8, 5, 11, 13, 13, 11, -3, 3, 8, 3, 7, 7, 7, 5, 4, -3, -5, -3, 4, 3, 13, 1, 2, 1, -1, 2, 3, 5, 8, 4, -5, -6, -8, -11, -4, 0, -5, -1, -7, -12, -8, -16, -6, -6, 0, 2, -9, -9, -11, -3, -9, 2, 3, -1, -5, -13, 4, -20 } }; private int[,] T_Queens = new int[3, 64] { { -28, 0, 29, 12, 59, 44, 43, 45, -24, -39, -5, 1, -16, 57, 28, 54, -13, -17, 7, 8, 29, 56, 47, 57, -27, -27, -16, -16, -1, 17, -2, 1, -9, -26, -9, -10, -2, -4, 3, -3, -14, 2, -11, -2, -5, 2, 14, 5, -35, -8, 11, 2, 8, 15, -3, 1, -1, -18, -9, 10, -15, -25, -31, -50 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -9, 22, 22, 27, 27, 19, 10, 20, -17, 20, 32, 41, 58, 25, 30, 0, -20, 6, 9, 49, 47, 35, 19, 9, 3, 22, 24, 45, 57, 40, 57, 36, -18, 28, 19, 47, 31, 34, 39, 23, -16, -27, 15, 6, 9, 17, 10, 5, -22, -23, -30, -16, -16, -23, -36, -32, -33, -28, -22, -43, -5, -32, -20, -41 } }; private int[,] T_Kings = new int[3, 64] { { -65, 23, 16, -15, -56, -34, 2, 13, 29, -1, -20, -7, -8, -4, -38, -29, -9, 24, 2, -16, -20, 6, 22, -22, -17, -20, -12, -27, -30, -25, -14, -36, -49, -1, -27, -39, -46, -44, -33, -51, -14, -14, -22, -46, -44, -30, -15, -27, 1, 7, -8, -64, -43, -16, 9, 8, -15, 36, 12, -54, 8, -28, 24, 14 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -74, -35, -18, -18, -11, 15, 4, -17, -12, 17, 14, 17, 17, 38, 23, 11, 10, 17, 23, 15, 20, 45, 44, 13, -8, 22, 24, 27, 26, 33, 26, 3, -18, -4, 21, 24, 27, 23, 9, -11, -19, -3, 11, 21, 23, 16, 7, -9, -27, -11, 4, 13, 14, 4, -5, -17, -53, -34, -21, -11, -28, -14, -24, -43 } }; private int[] paramsLowerLimits = new int[5] { -10000, -10000, -10000, -10000, -10000 }; private int[] paramsUpperLimits = new int[5] { 10000, 10000, 10000, 10000, 10000 }; private List<TLM_ChessGame> threadDataset; private int threadFrom, threadTo; private int[] threadParams; private int customThreadID = 0; private ulong ulAllThreadIDsUnfinished = 0; private double lastCostVal = 0d; private double sumCostVals = 0d; private int costCalculations = 0; private readonly string[] TEXELPRINT_GAMEPARTS = new string[3] { "Early Game: ", "Mid Game: ", "Late Game: "}; private readonly string[] TEXELPRINT_PIECES = new string[6] { "Bauer: ", "Springer: ", "Lufer: ", "Turm: ", "Dame: ", "Knig: "}; private double[] earlyGameMultipliers = new double[33]; private double[] middleGameMultipliers = new double[33]; private double[] lateGameMultipliers = new double[33]; private int[] pieceTypeGameProgressImpact = new int[14] { 0, 0, 1, 1, 2, 4, 0, 0, 0, 1, 1, 2, 4, 0 }; private void PrecalculateMultipliers() { if (BOARD_MANAGER_ID == ENGINE_VALS.PARALLEL_BOARDS - 1) SNAPSHOT_WRITLINE_REPLACEMENT(); for (int i = 0; i < 25; i++) { earlyGameMultipliers[i] = EGMultiplierFunction(i); lateGameMultipliers[i] = LGMultiplierFunction(i); if (BOARD_MANAGER_ID == ENGINE_VALS.PARALLEL_BOARDS - 1) SNAPSHOT_WRITLINE_REPLACEMENT("[" + i + "] "+ earlyGameMultipliers[i] + " | "+ middleGameMultipliers[i] + " | "+ lateGameMultipliers[i]); } } private double MultiplierFunction(double pVal, double pXShift) { double d = Math.Exp(1d /6d * (pVal - pXShift)); return 5 * (d /Math.Pow(d + 1, 2d)); } private double EGMultiplierFunction(double pVal) { return Math.Clamp(1 /16d * (pVal - 4d), 0d, 1d); } private double LGMultiplierFunction(double pVal) { return Math.Clamp(1 /-16d * (pVal - 4d) + 1d, 0d, 1d); } private double EGMultiplierFunction2(double pVal) { return Math.Clamp(1 /32d * pVal, 0d, 1d); } private double LGMultiplierFunction2(double pVal) { return Math.Clamp(1 /-32d * pVal + 1d, 0d, 1d); } private void TuneWithTxtFile(string pTXTName) { List<TLM_ChessGame> gameDataset = new List<TLM_ChessGame>(); string tPath = PathManager.GetTXTPath(pTXTName); string[] tStrs = File.ReadAllLines(tPath); List<string> tGames = new List<string>(); foreach (string s in tStrs) if (s.Contains(';') && s.Replace(" ", "") != "") tGames.Add(s); foreach (string s in tGames) { TLM_ChessGame tGame = CGFF.GetGame(s); LoadFenString(tGame.startFen); foreach (int hMove in tGame.hashedMoves) { List<Move> moveOptionList = new List<Move>(); GetLegalMoves(ref moveOptionList); int tL = moveOptionList.Count; for (int j = 0; j < tL; j++) { Move tMove = moveOptionList[j]; if (tMove.moveHash == hMove) { tGame.actualMoves.Add(tMove); PlainMakeMove(tMove); tL = -1; break; } } if (tL != -1) break; } gameDataset.Add(tGame); } SNAPSHOT_WRITLINE_REPLACEMENT("[TLM TEXEL TUNER] " + tGames.Count + " Games Loaded In!"); BOT_MAIN.curTEXELPARAMS = new int[TEXEL_PARAMS]; BOT_MAIN.ParallelTexelTuning(gameDataset); } private void LoadBestTexelParamsIn() { int[] ttt = new int[778] { 82, 341, 416, 470, 1106, 102, 302, 304, 518, 960, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, -46, 0, -20, 0, 64, -21, -71, 37, 29, 6, 98, 13, 44, 0, -26, -14, -36, -20, 94, 16, 60, 10, -62, -19, -38, -8, -28, 14, -26, -4, -32, -28, -52, 30, 56, -40, -72, -22, 100, 4, -98, -34, 6, -49, 32, -10, 72, 20, 84, -56, -60, -112, 128, -28, 152, 34, 26, -52, 200, -56, 76, 44, -56, -113, -156, 188, -39, 28, 200, -90, -60, -86, 100, -178, -119, -200, 200, 200, -20, -22, -78, -158, -200, 196, 200, -200, -200, -200, 104, 200, 138, -122, 200, 200, 124, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 200, 156, -37, -68, -148, -200, 200, -70, 72, 76, -31, -200, -21, 178, -200, 200, 200, -200, 123, -188, -6, 164, -74, 24, -28, -8, 71, -50, -112, -200, -8, -44, 27, -23, -50, 19, 19, 41, 150, 152, 4, -98, -36, -34, 174, -106, -16, 17, 141, -48, -108, 162, 6, -112, -52, 76, 68, 8, -86, 68, -176, 189, 81, 162, -200, 152, -41, 128, 172, -173, -144, 56, 22, 94, -28, 32, 16, -63, 36, -200, -200, -200, -22, 56, -116, 76, -36, -30, 100, 52, -166, -114, 142, -52, -44, -200, -18, -72, 60, 200, -160, 96, 46, -200, -28, -32, -44, 132, 60, -200, -137, -200, -176, 200, -200, -200, 4, 200, -200, 72, 200, -78, 200, 160, -105, 200, 96, -114, 200, 200, -88, -24, 11, -34, 184, 26, 83, -140, 10, -16, -72, -200, 12, -200, 46, -200, 11, 82, 66, -102, 22, -184, 32, 114, 140, -26, -18, -36, 66, 100, 25, -24, 133, -96, 50, 2, 80, 184, 43, -136, 44, 124, -148, 180, 69, -126, -200, 6, 78, -96, 89, -68, 200, -116, 114, 158, 5, -154, 115, 200, -152, -171, 41, -80, -23, 137, 98, -80, 40, -42, 200, 52, 146, 200, 6, -112, 32, 200, 132, 4, 90, -200, -200, 104, 67, -56, 186, 124, 140, 97, -144, 200, -4, -160, -117, -200, 24, -80, 200, 28, -46, -24, -52, -200, -200, 72, 20, 34, 200, -16, 88, 56, 200, -146, 120, 174, 200, -200, -86, 125, 172, -70, 4, 124, -72, 0, -2, 70, -14, 48, -32, 200, 80, 24, -132, 74, -44, 184, -4, -136, 0, -16, 20, -18, -32, 96, 92, 56, 2, 174, 196, -200, -56, -116, 88, 200, -8, 168, -13, 74, -106, 200, -182, 80, 82, -128, -16, 90, -200, 66, -88, 58, -16, 80, -34, 96, -95, -96, -200, 76, 26, -72, 32, -27, -108, 164, 200, -36, -93, -10, -56, 22, 36, 74, -200, -96, 200, 88, -88, 156, -92, 96, -200, 200, 191, -8, 62, -8, -100, 136, -72, -36, 200, -64, -114, 153, -110, 174, 46, 108, 142, 121, -200, 108, -200, 74, -4, 104, -200, 116, 82, 200, -76, 176, -200, 76, -8, 200, 46, 29, -86, 12, -24, -80, -12, 200, 124, -16, 54, 104, 200, -94, 140, 36, 32, -64, 24, -178, 15, -200, 0, -200, 4, -32, -124, 148, 176, 192, 90, 164, -91, 200, 172, -200, 64, 34, 40, -200, 0, -200, 12, -124, 48, -200, -56, 184, -8, -184, 0, 200, -16, 200, -8, 180, -18, -20, 24, -200, -58, 174, -200, 40, -4, -200, -24, 200, 54, 200, -24, -32, 37, 192, 48, 44, 26, 200, -22, 200, -145, -200, 30, 86, 54, 200, -102, -34, 94, -98, 92, -200, -76, 196, -18, -200, -180, 16, 186, -92, -200, -200, 164, -200, 62, 192, 159, -112, -12, -70, 184, 104, 200, -200, -148, -4, 86, -144, 200, -100, 200, 200, -104, 114, 132, -168, 12, 56, -10, 82, 200, -200, -200, -196, -6, 52, -200, 84, 200, -192, 128, 200, -200, -200, 200, 88, 168, -32, -84, 172, 52, -172, 0, -40, 68, -186, 42, 96, -200, -198, 200, -56, -176, 88, 0, 86, 16, -124, -46, 40, -16, -4, 54, -184, 200, 58, -200, 77, -200, -44, 102, 0, -50, -10, -92, 100, -86, 8, 20, -20, -200, 38, -200, -49, -4, 2, -200, 78, 0, -40, -92, 32, 0, -164, -88, -38, -138, -118, 29, -34, -200, -200, -200, -71, -200, 200, -200, -108, -200, 0, 192, -24, 104, -200, 200, 190, -28, -200, -200, -200, 128, -96, 200, 200, 200, 200, -200, -200, 177, -24, 200, 132, 200, -190, 200, -130, 200, 148, 200, 200, -200, -100, 200, -196, -200, 90, 200, -200, 200, 200, -200, -200, -200, -200, -200, 118, -200, 85, -200, 166, 199, -200 }; SetupTexelEvaluationParams(ttt); } private void SetupTexelEvaluationParams(int[] pParams) { texelPieceEvaluationsV2EG[8] = -(texelPieceEvaluationsV2EG[1] = pParams[0]); texelPieceEvaluationsV2EG[9] = -(texelPieceEvaluationsV2EG[2] = pParams[1]); texelPieceEvaluationsV2EG[10] = -(texelPieceEvaluationsV2EG[3] = pParams[2]); texelPieceEvaluationsV2EG[11] = -(texelPieceEvaluationsV2EG[4] = pParams[3]); texelPieceEvaluationsV2EG[12] = -(texelPieceEvaluationsV2EG[5] = pParams[4]); texelPieceEvaluationsV2LG[8] = -(texelPieceEvaluationsV2LG[1] = pParams[5]); texelPieceEvaluationsV2LG[9] = -(texelPieceEvaluationsV2LG[2] = pParams[6]); texelPieceEvaluationsV2LG[10] = -(texelPieceEvaluationsV2LG[3] = pParams[7]); texelPieceEvaluationsV2LG[11] = -(texelPieceEvaluationsV2LG[4] = pParams[8]); texelPieceEvaluationsV2LG[12] = -(texelPieceEvaluationsV2LG[5] = pParams[9]); int c = 10; for (int p = 1; p < 7; p++) { for (int s = 0; s < 64; s++) { texelTuningRuntimePositionalValsV2EG[p + 7][blackSidedSquares[s]] = -(texelTuningRuntimePositionalValsV2EG[p][s] = pParams[c++]); texelTuningRuntimePositionalValsV2LG[p + 7][blackSidedSquares[s]] = -(texelTuningRuntimePositionalValsV2LG[p][s] = pParams[c++]); } } return; for (int p = 2; p < 7; p++) { for (int a = 0; a < 15; a++) { if (a != 14) { texelMobilityDiagonalEG[p + 7, a] = -(texelMobilityDiagonalEG[p, a] = pParams[c++]); texelMobilityDiagonalLG[p + 7, a] = -(texelMobilityDiagonalLG[p, a] = pParams[c++]); } texelMobilityStraightEG[p + 7, a] = -(texelMobilityStraightEG[p, a] = pParams[c++]); texelMobilityStraightLG[p + 7, a] = -(texelMobilityStraightLG[p, a] = pParams[c++]); } } for (int i = 0; i < 12; i++) { texelKingSafetySREvaluationsPT1EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT2EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT3EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT4EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT5EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT6EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT1LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT2LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT3LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT4LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT5LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT6LG[i] = pParams[c++]; } } private void PrintDefinedTexelParams(int[] pParams) { int c = 0; for (int t = 0; t < 3; t++) { SNAPSHOT_WRITLINE_REPLACEMENT(TEXELPRINT_GAMEPARTS[t]); for (int p = 0; p < 6; p++) { SNAPSHOT_WRITLINE_REPLACEMENT(TEXELPRINT_PIECES[p]); texelTuningVals[t, p] = new int[64]; for (int s = 0; s < 64; s++) { if (s % 8 == 0 && s != 0) SNAPSHOT_WRITLINE_REPLACEMENT(); SNAPSHOT_WRITLINE_REPLACEMENT((texelTuningVals[t, p][s] = pParams[c++]) + ", "); } SNAPSHOT_WRITLINE_REPLACEMENT(); } } piecePositionEvals = GetInterpolatedProcessedValues(texelTuningVals); } public void TLMTuning(List<TLM_ChessGame> pDataset) { int tGameDataSetLen = pDataset.Count; int[,][] tRatio = new int[33, 6][]; int[,][] tTotalMoves = new int[33, 6][]; double[,][] tSummedRatios = new double[33, 6][]; double[,][] tSummedDataAmount = new double[33, 6][]; double[,][] tTuningResults = new double[33, 6][]; for (int t = 1; t < 33; t++) { for (int p = 0; p < 6; p++) { tRatio[t, p] = new int[64]; tTotalMoves[t, p] = new int[64]; tSummedRatios[t, p] = new double[64]; tSummedDataAmount[t, p] = new double[64]; tTuningResults[t, p] = new double[64]; } } for (int j = 0; j < tGameDataSetLen; j++) { TLM_ChessGame tGame = pDataset[j]; int tGR = tGame.gameResult - 1; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count - 5; for (int i = 0; i < tL; i++) { if (tGame.isMoveNonTactical[i]) { int tPieceAmount = ULONG_OPERATIONS.CountBits(allPieceBitboard); for (int s = 0; s < 64; s++) { int tPT = pieceTypeArray[s] - 1; if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, s)) { tTotalMoves[tPieceAmount, tPT][s]++; tRatio[tPieceAmount, tPT][s] += tGR; } else if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, s)) { int b = blackSidedSquares[s]; tTotalMoves[tPieceAmount, tPT][b]++; tRatio[tPieceAmount, tPT][b] += tGR; } } } PlainMakeMove(tGame.actualMoves[i]); } } double[,] allMultipliers = new double[33, 33]; for (int sh = 0; sh < 33; sh++) { for (int i = 0; i < 33; i++) { allMultipliers[sh, i] = MultiplierFunction(i, sh); } } for (int t = 1; t < 33; t++) { for (int p = 0; p < 6; p++) { for (int s = 0; s < 64; s++) { for (int t2 = 1; t2 < 33; t2++) { double cmult = allMultipliers[t, t2]; tSummedRatios[t, p][s] += tRatio[t2, p][s] * cmult; tSummedDataAmount[t, p][s] += tTotalMoves[t2, p][s] * cmult; } tTuningResults[t, p][s] = TTT(tSummedRatios[t, p][s], tSummedDataAmount[t, p][s]); } } } int c = 0; int[] tparams = new int[1152]; for (int t = 1; t < 33; t += 15) { if (t == 31) t = 32; SNAPSHOT_WRITLINE_REPLACEMENT("PieceCount = " + t + ": "); for (int p = 0; p < 6; p++) { SNAPSHOT_WRITLINE_REPLACEMENT(TEXELPRINT_PIECES[p]); for (int s = 0; s < 64; s++) { if (s % 8 == 0 && s != 0) SNAPSHOT_WRITLINE_REPLACEMENT(); SNAPSHOT_WRITLINE_REPLACEMENT((tparams[c++] = (int)(tTuningResults[t, p][s] * 100)).ToString().Replace(",", ".") + "("+ (int)tSummedDataAmount[t, p][s] + ")"+ ", "); } SNAPSHOT_WRITLINE_REPLACEMENT(); } } string tS = "PARAMS: {"; for (int i = 0; i < tparams.Length; i++) tS += tparams[i] + ","; tS = tS.Substring(0, tS.Length - 1) + "}\n"; SNAPSHOT_WRITLINE_REPLACEMENT(tS); TexelTuning(pDataset, tparams); } private double TTT(double d1, double d2) { if (d2 == 0) return 0; return d1 /d2; } public void TexelTuning(List<TLM_ChessGame> pDataset, int[] pCurBestParams) { Stopwatch sw = Stopwatch.StartNew(); string tPath = PathManager.GetTXTPath("OTHER/TEXEL_TUNING"); int paramCount = pCurBestParams.Length; double bestAvrgCost = CalculateAverageTexelCost(pDataset, pCurBestParams); SNAPSHOT_WRITLINE_REPLACEMENT("CUR PARAMS COST: " + bestAvrgCost); int packetSize = Math.Clamp(paramCount /ENGINE_VALS.CPU_CORES, 1, 100000); paramsLowerLimits = new int[paramCount]; paramsUpperLimits = new int[paramCount]; for (int i = 0; i < paramCount; i++) { int lim = i < 10 ? 100000 : 200; paramsLowerLimits[i] = -lim; paramsUpperLimits[i] = lim; } SNAPSHOT_WRITLINE_REPLACEMENT("PARAM-COUNT: " + paramCount); SNAPSHOT_WRITLINE_REPLACEMENT("PACKET-SIZE: " + packetSize); while (packetSize <= paramCount) { BOT_MAIN.TEXELfinished = 0; int lM = 0, tC = 0; ulong tUL = 0ul; for (int m = packetSize; lM < paramCount; m += packetSize) { if (m > paramCount) m = paramCount; tUL = ULONG_OPERATIONS.SetBitToOne(tUL, ++tC); lM = m; } tC = lM = 0; for (int m = packetSize; lM < paramCount; m += packetSize) { if (m > paramCount) m = paramCount; tC++; BOT_MAIN.boardManagers[tC].SetPlayTexelVals(pDataset, lM, m, pCurBestParams, paramsLowerLimits, paramsUpperLimits, tC, tUL); ThreadPool.QueueUserWorkItem(new WaitCallback(BOT_MAIN.boardManagers[tC].TexelTuningThreadedPackage)); lM = m; } packetSize = paramCount + 1; int tmod = 0; while (tC != BOT_MAIN.TEXELfinished) { if (++tmod % 20 == 0) { WriteTexelParamsToTXT(tPath, BOT_MAIN.curTEXELPARAMS); SNAPSHOT_WRITLINE_REPLACEMENT(CalculateAverageTexelCost(pDataset, BOT_MAIN.curTEXELPARAMS) + " | "+ BOT_MAIN.TEXELadjustmentsmade); SNAPSHOT_WRITLINE_REPLACEMENT(ULONG_OPERATIONS.GetBitVisualization(BOT_MAIN.TEXELfinishedwithoutimpovement)); } Thread.Sleep(100); } SNAPSHOT_WRITLINE_REPLACEMENT("One Thread Generation FINISHED! :) :) :)"); pCurBestParams = BOT_MAIN.curTEXELPARAMS; } sw.Stop(); WriteTexelParamsToTXT(tPath, BOT_MAIN.curTEXELPARAMS); SNAPSHOT_WRITLINE_REPLACEMENT("END COST: " + CalculateAverageTexelCost(pDataset, BOT_MAIN.curTEXELPARAMS)); SNAPSHOT_WRITLINE_REPLACEMENT(BOT_MAIN.TEXELadjustmentsmade); SNAPSHOT_WRITLINE_REPLACEMENT(sw.ElapsedMilliseconds); } public void TexelTuningThreadedPackage(object obj) { SNAPSHOT_WRITLINE_REPLACEMENT("Started CThreadID [" + customThreadID + "] which is handling Params ["+ threadFrom + "] - ["+ threadTo + "]"); bool firstIter = true; do { double bestAvrgCost = CalculateAverageTexelCost(threadDataset, threadParams); int adjust_val = firstIter ? 512 : 8; do { adjust_val /= 2; bool improvedAvrgCost = true; while (improvedAvrgCost) { improvedAvrgCost = false; for (int i = threadFrom; i < threadTo; i++) { bool improvedWithThisParam = true; int tadjustval = adjust_val; bool lastTimeMaximized = false, lastTimeMinimized = false; while (improvedWithThisParam) { improvedWithThisParam = false; int[] curParams = (int[])threadParams.Clone(); int paramBefore = curParams[i]; curParams[i] = Math.Clamp(paramBefore + adjust_val, paramsLowerLimits[i], paramsUpperLimits[i]); double curAvrgCost = CalculateAverageTexelCost(threadDataset, curParams); if (curAvrgCost < bestAvrgCost) { improvedAvrgCost = true; improvedWithThisParam = true; SNAPSHOT_WRITLINE_REPLACEMENT("Improved Param [" + i + "] at CThreadID ["+ customThreadID + "]: +"+ adjust_val + " ("+ GetDoublePrecentageString(bestAvrgCost - curAvrgCost) + ")"); bestAvrgCost = curAvrgCost; threadParams = curParams; BOT_MAIN.TEXELadjustmentsmade++; BOT_MAIN.TEXELfinishedwithoutimpovement = ulAllThreadIDsUnfinished; if (lastTimeMaximized) { adjust_val *= 4; lastTimeMaximized = false; } else lastTimeMaximized = true; lastTimeMinimized = false; } else { curParams[i] = Math.Clamp(paramBefore - adjust_val, paramsLowerLimits[i], paramsUpperLimits[i]); curAvrgCost = CalculateAverageTexelCost(threadDataset, curParams); if (curAvrgCost < bestAvrgCost) { improvedAvrgCost = true; improvedWithThisParam = true; SNAPSHOT_WRITLINE_REPLACEMENT("Improved Param [" + i + "] at CThreadID ["+ customThreadID + "]: -"+ adjust_val + " ("+ GetDoublePrecentageString(bestAvrgCost - curAvrgCost) + ")"); bestAvrgCost = curAvrgCost; threadParams = curParams; BOT_MAIN.TEXELadjustmentsmade++; BOT_MAIN.TEXELfinishedwithoutimpovement = ulAllThreadIDsUnfinished; if (lastTimeMinimized) { adjust_val *= 4; lastTimeMinimized = false; } else lastTimeMinimized = true; lastTimeMaximized = false; } } if (adjust_val != 1) adjust_val /= 2; for (int j = threadFrom; j < threadTo; j++) { BOT_MAIN.curTEXELPARAMS[j] = threadParams[j]; } threadParams = (int[])BOT_MAIN.curTEXELPARAMS.Clone(); bestAvrgCost = CalculateAverageTexelCost(threadDataset, threadParams); } adjust_val = tadjustval; } } } while (adjust_val != 1); BOT_MAIN.TEXELfinishedwithoutimpovement = ULONG_OPERATIONS.SetBitToZero(BOT_MAIN.TEXELfinishedwithoutimpovement, customThreadID); SNAPSHOT_WRITLINE_REPLACEMENT("FULLY FINISHED " + customThreadID + ". IMPROVEMENT THREAD PACKAGE CYCLE"); firstIter = false; } while (BOT_MAIN.TEXELfinishedwithoutimpovement != 0); BOT_MAIN.TEXELfinished++; } private void WriteTexelParamsToTXT(string pPath, int[] pParams) { try { string tS = "PARAMS: {"; for (int i = 0; i < pParams.Length; i++) tS += pParams[i] + ","; tS = tS.Substring(0, tS.Length - 1) + "}\n"; File.AppendAllText(pPath, tS); } catch { SNAPSHOT_WRITLINE_REPLACEMENT("Mal wieder TXT zu lange gebraucht um zu aktualisieren."); } } private double costSum = 0d; private int texelCostMovesEvaluated = 0; private double CalculateAverageTexelCost(List<TLM_ChessGame> tDataset, int[] pParams, bool pFullCost = true) { costSum = 0d; texelCostMovesEvaluated = 0; SetupTexelEvaluationParams(pParams); int tGameDataSetLen = tDataset.Count; int start = 0, end = tGameDataSetLen; if (!pFullCost) { end = (start = globalRandom.Next(0, end - 256)) + 256; } for (int j = start; j < end; j++) { TLM_ChessGame tGame = tDataset[j]; double tGR = tGame.gameResult; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count - 5; texelCostMovesEvaluated += tL; for (int i = 0; i < tL; i++) { costSum += TexelCost(tGR - TexelTuningSigmoid(TexelEvaluate())); PlainMakeMove(tGame.actualMoves[i]); } } return costSum /texelCostMovesEvaluated; } private double CalculateAverageTexelCostThreadedVersionLEGACYDOESNTWORK(List<TLM_ChessGame> tDataset, int[] pParams) { Stopwatch sw = Stopwatch.StartNew(); BOT_MAIN.TEXELcostSum = 0d; BOT_MAIN.TEXELfinished = 0; BOT_MAIN.TEXELcostMovesEvaluated = 0; int tGameDataSetLen = tDataset.Count; int gamesPerThread = tGameDataSetLen /ENGINE_VALS.CPU_CORES; for (int i = 0; i < ENGINE_VALS.CPU_CORES - 1; i++) { } for (int i = 0; i < ENGINE_VALS.CPU_CORES - 1; i++) { } while (BOT_MAIN.TEXELfinished != ENGINE_VALS.CPU_CORES) Thread.Sleep(1); sw.Stop(); return BOT_MAIN.TEXELcostSum /BOT_MAIN.TEXELcostMovesEvaluated; } public void SetPlayThroughVals(List<TLM_ChessGame> pDataset, int pFrom, int pTo) { threadDataset = pDataset; threadFrom = pFrom; threadTo = pTo; } public void SetPlayTexelVals(List<TLM_ChessGame> pDataset, int pFrom, int pTo, int[] pTexelParams, int[] pLowerLimits, int[] pUpperLimits, int pThreadID, ulong pUL) { threadDataset = pDataset; threadFrom = pFrom; threadTo = pTo; threadParams = pTexelParams; paramsLowerLimits = pLowerLimits; paramsUpperLimits = pUpperLimits; customThreadID = pThreadID; ulAllThreadIDsUnfinished = pUL; } public void PlayThroughSetOfGames(object obj) { SNAPSHOT_WRITLINE_REPLACEMENT(threadFrom + "->"+ threadTo); int sortedOut = 0; for (int j = threadFrom; j < threadTo; j++) { TLM_ChessGame tGame = threadDataset[j]; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count; for (int i = 0; i < tL; i++) { int tQuietEval = isWhiteToMove ? QuiescenceWhite(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, 0, PreMinimaxCheckCheckWhite(), NULL_MOVE) : QuiescenceBlack(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, 0, PreMinimaxCheckCheckBlack(), NULL_MOVE); bool tB; tGame.isMoveNonTactical.Add(tB = (Evaluate() == tQuietEval && i > 4)); if (!tB) sortedOut++; PlainMakeMove(tGame.actualMoves[i]); } } BOT_MAIN.TEXELsortedout += sortedOut; BOT_MAIN.TEXELfinished++; } public void CalculateAverageTexelCostThreadFunction(object obj) { SetupTexelEvaluationParams(threadParams); double d = 0d; for (int j = threadFrom; j < threadTo; j++) { TLM_ChessGame tGame = threadDataset[j]; double tGR = tGame.gameResult; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count - 5; BOT_MAIN.TEXELcostMovesEvaluated += tL; for (int i = 0; i < tL; i++) { d += TexelCost(tGR - TexelTuningSigmoid(TexelEvaluate())); PlainMakeMove(tGame.actualMoves[i]); } } BOT_MAIN.TEXELcostSum += d; BOT_MAIN.TEXELfinished++; } private void ConsoleWriteLineTuneArray<T>(T[,][] pArr) { for (int j = 0; j < 3; j++) { SNAPSHOT_WRITLINE_REPLACEMENT("{"); for (int k = 0; k < 6; k++) { SNAPSHOT_WRITLINE_REPLACEMENT("{"); for (int s = 0; s < 64; s++) SNAPSHOT_WRITLINE_REPLACEMENT(pArr[j, k][s] + ", "); SNAPSHOT_WRITLINE_REPLACEMENT("\n}"); } SNAPSHOT_WRITLINE_REPLACEMENT("}"); } } private void Tune(string pGameCGFF, double pLearningRate) { TLM_ChessGame tGame = CGFF.GetGame(pGameCGFF); LoadFenString(tGame.startFen); double tDGameResult = tGame.gameResult; foreach (int hMove in tGame.hashedMoves) { Tune(tDGameResult, pLearningRate); List<Move> moveOptionList = new List<Move>(); GetLegalMoves(ref moveOptionList); int tL = moveOptionList.Count; for (int i = 0; i < tL; i++) { Move tMove = moveOptionList[i]; if (tMove.moveHash == hMove) { PlainMakeMove(tMove); tL = -1; break; } } if (tL != -1) break; } } private void Tune(double pGameResult, double pLearningRate) { int tPC = ULONG_OPERATIONS.CountBits(allPieceBitboard); double oneThroughPieceCount = 1d /tPC; double egMult = earlyGameMultipliers[tPC], mgMult = middleGameMultipliers[tPC], lgMult = lateGameMultipliers[tPC]; double tTexelResult = TexelEvaluateF(); double tSigmoidedTexelResult = TexelSigmoid(tTexelResult); double tDif = tSigmoidedTexelResult - pGameResult; double tM = oneThroughPieceCount * TexelCostDerivative(tDif) * TexelSigmoidDerivative(tTexelResult) * pLearningRate; sumCostVals += lastCostVal = TexelCost(tDif); costCalculations++; for (int i = 0; i < 64; i++) { if (ULONG_OPERATIONS.IsBitZero(allPieceBitboard, i)) continue; int tPT = pieceTypeArray[i] - 1, tI = i; if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, i)) tI = blackSidedSquares[i]; texelTuningAdjustIterations[tPT, tI]++; } } private double TexelEvaluateF() { texelTuningRuntimeVals = GetInterpolatedProcessedValues(texelTuningVals); return TexelEvaluate(); } private int TexelEvaluate() { int tEvalEG = 0, tEvalLG = 0, tProgress = 0; ulong[] attkULs = new ulong[14]; for (int p = 0; p < 64; p++) { if (((int)(allPieceBitboard >> p) & 1) == 0) continue; int aPT = pieceTypeArray[p], tPT = aPT + 7 * ((int)(blackPieceBitboard >> p) & 1); tEvalEG += texelTuningRuntimePositionalValsV2EG[tPT][p] + texelPieceEvaluationsV2EG[tPT]; tEvalLG += texelTuningRuntimePositionalValsV2LG[tPT][p] + texelPieceEvaluationsV2LG[tPT]; tProgress += pieceTypeGameProgressImpact[tPT]; } if (tProgress > 24) tProgress = 24; return (int)(earlyGameMultipliers[tProgress] * tEvalEG + lateGameMultipliers[tProgress] * tEvalLG); } private const double TexelK = 0.2; private double TexelTuningSigmoid(double pVal) { return 2d /(1 + Math.Pow(10, -TexelK * pVal /400)); } private double TexelSigmoid(double pVal) { return 2d /(Math.Exp(-0.04d * pVal) + 1d); } private double TexelSigmoidDerivative(double pVal) { double d = Math.Exp(-0.04d * pVal); return 2d * d /(25d * (d + 1d) * (d + 1d)); } private double TexelCost(double pVal) { return pVal * pVal; } private double TexelCostDerivative(double pVal) { return 2 * pVal; } private char[] fenPieces = new char[7] { 'z', 'p', 'n', 'b', 'r', 'q', 'k' }; private string[] squareNames = new string[64] { "a1", "b1", "c1", "d1", "e1", "f1", "g1", "h1", "a2", "b2", "c2", "d2", "e2", "f2", "g2", "h2", "a3", "b3", "c3", "d3", "e3", "f3", "g3", "h3", "a4", "b4", "c4", "d4", "e4", "f4", "g4", "h4", "a5", "b5", "c5", "d5", "e5", "f5", "g5", "h5", "a6", "b6", "c6", "d6", "e6", "f6", "g6", "h6", "a7", "b7", "c7", "d7", "e7", "f7", "g7", "h7", "a8", "b8", "c8", "d8", "e8", "f8", "g8", "h8"}; public string CreateFenString() { string rFEN = ""; for (int i = 7; i >= 0; i--) { int t = 0; for (int j = 0; j < 8; j++) { int sq = i * 8 + j; if (pieceTypeArray[sq] != 0) { if (t != 0) rFEN += t; t = 0; } if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, sq)) { switch (pieceTypeArray[sq]) { case 0: t++; SNAPSHOT_WRITLINE_REPLACEMENT("???"); break; case 1: rFEN += 'P'; break; case 2: rFEN += 'N'; break; case 3: rFEN += 'B'; break; case 4: rFEN += 'R'; break; case 5: rFEN += 'Q'; break; case 6: rFEN += 'K'; break; } } else { switch (pieceTypeArray[sq]) { case 0: t++; break; case 1: rFEN += 'p'; break; case 2: rFEN += 'n'; break; case 3: rFEN += 'b'; break; case 4: rFEN += 'r'; break; case 5: rFEN += 'q'; break; case 6: rFEN += 'k'; break; } } } if (t != 0) rFEN += t; if (i != 0) rFEN += "/"; } rFEN += (isWhiteToMove ? " w": " b"); rFEN += (whiteCastleRightKingSide ? " K": " "); rFEN += (whiteCastleRightQueenSide ? "Q": ""); rFEN += (blackCastleRightKingSide ? "k": ""); rFEN += (blackCastleRightQueenSide ? "q": ""); if (!whiteCastleRightKingSide && !whiteCastleRightQueenSide && !blackCastleRightKingSide && !blackCastleRightQueenSide) rFEN += "-"; if (enPassantSquare < 64) rFEN += " "+ squareNames[enPassantSquare] + " "; else rFEN += " - "; return rFEN + fiftyMoveRuleCounter + " "+ ((happenedHalfMoves - happenedHalfMoves % 2) /2); } public void LoadFenString(string fenStr) { debugFEN = fenStr; lastMadeMove = NULL_MOVE; zobristKey = 0ul; whitePieceBitboard = blackPieceBitboard = allPieceBitboard = 0ul; for (int i = 0; i < 64; i++) pieceTypeArray[i] = 0; string[] spaceSpl = fenStr.Split(' '); string[] rowSpl = spaceSpl[0].Split('/'); string epstr = spaceSpl[3]; if (epstr == "-") enPassantSquare = 65; else enPassantSquare = (epstr[0] - 'a') + 8 * (epstr[1] - '1'); isWhiteToMove = true; if (spaceSpl[1] == "b") isWhiteToMove = false; if (!isWhiteToMove) zobristKey ^= blackTurnHash; string crstr = spaceSpl[2]; whiteCastleRightKingSide = whiteCastleRightQueenSide = blackCastleRightKingSide = blackCastleRightQueenSide = false; int crStrL = crstr.Length; for (int i = 0; i < crStrL; i++) { switch (crstr[i]) { case 'K': whiteCastleRightKingSide = true; break; case 'Q': whiteCastleRightQueenSide = true; break; case 'k': blackCastleRightKingSide = true; break; case 'q': blackCastleRightQueenSide = true; break; } } fiftyMoveRuleCounter = Convert.ToInt32(spaceSpl[4]); happenedHalfMoves = Convert.ToInt32(spaceSpl[5]) * 2; if (!isWhiteToMove) happenedHalfMoves++; int tSq = 0; for (int i = rowSpl.Length; i-- > 0;) { string tStr = rowSpl[i]; int tStrLen = tStr.Length; for (int c = 0; c < tStrLen; c++) { char tChar = tStr[c]; if (Char.IsDigit(tChar)) tSq += tChar - '0'; else { bool tCol = Char.IsLower(tChar); if (tCol) blackPieceBitboard = ULONG_OPERATIONS.SetBitToOne(blackPieceBitboard, tSq); else whitePieceBitboard = ULONG_OPERATIONS.SetBitToOne(whitePieceBitboard, tSq); if (tChar == 'k') blackKingSquare = tSq; else if (tChar == 'K') whiteKingSquare = tSq; pieceTypeArray[tSq] = Array.IndexOf(fenPieces, Char.ToLower(tChar)); if (tCol) zobristKey ^= pieceHashesBlack[tSq, pieceTypeArray[tSq]]; else zobristKey ^= pieceHashesWhite[tSq, pieceTypeArray[tSq]]; tSq++; } } } if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; zobristKey ^= enPassantSquareHashes[enPassantSquare]; allPieceBitboard = whitePieceBitboard | blackPieceBitboard; if (zobristKey == 16260251586586513106) moveHashList.Clear(); else { moveHashList.Clear(); moveHashList.Add(1); moveHashList.Add(2); moveHashList.Add(3); } } private ulong[,] pieceHashesWhite = new ulong[64, 7], pieceHashesBlack = new ulong[64, 7]; private ulong blackTurnHash, whiteKingSideRochadeRightHash, whiteQueenSideRochadeRightHash, blackKingSideRochadeRightHash, blackQueenSideRochadeRightHash; private ulong[] enPassantSquareHashes = new ulong[66]; private Dictionary<ulong, int> singleCheckCaseBackup = new Dictionary<ulong, int>(); private void InitZobrist() { Random rng = new Random(31415926); for (int sq = 0; sq < 64; sq++) { enPassantSquareHashes[sq] = ULONG_OPERATIONS.GetRandomULONG(rng); for (int it = 1; it < 7; it++) { pieceHashesWhite[sq, it] = ULONG_OPERATIONS.GetRandomULONG(rng); pieceHashesBlack[sq, it] = ULONG_OPERATIONS.GetRandomULONG(rng); } } blackTurnHash = ULONG_OPERATIONS.GetRandomULONG(rng); whiteKingSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); whiteQueenSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); blackKingSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); blackQueenSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); } public void SetKnightMasks(ulong[] uls) { knightSquareBitboards = uls; } public void SetKingMasks(ulong[] uls) { kingSquareBitboards = uls; } private Move[,] whiteEnPassantMoves = new Move[64, 64]; private Move[,] blackEnPassantMoves = new Move[64, 64]; private bool[] epValidationArray = new bool[64] { false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true , true , true , true , true , true , true , true, true , true , true , true , true , true , true , true, true , true , true , true , true , true , true , true, true , true , true , true , true , true , true , true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false }; private ulong[] kingSafetyRing1 = new ulong[64], kingSafetyRing2 = new ulong[64]; private ulong[] kingSafetySpecialRingW = new ulong[64], kingSafetySpecialRingB = new ulong[64]; private ulong[] rowPrecalcs = new ulong[8], columnPrecalcs = new ulong[8]; const ulong columnUL = 0x101010101010101, rowUL = 0b11111111; private void PrecalculateKingSafetyBitboards() { for (int i = 0; i < 8; i++) { rowPrecalcs[i] = rowUL << (8 * i); columnPrecalcs[i] = columnUL << i; } for (int i = 0; i < 64; i++) { int tMod = i % 8; int tRow = (i - tMod) /8; ulong tULC = columnPrecalcs[tMod], tULR = rowPrecalcs[tRow]; ulong tULC2 = columnPrecalcs[tMod], tULR2 = rowPrecalcs[tRow]; if (tMod < 7) tULC |= columnPrecalcs[tMod + 1]; if (tMod > 0) tULC |= columnPrecalcs[tMod - 1]; if (tRow < 7) tULR |= rowPrecalcs[tRow + 1]; if (tRow > 0) tULR |= rowPrecalcs[tRow - 1]; if (tMod < 6) tULC2 |= columnPrecalcs[tMod + 2]; if (tMod > 1) tULC2 |= columnPrecalcs[tMod - 2]; if (tRow < 6) tULR2 |= rowPrecalcs[tRow + 2]; if (tRow > 1) tULR2 |= rowPrecalcs[tRow - 2]; tULR2 |= tULR; tULC2 |= tULC; kingSafetyRing1[i] = ULONG_OPERATIONS.SetBitToZero(tULR & tULC, i); kingSafetyRing2[i] = ULONG_OPERATIONS.SetBitsToZero(tULR2 & tULC2, i, i + 1, i - 1, i + 7, i + 8, i + 9, i - 7, i - 8, i - 9); } for (int i = 0; i < 64; i++) { if (i < 56) kingSafetySpecialRingW[i] = ULONG_OPERATIONS.SetBitToZero(kingSafetyRing1[i] | kingSafetyRing1[i + 8], i); else kingSafetySpecialRingW[i] = kingSafetyRing1[i]; if (i > 7) kingSafetySpecialRingB[i] = ULONG_OPERATIONS.SetBitToZero(kingSafetyRing1[i] | kingSafetyRing1[i - 8], i); else kingSafetySpecialRingB[i] = kingSafetyRing1[i]; } } private void PrecalculateEnPassantMoves() { for (int i = 0; i < 64; i++) { if (!epValidationArray[i]) continue; for (int j = 0; j < 64; j++) { if (i == j) continue; if (Math.Abs(i - j) > 9) continue; if (!epValidationArray[j]) continue; whiteEnPassantMoves[i, j] = new Move(false, i, j, j - 8); blackEnPassantMoves[i, j] = new Move(false, i, j, j + 8); } } } private void PawnAttackBitboards() { for (int sq = 0; sq < 64; sq++) { ulong u = 0ul; if (sq % 8 != 0) u = ULONG_OPERATIONS.SetBitToOne(u, sq + 7); if (sq % 8 != 7) u = ULONG_OPERATIONS.SetBitToOne(u, sq + 9); whitePawnAttackSquareBitboards[sq] = u; u = 0ul; if (sq % 8 != 0 && sq - 9 > -1) u = ULONG_OPERATIONS.SetBitToOne(u, sq - 9); if (sq % 8 != 7 && sq - 7 > -1) u = ULONG_OPERATIONS.SetBitToOne(u, sq - 7); blackPawnAttackSquareBitboards[sq] = u; } } private int[] squareConnectivesPrecalculationArray = new int[4096]; public int[] squareConnectivesCrossDirsPrecalculationArray { get; set; } = new int[4096]; private ulong[] squareConnectivesPrecalculationRayArray = new ulong[4096]; private ulong[] squareConnectivesPrecalculationLineArray = new ulong[4096]; private List<Dictionary<ulong, int>> rayCollidingSquareCalculations = new List<Dictionary<ulong, int>>(); private readonly int[] maxIntWithSpecifiedBitcount = new int[8] { 0, 0b1, 0b11, 0b111, 0b1111, 0b11111, 0b111111, 0b1111111 }; private List<ulong> differentRays = new List<ulong>(); private void SquareConnectivesPrecalculations() { for (int square = 0; square < 64; square++) { rayCollidingSquareCalculations.Add(new Dictionary<ulong, int>()); rayCollidingSquareCalculations[square].Add(0ul, square); for (int square2 = 0; square2 < 64; square2++) { if (square == square2) continue; int t = 0, t2 = 0, difSign = Math.Sign(square2 - square), itSq = square, g = 0; ulong tRay = 0ul, tExclRay = 0ul; List<int> tRayInts = new List<int>(); if (difSign == -1) g = 7; if (square % 8 == square2 % 8) { t2 = t = 1; while ((itSq += difSign * 8) < 64 && itSq > -1) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } } else if ((square - square % 8) == (square2 - square2 % 8)) { t = 1; t2 = -1; while ((itSq += difSign) % 8 != g && itSq > -1 && itSq < 64) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } } else { int dif = Math.Abs(square2 - square); if (dif % 7 == 0) { t = 2; t2 = 2; g = (difSign == 1) ? 7 : 0; while ((itSq += difSign * 7) % 8 != g && itSq < 64 && itSq > -1) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } if (ULONG_OPERATIONS.IsBitZero(tRay, square2)) { t2 = t = 0; tRay = 0ul; } } else if (dif % 9 == 0) { t = 2; t2 = -2; if (square == 0 && square2 == 63 || square == 63 && square2 == 0) SNAPSHOT_WRITLINE_REPLACEMENT("!"); while ((itSq += difSign * 9) % 8 != g && itSq < 64 && itSq > -1) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } if (ULONG_OPERATIONS.IsBitZero(tRay, square2)) { t2 = t = 0; tRay = 0ul; } } } if (square == 0 && square2 == 63) { t2 = t = 2; tRayInts.Clear(); tExclRay = tRay = ULONG_OPERATIONS.SetBitsToOne(0ul, 9, 18, 27, 36, 45, 54, 63); tRayInts = new List<int>() { 9, 18, 27, 36, 45, 54, 63 }; } else if (square2 == 0 && square == 63) { t = 2; tRayInts.Clear(); t2 = -2; tExclRay = tRay = ULONG_OPERATIONS.SetBitsToOne(0ul, 0, 9, 18, 27, 36, 45, 54); tRayInts = new List<int>() { 54, 45, 36, 27, 18, 9, 0 }; } if (tRay != 0ul && !differentRays.Contains(tRay)) { differentRays.Add(tRay); int ccount, combI = maxIntWithSpecifiedBitcount[ccount = ULONG_OPERATIONS.CountBits(tRay)]; do { ulong curAllPieceBitboard = 0ul; int solution = square; for (int j = 0; j < ccount; j++) { if (((combI >> j) & 1) == 1) { curAllPieceBitboard = ULONG_OPERATIONS.SetBitToOne(curAllPieceBitboard, tRayInts[j]); if (solution == square) solution = tRayInts[j]; } } rayCollidingSquareCalculations[square].Add(curAllPieceBitboard, solution); } while (--combI != 0); } squareConnectivesPrecalculationArray[square << 6 | square2] = t; squareConnectivesPrecalculationRayArray[square << 6 | square2] = tRay; squareConnectivesCrossDirsPrecalculationArray[square << 6 | square2] = t2; if (t != 0) squareConnectivesPrecalculationLineArray[square << 6 | square2] = (square == 0 && square2 == 63 || square2 == 0 && square == 63) ? tExclRay : ULONG_OPERATIONS.SetBitToOne(tExclRay, square2); if (squareConnectivesPrecalculationLineArray[square << 6 | square2] == 0ul && ULONG_OPERATIONS.IsBitOne(knightSquareBitboards[square], square2)) squareConnectivesPrecalculationLineArray[square << 6 | square2] = 1ul << square2; } differentRays.Clear(); } } public void SNAPSHOT_WRITLINE_REPLACEMENT() { } public void SNAPSHOT_WRITLINE_REPLACEMENT(object pStr) { } private string GetDoublePrecentageString(double pVal) { return ((int)(pVal * 1_000_000) /10_000d) + "%"; } private string ReplaceAllULONGIsBitOne(string pCode) { const string METHOD_NAME = "ULONG_OPERATIONS.IsBitOne"; int METHOD_NAME_LEN = METHOD_NAME.Length, iterations = 0; int pIndex = pCode.IndexOf(METHOD_NAME); while (pIndex != -1 && ++iterations < 10_000) { List<int> paramIndexes = new List<int>(); int openedBracketCount = 1, closedBracketCount = 0, a = METHOD_NAME_LEN + pIndex; string tpCode = pCode.Substring(0, pIndex); paramIndexes.Add(a + 1); while (++a < pCode.Length) { switch (pCode[a]) { case '(': openedBracketCount++; break; case ')': if (++closedBracketCount == openedBracketCount) { pIndex = a; a = int.MaxValue - 5; } break; case ',': if (openedBracketCount - closedBracketCount == 1) paramIndexes.Add(a + 1); break; } } if (openedBracketCount == closedBracketCount && paramIndexes.Count == 2) { tpCode += "((int)("+ pCode.Substring(paramIndexes[0], paramIndexes[1] - paramIndexes[0] - 1) + (pCode[paramIndexes[1]] == ' ' ? " >> (": " >> (") + pCode.Substring(paramIndexes[1], pIndex - paramIndexes[1]) + ")) & 1) == 1"+ pCode.Substring(pIndex + 1, pCode.Length - pIndex - 1); } pIndex = (pCode = tpCode).IndexOf(METHOD_NAME); } SNAPSHOT_WRITLINE_REPLACEMENT(iterations + " ITERATIONS"); return pCode; } private string ReplaceAllULONGIsBitZero(string pCode) { const string METHOD_NAME = "ULONG_OPERATIONS.IsBitZero"; int METHOD_NAME_LEN = METHOD_NAME.Length, iterations = 0; int pIndex = pCode.IndexOf(METHOD_NAME); while (pIndex != -1 && ++iterations < 10_000) { List<int> paramIndexes = new List<int>(); int openedBracketCount = 1, closedBracketCount = 0, a = METHOD_NAME_LEN + pIndex; string tpCode = pCode.Substring(0, pIndex); paramIndexes.Add(a + 1); while (++a < pCode.Length) { switch (pCode[a]) { case '(': openedBracketCount++; break; case ')': if (++closedBracketCount == openedBracketCount) { pIndex = a; a = int.MaxValue - 5; } break; case ',': if (openedBracketCount - closedBracketCount == 1) paramIndexes.Add(a + 1); break; } } if (openedBracketCount == closedBracketCount && paramIndexes.Count == 2) { tpCode += "((int)("+ pCode.Substring(paramIndexes[0], paramIndexes[1] - paramIndexes[0] - 1) + (pCode[paramIndexes[1]] == ' ' ? " >>": " >> ") + pCode.Substring(paramIndexes[1], pIndex - paramIndexes[1]) + ") & 1) == 0"+ pCode.Substring(pIndex + 1, pCode.Length - pIndex - 1); } pIndex = (pCode = tpCode).IndexOf(METHOD_NAME); } SNAPSHOT_WRITLINE_REPLACEMENT(iterations + " ITERATIONS"); return pCode; } private string GetThreeDigitSeperatedInteger(int pInt) { string s = pInt.ToString(), r = s[0].ToString(); int t = s.Length % 3; for (int i = 1; i < s.Length; i++) { if (i % 3 == t) r += "."; r += s[i]; } s = ""; for (int i = 0; i < r.Length; i++) s += r[i]; return s; } public double GetAverageDepth() { return (double)depths /(double)searches; } }
public class SNAPSHOT_V01_00_010 : IBoardManager  { public int TEXEL_PARAMS { get; } = 778; private const int BESTMOVE_SORT_VAL = -2_000_000_000; private const int CAPTURE_SORT_VAL = -1_000_000_000; private const int KILLERMOVE_SORT_VAL = -1000; private readonly int[,] MVVLVA_TABLE = new int[7, 7] { { 0, 0, 0, 0, 0, 0, 0 }, { 0, 1500, 1400, 1300, 1200, 1100, 1000 }, { 0, 3500, 3400, 3300, 3200, 3100, 3000 }, { 0, 4500, 4400, 4300, 4200, 4100, 4000 }, { 0, 5500, 5400, 5300, 5200, 5100, 5000 }, { 0, 9500, 9400, 9300, 9200, 9100, 9000 }, { 0, 0, 0, 0, 0, 0, 0 }}; private int BOARD_MANAGER_ID = -1; private bool debugSearchDepthResults = false; private bool debugSortResults = false; private RookMovement rookMovement; private BishopMovement bishopMovement; private QueenMovement queenMovement; private KnightMovement knightMovement; private KingMovement kingMovement; private WhitePawnMovement whitePawnMovement; private BlackPawnMovement blackPawnMovement; private Rays rays; public List<Move> moveOptionList { get; set; } private int[] pieceTypeArray = new int[64]; public ulong whitePieceBitboard, blackPieceBitboard, allPieceBitboard; private ulong zobristKey; private int whiteKingSquare, blackKingSquare, enPassantSquare = 65, happenedHalfMoves = 0, fiftyMoveRuleCounter = 0; private bool whiteCastleRightKingSide, whiteCastleRightQueenSide, blackCastleRightKingSide, blackCastleRightQueenSide; private bool isWhiteToMove; private const ulong WHITE_KING_ROCHADE = 96, WHITE_QUEEN_ROCHADE = 14, BLACK_KING_ROCHADE = 6917529027641081856, BLACK_QUEEN_ROCHADE = 1008806316530991104, WHITE_QUEEN_ATTK_ROCHADE = 12, BLACK_QUEEN_ATTK_ROCHADE = 864691128455135232; private readonly Move mWHITE_KING_ROCHADE = new Move(4, 6, 7, 5), mWHITE_QUEEN_ROCHADE = new Move(4, 2, 0, 3), mBLACK_KING_ROCHADE = new Move(60, 62, 63, 61), mBLACK_QUEEN_ROCHADE = new Move(60, 58, 56, 59); private ulong[] knightSquareBitboards = new ulong[64]; private ulong[] whitePawnAttackSquareBitboards = new ulong[64]; private ulong[] blackPawnAttackSquareBitboards = new ulong[64]; private ulong[] kingSquareBitboards = new ulong[64]; private bool[,] pieceTypeAbilities = new bool[7, 3] { { false, false, false }, { false, false, false }, { false, false, false }, { false, false, true }, { false, true, false }, { false, true, true }, { false, false, false } }; private List<int> moveHashList = new List<int>(); private ulong[] curSearchZobristKeyLine = Array.Empty<ulong>(); private Move[] debugMoveList = new Move[128]; private string debugFEN = ""; private Stopwatch globalTimer = Stopwatch.StartNew(); private Move lastMadeMove; private int depths, searches; private Random globalRandom = new Random(); public SNAPSHOT_V01_00_010(string fen) { Setup(fen); } public void Setup(string pFen) { Stopwatch setupStopwatch = Stopwatch.StartNew(); BOARD_MANAGER_ID = BOT_MAIN.curBoardManagerID; for (int i = 0; i < 33; i++) for (int j = 0; j < 14; j++) piecePositionEvals[i, j] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; for (int i = 0; i < 33; i++) for (int j = 0; j < 14; j++) texelTuningRuntimeVals[i, j] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; for (int i = 0; i < 3; i++) for (int j = 0; j < 6; j++) texelTuningVals[i, j] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; for (int i = 0; i < 14; i++) { texelTuningRuntimePositionalValsV2EG[i] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; texelTuningRuntimePositionalValsV2LG[i] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; } PrecalculateKingSafetyBitboards(); PrecalculateMultipliers(); GetLowNoisePositionalEvaluation(globalRandom); MinimaxRoot(1L); SetupConsoleWrite("[PRECALCS] Zobrist Hashing"); InitZobrist(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Knight Movement"); knightMovement = new KnightMovement(this); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Square Connectives"); SquareConnectivesPrecalculations(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Pawn Attack Bitboards"); PawnAttackBitboards(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Rays"); rays = new Rays(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); queenMovement = new QueenMovement(this); SetupConsoleWrite("[PRECALCS] Rook Movement"); rookMovement = new RookMovement(this, queenMovement); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Bishop Movement"); bishopMovement = new BishopMovement(this, queenMovement); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] King Movement"); kingMovement = new KingMovement(this); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Pawn Movement"); whitePawnMovement = new WhitePawnMovement(this); blackPawnMovement = new BlackPawnMovement(this); PrecalculateEnPassantMoves(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWriteLine("[DONE]\n\n"); LoadFenString(pFen); LoadBestTexelParamsIn(); setupStopwatch.Stop(); } private void SetupConsoleWriteLine(string pStr) { if (BOT_MAIN.isFirstBoardManagerInitialized) return; SNAPSHOT_WRITLINE_REPLACEMENT(pStr); } private void SetupConsoleWrite(string pStr) { if (BOT_MAIN.isFirstBoardManagerInitialized) return; SNAPSHOT_WRITLINE_REPLACEMENT(pStr); } public void GetLowNoisePositionalEvaluation(System.Random rng) { int[,][] digitArray = new int[3, 6][]; for (int i = 0; i < 3; i++) for (int j = 0; j < 6; j++) digitArray[i, j] = GetRand64IntArray(rng, -5, 6); lowNoisePositionEvals1 = GetInterpolatedProcessedValues(digitArray); int[,][] digitArray2 = new int[3, 6][]; for (int i = 0; i < 3; i++) for (int j = 0; j < 6; j++) digitArray2[i, j] = GetRand64IntArray(rng, -5, 6); lowNoisePositionEvals2 = GetInterpolatedProcessedValues(digitArray2); } private int[] GetRand64IntArray(System.Random rng, int pMin, int pMax) { return new int[64] { rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax) }; } private string GetAIArrayValuesStringRepresentation(int[,][] pArr) { string r = "int[,][] ReLe_AI_RESULT_VALS = new int[3, 6][] {"; for (int i = 0; i < 3; i++) { r += "{"; for (int j = 0; j < 5; j++) { r += GetIntArray64LStringRepresentation(pArr[i, j]) + ","; } r += GetIntArray64LStringRepresentation(pArr[i, 5]) + "},"; } return r.Substring(0, r.Length - 1) + "};"; } private string GetIntArray64LStringRepresentation(int[] p64LArr) { if (p64LArr == null) return ""; string r = "new int[64]{"; for (int i = 0; i < 63; i++) { r += p64LArr[i] + ","; } return r + p64LArr[63] + "}"; } public void TempStuff() { } private string[] gameResultStrings = new string[5] { "Black Has Won!", "Draw!", "White Has Won!", "Non Existant Result!", "Game is Ongoing!"}; private int[,][] lowNoisePositionEvals1, lowNoisePositionEvals2; public void ThreadSelfPlay(object obj) { PlayGameAgainstItself(obj); } public void PlayGameAgainstItself(object obj, string pStartFEN = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1", long tickLimitForEngine = ENGINE_VALS.SELF_PLAY_THINK_TIME) { int ttGState; while (BOT_MAIN.goalGameCount > BOT_MAIN.gamesPlayed) { try { string tGameStr; GetLowNoisePositionalEvaluation(globalRandom); LoadFenString(tGameStr = pStartFEN); tGameStr += ";"; int tGState = 3, tmc = 0; bool lowNoiceDecider = globalRandom.NextDouble() < 0.5d; while (tGState == 3) { piecePositionEvals = lowNoiceDecider ? lowNoisePositionEvals1 : lowNoisePositionEvals2; MinimaxRoot(tickLimitForEngine); Move tM = transpositionTable[zobristKey].bestMove; PlainMakeMove(tM); tGameStr += NuCRe.GetNuCRe(tM.moveHash) + ","; BOT_MAIN.movesPlayed++; tGState = GameState(isWhiteToMove); lowNoiceDecider = !lowNoiceDecider; tmc++; } ttGState = tGState; tGameStr += ttGState + 1; SNAPSHOT_WRITLINE_REPLACEMENT(tGameStr); BOT_MAIN.gamesPlayedResultArray[ttGState + 1]++; BOT_MAIN.gamesPlayed++; BOT_MAIN.selfPlayGameStrings.Add(tGameStr); } catch (Exception tE) { SNAPSHOT_WRITLINE_REPLACEMENT(tE.ToString()); } } } public void PlayGameOnConsoleAgainstHuman(string pStartFEN = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1", bool pHumanPlaysWhite = true, long tickLimitForEngine = 10_000_000L) { debugSearchDepthResults = true; LoadFenString(pStartFEN); if (!(pHumanPlaysWhite ^ isWhiteToMove)) { var pVS = Console.ReadLine(); if (pVS == null) return; Move tm = GetMoveOfString(pVS.ToString()); SNAPSHOT_WRITLINE_REPLACEMENT(tm); PlainMakeMove(tm); } int tGState = 3; while (tGState == 3) { MinimaxRoot(tickLimitForEngine); PlayThroughZobristTree(); Move tM = transpositionTable[zobristKey].bestMove; SNAPSHOT_WRITLINE_REPLACEMENT(tM); SNAPSHOT_WRITLINE_REPLACEMENT(CreateFenString()); PlainMakeMove(tM); tGState = GameState(isWhiteToMove); if (tGState != 3 || tM == NULL_MOVE) break; var pV = ""; tM = NULL_MOVE; do { pV = Console.ReadLine(); if (pV == null) continue; tM = GetMoveOfString(pV.ToString()); SNAPSHOT_WRITLINE_REPLACEMENT(tM); } while (tM == NULL_MOVE); PlainMakeMove(tM); tGState = GameState(isWhiteToMove); } } private void PlayThroughZobristTree() { SetJumpState(); SNAPSHOT_WRITLINE_REPLACEMENT("\n- - - - - - - - - - - - -"); int tC = 1; Dictionary<ulong, bool> usedULs = new Dictionary<ulong, bool>(); while (transpositionTable.TryGetValue(zobristKey, out TranspositionEntry tM)) { if (usedULs.ContainsKey(zobristKey)) { SNAPSHOT_WRITLINE_REPLACEMENT(tC + ": AT LEAST ONE REPETION; REST NOT VISIBLE"); break; } SNAPSHOT_WRITLINE_REPLACEMENT(tC + ": "+ tM.bestMove + " > "); usedULs.Add(zobristKey, true); PlainMakeMove(tM.bestMove); tC++; } SNAPSHOT_WRITLINE_REPLACEMENT("- - - - - - - - - - - - -\n"); LoadJumpState(); } public Move? ReturnNextMove(Move? lastMove, long pThinkingTime) { if (lastMove != null) PlainMakeMove(lastMove); if (GameState(isWhiteToMove) != 3) return null; MinimaxRoot(pThinkingTime); if (!transpositionTable.ContainsKey(zobristKey)) return null; Move tm = transpositionTable[zobristKey].bestMove; PlainMakeMove(tm); return tm; } private int[] jmpSt_pieceTypeArray; private ulong jmpSt_whitePieceBitboard, jmpSt_blackPieceBitboard; private ulong jmpSt_zobristKey; private int jmpSt_whiteKingSquare, jmpSt_blackKingSquare, jmpSt_enPassantSquare, jmpSt_happenedHalfMoves, jmpSt_fiftyMoveRuleCounter; private bool jmpSt_whiteCastleRightKingSide, jmpSt_whiteCastleRightQueenSide, jmpSt_blackCastleRightKingSide, jmpSt_blackCastleRightQueenSide; private bool jmpSt_isWhiteToMove; private ulong[] jmpSt_curSearchZobristKeyLine; private int[] jmpSt_moveHashList; public void LoadJumpState() { pieceTypeArray = (int[])jmpSt_pieceTypeArray.Clone(); whitePieceBitboard = jmpSt_whitePieceBitboard; blackPieceBitboard = jmpSt_blackPieceBitboard; zobristKey = jmpSt_zobristKey; whiteKingSquare = jmpSt_whiteKingSquare; blackKingSquare = jmpSt_blackKingSquare; enPassantSquare = jmpSt_enPassantSquare; happenedHalfMoves = jmpSt_happenedHalfMoves; fiftyMoveRuleCounter = jmpSt_fiftyMoveRuleCounter; whiteCastleRightKingSide = jmpSt_whiteCastleRightKingSide; whiteCastleRightQueenSide = jmpSt_whiteCastleRightQueenSide; blackCastleRightKingSide = jmpSt_blackCastleRightKingSide; blackCastleRightQueenSide = jmpSt_blackCastleRightQueenSide; isWhiteToMove = jmpSt_isWhiteToMove; curSearchZobristKeyLine = (ulong[])jmpSt_curSearchZobristKeyLine.Clone(); allPieceBitboard = blackPieceBitboard | whitePieceBitboard; moveHashList = jmpSt_moveHashList.ToList(); } public void SetJumpState() { jmpSt_pieceTypeArray = (int[])pieceTypeArray.Clone(); jmpSt_whitePieceBitboard = whitePieceBitboard; jmpSt_blackPieceBitboard = blackPieceBitboard; jmpSt_zobristKey = zobristKey; jmpSt_whiteKingSquare = whiteKingSquare; jmpSt_blackKingSquare = blackKingSquare; jmpSt_enPassantSquare = enPassantSquare; jmpSt_happenedHalfMoves = happenedHalfMoves; jmpSt_fiftyMoveRuleCounter = fiftyMoveRuleCounter; jmpSt_whiteCastleRightKingSide = whiteCastleRightKingSide; jmpSt_whiteCastleRightQueenSide = whiteCastleRightQueenSide; jmpSt_blackCastleRightKingSide = blackCastleRightKingSide; jmpSt_blackCastleRightQueenSide = blackCastleRightQueenSide; jmpSt_isWhiteToMove = isWhiteToMove; jmpSt_curSearchZobristKeyLine = (ulong[])curSearchZobristKeyLine.Clone(); jmpSt_moveHashList = moveHashList.ToArray(); } private int PreMinimaxCheckCheckWhite() { ulong bitShiftedKingPos = 1ul << whiteKingSquare; int curR = -1; for (int p = 0; p < 64; p++) { if (ULONG_OPERATIONS.IsBitZero(blackPieceBitboard, p)) continue; int tPT; switch (tPT = pieceTypeArray[p]) { case 1: if ((bitShiftedKingPos & blackPawnAttackSquareBitboards[p]) != 0ul) return p; break; case 2: if ((bitShiftedKingPos & knightSquareBitboards[p]) != 0ul) return p; break; case 6: break; default: if ((squareConnectivesPrecalculationLineArray[whiteKingSquare << 6 | p] & allPieceBitboard) == (1ul << p) && pieceTypeAbilities[tPT, squareConnectivesPrecalculationArray[whiteKingSquare << 6 | p]]) { if (curR != -1) return -779; curR = p; } break; } } return curR; } private int PreMinimaxCheckCheckBlack() { ulong bitShiftedKingPos = 1ul << blackKingSquare; int curR = -1; for (int p = 0; p < 64; p++) { if (ULONG_OPERATIONS.IsBitZero(whitePieceBitboard, p)) continue; int tPT; switch (tPT = pieceTypeArray[p]) { case 1: if ((bitShiftedKingPos & whitePawnAttackSquareBitboards[p]) != 0ul) return p; break; case 2: if ((bitShiftedKingPos & knightSquareBitboards[p]) != 0ul) return p; break; case 6: break; default: if ((squareConnectivesPrecalculationLineArray[blackKingSquare << 6 | p] & allPieceBitboard) == (1ul << p) && pieceTypeAbilities[tPT, squareConnectivesPrecalculationArray[blackKingSquare << 6 | p]]) { if (curR != -1) return -779; curR = p; } break; } } return curR; } private int LecacyLeafCheckingPieceCheckWhite(int pStartPos, int pEndPos, int pPieceType) { int tI, tPossibleAttackPiece; if (pPieceType == 1) { if (ULONG_OPERATIONS.IsBitOne(blackPawnAttackSquareBitboards[pEndPos], whiteKingSquare)) return pEndPos; } else if (pPieceType == 2) { if (ULONG_OPERATIONS.IsBitOne(knightSquareBitboards[pEndPos], whiteKingSquare)) return pEndPos; } else if (pPieceType != 6) { tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | pEndPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; } tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | pStartPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; return -1; } private int LecacyLeafCheckingPieceCheckBlack(int pStartPos, int pEndPos, int pPieceType) { int tI, tPossibleAttackPiece; if (pPieceType == 1) { if (ULONG_OPERATIONS.IsBitOne(whitePawnAttackSquareBitboards[pEndPos], blackKingSquare)) return pEndPos; } else if (pPieceType == 2) { if (ULONG_OPERATIONS.IsBitOne(knightSquareBitboards[pEndPos], blackKingSquare)) return pEndPos; } else if (pPieceType != 6) { tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | pEndPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; } tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | pStartPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; return -1; } public void GetLegalMoves(ref List<Move> pMoveList) { int attk; if (isWhiteToMove) { attk = PreMinimaxCheckCheckWhite(); if (attk == -779) GetLegalWhiteMovesSpecialDoubleCheckCase(ref pMoveList); else GetLegalWhiteMoves(attk, ref pMoveList); } else { attk = PreMinimaxCheckCheckBlack(); if (attk == -779) GetLegalBlackMovesSpecialDoubleCheckCase(ref pMoveList); else GetLegalBlackMoves(attk, ref pMoveList); } } private void GetLegalWhiteMoves(int pCheckingPieceSquare, ref List<Move> pMoveList) { if (pCheckingPieceSquare == -779) { GetLegalWhiteMovesSpecialDoubleCheckCase(ref pMoveList); return; } moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= blackPawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, whiteKingSquare); if (curCheckCount == 0) { if (whiteCastleRightKingSide && ((allPieceBitboard | oppAttkBitboard) & WHITE_KING_ROCHADE) == 0ul) pMoveList.Add(mWHITE_KING_ROCHADE); if (whiteCastleRightQueenSide && (allPieceBitboard & WHITE_QUEEN_ROCHADE | oppAttkBitboard & WHITE_QUEEN_ATTK_ROCHADE) == 0ul) pMoveList.Add(mWHITE_QUEEN_ROCHADE); if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, whitePieceBitboard, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[whiteKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare + 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, whitePieceBitboard, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveList(whiteKingSquare, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalWhiteCaptures(int pCheckingPieceSquare, ref List<Move> pMoveList) { if (pCheckingPieceSquare == -779) { GetLegalWhiteCapturesSpecialDoubleCheckCase(ref pMoveList); return; } moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= blackPawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, whiteKingSquare); if (curCheckCount == 0) { if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & blackPieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[whiteKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare + 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & blackPieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveListOnlyCaptures(whiteKingSquare, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalWhiteMovesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= blackPawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveList(whiteKingSquare, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalWhiteCapturesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= blackPawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveListOnlyCaptures(whiteKingSquare, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalBlackMoves(int pCheckingPieceSquare, ref List<Move> pMoveList) { if (pCheckingPieceSquare == -779) { GetLegalBlackMovesSpecialDoubleCheckCase(ref pMoveList); return; } moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= whitePawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, blackKingSquare); if (curCheckCount == 0) { if (blackCastleRightKingSide && ((allPieceBitboard | oppAttkBitboard) & BLACK_KING_ROCHADE) == 0ul) pMoveList.Add(mBLACK_KING_ROCHADE); if (blackCastleRightQueenSide && (allPieceBitboard & BLACK_QUEEN_ROCHADE | oppAttkBitboard & BLACK_QUEEN_ATTK_ROCHADE) == 0ul) pMoveList.Add(mBLACK_QUEEN_ROCHADE); if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveList(p, blackKingSquare, blackPieceBitboard, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[blackKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare - 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveList(p, blackKingSquare, blackPieceBitboard, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveList(blackKingSquare, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); } private void GetLegalBlackCaptures(int pCheckingPieceSquare, ref List<Move> pMoveList) { if (pCheckingPieceSquare == -779) { GetLegalBlackCapturesSpecialDoubleCheckCase(ref pMoveList); return; } moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= whitePawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, blackKingSquare); if (curCheckCount == 0) { if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & whitePieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[blackKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare - 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & whitePieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveListOnlyCaptures(blackKingSquare, ~oppAttkBitboard & whitePieceBitboard); } private void GetLegalBlackMovesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= whitePawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveList(blackKingSquare, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); } private void GetLegalBlackCapturesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= whitePawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveListOnlyCaptures(blackKingSquare, ~oppAttkBitboard & whitePieceBitboard); } public Move GetMoveOfString(string pMove) { int tSP, tEP; string[] tSpl = pMove.Split(','); if (Char.IsNumber(pMove[0])) { tSP = Convert.ToInt32(tSpl[0]); tEP = Convert.ToInt32(tSpl[1]); } else { tSP = SQUARES.NumberNotation(tSpl[0]); tEP = SQUARES.NumberNotation(tSpl[1]); } int tPT = pieceTypeArray[tSP]; bool tIC = ULONG_OPERATIONS.IsBitOne(allPieceBitboard, tEP), tIEP = enPassantSquare == tEP && tPT == 1; if (tSpl.Length == 3) return new Move(tSP, tEP, tPT, Convert.ToInt32(tSpl[2]), tIC); if (tIEP) return new Move(true, tSP, tEP, isWhiteToMove ? tEP - 8 : tEP + 8); if (tPT == 1 && Math.Abs(tSP - tEP) > 11) return new Move(tSP, tEP, 1, false, isWhiteToMove ? tSP + 8 : tSP - 8); if (tPT == 6 && (Math.Abs(tSP - tEP) == 2 || Math.Abs(tSP - tEP) == 3)) { if (isWhiteToMove) return tEP == 6 ? mWHITE_KING_ROCHADE : mWHITE_QUEEN_ROCHADE; return tEP == 62 ? mBLACK_KING_ROCHADE : mBLACK_QUEEN_ROCHADE; } return new Move(tSP, tEP, tPT, tIC); } public void PlainMakeMove(string pMoveName) { PlainMakeMove(GetMoveOfString(pMoveName)); } public void PlainMakeMove(Move pMove) { lastMadeMove = pMove; if (isWhiteToMove) WhiteMakeMove(pMove); else BlackMakeMove(pMove); debugFEN = CreateFenString(); } public void WhiteMakeMove(Move pMove) { int tEndPos = pMove.endPos, tStartPos = pMove.startPos, tPieceType = pMove.pieceType, tPTI = pieceTypeArray[tEndPos]; fiftyMoveRuleCounter++; whitePieceBitboard ^= pMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey ^= blackTurnHash ^ enPassantSquareHashes[enPassantSquare] ^ pieceHashesWhite[tStartPos, tPieceType] ^ pieceHashesWhite[tEndPos, tPieceType]; enPassantSquare = 65; isWhiteToMove = false; switch (pMove.moveTypeID) { case 0: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 1: fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 2: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 3: whiteKingSquare = tEndPos; if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 4: if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 5: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 6: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 7: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[whiteKingSquare = tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 8: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 9: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = pMove.enPassantOption]; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 11: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; whiteKingSquare = tEndPos; pieceTypeArray[pMove.rochadeEndPos] = 4; pieceTypeArray[pMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesWhite[pMove.rochadeStartPos, 4] ^ pieceHashesWhite[pMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 12: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[pMove.enPassantOption] = 0; zobristKey ^= pieceHashesBlack[pMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 13: fiftyMoveRuleCounter = 0; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; zobristKey ^= pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, pMove.promotionType]; break; case 14: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, tPTI] ^ pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, pMove.promotionType]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; } moveHashList.Add(pMove.moveHash); if (pMove.isCapture || tPieceType == 1) { curSearchZobristKeyLine = Array.Empty<ulong>(); return; } ulong[] u = new ulong[(tPTI = curSearchZobristKeyLine.Length) + 1]; for (int i = tPTI; i-- > 0;) u[i] = curSearchZobristKeyLine[i]; u[tPTI] = zobristKey; curSearchZobristKeyLine = u; } public void BlackMakeMove(Move pMove) { int tEndPos = pMove.endPos, tStartPos = pMove.startPos, tPieceType = pMove.pieceType, tPTI = pieceTypeArray[tEndPos]; fiftyMoveRuleCounter++; blackPieceBitboard ^= pMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey ^= blackTurnHash ^ enPassantSquareHashes[enPassantSquare] ^ pieceHashesBlack[tStartPos, tPieceType] ^ pieceHashesBlack[tEndPos, tPieceType]; enPassantSquare = 65; isWhiteToMove = true; switch (pMove.moveTypeID) { case 0: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 1: fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 2: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 3: blackKingSquare = tEndPos; if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 4: if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 5: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 6: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 7: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[blackKingSquare = tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 8: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 9: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = pMove.enPassantOption]; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 11: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; blackKingSquare = tEndPos; pieceTypeArray[pMove.rochadeEndPos] = 4; pieceTypeArray[pMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesBlack[pMove.rochadeStartPos, 4] ^ pieceHashesBlack[pMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 12: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[pMove.enPassantOption] = 0; zobristKey ^= pieceHashesWhite[pMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 13: fiftyMoveRuleCounter = 0; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, pMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 14: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } zobristKey ^= pieceHashesWhite[tEndPos, tPTI] ^ pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, pMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; } moveHashList.Add(pMove.moveHash); if (pMove.isCapture || tPieceType == 1) { curSearchZobristKeyLine = Array.Empty<ulong>(); return; } ulong[] u = new ulong[(tPTI = curSearchZobristKeyLine.Length) + 1]; for (int i = tPTI; i-- > 0;) u[i] = curSearchZobristKeyLine[i]; u[tPTI] = zobristKey; curSearchZobristKeyLine = u; } public void WhiteUndoMove(Move pMove) { } private const int WHITE_CHECKMATE_VAL = 100000, BLACK_CHECKMATE_VAL = -100000, CHECK_EXTENSION_LENGTH = -12, MAX_QUIESCENCE_TOTAL_LENGTH = -32; private readonly Move NULL_MOVE = new Move(0, 0, 0); private int curSearchDepth = 0, curSubSearchDepth = -1; public int MinimaxRoot(long pTime) { evalCount = 0; searches++; int baseLineLen = 0; long tTimestamp = globalTimer.ElapsedTicks + pTime; ClearHeuristics(); transpositionTable.Clear(); ulong[] tZobristKeyLine = Array.Empty<ulong>(); if (curSearchZobristKeyLine != null) { baseLineLen = curSearchZobristKeyLine.Length; tZobristKeyLine = new ulong[baseLineLen]; Array.Copy(curSearchZobristKeyLine, tZobristKeyLine, baseLineLen); } int perftScore, tattk = isWhiteToMove ? PreMinimaxCheckCheckWhite() : PreMinimaxCheckCheckBlack(), pDepth = 1; (string, int) bookMoveTuple = TLMDatabase.SearchForNextBookMove(moveHashList); if (bookMoveTuple.Item2 != 0) { int actualMoveHash = NuCRe.GetNumber(bookMoveTuple.Item1); List<Move> tMoves = new List<Move>(); GetLegalMoves(ref tMoves); int tL = tMoves.Count; for (int i = 0; i < tL; i++) { if (tMoves[i].moveHash == actualMoveHash) { if (debugSearchDepthResults) { SNAPSHOT_WRITLINE_REPLACEMENT("TLM_DB_Count: " + bookMoveTuple.Item2); SNAPSHOT_WRITLINE_REPLACEMENT(">> " + tMoves[i]); } transpositionTable.Add(zobristKey, new TranspositionEntry(tMoves[i], Array.Empty<int>())); return 0; } } } do { curSearchDepth = pDepth; curSubSearchDepth = pDepth - 1; ulong[] completeZobristHistory = new ulong[baseLineLen + pDepth - CHECK_EXTENSION_LENGTH + 1]; for (int i = 0; i < baseLineLen; i++) completeZobristHistory[i] = curSearchZobristKeyLine[i]; curSearchZobristKeyLine = completeZobristHistory; if (isWhiteToMove) { if (tattk == -1) perftScore = MinimaxWhite(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); else perftScore = MinimaxWhite(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); } else { if (tattk == -1) perftScore = MinimaxBlack(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); else perftScore = MinimaxBlack(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); } if (debugSearchDepthResults && pTime != 1L) { int tNpS = Convert.ToInt32((double)evalCount * 10_000_000d /(double)(pTime - tTimestamp + globalTimer.ElapsedTicks)); int tSearchEval = perftScore; int timeForSearchSoFar = (int)((pTime - tTimestamp + globalTimer.ElapsedTicks) /10000d); Move tBestMove = transpositionTable[zobristKey].bestMove; SNAPSHOT_WRITLINE_REPLACEMENT((tSearchEval >= 0 ? "+": "") + tSearchEval); SNAPSHOT_WRITLINE_REPLACEMENT(" " + tBestMove + "  ["); SNAPSHOT_WRITLINE_REPLACEMENT("Depth = " + pDepth + ", "); SNAPSHOT_WRITLINE_REPLACEMENT("Evals = " + GetThreeDigitSeperatedInteger(evalCount) + ", "); SNAPSHOT_WRITLINE_REPLACEMENT("Time = " + GetThreeDigitSeperatedInteger(timeForSearchSoFar) + "ms, "); SNAPSHOT_WRITLINE_REPLACEMENT("NpS = " + GetThreeDigitSeperatedInteger(tNpS) + "]"); } pDepth++; } while (globalTimer.ElapsedTicks < tTimestamp && pDepth < 179); depths += pDepth - 1; BOT_MAIN.depthsSearched += pDepth - 1; BOT_MAIN.searchesFinished++; BOT_MAIN.evaluationsMade += evalCount; curSearchZobristKeyLine = tZobristKeyLine; return perftScore; } private int MinimaxWhite(int pPly, int pAlpha, int pBeta, int pDepth, int pRepetitionHistoryPly, int pCheckingSquare, Move pLastMove) { if (IsDrawByRepetition(pRepetitionHistoryPly - 4)) return 0; if ((pDepth <= 0 && pCheckingSquare == -1) || pDepth < CHECK_EXTENSION_LENGTH) return QuiescenceWhite(pPly, pAlpha, pBeta, pDepth - 1, pCheckingSquare, pLastMove); List<Move> moveOptionList = new List<Move>(); Move bestMove = NULL_MOVE; if (pLastMove.isPromotion && pLastMove.isCapture && pLastMove.startPos % 8 == pCheckingSquare % 8 && pLastMove.startPos == whiteKingSquare + 8 && (pLastMove.promotionType == 4 || pLastMove.promotionType == 5)) GetLegalWhiteMovesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalWhiteMoves(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tWhiteKingSquare = whiteKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1, curEval = BLACK_CHECKMATE_VAL - pDepth; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = true; double[] moveSortingArray = new double[molc]; int[] moveSortingArrayIndexes = new int[molc], thisSearchMoveSortingArrayForTransposEntry = new int[molc]; transpositionTable.TryGetValue(zobristKey, out TranspositionEntry transposEntry); if (transposEntry == null) { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; } } else { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove == transposEntry.bestMove) moveSortingArray[m] = BESTMOVE_SORT_VAL; else if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; if (transposEntry.moveGenOrderedEvalLength > m) moveSortingArray[m] -= transposEntry.moveGenOrderedEvals[m]; } } Array.Sort(moveSortingArray, moveSortingArrayIndexes); for (int m = 0; m < molc; m++) { int tActualIndex = moveSortingArrayIndexes[m]; Move curMove = moveOptionList[tActualIndex]; if (debugSortResults && pDepth == curSubSearchDepth) { SNAPSHOT_WRITLINE_REPLACEMENT(moveSortingArray[m] + " | "+ curMove); } int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; whitePieceBitboard = tWPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesWhite[tStartPos, tPieceType] ^ pieceHashesWhite[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 0: blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 1: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 2: blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 3: whiteKingSquare = tEndPos; if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 4: blackPieceBitboard = tBPB; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 5: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[whiteKingSquare = tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = curMove.enPassantOption]; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 11: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; whiteKingSquare = tEndPos; blackPieceBitboard = tBPB; pieceTypeArray[curMove.rochadeEndPos] = 4; pieceTypeArray[curMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesWhite[curMove.rochadeStartPos, 4] ^ pieceHashesWhite[curMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | curMove.rochadeEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << curMove.rochadeEndPos)) tCheckPos = curMove.rochadeEndPos; break; case 12: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesBlack[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 13: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; zobristKey ^= pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, curMove.promotionType]; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; case 14: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, tPTI] ^ pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, curMove.promotionType]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } curSearchZobristKeyLine[pRepetitionHistoryPly] = zobristKey; debugMoveList[pPly] = curMove; int tEval = MinimaxBlack(pPly + 1, pAlpha, pBeta, pDepth - 1, pRepetitionHistoryPly + 1, tCheckPos, curMove); thisSearchMoveSortingArrayForTransposEntry[tActualIndex] = tEval; pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 3: whiteKingSquare = tWhiteKingSquare; break; case 7: whiteKingSquare = tWhiteKingSquare; break; case 10: enPassantSquare = 65; break; case 11: whiteKingSquare = tWhiteKingSquare; pieceTypeArray[curMove.rochadeStartPos] = 4; pieceTypeArray[curMove.rochadeEndPos] = 0; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 13: pieceTypeArray[tStartPos] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval > curEval) { bestMove = curMove; curEval = tEval; } if (pAlpha < curEval) pAlpha = curEval; if (curEval >= pBeta) { if (!curMove.isCapture) { killerMoveHeuristic[curMove.moveHash] = true; if (pDepth > 0) historyHeuristic[curMove.moveHash] += pDepth * pDepth; } break; } } isWhiteToMove = true; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; if (molc == 0 && pCheckingSquare == -1) curEval = 0; if (!transpositionTable.ContainsKey(zobristKey)) transpositionTable.Add(zobristKey, new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry)); else transpositionTable[zobristKey] = new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry); return curEval; } private int QuiescenceWhite(int pPly, int pAlpha, int pBeta, int pDepth, int pCheckingSquare, Move pLastMove) { int standPat = TexelEvaluate(); if (standPat >= pBeta || pDepth < MAX_QUIESCENCE_TOTAL_LENGTH) return pBeta; if (standPat > pAlpha) pAlpha = standPat; List<Move> moveOptionList = new List<Move>(); if (pLastMove.isPromotion && pLastMove.isCapture && pLastMove.startPos % 8 == pCheckingSquare % 8 && pLastMove.startPos == whiteKingSquare + 8 && (pLastMove.promotionType == 4 || pLastMove.promotionType == 5)) GetLegalWhiteCapturesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalWhiteCaptures(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tWhiteKingSquare = whiteKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = true; for (int m = 0; m < molc; m++) { Move curMove = moveOptionList[m]; int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; whitePieceBitboard = tWPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesWhite[tStartPos, tPieceType] ^ pieceHashesWhite[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 5: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[whiteKingSquare = tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 12: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesBlack[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 14: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, tPTI] ^ pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, curMove.promotionType]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } debugMoveList[pPly] = curMove; int tEval = QuiescenceBlack(pPly + 1, pAlpha, pBeta, pDepth - 1, tCheckPos, curMove); pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 7: whiteKingSquare = tWhiteKingSquare; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval >= pBeta) return pBeta; if (pAlpha < tEval) pAlpha = tEval; } isWhiteToMove = true; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; return pAlpha; } private int MinimaxBlack(int pPly, int pAlpha, int pBeta, int pDepth, int pRepetitionHistoryPly, int pCheckingSquare, Move pLastMove) { if (IsDrawByRepetition(pRepetitionHistoryPly - 4)) return 0; if ((pDepth <= 0 && pCheckingSquare == -1) || pDepth < CHECK_EXTENSION_LENGTH) return QuiescenceBlack(pPly, pAlpha, pBeta, pDepth - 1, pCheckingSquare, pLastMove); List<Move> moveOptionList = new List<Move>(); Move bestMove = NULL_MOVE; if (pLastMove.isPromotion && pLastMove.isCapture && pLastMove.startPos % 8 == pCheckingSquare % 8 && pLastMove.startPos == blackKingSquare - 8 && (pLastMove.promotionType == 4 || pLastMove.promotionType == 5)) GetLegalBlackMovesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalBlackMoves(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tBlackKingSquare = blackKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1, curEval = WHITE_CHECKMATE_VAL + pDepth; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = false; double[] moveSortingArray = new double[molc]; int[] moveSortingArrayIndexes = new int[molc], thisSearchMoveSortingArrayForTransposEntry = new int[molc]; transpositionTable.TryGetValue(zobristKey, out TranspositionEntry transposEntry); if (transposEntry == null) { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; } } else { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove == transposEntry.bestMove) moveSortingArray[m] = BESTMOVE_SORT_VAL; else if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; if (transposEntry.moveGenOrderedEvalLength > m) moveSortingArray[m] -= transposEntry.moveGenOrderedEvals[m]; } } Array.Sort(moveSortingArray, moveSortingArrayIndexes); for (int m = 0; m < molc; m++) { int tActualIndex = moveSortingArrayIndexes[m]; Move curMove = moveOptionList[tActualIndex]; if (debugSortResults && pDepth == curSearchDepth) { SNAPSHOT_WRITLINE_REPLACEMENT("=== " + moveSortingArray[m] + " | "+ curMove); } int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; blackPieceBitboard = tBPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesBlack[tStartPos, tPieceType] ^ pieceHashesBlack[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 0: whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 1: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 2: whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 3: blackKingSquare = tEndPos; if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 4: whitePieceBitboard = tWPB; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 5: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[blackKingSquare = tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = curMove.enPassantOption]; whitePieceBitboard = tWPB; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 11: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; blackKingSquare = tEndPos; whitePieceBitboard = tWPB; pieceTypeArray[curMove.rochadeEndPos] = 4; pieceTypeArray[curMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesBlack[curMove.rochadeStartPos, 4] ^ pieceHashesBlack[curMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | curMove.rochadeEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << curMove.rochadeEndPos)) tCheckPos = curMove.rochadeEndPos; break; case 12: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesWhite[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 13: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, curMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; case 14: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } zobristKey ^= pieceHashesWhite[tEndPos, tPTI] ^ pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, curMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } curSearchZobristKeyLine[pRepetitionHistoryPly] = zobristKey; debugMoveList[pPly] = curMove; int tEval = MinimaxWhite(pPly + 1, pAlpha, pBeta, pDepth - 1, pRepetitionHistoryPly + 1, tCheckPos, curMove); thisSearchMoveSortingArrayForTransposEntry[tActualIndex] = tEval; pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 3: blackKingSquare = tBlackKingSquare; break; case 7: blackKingSquare = tBlackKingSquare; break; case 10: enPassantSquare = 65; break; case 11: blackKingSquare = tBlackKingSquare; pieceTypeArray[curMove.rochadeStartPos] = 4; pieceTypeArray[curMove.rochadeEndPos] = 0; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 13: pieceTypeArray[tStartPos] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval < curEval) { bestMove = curMove; curEval = tEval; } if (pBeta > curEval) pBeta = curEval; if (curEval <= pAlpha) { if (!curMove.isCapture) { killerMoveHeuristic[curMove.moveHash] = true; if (pDepth > 0) historyHeuristic[curMove.moveHash] += pDepth * pDepth; } break; } } isWhiteToMove = false; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; if (molc == 0 && pCheckingSquare == -1) curEval = 0; if (!transpositionTable.ContainsKey(zobristKey)) transpositionTable.Add(zobristKey, new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry)); else transpositionTable[zobristKey] = new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry); return curEval; } private int QuiescenceBlack(int pPly, int pAlpha, int pBeta, int pDepth, int pCheckingSquare, Move pLastMove) { int standPat = TexelEvaluate(); if (standPat <= pAlpha || pDepth < MAX_QUIESCENCE_TOTAL_LENGTH) return pAlpha; if (standPat < pBeta) pBeta = standPat; List<Move> moveOptionList = new List<Move>(); if (pLastMove.isPromotion && pLastMove.isCapture && pLastMove.startPos % 8 == pCheckingSquare % 8 && pLastMove.startPos == blackKingSquare - 8 && (pLastMove.promotionType == 4 || pLastMove.promotionType == 5)) GetLegalBlackCapturesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalBlackCaptures(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tBlackKingSquare = blackKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = false; for (int m = 0; m < molc; m++) { Move curMove = moveOptionList[m]; int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; blackPieceBitboard = tBPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesBlack[tStartPos, tPieceType] ^ pieceHashesBlack[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 5: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[blackKingSquare = tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 12: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesWhite[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 14: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } zobristKey ^= pieceHashesWhite[tEndPos, tPTI] ^ pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, curMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } debugMoveList[pPly] = curMove; int tEval = QuiescenceWhite(pPly + 1, pAlpha, pBeta, pDepth - 1, tCheckPos, curMove); pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 7: blackKingSquare = tBlackKingSquare; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval <= pAlpha) return pAlpha; if (pBeta > tEval) pBeta = tEval; } isWhiteToMove = false; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; return pBeta; } private bool[] killerMoveHeuristic = new bool[262_144]; private int[] historyHeuristic = new int[262_144]; public void ClearHeuristics() { for (int i = 0; i < 262_144; i++) { killerMoveHeuristic[i] = false; historyHeuristic[i] = 0; } } private Dictionary<ulong, TranspositionEntry> transpositionTable = new Dictionary<ulong, TranspositionEntry>(); private int[] pieceEvals = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[,][] piecePositionEvals = new int[33, 14][]; private int evalCount = 0; private int Evaluate() { evalCount++; if (fiftyMoveRuleCounter > 99) return 0; int tEval = 0, tPT, pieceCount = ULONG_OPERATIONS.CountBits(allPieceBitboard); for (int p = 0; p < 64; p++) tEval += pieceEvals[tPT = pieceTypeArray[p] + 7 * ((int)(blackPieceBitboard >> p) & 1)] + piecePositionEvals[pieceCount, tPT][p]; return tEval; } public int GameState(bool pWhiteKingCouldBeAttacked) { if (IsDrawByRepetition(curSearchZobristKeyLine.Length - 5) || fiftyMoveRuleCounter > 99) return 0; int t; List<Move> tMoves = new List<Move>(); GetLegalMoves(ref tMoves); if (pWhiteKingCouldBeAttacked) { t = PreMinimaxCheckCheckWhite(); if (t == -1) return tMoves.Count == 0 ? 0 : 3; else if (tMoves.Count == 0) return -1; } else { t = PreMinimaxCheckCheckBlack(); if (t == -1) return tMoves.Count == 0 ? 0 : 3; else if (tMoves.Count == 0) return 1; } return 3; } private bool IsDrawByRepetition(int pPlyOfFirstPossibleRepeatedPosition) { int tC = 0; for (int i = pPlyOfFirstPossibleRepeatedPosition; i >= 0; i -= 2) { if (curSearchZobristKeyLine[i] == zobristKey) if (++tC == 2) return true; } return false; } private const int RELE_MAX_MOVE_COUNT_PER_GAME = 500; public double ReLePlayGame(int[,][] pEvalPositionValuesWhite, int[,][] pEvalPositionValuesBlack, long thinkingTimePerMove) { int[,][] processedValuesWhite = InitReLeAgent(pEvalPositionValuesWhite), processedValuesBlack = InitReLeAgent(pEvalPositionValuesBlack); int tGS, mc = 0; do { if (IsDrawByRepetition(curSearchZobristKeyLine.Length - 5)) return 0d; piecePositionEvals = isWhiteToMove ? processedValuesWhite : processedValuesBlack; MinimaxRoot(thinkingTimePerMove); if (transpositionTable.Count == 0) { SNAPSHOT_WRITLINE_REPLACEMENT("?!"); return 0d; } PlainMakeMove(transpositionTable[zobristKey].bestMove); tGS = GameState(isWhiteToMove); transpositionTable.Clear(); if (tGS != 3) break; } while (mc++ < RELE_MAX_MOVE_COUNT_PER_GAME); if (tGS == 3 || tGS == 0) return 0d; else if (tGS == 1) return 0.1d * (double)(RELE_MAX_MOVE_COUNT_PER_GAME - mc); return 0.1d * (double)(-RELE_MAX_MOVE_COUNT_PER_GAME + mc); } public int[,][] InitReLeAgent(int[,][] pEvalPositionValues) { return GetInterpolatedProcessedValues(pEvalPositionValues); } private int[,][] GetInterpolatedProcessedValues(int[,][] pEvalPositionValues) { int[,][] processedValues = new int[33, 14][]; for (int i = 0; i < 32; i++) { int ip1 = i + 1; processedValues[ip1, 7] = processedValues[ip1, 0] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; processedValues[ip1, 8] = SwapArrayViewingSide(processedValues[ip1, 1] = MultiplyArraysWithVal(pEvalPositionValues[0, 0], pEvalPositionValues[1, 0], pEvalPositionValues[2, 0], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 9] = SwapArrayViewingSide(processedValues[ip1, 2] = MultiplyArraysWithVal(pEvalPositionValues[0, 1], pEvalPositionValues[1, 1], pEvalPositionValues[2, 1], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 10] = SwapArrayViewingSide(processedValues[ip1, 3] = MultiplyArraysWithVal(pEvalPositionValues[0, 2], pEvalPositionValues[1, 2], pEvalPositionValues[2, 2], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 11] = SwapArrayViewingSide(processedValues[ip1, 4] = MultiplyArraysWithVal(pEvalPositionValues[0, 3], pEvalPositionValues[1, 3], pEvalPositionValues[2, 3], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 12] = SwapArrayViewingSide(processedValues[ip1, 5] = MultiplyArraysWithVal(pEvalPositionValues[0, 4], pEvalPositionValues[1, 4], pEvalPositionValues[2, 4], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 13] = SwapArrayViewingSide(processedValues[ip1, 6] = MultiplyArraysWithVal(pEvalPositionValues[0, 5], pEvalPositionValues[1, 5], pEvalPositionValues[2, 5], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); } return processedValues; } private double[,][] GetInterpolatedProcessedValues(double[,][] pEvalPositionValues) { double[,][] processedValues = new double[33, 14][]; for (int i = 0; i < 32; i++) { int ip1 = i + 1; processedValues[ip1, 7] = processedValues[ip1, 0] = new double[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; processedValues[ip1, 8] = SwapArrayViewingSide(processedValues[ip1, 1] = MultiplyArraysWithVal(pEvalPositionValues[0, 0], pEvalPositionValues[1, 0], pEvalPositionValues[2, 0], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 9] = SwapArrayViewingSide(processedValues[ip1, 2] = MultiplyArraysWithVal(pEvalPositionValues[0, 1], pEvalPositionValues[1, 1], pEvalPositionValues[2, 1], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 10] = SwapArrayViewingSide(processedValues[ip1, 3] = MultiplyArraysWithVal(pEvalPositionValues[0, 2], pEvalPositionValues[1, 2], pEvalPositionValues[2, 2], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 11] = SwapArrayViewingSide(processedValues[ip1, 4] = MultiplyArraysWithVal(pEvalPositionValues[0, 3], pEvalPositionValues[1, 3], pEvalPositionValues[2, 3], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 12] = SwapArrayViewingSide(processedValues[ip1, 5] = MultiplyArraysWithVal(pEvalPositionValues[0, 4], pEvalPositionValues[1, 4], pEvalPositionValues[2, 4], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 13] = SwapArrayViewingSide(processedValues[ip1, 6] = MultiplyArraysWithVal(pEvalPositionValues[0, 5], pEvalPositionValues[1, 5], pEvalPositionValues[2, 5], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); } return processedValues; } private double[] MultiplyArraysWithVal(double[] pArr1, double[] pArr2, double[] pArr3, double pVal1, double pVal2, double pVal3) { int tL = pArr1.Length; double[] rArr = new double[tL]; for (int i = 0; i < tL; i++) { rArr[i] = pArr1[i] * pVal1 + pArr2[i] * pVal2 + pArr3[i] * pVal3; } return rArr; } private int[] MultiplyArraysWithVal(int[] pArr1, int[] pArr2, int[] pArr3, double pVal1, double pVal2, double pVal3) { int tL = pArr1.Length; int[] rArr = new int[tL]; for (int i = 0; i < tL; i++) { rArr[i] = (int)(pArr1[i] * pVal1 + pArr2[i] * pVal2 + pArr3[i] * pVal3); } return rArr; } private int[] SwapArrayViewingSideAndNegate(int[] pArr) { return new int[64] { -pArr[56], -pArr[57], -pArr[58], -pArr[59], -pArr[60], -pArr[61], -pArr[62], -pArr[63], -pArr[48], -pArr[49], -pArr[50], -pArr[51], -pArr[52], -pArr[53], -pArr[54], -pArr[55], -pArr[40], -pArr[41], -pArr[42], -pArr[43], -pArr[44], -pArr[45], -pArr[46], -pArr[47], -pArr[32], -pArr[33], -pArr[34], -pArr[35], -pArr[36], -pArr[37], -pArr[38], -pArr[39], -pArr[24], -pArr[25], -pArr[26], -pArr[27], -pArr[28], -pArr[29], -pArr[30], -pArr[31], -pArr[16], -pArr[17], -pArr[18], -pArr[19], -pArr[20], -pArr[21], -pArr[22], -pArr[23], -pArr[8], -pArr[9], -pArr[10], -pArr[11], -pArr[12], -pArr[13], -pArr[14], -pArr[15], -pArr[0], -pArr[1], -pArr[2], -pArr[3], -pArr[4], -pArr[5], -pArr[6], -pArr[7] }; } private int[] SwapArrayViewingSide(int[] pArr) { return new int[64] { pArr[56], pArr[57], pArr[58], pArr[59], pArr[60], pArr[61], pArr[62], pArr[63], pArr[48], pArr[49], pArr[50], pArr[51], pArr[52], pArr[53], pArr[54], pArr[55], pArr[40], pArr[41], pArr[42], pArr[43], pArr[44], pArr[45], pArr[46], pArr[47], pArr[32], pArr[33], pArr[34], pArr[35], pArr[36], pArr[37], pArr[38], pArr[39], pArr[24], pArr[25], pArr[26], pArr[27], pArr[28], pArr[29], pArr[30], pArr[31], pArr[16], pArr[17], pArr[18], pArr[19], pArr[20], pArr[21], pArr[22], pArr[23], pArr[8], pArr[9], pArr[10], pArr[11], pArr[12], pArr[13], pArr[14], pArr[15], pArr[0], pArr[1], pArr[2], pArr[3], pArr[4], pArr[5], pArr[6], pArr[7] }; } private double[] SwapArrayViewingSide(double[] pArr) { return new double[64] { pArr[56], pArr[57], pArr[58], pArr[59], pArr[60], pArr[61], pArr[62], pArr[63], pArr[48], pArr[49], pArr[50], pArr[51], pArr[52], pArr[53], pArr[54], pArr[55], pArr[40], pArr[41], pArr[42], pArr[43], pArr[44], pArr[45], pArr[46], pArr[47], pArr[32], pArr[33], pArr[34], pArr[35], pArr[36], pArr[37], pArr[38], pArr[39], pArr[24], pArr[25], pArr[26], pArr[27], pArr[28], pArr[29], pArr[30], pArr[31], pArr[16], pArr[17], pArr[18], pArr[19], pArr[20], pArr[21], pArr[22], pArr[23], pArr[8], pArr[9], pArr[10], pArr[11], pArr[12], pArr[13], pArr[14], pArr[15], pArr[0], pArr[1], pArr[2], pArr[3], pArr[4], pArr[5], pArr[6], pArr[7] }; } private int[,][] texelTuningRuntimeVals = new int[33, 14][]; private int[,][] texelTuningVals = new int[3, 6][]; private int[,] texelTuningAdjustIterations = new int[6, 64]; private int[][] texelTuningRuntimePositionalValsV2EG = new int[14][]; private int[][] texelTuningRuntimePositionalValsV2LG = new int[14][]; private int[] texelPieceEvaluationsV2EG = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[] texelPieceEvaluationsV2LG = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[] texelKingSafetyR1EvaluationsEG = new int[9]; private int[] texelKingSafetyR2EvaluationsEG = new int[17]; private int[] texelKingSafetyR1EvaluationsLG = new int[9]; private int[] texelKingSafetyR2EvaluationsLG = new int[17]; private int[] texelKingSafetySREvaluationsPT1EG = new int[12]; private int[] texelKingSafetySREvaluationsPT2EG = new int[12]; private int[] texelKingSafetySREvaluationsPT3EG = new int[12]; private int[] texelKingSafetySREvaluationsPT4EG = new int[12]; private int[] texelKingSafetySREvaluationsPT5EG = new int[12]; private int[] texelKingSafetySREvaluationsPT6EG = new int[12]; private int[] texelKingSafetySREvaluationsPT1LG = new int[12]; private int[] texelKingSafetySREvaluationsPT2LG = new int[12]; private int[] texelKingSafetySREvaluationsPT3LG = new int[12]; private int[] texelKingSafetySREvaluationsPT4LG = new int[12]; private int[] texelKingSafetySREvaluationsPT5LG = new int[12]; private int[] texelKingSafetySREvaluationsPT6LG = new int[12]; private int[,] texelMobilityStraightEG = new int[14, 15], texelMobilityStraightLG = new int[14, 15]; private int[,] texelMobilityDiagonalEG = new int[14, 14], texelMobilityDiagonalLG = new int[14, 14]; private int[] texelPieceEvaluations = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[] blackSidedSquares = new int[64] { 56, 57, 58, 59, 60, 61, 62, 63, 48, 49, 50, 51, 52, 53, 54, 55, 40, 41, 42, 43, 44, 45, 46, 47, 32, 33, 34, 35, 36, 37, 38, 39, 24, 25, 26, 27, 28, 29, 30, 31, 16, 17, 18, 19, 20, 21, 22, 23, 08, 09, 10, 11, 12, 13, 14, 15, 00, 01, 02, 03, 04, 05, 06, 07 }; private int[,] T_Pawns = new int[3, 64] { { 0, 0, 0, 0, 0, 0, 0, 0, 98, 134, 61, 95, 68, 126, 34, -11, -6, 7, 26, 31, 65, 56, 25, -20, -14, 13, 6, 21, 23, 12, 17, -23, -27, -2, -5, 12, 17, 6, 10, -25, -26, -4, -4, -10, 3, 3, 33, -12, -35, -1, -20, -23, -15, 24, 38, -22, 0, 0, 0, 0, 0, 0, 0, 0, } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { 0, 0, 0, 0, 0, 0, 0, 0, 178, 173, 158, 134, 147, 132, 165, 187, 94, 100, 85, 67, 56, 53, 82, 84, 32, 24, 13, 5, -2, 4, 17, 17, 13, 9, -3, -7, -7, -8, 3, -1, 4, 7, -6, 1, 0, -5, -1, -8, 13, 8, 8, 10, 13, 0, 2, -7, 0, 0, 0, 0, 0, 0, 0, 0, } }; private int[,] T_Knights = new int[3, 64] { { -167, -89, -34, -49, 61, -97, -15, -107, -73, -41, 72, 36, 23, 62, 7, -17, -47, 60, 37, 65, 84, 129, 73, 44, -9, 17, 19, 53, 37, 69, 18, 22, -13, 4, 16, 13, 28, 19, 21, -8, -23, -9, 12, 10, 19, 17, 25, -16, -29, -53, -12, -3, -1, 18, -14, -19, -105, -21, -58, -33, -17, -28, -19, -23 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -58, -38, -13, -28, -31, -27, -63, -99, -25, -8, -25, -2, -9, -25, -24, -52, -24, -20, 10, 9, -1, -9, -19, -41, -17, 3, 22, 22, 22, 11, 8, -18, -18, -6, 16, 25, 16, 17, 4, -18, -23, -3, -1, 15, 10, -3, -20, -22, -42, -20, -10, -5, -2, -20, -23, -44, -29, -51, -23, -15, -22, -18, -50, -64 } }; private int[,] T_Bishops = new int[3, 64] { { -29, 4, -82, -37, -25, -42, 7, -8, -26, 16, -18, -13, 30, 59, 18, -47, -16, 37, 43, 40, 35, 50, 37, -2, -4, 5, 19, 50, 37, 37, 7, -2, -6, 13, 13, 26, 34, 12, 10, 4, 0, 15, 15, 15, 14, 27, 18, 10, 4, 15, 16, 0, 7, 21, 33, 1, -33, -3, -14, -21, -13, -12, -39, -21 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -14, -21, -11, -8, -7, -9, -17, -24, -8, -4, 7, -12, -3, -13, -4, -14, 2, -8, 0, -1, -2, 6, 0, 4, -3, 9, 12, 9, 14, 10, 3, 2, -6, 3, 13, 19, 7, 10, -3, -9, -12, -3, 8, 10, 13, 3, -7, -15, -14, -18, -7, -1, 4, -9, -15, -27, -23, -9, -23, -5, -9, -16, -5, -17 } }; private int[,] T_Rooks = new int[3, 64] { { 32, 42, 32, 51, 63, 9, 31, 43, 27, 32, 58, 62, 80, 67, 26, 44, -5, 19, 26, 36, 17, 45, 61, 16, -24, -11, 7, 26, 24, 35, -8, -20, -36, -26, -12, -1, 9, -7, 6, -23, -45, -25, -16, -17, 3, 0, -5, -33, -44, -16, -20, -9, -1, 11, -6, -71, -19, -13, 1, 17, 16, 7, -37, -26 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { 13, 10, 18, 15, 12, 12, 8, 5, 11, 13, 13, 11, -3, 3, 8, 3, 7, 7, 7, 5, 4, -3, -5, -3, 4, 3, 13, 1, 2, 1, -1, 2, 3, 5, 8, 4, -5, -6, -8, -11, -4, 0, -5, -1, -7, -12, -8, -16, -6, -6, 0, 2, -9, -9, -11, -3, -9, 2, 3, -1, -5, -13, 4, -20 } }; private int[,] T_Queens = new int[3, 64] { { -28, 0, 29, 12, 59, 44, 43, 45, -24, -39, -5, 1, -16, 57, 28, 54, -13, -17, 7, 8, 29, 56, 47, 57, -27, -27, -16, -16, -1, 17, -2, 1, -9, -26, -9, -10, -2, -4, 3, -3, -14, 2, -11, -2, -5, 2, 14, 5, -35, -8, 11, 2, 8, 15, -3, 1, -1, -18, -9, 10, -15, -25, -31, -50 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -9, 22, 22, 27, 27, 19, 10, 20, -17, 20, 32, 41, 58, 25, 30, 0, -20, 6, 9, 49, 47, 35, 19, 9, 3, 22, 24, 45, 57, 40, 57, 36, -18, 28, 19, 47, 31, 34, 39, 23, -16, -27, 15, 6, 9, 17, 10, 5, -22, -23, -30, -16, -16, -23, -36, -32, -33, -28, -22, -43, -5, -32, -20, -41 } }; private int[,] T_Kings = new int[3, 64] { { -65, 23, 16, -15, -56, -34, 2, 13, 29, -1, -20, -7, -8, -4, -38, -29, -9, 24, 2, -16, -20, 6, 22, -22, -17, -20, -12, -27, -30, -25, -14, -36, -49, -1, -27, -39, -46, -44, -33, -51, -14, -14, -22, -46, -44, -30, -15, -27, 1, 7, -8, -64, -43, -16, 9, 8, -15, 36, 12, -54, 8, -28, 24, 14 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -74, -35, -18, -18, -11, 15, 4, -17, -12, 17, 14, 17, 17, 38, 23, 11, 10, 17, 23, 15, 20, 45, 44, 13, -8, 22, 24, 27, 26, 33, 26, 3, -18, -4, 21, 24, 27, 23, 9, -11, -19, -3, 11, 21, 23, 16, 7, -9, -27, -11, 4, 13, 14, 4, -5, -17, -53, -34, -21, -11, -28, -14, -24, -43 } }; private int[] paramsLowerLimits = new int[5] { -10000, -10000, -10000, -10000, -10000 }; private int[] paramsUpperLimits = new int[5] { 10000, 10000, 10000, 10000, 10000 }; private List<TLM_ChessGame> threadDataset; private int threadFrom, threadTo; private int[] threadParams; private int customThreadID = 0; private ulong ulAllThreadIDsUnfinished = 0; private double lastCostVal = 0d; private double sumCostVals = 0d; private int costCalculations = 0; private readonly string[] TEXELPRINT_GAMEPARTS = new string[3] { "Early Game: ", "Mid Game: ", "Late Game: "}; private readonly string[] TEXELPRINT_PIECES = new string[6] { "Bauer: ", "Springer: ", "Lufer: ", "Turm: ", "Dame: ", "Knig: "}; private double[] earlyGameMultipliers = new double[33]; private double[] middleGameMultipliers = new double[33]; private double[] lateGameMultipliers = new double[33]; private int[] pieceTypeGameProgressImpact = new int[14] { 0, 0, 1, 1, 2, 4, 0, 0, 0, 1, 1, 2, 4, 0 }; private void PrecalculateMultipliers() { if (BOARD_MANAGER_ID == ENGINE_VALS.PARALLEL_BOARDS - 1) SNAPSHOT_WRITLINE_REPLACEMENT(); for (int i = 0; i < 25; i++) { earlyGameMultipliers[i] = EGMultiplierFunction(i); lateGameMultipliers[i] = LGMultiplierFunction(i); if (BOARD_MANAGER_ID == ENGINE_VALS.PARALLEL_BOARDS - 1) SNAPSHOT_WRITLINE_REPLACEMENT("[" + i + "] "+ earlyGameMultipliers[i] + " | "+ middleGameMultipliers[i] + " | "+ lateGameMultipliers[i]); } } private double MultiplierFunction(double pVal, double pXShift) { double d = Math.Exp(1d /6d * (pVal - pXShift)); return 5 * (d /Math.Pow(d + 1, 2d)); } private double EGMultiplierFunction(double pVal) { return Math.Clamp(1 /16d * (pVal - 4d), 0d, 1d); } private double LGMultiplierFunction(double pVal) { return Math.Clamp(1 /-16d * (pVal - 4d) + 1d, 0d, 1d); } private double EGMultiplierFunction2(double pVal) { return Math.Clamp(1 /32d * pVal, 0d, 1d); } private double LGMultiplierFunction2(double pVal) { return Math.Clamp(1 /-32d * pVal + 1d, 0d, 1d); } private void TuneWithTxtFile(string pTXTName) { List<TLM_ChessGame> gameDataset = new List<TLM_ChessGame>(); string tPath = PathManager.GetTXTPath(pTXTName); string[] tStrs = File.ReadAllLines(tPath); List<string> tGames = new List<string>(); foreach (string s in tStrs) if (s.Contains(';') && s.Replace(" ", "") != "") tGames.Add(s); foreach (string s in tGames) { TLM_ChessGame tGame = CGFF.GetGame(s); LoadFenString(tGame.startFen); foreach (int hMove in tGame.hashedMoves) { List<Move> moveOptionList = new List<Move>(); GetLegalMoves(ref moveOptionList); int tL = moveOptionList.Count; for (int j = 0; j < tL; j++) { Move tMove = moveOptionList[j]; if (tMove.moveHash == hMove) { tGame.actualMoves.Add(tMove); PlainMakeMove(tMove); tL = -1; break; } } if (tL != -1) break; } gameDataset.Add(tGame); } SNAPSHOT_WRITLINE_REPLACEMENT("[TLM TEXEL TUNER] " + tGames.Count + " Games Loaded In!"); BOT_MAIN.curTEXELPARAMS = new int[TEXEL_PARAMS]; BOT_MAIN.ParallelTexelTuning(gameDataset); } private void LoadBestTexelParamsIn() { int[] ttt = new int[778]; ttt[0] = 82; ttt[1] = 341; ttt[2] = 416; ttt[3] = 470; ttt[4] = 1106; ttt[5] = 102; ttt[6] = 302; ttt[7] = 304; ttt[8] = 518; ttt[9] = 960; SetupTexelEvaluationParams(ttt); } private void SetupTexelEvaluationParams(int[] pParams) { texelPieceEvaluationsV2EG[8] = -(texelPieceEvaluationsV2EG[1] = pParams[0]); texelPieceEvaluationsV2EG[9] = -(texelPieceEvaluationsV2EG[2] = pParams[1]); texelPieceEvaluationsV2EG[10] = -(texelPieceEvaluationsV2EG[3] = pParams[2]); texelPieceEvaluationsV2EG[11] = -(texelPieceEvaluationsV2EG[4] = pParams[3]); texelPieceEvaluationsV2EG[12] = -(texelPieceEvaluationsV2EG[5] = pParams[4]); texelPieceEvaluationsV2LG[8] = -(texelPieceEvaluationsV2LG[1] = pParams[5]); texelPieceEvaluationsV2LG[9] = -(texelPieceEvaluationsV2LG[2] = pParams[6]); texelPieceEvaluationsV2LG[10] = -(texelPieceEvaluationsV2LG[3] = pParams[7]); texelPieceEvaluationsV2LG[11] = -(texelPieceEvaluationsV2LG[4] = pParams[8]); texelPieceEvaluationsV2LG[12] = -(texelPieceEvaluationsV2LG[5] = pParams[9]); int c = 10; for (int p = 1; p < 7; p++) { for (int s = 0; s < 64; s++) { texelTuningRuntimePositionalValsV2EG[p + 7][blackSidedSquares[s]] = -(texelTuningRuntimePositionalValsV2EG[p][s] = pParams[c++]); texelTuningRuntimePositionalValsV2LG[p + 7][blackSidedSquares[s]] = -(texelTuningRuntimePositionalValsV2LG[p][s] = pParams[c++]); } } return; for (int p = 2; p < 7; p++) { for (int a = 0; a < 15; a++) { if (a != 14) { texelMobilityDiagonalEG[p + 7, a] = -(texelMobilityDiagonalEG[p, a] = pParams[c++]); texelMobilityDiagonalLG[p + 7, a] = -(texelMobilityDiagonalLG[p, a] = pParams[c++]); } texelMobilityStraightEG[p + 7, a] = -(texelMobilityStraightEG[p, a] = pParams[c++]); texelMobilityStraightLG[p + 7, a] = -(texelMobilityStraightLG[p, a] = pParams[c++]); } } for (int i = 0; i < 12; i++) { texelKingSafetySREvaluationsPT1EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT2EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT3EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT4EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT5EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT6EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT1LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT2LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT3LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT4LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT5LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT6LG[i] = pParams[c++]; } } private void PrintDefinedTexelParams(int[] pParams) { int c = 0; for (int t = 0; t < 3; t++) { SNAPSHOT_WRITLINE_REPLACEMENT(TEXELPRINT_GAMEPARTS[t]); for (int p = 0; p < 6; p++) { SNAPSHOT_WRITLINE_REPLACEMENT(TEXELPRINT_PIECES[p]); texelTuningVals[t, p] = new int[64]; for (int s = 0; s < 64; s++) { if (s % 8 == 0 && s != 0) SNAPSHOT_WRITLINE_REPLACEMENT(); SNAPSHOT_WRITLINE_REPLACEMENT((texelTuningVals[t, p][s] = pParams[c++]) + ", "); } SNAPSHOT_WRITLINE_REPLACEMENT(); } } piecePositionEvals = GetInterpolatedProcessedValues(texelTuningVals); } public void TLMTuning(List<TLM_ChessGame> pDataset) { int tGameDataSetLen = pDataset.Count; int[,][] tRatio = new int[33, 6][]; int[,][] tTotalMoves = new int[33, 6][]; double[,][] tSummedRatios = new double[33, 6][]; double[,][] tSummedDataAmount = new double[33, 6][]; double[,][] tTuningResults = new double[33, 6][]; for (int t = 1; t < 33; t++) { for (int p = 0; p < 6; p++) { tRatio[t, p] = new int[64]; tTotalMoves[t, p] = new int[64]; tSummedRatios[t, p] = new double[64]; tSummedDataAmount[t, p] = new double[64]; tTuningResults[t, p] = new double[64]; } } for (int j = 0; j < tGameDataSetLen; j++) { TLM_ChessGame tGame = pDataset[j]; int tGR = tGame.gameResult - 1; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count - 5; for (int i = 0; i < tL; i++) { if (tGame.isMoveNonTactical[i]) { int tPieceAmount = ULONG_OPERATIONS.CountBits(allPieceBitboard); for (int s = 0; s < 64; s++) { int tPT = pieceTypeArray[s] - 1; if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, s)) { tTotalMoves[tPieceAmount, tPT][s]++; tRatio[tPieceAmount, tPT][s] += tGR; } else if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, s)) { int b = blackSidedSquares[s]; tTotalMoves[tPieceAmount, tPT][b]++; tRatio[tPieceAmount, tPT][b] += tGR; } } } PlainMakeMove(tGame.actualMoves[i]); } } double[,] allMultipliers = new double[33, 33]; for (int sh = 0; sh < 33; sh++) { for (int i = 0; i < 33; i++) { allMultipliers[sh, i] = MultiplierFunction(i, sh); } } for (int t = 1; t < 33; t++) { for (int p = 0; p < 6; p++) { for (int s = 0; s < 64; s++) { for (int t2 = 1; t2 < 33; t2++) { double cmult = allMultipliers[t, t2]; tSummedRatios[t, p][s] += tRatio[t2, p][s] * cmult; tSummedDataAmount[t, p][s] += tTotalMoves[t2, p][s] * cmult; } tTuningResults[t, p][s] = TTT(tSummedRatios[t, p][s], tSummedDataAmount[t, p][s]); } } } int c = 0; int[] tparams = new int[1152]; for (int t = 1; t < 33; t += 15) { if (t == 31) t = 32; SNAPSHOT_WRITLINE_REPLACEMENT("PieceCount = " + t + ": "); for (int p = 0; p < 6; p++) { SNAPSHOT_WRITLINE_REPLACEMENT(TEXELPRINT_PIECES[p]); for (int s = 0; s < 64; s++) { if (s % 8 == 0 && s != 0) SNAPSHOT_WRITLINE_REPLACEMENT(); SNAPSHOT_WRITLINE_REPLACEMENT((tparams[c++] = (int)(tTuningResults[t, p][s] * 100)).ToString().Replace(",", ".") + "("+ (int)tSummedDataAmount[t, p][s] + ")"+ ", "); } SNAPSHOT_WRITLINE_REPLACEMENT(); } } string tS = "PARAMS: {"; for (int i = 0; i < tparams.Length; i++) tS += tparams[i] + ","; tS = tS.Substring(0, tS.Length - 1) + "}\n"; SNAPSHOT_WRITLINE_REPLACEMENT(tS); TexelTuning(pDataset, tparams); } private double TTT(double d1, double d2) { if (d2 == 0) return 0; return d1 /d2; } public void TexelTuning(List<TLM_ChessGame> pDataset, int[] pCurBestParams) { Stopwatch sw = Stopwatch.StartNew(); string tPath = PathManager.GetTXTPath("OTHER/TEXEL_TUNING"); int paramCount = pCurBestParams.Length; double bestAvrgCost = CalculateAverageTexelCost(pDataset, pCurBestParams); SNAPSHOT_WRITLINE_REPLACEMENT("CUR PARAMS COST: " + bestAvrgCost); int packetSize = Math.Clamp(paramCount /ENGINE_VALS.CPU_CORES, 1, 100000); paramsLowerLimits = new int[paramCount]; paramsUpperLimits = new int[paramCount]; for (int i = 0; i < paramCount; i++) { int lim = i < 10 ? 100000 : 200; paramsLowerLimits[i] = -lim; paramsUpperLimits[i] = lim; } SNAPSHOT_WRITLINE_REPLACEMENT("PARAM-COUNT: " + paramCount); SNAPSHOT_WRITLINE_REPLACEMENT("PACKET-SIZE: " + packetSize); while (packetSize <= paramCount) { BOT_MAIN.TEXELfinished = 0; int lM = 0, tC = 0; ulong tUL = 0ul; for (int m = packetSize; lM < paramCount; m += packetSize) { if (m > paramCount) m = paramCount; tUL = ULONG_OPERATIONS.SetBitToOne(tUL, ++tC); lM = m; } tC = lM = 0; for (int m = packetSize; lM < paramCount; m += packetSize) { if (m > paramCount) m = paramCount; tC++; BOT_MAIN.boardManagers[tC].SetPlayTexelVals(pDataset, lM, m, pCurBestParams, paramsLowerLimits, paramsUpperLimits, tC, tUL); ThreadPool.QueueUserWorkItem(new WaitCallback(BOT_MAIN.boardManagers[tC].TexelTuningThreadedPackage)); lM = m; } packetSize = paramCount + 1; int tmod = 0; while (tC != BOT_MAIN.TEXELfinished) { if (++tmod % 20 == 0) { WriteTexelParamsToTXT(tPath, BOT_MAIN.curTEXELPARAMS); SNAPSHOT_WRITLINE_REPLACEMENT(CalculateAverageTexelCost(pDataset, BOT_MAIN.curTEXELPARAMS) + " | "+ BOT_MAIN.TEXELadjustmentsmade); SNAPSHOT_WRITLINE_REPLACEMENT(ULONG_OPERATIONS.GetBitVisualization(BOT_MAIN.TEXELfinishedwithoutimpovement)); } Thread.Sleep(100); } SNAPSHOT_WRITLINE_REPLACEMENT("One Thread Generation FINISHED! :) :) :)"); pCurBestParams = BOT_MAIN.curTEXELPARAMS; } sw.Stop(); WriteTexelParamsToTXT(tPath, BOT_MAIN.curTEXELPARAMS); SNAPSHOT_WRITLINE_REPLACEMENT("END COST: " + CalculateAverageTexelCost(pDataset, BOT_MAIN.curTEXELPARAMS)); SNAPSHOT_WRITLINE_REPLACEMENT(BOT_MAIN.TEXELadjustmentsmade); SNAPSHOT_WRITLINE_REPLACEMENT(sw.ElapsedMilliseconds); } public void TexelTuningThreadedPackage(object obj) { SNAPSHOT_WRITLINE_REPLACEMENT("Started CThreadID [" + customThreadID + "] which is handling Params ["+ threadFrom + "] - ["+ threadTo + "]"); bool firstIter = true; do { double bestAvrgCost = CalculateAverageTexelCost(threadDataset, threadParams); int adjust_val = firstIter ? 512 : 8; do { adjust_val /= 2; bool improvedAvrgCost = true; while (improvedAvrgCost) { improvedAvrgCost = false; for (int i = threadFrom; i < threadTo; i++) { bool improvedWithThisParam = true; int tadjustval = adjust_val; bool lastTimeMaximized = false, lastTimeMinimized = false; while (improvedWithThisParam) { improvedWithThisParam = false; int[] curParams = (int[])threadParams.Clone(); int paramBefore = curParams[i]; curParams[i] = Math.Clamp(paramBefore + adjust_val, paramsLowerLimits[i], paramsUpperLimits[i]); double curAvrgCost = CalculateAverageTexelCost(threadDataset, curParams); if (curAvrgCost < bestAvrgCost) { improvedAvrgCost = true; improvedWithThisParam = true; SNAPSHOT_WRITLINE_REPLACEMENT("Improved Param [" + i + "] at CThreadID ["+ customThreadID + "]: +"+ adjust_val + " ("+ GetDoublePrecentageString(bestAvrgCost - curAvrgCost) + ")"); bestAvrgCost = curAvrgCost; threadParams = curParams; BOT_MAIN.TEXELadjustmentsmade++; BOT_MAIN.TEXELfinishedwithoutimpovement = ulAllThreadIDsUnfinished; if (lastTimeMaximized) { adjust_val *= 4; lastTimeMaximized = false; } else lastTimeMaximized = true; lastTimeMinimized = false; } else { curParams[i] = Math.Clamp(paramBefore - adjust_val, paramsLowerLimits[i], paramsUpperLimits[i]); curAvrgCost = CalculateAverageTexelCost(threadDataset, curParams); if (curAvrgCost < bestAvrgCost) { improvedAvrgCost = true; improvedWithThisParam = true; SNAPSHOT_WRITLINE_REPLACEMENT("Improved Param [" + i + "] at CThreadID ["+ customThreadID + "]: -"+ adjust_val + " ("+ GetDoublePrecentageString(bestAvrgCost - curAvrgCost) + ")"); bestAvrgCost = curAvrgCost; threadParams = curParams; BOT_MAIN.TEXELadjustmentsmade++; BOT_MAIN.TEXELfinishedwithoutimpovement = ulAllThreadIDsUnfinished; if (lastTimeMinimized) { adjust_val *= 4; lastTimeMinimized = false; } else lastTimeMinimized = true; lastTimeMaximized = false; } } if (adjust_val != 1) adjust_val /= 2; for (int j = threadFrom; j < threadTo; j++) { BOT_MAIN.curTEXELPARAMS[j] = threadParams[j]; } threadParams = (int[])BOT_MAIN.curTEXELPARAMS.Clone(); bestAvrgCost = CalculateAverageTexelCost(threadDataset, threadParams); } adjust_val = tadjustval; } } } while (adjust_val != 1); BOT_MAIN.TEXELfinishedwithoutimpovement = ULONG_OPERATIONS.SetBitToZero(BOT_MAIN.TEXELfinishedwithoutimpovement, customThreadID); SNAPSHOT_WRITLINE_REPLACEMENT("FULLY FINISHED " + customThreadID + ". IMPROVEMENT THREAD PACKAGE CYCLE"); firstIter = false; } while (BOT_MAIN.TEXELfinishedwithoutimpovement != 0); BOT_MAIN.TEXELfinished++; } private void WriteTexelParamsToTXT(string pPath, int[] pParams) { try { string tS = "PARAMS: {"; for (int i = 0; i < pParams.Length; i++) tS += pParams[i] + ","; tS = tS.Substring(0, tS.Length - 1) + "}\n"; File.AppendAllText(pPath, tS); } catch { SNAPSHOT_WRITLINE_REPLACEMENT("Mal wieder TXT zu lange gebraucht um zu aktualisieren."); } } private double costSum = 0d; private int texelCostMovesEvaluated = 0; private double CalculateAverageTexelCost(List<TLM_ChessGame> tDataset, int[] pParams, bool pFullCost = true) { costSum = 0d; texelCostMovesEvaluated = 0; SetupTexelEvaluationParams(pParams); int tGameDataSetLen = tDataset.Count; int start = 0, end = tGameDataSetLen; if (!pFullCost) { end = (start = globalRandom.Next(0, end - 256)) + 256; } for (int j = start; j < end; j++) { TLM_ChessGame tGame = tDataset[j]; double tGR = tGame.gameResult; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count - 5; texelCostMovesEvaluated += tL; for (int i = 0; i < tL; i++) { costSum += TexelCost(tGR - TexelTuningSigmoid(TexelEvaluate())); PlainMakeMove(tGame.actualMoves[i]); } } return costSum /texelCostMovesEvaluated; } private double CalculateAverageTexelCostThreadedVersionLEGACYDOESNTWORK(List<TLM_ChessGame> tDataset, int[] pParams) { Stopwatch sw = Stopwatch.StartNew(); BOT_MAIN.TEXELcostSum = 0d; BOT_MAIN.TEXELfinished = 0; BOT_MAIN.TEXELcostMovesEvaluated = 0; int tGameDataSetLen = tDataset.Count; int gamesPerThread = tGameDataSetLen /ENGINE_VALS.CPU_CORES; for (int i = 0; i < ENGINE_VALS.CPU_CORES - 1; i++) { } for (int i = 0; i < ENGINE_VALS.CPU_CORES - 1; i++) { } while (BOT_MAIN.TEXELfinished != ENGINE_VALS.CPU_CORES) Thread.Sleep(1); sw.Stop(); return BOT_MAIN.TEXELcostSum /BOT_MAIN.TEXELcostMovesEvaluated; } public void SetPlayThroughVals(List<TLM_ChessGame> pDataset, int pFrom, int pTo) { threadDataset = pDataset; threadFrom = pFrom; threadTo = pTo; } public void SetPlayTexelVals(List<TLM_ChessGame> pDataset, int pFrom, int pTo, int[] pTexelParams, int[] pLowerLimits, int[] pUpperLimits, int pThreadID, ulong pUL) { threadDataset = pDataset; threadFrom = pFrom; threadTo = pTo; threadParams = pTexelParams; paramsLowerLimits = pLowerLimits; paramsUpperLimits = pUpperLimits; customThreadID = pThreadID; ulAllThreadIDsUnfinished = pUL; } public void PlayThroughSetOfGames(object obj) { SNAPSHOT_WRITLINE_REPLACEMENT(threadFrom + "->"+ threadTo); int sortedOut = 0; for (int j = threadFrom; j < threadTo; j++) { TLM_ChessGame tGame = threadDataset[j]; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count; for (int i = 0; i < tL; i++) { int tQuietEval = isWhiteToMove ? QuiescenceWhite(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, 0, PreMinimaxCheckCheckWhite(), NULL_MOVE) : QuiescenceBlack(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, 0, PreMinimaxCheckCheckBlack(), NULL_MOVE); bool tB; tGame.isMoveNonTactical.Add(tB = (Evaluate() == tQuietEval && i > 4)); if (!tB) sortedOut++; PlainMakeMove(tGame.actualMoves[i]); } } BOT_MAIN.TEXELsortedout += sortedOut; BOT_MAIN.TEXELfinished++; } public void CalculateAverageTexelCostThreadFunction(object obj) { SetupTexelEvaluationParams(threadParams); double d = 0d; for (int j = threadFrom; j < threadTo; j++) { TLM_ChessGame tGame = threadDataset[j]; double tGR = tGame.gameResult; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count - 5; BOT_MAIN.TEXELcostMovesEvaluated += tL; for (int i = 0; i < tL; i++) { d += TexelCost(tGR - TexelTuningSigmoid(TexelEvaluate())); PlainMakeMove(tGame.actualMoves[i]); } } BOT_MAIN.TEXELcostSum += d; BOT_MAIN.TEXELfinished++; } private void ConsoleWriteLineTuneArray<T>(T[,][] pArr) { for (int j = 0; j < 3; j++) { SNAPSHOT_WRITLINE_REPLACEMENT("{"); for (int k = 0; k < 6; k++) { SNAPSHOT_WRITLINE_REPLACEMENT("{"); for (int s = 0; s < 64; s++) SNAPSHOT_WRITLINE_REPLACEMENT(pArr[j, k][s] + ", "); SNAPSHOT_WRITLINE_REPLACEMENT("\n}"); } SNAPSHOT_WRITLINE_REPLACEMENT("}"); } } private void Tune(string pGameCGFF, double pLearningRate) { TLM_ChessGame tGame = CGFF.GetGame(pGameCGFF); LoadFenString(tGame.startFen); double tDGameResult = tGame.gameResult; foreach (int hMove in tGame.hashedMoves) { Tune(tDGameResult, pLearningRate); List<Move> moveOptionList = new List<Move>(); GetLegalMoves(ref moveOptionList); int tL = moveOptionList.Count; for (int i = 0; i < tL; i++) { Move tMove = moveOptionList[i]; if (tMove.moveHash == hMove) { PlainMakeMove(tMove); tL = -1; break; } } if (tL != -1) break; } } private void Tune(double pGameResult, double pLearningRate) { int tPC = ULONG_OPERATIONS.CountBits(allPieceBitboard); double oneThroughPieceCount = 1d /tPC; double egMult = earlyGameMultipliers[tPC], mgMult = middleGameMultipliers[tPC], lgMult = lateGameMultipliers[tPC]; double tTexelResult = TexelEvaluateF(); double tSigmoidedTexelResult = TexelSigmoid(tTexelResult); double tDif = tSigmoidedTexelResult - pGameResult; double tM = oneThroughPieceCount * TexelCostDerivative(tDif) * TexelSigmoidDerivative(tTexelResult) * pLearningRate; sumCostVals += lastCostVal = TexelCost(tDif); costCalculations++; for (int i = 0; i < 64; i++) { if (ULONG_OPERATIONS.IsBitZero(allPieceBitboard, i)) continue; int tPT = pieceTypeArray[i] - 1, tI = i; if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, i)) tI = blackSidedSquares[i]; texelTuningAdjustIterations[tPT, tI]++; } } private double TexelEvaluateF() { texelTuningRuntimeVals = GetInterpolatedProcessedValues(texelTuningVals); return TexelEvaluate(); } private int TexelEvaluate() { int tEvalEG = 0, tEvalLG = 0, tProgress = 0; ulong[] attkULs = new ulong[14]; for (int p = 0; p < 64; p++) { if (((int)(allPieceBitboard >> p) & 1) == 0) continue; int aPT = pieceTypeArray[p], tPT = aPT + 7 * ((int)(blackPieceBitboard >> p) & 1); tEvalEG += texelTuningRuntimePositionalValsV2EG[tPT][p] + texelPieceEvaluationsV2EG[tPT]; tEvalLG += texelTuningRuntimePositionalValsV2LG[tPT][p] + texelPieceEvaluationsV2LG[tPT]; tProgress += pieceTypeGameProgressImpact[tPT]; } if (tProgress > 24) tProgress = 24; return (int)(earlyGameMultipliers[tProgress] * tEvalEG + lateGameMultipliers[tProgress] * tEvalLG); } private const double TexelK = 0.2; private double TexelTuningSigmoid(double pVal) { return 2d /(1 + Math.Pow(10, -TexelK * pVal /400)); } private double TexelSigmoid(double pVal) { return 2d /(Math.Exp(-0.04d * pVal) + 1d); } private double TexelSigmoidDerivative(double pVal) { double d = Math.Exp(-0.04d * pVal); return 2d * d /(25d * (d + 1d) * (d + 1d)); } private double TexelCost(double pVal) { return pVal * pVal; } private double TexelCostDerivative(double pVal) { return 2 * pVal; } private char[] fenPieces = new char[7] { 'z', 'p', 'n', 'b', 'r', 'q', 'k' }; private string[] squareNames = new string[64] { "a1", "b1", "c1", "d1", "e1", "f1", "g1", "h1", "a2", "b2", "c2", "d2", "e2", "f2", "g2", "h2", "a3", "b3", "c3", "d3", "e3", "f3", "g3", "h3", "a4", "b4", "c4", "d4", "e4", "f4", "g4", "h4", "a5", "b5", "c5", "d5", "e5", "f5", "g5", "h5", "a6", "b6", "c6", "d6", "e6", "f6", "g6", "h6", "a7", "b7", "c7", "d7", "e7", "f7", "g7", "h7", "a8", "b8", "c8", "d8", "e8", "f8", "g8", "h8"}; public string CreateFenString() { string rFEN = ""; for (int i = 7; i >= 0; i--) { int t = 0; for (int j = 0; j < 8; j++) { int sq = i * 8 + j; if (pieceTypeArray[sq] != 0) { if (t != 0) rFEN += t; t = 0; } if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, sq)) { switch (pieceTypeArray[sq]) { case 0: t++; SNAPSHOT_WRITLINE_REPLACEMENT("???"); break; case 1: rFEN += 'P'; break; case 2: rFEN += 'N'; break; case 3: rFEN += 'B'; break; case 4: rFEN += 'R'; break; case 5: rFEN += 'Q'; break; case 6: rFEN += 'K'; break; } } else { switch (pieceTypeArray[sq]) { case 0: t++; break; case 1: rFEN += 'p'; break; case 2: rFEN += 'n'; break; case 3: rFEN += 'b'; break; case 4: rFEN += 'r'; break; case 5: rFEN += 'q'; break; case 6: rFEN += 'k'; break; } } } if (t != 0) rFEN += t; if (i != 0) rFEN += "/"; } rFEN += (isWhiteToMove ? " w": " b"); rFEN += (whiteCastleRightKingSide ? " K": " "); rFEN += (whiteCastleRightQueenSide ? "Q": ""); rFEN += (blackCastleRightKingSide ? "k": ""); rFEN += (blackCastleRightQueenSide ? "q": ""); if (!whiteCastleRightKingSide && !whiteCastleRightQueenSide && !blackCastleRightKingSide && !blackCastleRightQueenSide) rFEN += "-"; if (enPassantSquare < 64) rFEN += " "+ squareNames[enPassantSquare] + " "; else rFEN += " - "; return rFEN + fiftyMoveRuleCounter + " "+ ((happenedHalfMoves - happenedHalfMoves % 2) /2); } public void LoadFenString(string fenStr) { debugFEN = fenStr; lastMadeMove = NULL_MOVE; zobristKey = 0ul; whitePieceBitboard = blackPieceBitboard = allPieceBitboard = 0ul; for (int i = 0; i < 64; i++) pieceTypeArray[i] = 0; string[] spaceSpl = fenStr.Split(' '); string[] rowSpl = spaceSpl[0].Split('/'); string epstr = spaceSpl[3]; if (epstr == "-") enPassantSquare = 65; else enPassantSquare = (epstr[0] - 'a') + 8 * (epstr[1] - '1'); isWhiteToMove = true; if (spaceSpl[1] == "b") isWhiteToMove = false; if (!isWhiteToMove) zobristKey ^= blackTurnHash; string crstr = spaceSpl[2]; whiteCastleRightKingSide = whiteCastleRightQueenSide = blackCastleRightKingSide = blackCastleRightQueenSide = false; int crStrL = crstr.Length; for (int i = 0; i < crStrL; i++) { switch (crstr[i]) { case 'K': whiteCastleRightKingSide = true; break; case 'Q': whiteCastleRightQueenSide = true; break; case 'k': blackCastleRightKingSide = true; break; case 'q': blackCastleRightQueenSide = true; break; } } fiftyMoveRuleCounter = Convert.ToInt32(spaceSpl[4]); happenedHalfMoves = Convert.ToInt32(spaceSpl[5]) * 2; if (!isWhiteToMove) happenedHalfMoves++; int tSq = 0; for (int i = rowSpl.Length; i-- > 0;) { string tStr = rowSpl[i]; int tStrLen = tStr.Length; for (int c = 0; c < tStrLen; c++) { char tChar = tStr[c]; if (Char.IsDigit(tChar)) tSq += tChar - '0'; else { bool tCol = Char.IsLower(tChar); if (tCol) blackPieceBitboard = ULONG_OPERATIONS.SetBitToOne(blackPieceBitboard, tSq); else whitePieceBitboard = ULONG_OPERATIONS.SetBitToOne(whitePieceBitboard, tSq); if (tChar == 'k') blackKingSquare = tSq; else if (tChar == 'K') whiteKingSquare = tSq; pieceTypeArray[tSq] = Array.IndexOf(fenPieces, Char.ToLower(tChar)); if (tCol) zobristKey ^= pieceHashesBlack[tSq, pieceTypeArray[tSq]]; else zobristKey ^= pieceHashesWhite[tSq, pieceTypeArray[tSq]]; tSq++; } } } if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; zobristKey ^= enPassantSquareHashes[enPassantSquare]; allPieceBitboard = whitePieceBitboard | blackPieceBitboard; if (zobristKey == 16260251586586513106) moveHashList.Clear(); else { moveHashList.Clear(); moveHashList.Add(1); moveHashList.Add(2); moveHashList.Add(3); } } private ulong[,] pieceHashesWhite = new ulong[64, 7], pieceHashesBlack = new ulong[64, 7]; private ulong blackTurnHash, whiteKingSideRochadeRightHash, whiteQueenSideRochadeRightHash, blackKingSideRochadeRightHash, blackQueenSideRochadeRightHash; private ulong[] enPassantSquareHashes = new ulong[66]; private Dictionary<ulong, int> singleCheckCaseBackup = new Dictionary<ulong, int>(); private void InitZobrist() { Random rng = new Random(31415926); for (int sq = 0; sq < 64; sq++) { enPassantSquareHashes[sq] = ULONG_OPERATIONS.GetRandomULONG(rng); for (int it = 1; it < 7; it++) { pieceHashesWhite[sq, it] = ULONG_OPERATIONS.GetRandomULONG(rng); pieceHashesBlack[sq, it] = ULONG_OPERATIONS.GetRandomULONG(rng); } } blackTurnHash = ULONG_OPERATIONS.GetRandomULONG(rng); whiteKingSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); whiteQueenSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); blackKingSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); blackQueenSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); } public void SetKnightMasks(ulong[] uls) { knightSquareBitboards = uls; } public void SetKingMasks(ulong[] uls) { kingSquareBitboards = uls; } private Move[,] whiteEnPassantMoves = new Move[64, 64]; private Move[,] blackEnPassantMoves = new Move[64, 64]; private bool[] epValidationArray = new bool[64] { false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true , true , true , true , true , true , true , true, true , true , true , true , true , true , true , true, true , true , true , true , true , true , true , true, true , true , true , true , true , true , true , true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false }; private ulong[] kingSafetyRing1 = new ulong[64], kingSafetyRing2 = new ulong[64]; private ulong[] kingSafetySpecialRingW = new ulong[64], kingSafetySpecialRingB = new ulong[64]; private ulong[] rowPrecalcs = new ulong[8], columnPrecalcs = new ulong[8]; const ulong columnUL = 0x101010101010101, rowUL = 0b11111111; private void PrecalculateKingSafetyBitboards() { for (int i = 0; i < 8; i++) { rowPrecalcs[i] = rowUL << (8 * i); columnPrecalcs[i] = columnUL << i; } for (int i = 0; i < 64; i++) { int tMod = i % 8; int tRow = (i - tMod) /8; ulong tULC = columnPrecalcs[tMod], tULR = rowPrecalcs[tRow]; ulong tULC2 = columnPrecalcs[tMod], tULR2 = rowPrecalcs[tRow]; if (tMod < 7) tULC |= columnPrecalcs[tMod + 1]; if (tMod > 0) tULC |= columnPrecalcs[tMod - 1]; if (tRow < 7) tULR |= rowPrecalcs[tRow + 1]; if (tRow > 0) tULR |= rowPrecalcs[tRow - 1]; if (tMod < 6) tULC2 |= columnPrecalcs[tMod + 2]; if (tMod > 1) tULC2 |= columnPrecalcs[tMod - 2]; if (tRow < 6) tULR2 |= rowPrecalcs[tRow + 2]; if (tRow > 1) tULR2 |= rowPrecalcs[tRow - 2]; tULR2 |= tULR; tULC2 |= tULC; kingSafetyRing1[i] = ULONG_OPERATIONS.SetBitToZero(tULR & tULC, i); kingSafetyRing2[i] = ULONG_OPERATIONS.SetBitsToZero(tULR2 & tULC2, i, i + 1, i - 1, i + 7, i + 8, i + 9, i - 7, i - 8, i - 9); } for (int i = 0; i < 64; i++) { if (i < 56) kingSafetySpecialRingW[i] = ULONG_OPERATIONS.SetBitToZero(kingSafetyRing1[i] | kingSafetyRing1[i + 8], i); else kingSafetySpecialRingW[i] = kingSafetyRing1[i]; if (i > 7) kingSafetySpecialRingB[i] = ULONG_OPERATIONS.SetBitToZero(kingSafetyRing1[i] | kingSafetyRing1[i - 8], i); else kingSafetySpecialRingB[i] = kingSafetyRing1[i]; } } private void PrecalculateEnPassantMoves() { for (int i = 0; i < 64; i++) { if (!epValidationArray[i]) continue; for (int j = 0; j < 64; j++) { if (i == j) continue; if (Math.Abs(i - j) > 9) continue; if (!epValidationArray[j]) continue; whiteEnPassantMoves[i, j] = new Move(false, i, j, j - 8); blackEnPassantMoves[i, j] = new Move(false, i, j, j + 8); } } } private void PawnAttackBitboards() { for (int sq = 0; sq < 64; sq++) { ulong u = 0ul; if (sq % 8 != 0) u = ULONG_OPERATIONS.SetBitToOne(u, sq + 7); if (sq % 8 != 7) u = ULONG_OPERATIONS.SetBitToOne(u, sq + 9); whitePawnAttackSquareBitboards[sq] = u; u = 0ul; if (sq % 8 != 0 && sq - 9 > -1) u = ULONG_OPERATIONS.SetBitToOne(u, sq - 9); if (sq % 8 != 7 && sq - 7 > -1) u = ULONG_OPERATIONS.SetBitToOne(u, sq - 7); blackPawnAttackSquareBitboards[sq] = u; } } private int[] squareConnectivesPrecalculationArray = new int[4096]; public int[] squareConnectivesCrossDirsPrecalculationArray { get; set; } = new int[4096]; private ulong[] squareConnectivesPrecalculationRayArray = new ulong[4096]; private ulong[] squareConnectivesPrecalculationLineArray = new ulong[4096]; private List<Dictionary<ulong, int>> rayCollidingSquareCalculations = new List<Dictionary<ulong, int>>(); private readonly int[] maxIntWithSpecifiedBitcount = new int[8] { 0, 0b1, 0b11, 0b111, 0b1111, 0b11111, 0b111111, 0b1111111 }; private List<ulong> differentRays = new List<ulong>(); private void SquareConnectivesPrecalculations() { for (int square = 0; square < 64; square++) { rayCollidingSquareCalculations.Add(new Dictionary<ulong, int>()); rayCollidingSquareCalculations[square].Add(0ul, square); for (int square2 = 0; square2 < 64; square2++) { if (square == square2) continue; int t = 0, t2 = 0, difSign = Math.Sign(square2 - square), itSq = square, g = 0; ulong tRay = 0ul, tExclRay = 0ul; List<int> tRayInts = new List<int>(); if (difSign == -1) g = 7; if (square % 8 == square2 % 8) { t2 = t = 1; while ((itSq += difSign * 8) < 64 && itSq > -1) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } } else if ((square - square % 8) == (square2 - square2 % 8)) { t = 1; t2 = -1; while ((itSq += difSign) % 8 != g && itSq > -1 && itSq < 64) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } } else { int dif = Math.Abs(square2 - square); if (dif % 7 == 0) { t = 2; t2 = 2; g = (difSign == 1) ? 7 : 0; while ((itSq += difSign * 7) % 8 != g && itSq < 64 && itSq > -1) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } if (ULONG_OPERATIONS.IsBitZero(tRay, square2)) { t2 = t = 0; tRay = 0ul; } } else if (dif % 9 == 0) { t = 2; t2 = -2; if (square == 0 && square2 == 63 || square == 63 && square2 == 0) SNAPSHOT_WRITLINE_REPLACEMENT("!"); while ((itSq += difSign * 9) % 8 != g && itSq < 64 && itSq > -1) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } if (ULONG_OPERATIONS.IsBitZero(tRay, square2)) { t2 = t = 0; tRay = 0ul; } } } if (square == 0 && square2 == 63) { t2 = t = 2; tRayInts.Clear(); tExclRay = tRay = ULONG_OPERATIONS.SetBitsToOne(0ul, 9, 18, 27, 36, 45, 54, 63); tRayInts = new List<int>() { 9, 18, 27, 36, 45, 54, 63 }; } else if (square2 == 0 && square == 63) { t = 2; tRayInts.Clear(); t2 = -2; tExclRay = tRay = ULONG_OPERATIONS.SetBitsToOne(0ul, 0, 9, 18, 27, 36, 45, 54); tRayInts = new List<int>() { 54, 45, 36, 27, 18, 9, 0 }; } if (tRay != 0ul && !differentRays.Contains(tRay)) { differentRays.Add(tRay); int ccount, combI = maxIntWithSpecifiedBitcount[ccount = ULONG_OPERATIONS.CountBits(tRay)]; do { ulong curAllPieceBitboard = 0ul; int solution = square; for (int j = 0; j < ccount; j++) { if (((combI >> j) & 1) == 1) { curAllPieceBitboard = ULONG_OPERATIONS.SetBitToOne(curAllPieceBitboard, tRayInts[j]); if (solution == square) solution = tRayInts[j]; } } rayCollidingSquareCalculations[square].Add(curAllPieceBitboard, solution); } while (--combI != 0); } squareConnectivesPrecalculationArray[square << 6 | square2] = t; squareConnectivesPrecalculationRayArray[square << 6 | square2] = tRay; squareConnectivesCrossDirsPrecalculationArray[square << 6 | square2] = t2; if (t != 0) squareConnectivesPrecalculationLineArray[square << 6 | square2] = (square == 0 && square2 == 63 || square2 == 0 && square == 63) ? tExclRay : ULONG_OPERATIONS.SetBitToOne(tExclRay, square2); if (squareConnectivesPrecalculationLineArray[square << 6 | square2] == 0ul && ULONG_OPERATIONS.IsBitOne(knightSquareBitboards[square], square2)) squareConnectivesPrecalculationLineArray[square << 6 | square2] = 1ul << square2; } differentRays.Clear(); } } public void SNAPSHOT_WRITLINE_REPLACEMENT() { } public void SNAPSHOT_WRITLINE_REPLACEMENT(object pStr) { } private string GetDoublePrecentageString(double pVal) { return ((int)(pVal * 1_000_000) /10_000d) + "%"; } private string ReplaceAllULONGIsBitOne(string pCode) { const string METHOD_NAME = "ULONG_OPERATIONS.IsBitOne"; int METHOD_NAME_LEN = METHOD_NAME.Length, iterations = 0; int pIndex = pCode.IndexOf(METHOD_NAME); while (pIndex != -1 && ++iterations < 10_000) { List<int> paramIndexes = new List<int>(); int openedBracketCount = 1, closedBracketCount = 0, a = METHOD_NAME_LEN + pIndex; string tpCode = pCode.Substring(0, pIndex); paramIndexes.Add(a + 1); while (++a < pCode.Length) { switch (pCode[a]) { case '(': openedBracketCount++; break; case ')': if (++closedBracketCount == openedBracketCount) { pIndex = a; a = int.MaxValue - 5; } break; case ',': if (openedBracketCount - closedBracketCount == 1) paramIndexes.Add(a + 1); break; } } if (openedBracketCount == closedBracketCount && paramIndexes.Count == 2) { tpCode += "((int)("+ pCode.Substring(paramIndexes[0], paramIndexes[1] - paramIndexes[0] - 1) + (pCode[paramIndexes[1]] == ' ' ? " >> (": " >> (") + pCode.Substring(paramIndexes[1], pIndex - paramIndexes[1]) + ")) & 1) == 1"+ pCode.Substring(pIndex + 1, pCode.Length - pIndex - 1); } pIndex = (pCode = tpCode).IndexOf(METHOD_NAME); } SNAPSHOT_WRITLINE_REPLACEMENT(iterations + " ITERATIONS"); return pCode; } private string ReplaceAllULONGIsBitZero(string pCode) { const string METHOD_NAME = "ULONG_OPERATIONS.IsBitZero"; int METHOD_NAME_LEN = METHOD_NAME.Length, iterations = 0; int pIndex = pCode.IndexOf(METHOD_NAME); while (pIndex != -1 && ++iterations < 10_000) { List<int> paramIndexes = new List<int>(); int openedBracketCount = 1, closedBracketCount = 0, a = METHOD_NAME_LEN + pIndex; string tpCode = pCode.Substring(0, pIndex); paramIndexes.Add(a + 1); while (++a < pCode.Length) { switch (pCode[a]) { case '(': openedBracketCount++; break; case ')': if (++closedBracketCount == openedBracketCount) { pIndex = a; a = int.MaxValue - 5; } break; case ',': if (openedBracketCount - closedBracketCount == 1) paramIndexes.Add(a + 1); break; } } if (openedBracketCount == closedBracketCount && paramIndexes.Count == 2) { tpCode += "((int)("+ pCode.Substring(paramIndexes[0], paramIndexes[1] - paramIndexes[0] - 1) + (pCode[paramIndexes[1]] == ' ' ? " >>": " >> ") + pCode.Substring(paramIndexes[1], pIndex - paramIndexes[1]) + ") & 1) == 0"+ pCode.Substring(pIndex + 1, pCode.Length - pIndex - 1); } pIndex = (pCode = tpCode).IndexOf(METHOD_NAME); } SNAPSHOT_WRITLINE_REPLACEMENT(iterations + " ITERATIONS"); return pCode; } private string GetThreeDigitSeperatedInteger(int pInt) { string s = pInt.ToString(), r = s[0].ToString(); int t = s.Length % 3; for (int i = 1; i < s.Length; i++) { if (i % 3 == t) r += "."; r += s[i]; } s = ""; for (int i = 0; i < r.Length; i++) s += r[i]; return s; } public double GetAverageDepth() { return (double)depths /(double)searches; } }
public class SNAPSHOT_V01_00_011 : IBoardManager  { public int TEXEL_PARAMS { get; } = 778; private const int BESTMOVE_SORT_VAL = -2_000_000_000; private const int CAPTURE_SORT_VAL = -1_000_000_000; private const int KILLERMOVE_SORT_VAL = -1000; private readonly int[,] MVVLVA_TABLE = new int[7, 7] { { 0, 0, 0, 0, 0, 0, 0 }, { 0, 1500, 1400, 1300, 1200, 1100, 1000 }, { 0, 3500, 3400, 3300, 3200, 3100, 3000 }, { 0, 4500, 4400, 4300, 4200, 4100, 4000 }, { 0, 5500, 5400, 5300, 5200, 5100, 5000 }, { 0, 9500, 9400, 9300, 9200, 9100, 9000 }, { 0, 0, 0, 0, 0, 0, 0 }}; private int BOARD_MANAGER_ID = -1; private bool debugSearchDepthResults = false; private bool debugSortResults = false; private RookMovement rookMovement; private BishopMovement bishopMovement; private QueenMovement queenMovement; private KnightMovement knightMovement; private KingMovement kingMovement; private WhitePawnMovement whitePawnMovement; private BlackPawnMovement blackPawnMovement; private Rays rays; public List<Move> moveOptionList { get; set; } private int[] pieceTypeArray = new int[64]; public ulong whitePieceBitboard, blackPieceBitboard, allPieceBitboard; private ulong zobristKey; private int whiteKingSquare, blackKingSquare, enPassantSquare = 65, happenedHalfMoves = 0, fiftyMoveRuleCounter = 0; private bool whiteCastleRightKingSide, whiteCastleRightQueenSide, blackCastleRightKingSide, blackCastleRightQueenSide; private bool isWhiteToMove; private const ulong WHITE_KING_ROCHADE = 96, WHITE_QUEEN_ROCHADE = 14, BLACK_KING_ROCHADE = 6917529027641081856, BLACK_QUEEN_ROCHADE = 1008806316530991104, WHITE_QUEEN_ATTK_ROCHADE = 12, BLACK_QUEEN_ATTK_ROCHADE = 864691128455135232; private readonly Move mWHITE_KING_ROCHADE = new Move(4, 6, 7, 5), mWHITE_QUEEN_ROCHADE = new Move(4, 2, 0, 3), mBLACK_KING_ROCHADE = new Move(60, 62, 63, 61), mBLACK_QUEEN_ROCHADE = new Move(60, 58, 56, 59); private ulong[] knightSquareBitboards = new ulong[64]; private ulong[] whitePawnAttackSquareBitboards = new ulong[64]; private ulong[] blackPawnAttackSquareBitboards = new ulong[64]; private ulong[] kingSquareBitboards = new ulong[64]; private bool[,] pieceTypeAbilities = new bool[7, 3] { { false, false, false }, { false, false, false }, { false, false, false }, { false, false, true }, { false, true, false }, { false, true, true }, { false, false, false } }; private List<int> moveHashList = new List<int>(); private ulong[] curSearchZobristKeyLine = Array.Empty<ulong>(); private Move[] debugMoveList = new Move[128]; private string debugFEN = ""; private Stopwatch globalTimer = Stopwatch.StartNew(); private Move lastMadeMove; private int depths, searches; private Random globalRandom = new Random(); public SNAPSHOT_V01_00_011(string fen) { Setup(fen); } public void Setup(string pFen) { Stopwatch setupStopwatch = Stopwatch.StartNew(); BOARD_MANAGER_ID = BOT_MAIN.curBoardManagerID; for (int i = 0; i < 33; i++) for (int j = 0; j < 14; j++) piecePositionEvals[i, j] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; for (int i = 0; i < 33; i++) for (int j = 0; j < 14; j++) texelTuningRuntimeVals[i, j] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; for (int i = 0; i < 3; i++) for (int j = 0; j < 6; j++) texelTuningVals[i, j] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; for (int i = 0; i < 14; i++) { texelTuningRuntimePositionalValsV2EG[i] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; texelTuningRuntimePositionalValsV2LG[i] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; } PrecalculateKingSafetyBitboards(); PrecalculateMultipliers(); GetLowNoisePositionalEvaluation(globalRandom); MinimaxRoot(1L); SetupConsoleWrite("[PRECALCS] Zobrist Hashing"); InitZobrist(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Knight Movement"); knightMovement = new KnightMovement(this); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Square Connectives"); SquareConnectivesPrecalculations(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Pawn Attack Bitboards"); PawnAttackBitboards(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Rays"); rays = new Rays(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); queenMovement = new QueenMovement(this); SetupConsoleWrite("[PRECALCS] Rook Movement"); rookMovement = new RookMovement(this, queenMovement); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Bishop Movement"); bishopMovement = new BishopMovement(this, queenMovement); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] King Movement"); kingMovement = new KingMovement(this); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Pawn Movement"); whitePawnMovement = new WhitePawnMovement(this); blackPawnMovement = new BlackPawnMovement(this); PrecalculateEnPassantMoves(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWriteLine("[DONE]\n\n"); LoadFenString(pFen); LoadBestTexelParamsIn(); setupStopwatch.Stop(); } private void SetupConsoleWriteLine(string pStr) { if (BOT_MAIN.isFirstBoardManagerInitialized) return; SNAPSHOT_WRITLINE_REPLACEMENT(pStr); } private void SetupConsoleWrite(string pStr) { if (BOT_MAIN.isFirstBoardManagerInitialized) return; SNAPSHOT_WRITLINE_REPLACEMENT(pStr); } public void GetLowNoisePositionalEvaluation(System.Random rng) { int[,][] digitArray = new int[3, 6][]; for (int i = 0; i < 3; i++) for (int j = 0; j < 6; j++) digitArray[i, j] = GetRand64IntArray(rng, -5, 6); lowNoisePositionEvals1 = GetInterpolatedProcessedValues(digitArray); int[,][] digitArray2 = new int[3, 6][]; for (int i = 0; i < 3; i++) for (int j = 0; j < 6; j++) digitArray2[i, j] = GetRand64IntArray(rng, -5, 6); lowNoisePositionEvals2 = GetInterpolatedProcessedValues(digitArray2); } private int[] GetRand64IntArray(System.Random rng, int pMin, int pMax) { return new int[64] { rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax) }; } private string GetAIArrayValuesStringRepresentation(int[,][] pArr) { string r = "int[,][] ReLe_AI_RESULT_VALS = new int[3, 6][] {"; for (int i = 0; i < 3; i++) { r += "{"; for (int j = 0; j < 5; j++) { r += GetIntArray64LStringRepresentation(pArr[i, j]) + ","; } r += GetIntArray64LStringRepresentation(pArr[i, 5]) + "},"; } return r.Substring(0, r.Length - 1) + "};"; } private string GetIntArray64LStringRepresentation(int[] p64LArr) { if (p64LArr == null) return ""; string r = "new int[64]{"; for (int i = 0; i < 63; i++) { r += p64LArr[i] + ","; } return r + p64LArr[63] + "}"; } public void TempStuff() { } private string[] gameResultStrings = new string[5] { "Black Has Won!", "Draw!", "White Has Won!", "Non Existant Result!", "Game is Ongoing!"}; private int[,][] lowNoisePositionEvals1, lowNoisePositionEvals2; public void ThreadSelfPlay(object obj) { PlayGameAgainstItself(obj); } public void PlayGameAgainstItself(object obj, string pStartFEN = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1", long tickLimitForEngine = ENGINE_VALS.SELF_PLAY_THINK_TIME) { int ttGState; while (BOT_MAIN.goalGameCount > BOT_MAIN.gamesPlayed) { try { string tGameStr; GetLowNoisePositionalEvaluation(globalRandom); LoadFenString(tGameStr = pStartFEN); tGameStr += ";"; int tGState = 3, tmc = 0; bool lowNoiceDecider = globalRandom.NextDouble() < 0.5d; while (tGState == 3) { piecePositionEvals = lowNoiceDecider ? lowNoisePositionEvals1 : lowNoisePositionEvals2; MinimaxRoot(tickLimitForEngine); Move tM = transpositionTable[zobristKey].bestMove; PlainMakeMove(tM); tGameStr += NuCRe.GetNuCRe(tM.moveHash) + ","; BOT_MAIN.movesPlayed++; tGState = GameState(isWhiteToMove); lowNoiceDecider = !lowNoiceDecider; tmc++; } ttGState = tGState; tGameStr += ttGState + 1; SNAPSHOT_WRITLINE_REPLACEMENT(tGameStr); BOT_MAIN.gamesPlayedResultArray[ttGState + 1]++; BOT_MAIN.gamesPlayed++; BOT_MAIN.selfPlayGameStrings.Add(tGameStr); } catch (Exception tE) { SNAPSHOT_WRITLINE_REPLACEMENT(tE.ToString()); } } } public void PlayGameOnConsoleAgainstHuman(string pStartFEN = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1", bool pHumanPlaysWhite = true, long tickLimitForEngine = 10_000_000L) { debugSearchDepthResults = true; LoadFenString(pStartFEN); if (!(pHumanPlaysWhite ^ isWhiteToMove)) { var pVS = Console.ReadLine(); if (pVS == null) return; Move tm = GetMoveOfString(pVS.ToString()); SNAPSHOT_WRITLINE_REPLACEMENT(tm); PlainMakeMove(tm); } int tGState = 3; while (tGState == 3) { MinimaxRoot(tickLimitForEngine); PlayThroughZobristTree(); Move tM = transpositionTable[zobristKey].bestMove; SNAPSHOT_WRITLINE_REPLACEMENT(tM); SNAPSHOT_WRITLINE_REPLACEMENT(CreateFenString()); PlainMakeMove(tM); tGState = GameState(isWhiteToMove); if (tGState != 3 || tM == NULL_MOVE) break; var pV = ""; tM = NULL_MOVE; do { pV = Console.ReadLine(); if (pV == null) continue; tM = GetMoveOfString(pV.ToString()); SNAPSHOT_WRITLINE_REPLACEMENT(tM); } while (tM == NULL_MOVE); PlainMakeMove(tM); tGState = GameState(isWhiteToMove); } } private void PlayThroughZobristTree() { SetJumpState(); SNAPSHOT_WRITLINE_REPLACEMENT("\n- - - - - - - - - - - - -"); int tC = 1; Dictionary<ulong, bool> usedULs = new Dictionary<ulong, bool>(); while (transpositionTable.TryGetValue(zobristKey, out TranspositionEntry tM)) { if (usedULs.ContainsKey(zobristKey)) { SNAPSHOT_WRITLINE_REPLACEMENT(tC + ": AT LEAST ONE REPETION; REST NOT VISIBLE"); break; } SNAPSHOT_WRITLINE_REPLACEMENT(tC + ": "+ tM.bestMove + " > "); usedULs.Add(zobristKey, true); PlainMakeMove(tM.bestMove); tC++; } SNAPSHOT_WRITLINE_REPLACEMENT("- - - - - - - - - - - - -\n"); LoadJumpState(); } public Move? ReturnNextMove(Move? lastMove, long pThinkingTime) { if (lastMove != null) PlainMakeMove(lastMove); if (GameState(isWhiteToMove) != 3) return null; MinimaxRoot(pThinkingTime); if (!transpositionTable.ContainsKey(zobristKey)) return null; Move tm = transpositionTable[zobristKey].bestMove; PlainMakeMove(tm); return tm; } private int[] jmpSt_pieceTypeArray; private ulong jmpSt_whitePieceBitboard, jmpSt_blackPieceBitboard; private ulong jmpSt_zobristKey; private int jmpSt_whiteKingSquare, jmpSt_blackKingSquare, jmpSt_enPassantSquare, jmpSt_happenedHalfMoves, jmpSt_fiftyMoveRuleCounter; private bool jmpSt_whiteCastleRightKingSide, jmpSt_whiteCastleRightQueenSide, jmpSt_blackCastleRightKingSide, jmpSt_blackCastleRightQueenSide; private bool jmpSt_isWhiteToMove; private ulong[] jmpSt_curSearchZobristKeyLine; private int[] jmpSt_moveHashList; public void LoadJumpState() { pieceTypeArray = (int[])jmpSt_pieceTypeArray.Clone(); whitePieceBitboard = jmpSt_whitePieceBitboard; blackPieceBitboard = jmpSt_blackPieceBitboard; zobristKey = jmpSt_zobristKey; whiteKingSquare = jmpSt_whiteKingSquare; blackKingSquare = jmpSt_blackKingSquare; enPassantSquare = jmpSt_enPassantSquare; happenedHalfMoves = jmpSt_happenedHalfMoves; fiftyMoveRuleCounter = jmpSt_fiftyMoveRuleCounter; whiteCastleRightKingSide = jmpSt_whiteCastleRightKingSide; whiteCastleRightQueenSide = jmpSt_whiteCastleRightQueenSide; blackCastleRightKingSide = jmpSt_blackCastleRightKingSide; blackCastleRightQueenSide = jmpSt_blackCastleRightQueenSide; isWhiteToMove = jmpSt_isWhiteToMove; curSearchZobristKeyLine = (ulong[])jmpSt_curSearchZobristKeyLine.Clone(); allPieceBitboard = blackPieceBitboard | whitePieceBitboard; moveHashList = jmpSt_moveHashList.ToList(); } public void SetJumpState() { jmpSt_pieceTypeArray = (int[])pieceTypeArray.Clone(); jmpSt_whitePieceBitboard = whitePieceBitboard; jmpSt_blackPieceBitboard = blackPieceBitboard; jmpSt_zobristKey = zobristKey; jmpSt_whiteKingSquare = whiteKingSquare; jmpSt_blackKingSquare = blackKingSquare; jmpSt_enPassantSquare = enPassantSquare; jmpSt_happenedHalfMoves = happenedHalfMoves; jmpSt_fiftyMoveRuleCounter = fiftyMoveRuleCounter; jmpSt_whiteCastleRightKingSide = whiteCastleRightKingSide; jmpSt_whiteCastleRightQueenSide = whiteCastleRightQueenSide; jmpSt_blackCastleRightKingSide = blackCastleRightKingSide; jmpSt_blackCastleRightQueenSide = blackCastleRightQueenSide; jmpSt_isWhiteToMove = isWhiteToMove; jmpSt_curSearchZobristKeyLine = (ulong[])curSearchZobristKeyLine.Clone(); jmpSt_moveHashList = moveHashList.ToArray(); } private int PreMinimaxCheckCheckWhite() { ulong bitShiftedKingPos = 1ul << whiteKingSquare; int curR = -1; for (int p = 0; p < 64; p++) { if (ULONG_OPERATIONS.IsBitZero(blackPieceBitboard, p)) continue; int tPT; switch (tPT = pieceTypeArray[p]) { case 1: if ((bitShiftedKingPos & blackPawnAttackSquareBitboards[p]) != 0ul) return p; break; case 2: if ((bitShiftedKingPos & knightSquareBitboards[p]) != 0ul) return p; break; case 6: break; default: if ((squareConnectivesPrecalculationLineArray[whiteKingSquare << 6 | p] & allPieceBitboard) == (1ul << p) && pieceTypeAbilities[tPT, squareConnectivesPrecalculationArray[whiteKingSquare << 6 | p]]) { if (curR != -1) return -779; curR = p; } break; } } return curR; } private int PreMinimaxCheckCheckBlack() { ulong bitShiftedKingPos = 1ul << blackKingSquare; int curR = -1; for (int p = 0; p < 64; p++) { if (ULONG_OPERATIONS.IsBitZero(whitePieceBitboard, p)) continue; int tPT; switch (tPT = pieceTypeArray[p]) { case 1: if ((bitShiftedKingPos & whitePawnAttackSquareBitboards[p]) != 0ul) return p; break; case 2: if ((bitShiftedKingPos & knightSquareBitboards[p]) != 0ul) return p; break; case 6: break; default: if ((squareConnectivesPrecalculationLineArray[blackKingSquare << 6 | p] & allPieceBitboard) == (1ul << p) && pieceTypeAbilities[tPT, squareConnectivesPrecalculationArray[blackKingSquare << 6 | p]]) { if (curR != -1) return -779; curR = p; } break; } } return curR; } private int LecacyLeafCheckingPieceCheckWhite(int pStartPos, int pEndPos, int pPieceType) { int tI, tPossibleAttackPiece; if (pPieceType == 1) { if (ULONG_OPERATIONS.IsBitOne(blackPawnAttackSquareBitboards[pEndPos], whiteKingSquare)) return pEndPos; } else if (pPieceType == 2) { if (ULONG_OPERATIONS.IsBitOne(knightSquareBitboards[pEndPos], whiteKingSquare)) return pEndPos; } else if (pPieceType != 6) { tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | pEndPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; } tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | pStartPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; return -1; } private int LecacyLeafCheckingPieceCheckBlack(int pStartPos, int pEndPos, int pPieceType) { int tI, tPossibleAttackPiece; if (pPieceType == 1) { if (ULONG_OPERATIONS.IsBitOne(whitePawnAttackSquareBitboards[pEndPos], blackKingSquare)) return pEndPos; } else if (pPieceType == 2) { if (ULONG_OPERATIONS.IsBitOne(knightSquareBitboards[pEndPos], blackKingSquare)) return pEndPos; } else if (pPieceType != 6) { tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | pEndPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; } tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | pStartPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; return -1; } public void GetLegalMoves(ref List<Move> pMoveList) { int attk; if (isWhiteToMove) { attk = PreMinimaxCheckCheckWhite(); if (attk == -779) GetLegalWhiteMovesSpecialDoubleCheckCase(ref pMoveList); else GetLegalWhiteMoves(attk, ref pMoveList); } else { attk = PreMinimaxCheckCheckBlack(); if (attk == -779) GetLegalBlackMovesSpecialDoubleCheckCase(ref pMoveList); else GetLegalBlackMoves(attk, ref pMoveList); } } private void GetLegalWhiteMoves(int pCheckingPieceSquare, ref List<Move> pMoveList) { if (pCheckingPieceSquare == -779) { GetLegalWhiteMovesSpecialDoubleCheckCase(ref pMoveList); return; } moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= blackPawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, whiteKingSquare); if (curCheckCount == 0) { if (whiteCastleRightKingSide && ((allPieceBitboard | oppAttkBitboard) & WHITE_KING_ROCHADE) == 0ul) pMoveList.Add(mWHITE_KING_ROCHADE); if (whiteCastleRightQueenSide && (allPieceBitboard & WHITE_QUEEN_ROCHADE | oppAttkBitboard & WHITE_QUEEN_ATTK_ROCHADE) == 0ul) pMoveList.Add(mWHITE_QUEEN_ROCHADE); if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, whitePieceBitboard, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[whiteKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare + 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, whitePieceBitboard, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveList(whiteKingSquare, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalWhiteCaptures(int pCheckingPieceSquare, ref List<Move> pMoveList) { if (pCheckingPieceSquare == -779) { GetLegalWhiteCapturesSpecialDoubleCheckCase(ref pMoveList); return; } moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= blackPawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, whiteKingSquare); if (curCheckCount == 0) { if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & blackPieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[whiteKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare + 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & blackPieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveListOnlyCaptures(whiteKingSquare, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalWhiteMovesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= blackPawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveList(whiteKingSquare, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalWhiteCapturesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= blackPawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveListOnlyCaptures(whiteKingSquare, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalBlackMoves(int pCheckingPieceSquare, ref List<Move> pMoveList) { if (pCheckingPieceSquare == -779) { GetLegalBlackMovesSpecialDoubleCheckCase(ref pMoveList); return; } moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= whitePawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, blackKingSquare); if (curCheckCount == 0) { if (blackCastleRightKingSide && ((allPieceBitboard | oppAttkBitboard) & BLACK_KING_ROCHADE) == 0ul) pMoveList.Add(mBLACK_KING_ROCHADE); if (blackCastleRightQueenSide && (allPieceBitboard & BLACK_QUEEN_ROCHADE | oppAttkBitboard & BLACK_QUEEN_ATTK_ROCHADE) == 0ul) pMoveList.Add(mBLACK_QUEEN_ROCHADE); if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveList(p, blackKingSquare, blackPieceBitboard, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[blackKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare - 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveList(p, blackKingSquare, blackPieceBitboard, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveList(blackKingSquare, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); } private void GetLegalBlackCaptures(int pCheckingPieceSquare, ref List<Move> pMoveList) { if (pCheckingPieceSquare == -779) { GetLegalBlackCapturesSpecialDoubleCheckCase(ref pMoveList); return; } moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= whitePawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, blackKingSquare); if (curCheckCount == 0) { if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & whitePieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[blackKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare - 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & whitePieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveListOnlyCaptures(blackKingSquare, ~oppAttkBitboard & whitePieceBitboard); } private void GetLegalBlackMovesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= whitePawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveList(blackKingSquare, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); } private void GetLegalBlackCapturesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= whitePawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveListOnlyCaptures(blackKingSquare, ~oppAttkBitboard & whitePieceBitboard); } public Move GetMoveOfString(string pMove) { int tSP, tEP; string[] tSpl = pMove.Split(','); if (Char.IsNumber(pMove[0])) { tSP = Convert.ToInt32(tSpl[0]); tEP = Convert.ToInt32(tSpl[1]); } else { tSP = SQUARES.NumberNotation(tSpl[0]); tEP = SQUARES.NumberNotation(tSpl[1]); } int tPT = pieceTypeArray[tSP]; bool tIC = ULONG_OPERATIONS.IsBitOne(allPieceBitboard, tEP), tIEP = enPassantSquare == tEP && tPT == 1; if (tSpl.Length == 3) return new Move(tSP, tEP, tPT, Convert.ToInt32(tSpl[2]), tIC); if (tIEP) return new Move(true, tSP, tEP, isWhiteToMove ? tEP - 8 : tEP + 8); if (tPT == 1 && Math.Abs(tSP - tEP) > 11) return new Move(tSP, tEP, 1, false, isWhiteToMove ? tSP + 8 : tSP - 8); if (tPT == 6 && (Math.Abs(tSP - tEP) == 2 || Math.Abs(tSP - tEP) == 3)) { if (isWhiteToMove) return tEP == 6 ? mWHITE_KING_ROCHADE : mWHITE_QUEEN_ROCHADE; return tEP == 62 ? mBLACK_KING_ROCHADE : mBLACK_QUEEN_ROCHADE; } return new Move(tSP, tEP, tPT, tIC); } public void PlainMakeMove(string pMoveName) { PlainMakeMove(GetMoveOfString(pMoveName)); } public void PlainMakeMove(Move pMove) { lastMadeMove = pMove; if (isWhiteToMove) WhiteMakeMove(pMove); else BlackMakeMove(pMove); debugFEN = CreateFenString(); } public void WhiteMakeMove(Move pMove) { int tEndPos = pMove.endPos, tStartPos = pMove.startPos, tPieceType = pMove.pieceType, tPTI = pieceTypeArray[tEndPos]; fiftyMoveRuleCounter++; whitePieceBitboard ^= pMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey ^= blackTurnHash ^ enPassantSquareHashes[enPassantSquare] ^ pieceHashesWhite[tStartPos, tPieceType] ^ pieceHashesWhite[tEndPos, tPieceType]; enPassantSquare = 65; isWhiteToMove = false; switch (pMove.moveTypeID) { case 0: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 1: fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 2: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 3: whiteKingSquare = tEndPos; if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 4: if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 5: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 6: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 7: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[whiteKingSquare = tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 8: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 9: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = pMove.enPassantOption]; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 11: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; whiteKingSquare = tEndPos; pieceTypeArray[pMove.rochadeEndPos] = 4; pieceTypeArray[pMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesWhite[pMove.rochadeStartPos, 4] ^ pieceHashesWhite[pMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 12: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[pMove.enPassantOption] = 0; zobristKey ^= pieceHashesBlack[pMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 13: fiftyMoveRuleCounter = 0; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; zobristKey ^= pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, pMove.promotionType]; break; case 14: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, tPTI] ^ pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, pMove.promotionType]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; } moveHashList.Add(pMove.moveHash); if (pMove.isCapture || tPieceType == 1) { curSearchZobristKeyLine = Array.Empty<ulong>(); return; } ulong[] u = new ulong[(tPTI = curSearchZobristKeyLine.Length) + 1]; for (int i = tPTI; i-- > 0;) u[i] = curSearchZobristKeyLine[i]; u[tPTI] = zobristKey; curSearchZobristKeyLine = u; } public void BlackMakeMove(Move pMove) { int tEndPos = pMove.endPos, tStartPos = pMove.startPos, tPieceType = pMove.pieceType, tPTI = pieceTypeArray[tEndPos]; fiftyMoveRuleCounter++; blackPieceBitboard ^= pMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey ^= blackTurnHash ^ enPassantSquareHashes[enPassantSquare] ^ pieceHashesBlack[tStartPos, tPieceType] ^ pieceHashesBlack[tEndPos, tPieceType]; enPassantSquare = 65; isWhiteToMove = true; switch (pMove.moveTypeID) { case 0: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 1: fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 2: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 3: blackKingSquare = tEndPos; if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 4: if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 5: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 6: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 7: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[blackKingSquare = tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 8: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 9: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = pMove.enPassantOption]; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 11: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; blackKingSquare = tEndPos; pieceTypeArray[pMove.rochadeEndPos] = 4; pieceTypeArray[pMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesBlack[pMove.rochadeStartPos, 4] ^ pieceHashesBlack[pMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 12: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[pMove.enPassantOption] = 0; zobristKey ^= pieceHashesWhite[pMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 13: fiftyMoveRuleCounter = 0; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, pMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 14: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } zobristKey ^= pieceHashesWhite[tEndPos, tPTI] ^ pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, pMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; } moveHashList.Add(pMove.moveHash); if (pMove.isCapture || tPieceType == 1) { curSearchZobristKeyLine = Array.Empty<ulong>(); return; } ulong[] u = new ulong[(tPTI = curSearchZobristKeyLine.Length) + 1]; for (int i = tPTI; i-- > 0;) u[i] = curSearchZobristKeyLine[i]; u[tPTI] = zobristKey; curSearchZobristKeyLine = u; } public void WhiteUndoMove(Move pMove) { } private const int WHITE_CHECKMATE_VAL = 100000, BLACK_CHECKMATE_VAL = -100000, CHECK_EXTENSION_LENGTH = -12, MAX_QUIESCENCE_TOTAL_LENGTH = -32; private readonly Move NULL_MOVE = new Move(0, 0, 0); private int curSearchDepth = 0, curSubSearchDepth = -1; public int MinimaxRoot(long pTime) { evalCount = 0; searches++; int baseLineLen = 0; long tTimestamp = globalTimer.ElapsedTicks + pTime; ClearHeuristics(); transpositionTable.Clear(); ulong[] tZobristKeyLine = Array.Empty<ulong>(); if (curSearchZobristKeyLine != null) { baseLineLen = curSearchZobristKeyLine.Length; tZobristKeyLine = new ulong[baseLineLen]; Array.Copy(curSearchZobristKeyLine, tZobristKeyLine, baseLineLen); } int perftScore, tattk = isWhiteToMove ? PreMinimaxCheckCheckWhite() : PreMinimaxCheckCheckBlack(), pDepth = 1; (string, int) bookMoveTuple = TLMDatabase.SearchForNextBookMove(moveHashList); if (bookMoveTuple.Item2 != 0) { int actualMoveHash = NuCRe.GetNumber(bookMoveTuple.Item1); List<Move> tMoves = new List<Move>(); GetLegalMoves(ref tMoves); int tL = tMoves.Count; for (int i = 0; i < tL; i++) { if (tMoves[i].moveHash == actualMoveHash) { if (debugSearchDepthResults) { SNAPSHOT_WRITLINE_REPLACEMENT("TLM_DB_Count: " + bookMoveTuple.Item2); SNAPSHOT_WRITLINE_REPLACEMENT(">> " + tMoves[i]); } transpositionTable.Add(zobristKey, new TranspositionEntry(tMoves[i], Array.Empty<int>())); return 0; } } } do { curSearchDepth = pDepth; curSubSearchDepth = pDepth - 1; ulong[] completeZobristHistory = new ulong[baseLineLen + pDepth - CHECK_EXTENSION_LENGTH + 1]; for (int i = 0; i < baseLineLen; i++) completeZobristHistory[i] = curSearchZobristKeyLine[i]; curSearchZobristKeyLine = completeZobristHistory; if (isWhiteToMove) { if (tattk == -1) perftScore = MinimaxWhite(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); else perftScore = MinimaxWhite(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); } else { if (tattk == -1) perftScore = MinimaxBlack(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); else perftScore = MinimaxBlack(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); } if (debugSearchDepthResults && pTime != 1L) { int tNpS = Convert.ToInt32((double)evalCount * 10_000_000d /(double)(pTime - tTimestamp + globalTimer.ElapsedTicks)); int tSearchEval = perftScore; int timeForSearchSoFar = (int)((pTime - tTimestamp + globalTimer.ElapsedTicks) /10000d); Move tBestMove = transpositionTable[zobristKey].bestMove; SNAPSHOT_WRITLINE_REPLACEMENT((tSearchEval >= 0 ? "+": "") + tSearchEval); SNAPSHOT_WRITLINE_REPLACEMENT(" " + tBestMove + "  ["); SNAPSHOT_WRITLINE_REPLACEMENT("Depth = " + pDepth + ", "); SNAPSHOT_WRITLINE_REPLACEMENT("Evals = " + GetThreeDigitSeperatedInteger(evalCount) + ", "); SNAPSHOT_WRITLINE_REPLACEMENT("Time = " + GetThreeDigitSeperatedInteger(timeForSearchSoFar) + "ms, "); SNAPSHOT_WRITLINE_REPLACEMENT("NpS = " + GetThreeDigitSeperatedInteger(tNpS) + "]"); } pDepth++; } while (globalTimer.ElapsedTicks < tTimestamp && pDepth < 179); depths += pDepth - 1; BOT_MAIN.depthsSearched += pDepth - 1; BOT_MAIN.searchesFinished++; BOT_MAIN.evaluationsMade += evalCount; curSearchZobristKeyLine = tZobristKeyLine; return perftScore; } private int[] squareToRankArray = new int[64] { 0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1, 2,2,2,2,2,2,2,2, 3,3,3,3,3,3,3,3, 4,4,4,4,4,4,4,4, 5,5,5,5,5,5,5,5, 6,6,6,6,6,6,6,6, 7,7,7,7,7,7,7,7 }; private bool WhiteIsPositionTheSpecialCase(Move pLastMove, int pCheckingSquare) { if (pLastMove.isPromotion && pLastMove.isCapture && (pLastMove.promotionType == 4 || pLastMove.promotionType == 5)) { if(pLastMove.startPos % 8 == pCheckingSquare % 8 && pLastMove.startPos == whiteKingSquare + 8) return true; if (squareToRankArray[pLastMove.startPos] == squareToRankArray[pCheckingSquare] && pLastMove.endPos == whiteKingSquare - 8) return true; } return false; } private bool BlackIsPositionTheSpecialCase(Move pLastMove, int pCheckingSquare) { if (pLastMove.isPromotion && pLastMove.isCapture && (pLastMove.promotionType == 4 || pLastMove.promotionType == 5)) { if (pLastMove.startPos % 8 == pCheckingSquare % 8 && pLastMove.startPos == blackKingSquare - 8) return true; if (squareToRankArray[pLastMove.startPos] == squareToRankArray[pCheckingSquare] && pLastMove.endPos == blackKingSquare + 8) return true; } return false; } private int MinimaxWhite(int pPly, int pAlpha, int pBeta, int pDepth, int pRepetitionHistoryPly, int pCheckingSquare, Move pLastMove) { if (IsDrawByRepetition(pRepetitionHistoryPly - 4)) return 0; if ((pDepth <= 0 && pCheckingSquare == -1) || pDepth < CHECK_EXTENSION_LENGTH) return QuiescenceWhite(pPly, pAlpha, pBeta, pDepth - 1, pCheckingSquare, pLastMove); List<Move> moveOptionList = new List<Move>(); Move bestMove = NULL_MOVE; if (WhiteIsPositionTheSpecialCase(pLastMove, pCheckingSquare)) GetLegalWhiteMovesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalWhiteMoves(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tWhiteKingSquare = whiteKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1, curEval = BLACK_CHECKMATE_VAL - pDepth; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = true; double[] moveSortingArray = new double[molc]; int[] moveSortingArrayIndexes = new int[molc], thisSearchMoveSortingArrayForTransposEntry = new int[molc]; transpositionTable.TryGetValue(zobristKey, out TranspositionEntry transposEntry); if (transposEntry == null) { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; } } else { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove == transposEntry.bestMove) moveSortingArray[m] = BESTMOVE_SORT_VAL; else if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; if (transposEntry.moveGenOrderedEvalLength > m) moveSortingArray[m] -= transposEntry.moveGenOrderedEvals[m]; } } Array.Sort(moveSortingArray, moveSortingArrayIndexes); for (int m = 0; m < molc; m++) { int tActualIndex = moveSortingArrayIndexes[m]; Move curMove = moveOptionList[tActualIndex]; if (debugSortResults && pDepth == curSubSearchDepth) { SNAPSHOT_WRITLINE_REPLACEMENT(moveSortingArray[m] + " | "+ curMove); } int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; whitePieceBitboard = tWPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesWhite[tStartPos, tPieceType] ^ pieceHashesWhite[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 0: blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 1: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 2: blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 3: whiteKingSquare = tEndPos; if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 4: blackPieceBitboard = tBPB; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 5: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[whiteKingSquare = tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = curMove.enPassantOption]; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 11: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; whiteKingSquare = tEndPos; blackPieceBitboard = tBPB; pieceTypeArray[curMove.rochadeEndPos] = 4; pieceTypeArray[curMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesWhite[curMove.rochadeStartPos, 4] ^ pieceHashesWhite[curMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | curMove.rochadeEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << curMove.rochadeEndPos)) tCheckPos = curMove.rochadeEndPos; break; case 12: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesBlack[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 13: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; zobristKey ^= pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, curMove.promotionType]; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; case 14: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, tPTI] ^ pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, curMove.promotionType]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } curSearchZobristKeyLine[pRepetitionHistoryPly] = zobristKey; debugMoveList[pPly] = curMove; int tEval = MinimaxBlack(pPly + 1, pAlpha, pBeta, pDepth - 1, pRepetitionHistoryPly + 1, tCheckPos, curMove); thisSearchMoveSortingArrayForTransposEntry[tActualIndex] = tEval; pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 3: whiteKingSquare = tWhiteKingSquare; break; case 7: whiteKingSquare = tWhiteKingSquare; break; case 10: enPassantSquare = 65; break; case 11: whiteKingSquare = tWhiteKingSquare; pieceTypeArray[curMove.rochadeStartPos] = 4; pieceTypeArray[curMove.rochadeEndPos] = 0; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 13: pieceTypeArray[tStartPos] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval > curEval) { bestMove = curMove; curEval = tEval; } if (pAlpha < curEval) pAlpha = curEval; if (curEval >= pBeta) { if (!curMove.isCapture) { killerMoveHeuristic[curMove.moveHash] = true; if (pDepth > 0) historyHeuristic[curMove.moveHash] += pDepth * pDepth; } break; } } isWhiteToMove = true; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; if (molc == 0 && pCheckingSquare == -1) curEval = 0; if (!transpositionTable.ContainsKey(zobristKey)) transpositionTable.Add(zobristKey, new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry)); else transpositionTable[zobristKey] = new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry); return curEval; } private int QuiescenceWhite(int pPly, int pAlpha, int pBeta, int pDepth, int pCheckingSquare, Move pLastMove) { int standPat = TexelEvaluate(); if (standPat >= pBeta || pDepth < MAX_QUIESCENCE_TOTAL_LENGTH) return pBeta; if (standPat > pAlpha) pAlpha = standPat; List<Move> moveOptionList = new List<Move>(); if (WhiteIsPositionTheSpecialCase(pLastMove, pCheckingSquare)) GetLegalWhiteCapturesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalWhiteCaptures(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tWhiteKingSquare = whiteKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = true; for (int m = 0; m < molc; m++) { Move curMove = moveOptionList[m]; int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; whitePieceBitboard = tWPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesWhite[tStartPos, tPieceType] ^ pieceHashesWhite[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 5: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[whiteKingSquare = tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 12: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesBlack[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 14: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, tPTI] ^ pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, curMove.promotionType]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } debugMoveList[pPly] = curMove; int tEval = QuiescenceBlack(pPly + 1, pAlpha, pBeta, pDepth - 1, tCheckPos, curMove); pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 7: whiteKingSquare = tWhiteKingSquare; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval >= pBeta) return pBeta; if (pAlpha < tEval) pAlpha = tEval; } isWhiteToMove = true; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; return pAlpha; } private int MinimaxBlack(int pPly, int pAlpha, int pBeta, int pDepth, int pRepetitionHistoryPly, int pCheckingSquare, Move pLastMove) { if (IsDrawByRepetition(pRepetitionHistoryPly - 4)) return 0; if ((pDepth <= 0 && pCheckingSquare == -1) || pDepth < CHECK_EXTENSION_LENGTH) return QuiescenceBlack(pPly, pAlpha, pBeta, pDepth - 1, pCheckingSquare, pLastMove); List<Move> moveOptionList = new List<Move>(); Move bestMove = NULL_MOVE; if (BlackIsPositionTheSpecialCase(pLastMove, pCheckingSquare)) GetLegalBlackMovesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalBlackMoves(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tBlackKingSquare = blackKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1, curEval = WHITE_CHECKMATE_VAL + pDepth; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = false; double[] moveSortingArray = new double[molc]; int[] moveSortingArrayIndexes = new int[molc], thisSearchMoveSortingArrayForTransposEntry = new int[molc]; transpositionTable.TryGetValue(zobristKey, out TranspositionEntry transposEntry); if (transposEntry == null) { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; } } else { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove == transposEntry.bestMove) moveSortingArray[m] = BESTMOVE_SORT_VAL; else if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; if (transposEntry.moveGenOrderedEvalLength > m) moveSortingArray[m] -= transposEntry.moveGenOrderedEvals[m]; } } Array.Sort(moveSortingArray, moveSortingArrayIndexes); for (int m = 0; m < molc; m++) { int tActualIndex = moveSortingArrayIndexes[m]; Move curMove = moveOptionList[tActualIndex]; if (debugSortResults && pDepth == curSearchDepth) { SNAPSHOT_WRITLINE_REPLACEMENT("=== " + moveSortingArray[m] + " | "+ curMove); } int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; blackPieceBitboard = tBPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesBlack[tStartPos, tPieceType] ^ pieceHashesBlack[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 0: whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 1: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 2: whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 3: blackKingSquare = tEndPos; if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 4: whitePieceBitboard = tWPB; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 5: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[blackKingSquare = tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = curMove.enPassantOption]; whitePieceBitboard = tWPB; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 11: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; blackKingSquare = tEndPos; whitePieceBitboard = tWPB; pieceTypeArray[curMove.rochadeEndPos] = 4; pieceTypeArray[curMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesBlack[curMove.rochadeStartPos, 4] ^ pieceHashesBlack[curMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | curMove.rochadeEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << curMove.rochadeEndPos)) tCheckPos = curMove.rochadeEndPos; break; case 12: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesWhite[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 13: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, curMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; case 14: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } zobristKey ^= pieceHashesWhite[tEndPos, tPTI] ^ pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, curMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } curSearchZobristKeyLine[pRepetitionHistoryPly] = zobristKey; debugMoveList[pPly] = curMove; int tEval = MinimaxWhite(pPly + 1, pAlpha, pBeta, pDepth - 1, pRepetitionHistoryPly + 1, tCheckPos, curMove); thisSearchMoveSortingArrayForTransposEntry[tActualIndex] = tEval; pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 3: blackKingSquare = tBlackKingSquare; break; case 7: blackKingSquare = tBlackKingSquare; break; case 10: enPassantSquare = 65; break; case 11: blackKingSquare = tBlackKingSquare; pieceTypeArray[curMove.rochadeStartPos] = 4; pieceTypeArray[curMove.rochadeEndPos] = 0; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 13: pieceTypeArray[tStartPos] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval < curEval) { bestMove = curMove; curEval = tEval; } if (pBeta > curEval) pBeta = curEval; if (curEval <= pAlpha) { if (!curMove.isCapture) { killerMoveHeuristic[curMove.moveHash] = true; if (pDepth > 0) historyHeuristic[curMove.moveHash] += pDepth * pDepth; } break; } } isWhiteToMove = false; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; if (molc == 0 && pCheckingSquare == -1) curEval = 0; if (!transpositionTable.ContainsKey(zobristKey)) transpositionTable.Add(zobristKey, new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry)); else transpositionTable[zobristKey] = new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry); return curEval; } private int QuiescenceBlack(int pPly, int pAlpha, int pBeta, int pDepth, int pCheckingSquare, Move pLastMove) { int standPat = TexelEvaluate(); if (standPat <= pAlpha || pDepth < MAX_QUIESCENCE_TOTAL_LENGTH) return pAlpha; if (standPat < pBeta) pBeta = standPat; List<Move> moveOptionList = new List<Move>(); if (BlackIsPositionTheSpecialCase(pLastMove, pCheckingSquare)) GetLegalBlackCapturesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalBlackCaptures(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tBlackKingSquare = blackKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = false; for (int m = 0; m < molc; m++) { Move curMove = moveOptionList[m]; int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; blackPieceBitboard = tBPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesBlack[tStartPos, tPieceType] ^ pieceHashesBlack[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 5: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[blackKingSquare = tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 12: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesWhite[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 14: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } zobristKey ^= pieceHashesWhite[tEndPos, tPTI] ^ pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, curMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } debugMoveList[pPly] = curMove; int tEval = QuiescenceWhite(pPly + 1, pAlpha, pBeta, pDepth - 1, tCheckPos, curMove); pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 7: blackKingSquare = tBlackKingSquare; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval <= pAlpha) return pAlpha; if (pBeta > tEval) pBeta = tEval; } isWhiteToMove = false; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; return pBeta; } private bool[] killerMoveHeuristic = new bool[262_144]; private int[] historyHeuristic = new int[262_144]; public void ClearHeuristics() { for (int i = 0; i < 262_144; i++) { killerMoveHeuristic[i] = false; historyHeuristic[i] = 0; } } private Dictionary<ulong, TranspositionEntry> transpositionTable = new Dictionary<ulong, TranspositionEntry>(); private int[] pieceEvals = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[,][] piecePositionEvals = new int[33, 14][]; private int evalCount = 0; private int Evaluate() { evalCount++; if (fiftyMoveRuleCounter > 99) return 0; int tEval = 0, tPT, pieceCount = ULONG_OPERATIONS.CountBits(allPieceBitboard); for (int p = 0; p < 64; p++) tEval += pieceEvals[tPT = pieceTypeArray[p] + 7 * ((int)(blackPieceBitboard >> p) & 1)] + piecePositionEvals[pieceCount, tPT][p]; return tEval; } public int GameState(bool pWhiteKingCouldBeAttacked) { if (IsDrawByRepetition(curSearchZobristKeyLine.Length - 5) || fiftyMoveRuleCounter > 99) return 0; int t; List<Move> tMoves = new List<Move>(); GetLegalMoves(ref tMoves); if (pWhiteKingCouldBeAttacked) { t = PreMinimaxCheckCheckWhite(); if (t == -1) return tMoves.Count == 0 ? 0 : 3; else if (tMoves.Count == 0) return -1; } else { t = PreMinimaxCheckCheckBlack(); if (t == -1) return tMoves.Count == 0 ? 0 : 3; else if (tMoves.Count == 0) return 1; } return 3; } private bool IsDrawByRepetition(int pPlyOfFirstPossibleRepeatedPosition) { int tC = 0; for (int i = pPlyOfFirstPossibleRepeatedPosition; i >= 0; i -= 2) { if (curSearchZobristKeyLine[i] == zobristKey) if (++tC == 2) return true; } return false; } private const int RELE_MAX_MOVE_COUNT_PER_GAME = 500; public double ReLePlayGame(int[,][] pEvalPositionValuesWhite, int[,][] pEvalPositionValuesBlack, long thinkingTimePerMove) { int[,][] processedValuesWhite = InitReLeAgent(pEvalPositionValuesWhite), processedValuesBlack = InitReLeAgent(pEvalPositionValuesBlack); int tGS, mc = 0; do { if (IsDrawByRepetition(curSearchZobristKeyLine.Length - 5)) return 0d; piecePositionEvals = isWhiteToMove ? processedValuesWhite : processedValuesBlack; MinimaxRoot(thinkingTimePerMove); if (transpositionTable.Count == 0) { SNAPSHOT_WRITLINE_REPLACEMENT("?!"); return 0d; } PlainMakeMove(transpositionTable[zobristKey].bestMove); tGS = GameState(isWhiteToMove); transpositionTable.Clear(); if (tGS != 3) break; } while (mc++ < RELE_MAX_MOVE_COUNT_PER_GAME); if (tGS == 3 || tGS == 0) return 0d; else if (tGS == 1) return 0.1d * (double)(RELE_MAX_MOVE_COUNT_PER_GAME - mc); return 0.1d * (double)(-RELE_MAX_MOVE_COUNT_PER_GAME + mc); } public int[,][] InitReLeAgent(int[,][] pEvalPositionValues) { return GetInterpolatedProcessedValues(pEvalPositionValues); } private int[,][] GetInterpolatedProcessedValues(int[,][] pEvalPositionValues) { int[,][] processedValues = new int[33, 14][]; for (int i = 0; i < 32; i++) { int ip1 = i + 1; processedValues[ip1, 7] = processedValues[ip1, 0] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; processedValues[ip1, 8] = SwapArrayViewingSide(processedValues[ip1, 1] = MultiplyArraysWithVal(pEvalPositionValues[0, 0], pEvalPositionValues[1, 0], pEvalPositionValues[2, 0], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 9] = SwapArrayViewingSide(processedValues[ip1, 2] = MultiplyArraysWithVal(pEvalPositionValues[0, 1], pEvalPositionValues[1, 1], pEvalPositionValues[2, 1], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 10] = SwapArrayViewingSide(processedValues[ip1, 3] = MultiplyArraysWithVal(pEvalPositionValues[0, 2], pEvalPositionValues[1, 2], pEvalPositionValues[2, 2], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 11] = SwapArrayViewingSide(processedValues[ip1, 4] = MultiplyArraysWithVal(pEvalPositionValues[0, 3], pEvalPositionValues[1, 3], pEvalPositionValues[2, 3], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 12] = SwapArrayViewingSide(processedValues[ip1, 5] = MultiplyArraysWithVal(pEvalPositionValues[0, 4], pEvalPositionValues[1, 4], pEvalPositionValues[2, 4], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 13] = SwapArrayViewingSide(processedValues[ip1, 6] = MultiplyArraysWithVal(pEvalPositionValues[0, 5], pEvalPositionValues[1, 5], pEvalPositionValues[2, 5], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); } return processedValues; } private double[,][] GetInterpolatedProcessedValues(double[,][] pEvalPositionValues) { double[,][] processedValues = new double[33, 14][]; for (int i = 0; i < 32; i++) { int ip1 = i + 1; processedValues[ip1, 7] = processedValues[ip1, 0] = new double[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; processedValues[ip1, 8] = SwapArrayViewingSide(processedValues[ip1, 1] = MultiplyArraysWithVal(pEvalPositionValues[0, 0], pEvalPositionValues[1, 0], pEvalPositionValues[2, 0], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 9] = SwapArrayViewingSide(processedValues[ip1, 2] = MultiplyArraysWithVal(pEvalPositionValues[0, 1], pEvalPositionValues[1, 1], pEvalPositionValues[2, 1], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 10] = SwapArrayViewingSide(processedValues[ip1, 3] = MultiplyArraysWithVal(pEvalPositionValues[0, 2], pEvalPositionValues[1, 2], pEvalPositionValues[2, 2], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 11] = SwapArrayViewingSide(processedValues[ip1, 4] = MultiplyArraysWithVal(pEvalPositionValues[0, 3], pEvalPositionValues[1, 3], pEvalPositionValues[2, 3], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 12] = SwapArrayViewingSide(processedValues[ip1, 5] = MultiplyArraysWithVal(pEvalPositionValues[0, 4], pEvalPositionValues[1, 4], pEvalPositionValues[2, 4], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 13] = SwapArrayViewingSide(processedValues[ip1, 6] = MultiplyArraysWithVal(pEvalPositionValues[0, 5], pEvalPositionValues[1, 5], pEvalPositionValues[2, 5], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); } return processedValues; } private double[] MultiplyArraysWithVal(double[] pArr1, double[] pArr2, double[] pArr3, double pVal1, double pVal2, double pVal3) { int tL = pArr1.Length; double[] rArr = new double[tL]; for (int i = 0; i < tL; i++) { rArr[i] = pArr1[i] * pVal1 + pArr2[i] * pVal2 + pArr3[i] * pVal3; } return rArr; } private int[] MultiplyArraysWithVal(int[] pArr1, int[] pArr2, int[] pArr3, double pVal1, double pVal2, double pVal3) { int tL = pArr1.Length; int[] rArr = new int[tL]; for (int i = 0; i < tL; i++) { rArr[i] = (int)(pArr1[i] * pVal1 + pArr2[i] * pVal2 + pArr3[i] * pVal3); } return rArr; } private int[] SwapArrayViewingSideAndNegate(int[] pArr) { return new int[64] { -pArr[56], -pArr[57], -pArr[58], -pArr[59], -pArr[60], -pArr[61], -pArr[62], -pArr[63], -pArr[48], -pArr[49], -pArr[50], -pArr[51], -pArr[52], -pArr[53], -pArr[54], -pArr[55], -pArr[40], -pArr[41], -pArr[42], -pArr[43], -pArr[44], -pArr[45], -pArr[46], -pArr[47], -pArr[32], -pArr[33], -pArr[34], -pArr[35], -pArr[36], -pArr[37], -pArr[38], -pArr[39], -pArr[24], -pArr[25], -pArr[26], -pArr[27], -pArr[28], -pArr[29], -pArr[30], -pArr[31], -pArr[16], -pArr[17], -pArr[18], -pArr[19], -pArr[20], -pArr[21], -pArr[22], -pArr[23], -pArr[8], -pArr[9], -pArr[10], -pArr[11], -pArr[12], -pArr[13], -pArr[14], -pArr[15], -pArr[0], -pArr[1], -pArr[2], -pArr[3], -pArr[4], -pArr[5], -pArr[6], -pArr[7] }; } private int[] SwapArrayViewingSide(int[] pArr) { return new int[64] { pArr[56], pArr[57], pArr[58], pArr[59], pArr[60], pArr[61], pArr[62], pArr[63], pArr[48], pArr[49], pArr[50], pArr[51], pArr[52], pArr[53], pArr[54], pArr[55], pArr[40], pArr[41], pArr[42], pArr[43], pArr[44], pArr[45], pArr[46], pArr[47], pArr[32], pArr[33], pArr[34], pArr[35], pArr[36], pArr[37], pArr[38], pArr[39], pArr[24], pArr[25], pArr[26], pArr[27], pArr[28], pArr[29], pArr[30], pArr[31], pArr[16], pArr[17], pArr[18], pArr[19], pArr[20], pArr[21], pArr[22], pArr[23], pArr[8], pArr[9], pArr[10], pArr[11], pArr[12], pArr[13], pArr[14], pArr[15], pArr[0], pArr[1], pArr[2], pArr[3], pArr[4], pArr[5], pArr[6], pArr[7] }; } private double[] SwapArrayViewingSide(double[] pArr) { return new double[64] { pArr[56], pArr[57], pArr[58], pArr[59], pArr[60], pArr[61], pArr[62], pArr[63], pArr[48], pArr[49], pArr[50], pArr[51], pArr[52], pArr[53], pArr[54], pArr[55], pArr[40], pArr[41], pArr[42], pArr[43], pArr[44], pArr[45], pArr[46], pArr[47], pArr[32], pArr[33], pArr[34], pArr[35], pArr[36], pArr[37], pArr[38], pArr[39], pArr[24], pArr[25], pArr[26], pArr[27], pArr[28], pArr[29], pArr[30], pArr[31], pArr[16], pArr[17], pArr[18], pArr[19], pArr[20], pArr[21], pArr[22], pArr[23], pArr[8], pArr[9], pArr[10], pArr[11], pArr[12], pArr[13], pArr[14], pArr[15], pArr[0], pArr[1], pArr[2], pArr[3], pArr[4], pArr[5], pArr[6], pArr[7] }; } private int[,][] texelTuningRuntimeVals = new int[33, 14][]; private int[,][] texelTuningVals = new int[3, 6][]; private int[,] texelTuningAdjustIterations = new int[6, 64]; private int[][] texelTuningRuntimePositionalValsV2EG = new int[14][]; private int[][] texelTuningRuntimePositionalValsV2LG = new int[14][]; private int[] texelPieceEvaluationsV2EG = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[] texelPieceEvaluationsV2LG = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[] texelKingSafetyR1EvaluationsEG = new int[9]; private int[] texelKingSafetyR2EvaluationsEG = new int[17]; private int[] texelKingSafetyR1EvaluationsLG = new int[9]; private int[] texelKingSafetyR2EvaluationsLG = new int[17]; private int[] texelKingSafetySREvaluationsPT1EG = new int[12]; private int[] texelKingSafetySREvaluationsPT2EG = new int[12]; private int[] texelKingSafetySREvaluationsPT3EG = new int[12]; private int[] texelKingSafetySREvaluationsPT4EG = new int[12]; private int[] texelKingSafetySREvaluationsPT5EG = new int[12]; private int[] texelKingSafetySREvaluationsPT6EG = new int[12]; private int[] texelKingSafetySREvaluationsPT1LG = new int[12]; private int[] texelKingSafetySREvaluationsPT2LG = new int[12]; private int[] texelKingSafetySREvaluationsPT3LG = new int[12]; private int[] texelKingSafetySREvaluationsPT4LG = new int[12]; private int[] texelKingSafetySREvaluationsPT5LG = new int[12]; private int[] texelKingSafetySREvaluationsPT6LG = new int[12]; private int[,] texelMobilityStraightEG = new int[14, 15], texelMobilityStraightLG = new int[14, 15]; private int[,] texelMobilityDiagonalEG = new int[14, 14], texelMobilityDiagonalLG = new int[14, 14]; private int[] texelPieceEvaluations = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[] blackSidedSquares = new int[64] { 56, 57, 58, 59, 60, 61, 62, 63, 48, 49, 50, 51, 52, 53, 54, 55, 40, 41, 42, 43, 44, 45, 46, 47, 32, 33, 34, 35, 36, 37, 38, 39, 24, 25, 26, 27, 28, 29, 30, 31, 16, 17, 18, 19, 20, 21, 22, 23, 08, 09, 10, 11, 12, 13, 14, 15, 00, 01, 02, 03, 04, 05, 06, 07 }; private int[,] T_Pawns = new int[3, 64] { { 0, 0, 0, 0, 0, 0, 0, 0, 98, 134, 61, 95, 68, 126, 34, -11, -6, 7, 26, 31, 65, 56, 25, -20, -14, 13, 6, 21, 23, 12, 17, -23, -27, -2, -5, 12, 17, 6, 10, -25, -26, -4, -4, -10, 3, 3, 33, -12, -35, -1, -20, -23, -15, 24, 38, -22, 0, 0, 0, 0, 0, 0, 0, 0, } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { 0, 0, 0, 0, 0, 0, 0, 0, 178, 173, 158, 134, 147, 132, 165, 187, 94, 100, 85, 67, 56, 53, 82, 84, 32, 24, 13, 5, -2, 4, 17, 17, 13, 9, -3, -7, -7, -8, 3, -1, 4, 7, -6, 1, 0, -5, -1, -8, 13, 8, 8, 10, 13, 0, 2, -7, 0, 0, 0, 0, 0, 0, 0, 0, } }; private int[,] T_Knights = new int[3, 64] { { -167, -89, -34, -49, 61, -97, -15, -107, -73, -41, 72, 36, 23, 62, 7, -17, -47, 60, 37, 65, 84, 129, 73, 44, -9, 17, 19, 53, 37, 69, 18, 22, -13, 4, 16, 13, 28, 19, 21, -8, -23, -9, 12, 10, 19, 17, 25, -16, -29, -53, -12, -3, -1, 18, -14, -19, -105, -21, -58, -33, -17, -28, -19, -23 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -58, -38, -13, -28, -31, -27, -63, -99, -25, -8, -25, -2, -9, -25, -24, -52, -24, -20, 10, 9, -1, -9, -19, -41, -17, 3, 22, 22, 22, 11, 8, -18, -18, -6, 16, 25, 16, 17, 4, -18, -23, -3, -1, 15, 10, -3, -20, -22, -42, -20, -10, -5, -2, -20, -23, -44, -29, -51, -23, -15, -22, -18, -50, -64 } }; private int[,] T_Bishops = new int[3, 64] { { -29, 4, -82, -37, -25, -42, 7, -8, -26, 16, -18, -13, 30, 59, 18, -47, -16, 37, 43, 40, 35, 50, 37, -2, -4, 5, 19, 50, 37, 37, 7, -2, -6, 13, 13, 26, 34, 12, 10, 4, 0, 15, 15, 15, 14, 27, 18, 10, 4, 15, 16, 0, 7, 21, 33, 1, -33, -3, -14, -21, -13, -12, -39, -21 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -14, -21, -11, -8, -7, -9, -17, -24, -8, -4, 7, -12, -3, -13, -4, -14, 2, -8, 0, -1, -2, 6, 0, 4, -3, 9, 12, 9, 14, 10, 3, 2, -6, 3, 13, 19, 7, 10, -3, -9, -12, -3, 8, 10, 13, 3, -7, -15, -14, -18, -7, -1, 4, -9, -15, -27, -23, -9, -23, -5, -9, -16, -5, -17 } }; private int[,] T_Rooks = new int[3, 64] { { 32, 42, 32, 51, 63, 9, 31, 43, 27, 32, 58, 62, 80, 67, 26, 44, -5, 19, 26, 36, 17, 45, 61, 16, -24, -11, 7, 26, 24, 35, -8, -20, -36, -26, -12, -1, 9, -7, 6, -23, -45, -25, -16, -17, 3, 0, -5, -33, -44, -16, -20, -9, -1, 11, -6, -71, -19, -13, 1, 17, 16, 7, -37, -26 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { 13, 10, 18, 15, 12, 12, 8, 5, 11, 13, 13, 11, -3, 3, 8, 3, 7, 7, 7, 5, 4, -3, -5, -3, 4, 3, 13, 1, 2, 1, -1, 2, 3, 5, 8, 4, -5, -6, -8, -11, -4, 0, -5, -1, -7, -12, -8, -16, -6, -6, 0, 2, -9, -9, -11, -3, -9, 2, 3, -1, -5, -13, 4, -20 } }; private int[,] T_Queens = new int[3, 64] { { -28, 0, 29, 12, 59, 44, 43, 45, -24, -39, -5, 1, -16, 57, 28, 54, -13, -17, 7, 8, 29, 56, 47, 57, -27, -27, -16, -16, -1, 17, -2, 1, -9, -26, -9, -10, -2, -4, 3, -3, -14, 2, -11, -2, -5, 2, 14, 5, -35, -8, 11, 2, 8, 15, -3, 1, -1, -18, -9, 10, -15, -25, -31, -50 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -9, 22, 22, 27, 27, 19, 10, 20, -17, 20, 32, 41, 58, 25, 30, 0, -20, 6, 9, 49, 47, 35, 19, 9, 3, 22, 24, 45, 57, 40, 57, 36, -18, 28, 19, 47, 31, 34, 39, 23, -16, -27, 15, 6, 9, 17, 10, 5, -22, -23, -30, -16, -16, -23, -36, -32, -33, -28, -22, -43, -5, -32, -20, -41 } }; private int[,] T_Kings = new int[3, 64] { { -65, 23, 16, -15, -56, -34, 2, 13, 29, -1, -20, -7, -8, -4, -38, -29, -9, 24, 2, -16, -20, 6, 22, -22, -17, -20, -12, -27, -30, -25, -14, -36, -49, -1, -27, -39, -46, -44, -33, -51, -14, -14, -22, -46, -44, -30, -15, -27, 1, 7, -8, -64, -43, -16, 9, 8, -15, 36, 12, -54, 8, -28, 24, 14 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -74, -35, -18, -18, -11, 15, 4, -17, -12, 17, 14, 17, 17, 38, 23, 11, 10, 17, 23, 15, 20, 45, 44, 13, -8, 22, 24, 27, 26, 33, 26, 3, -18, -4, 21, 24, 27, 23, 9, -11, -19, -3, 11, 21, 23, 16, 7, -9, -27, -11, 4, 13, 14, 4, -5, -17, -53, -34, -21, -11, -28, -14, -24, -43 } }; private int[] paramsLowerLimits = new int[5] { -10000, -10000, -10000, -10000, -10000 }; private int[] paramsUpperLimits = new int[5] { 10000, 10000, 10000, 10000, 10000 }; private List<TLM_ChessGame> threadDataset; private int threadFrom, threadTo; private int[] threadParams; private int customThreadID = 0; private ulong ulAllThreadIDsUnfinished = 0; private double lastCostVal = 0d; private double sumCostVals = 0d; private int costCalculations = 0; private readonly string[] TEXELPRINT_GAMEPARTS = new string[3] { "Early Game: ", "Mid Game: ", "Late Game: "}; private readonly string[] TEXELPRINT_PIECES = new string[6] { "Bauer: ", "Springer: ", "Lufer: ", "Turm: ", "Dame: ", "Knig: "}; private double[] earlyGameMultipliers = new double[33]; private double[] middleGameMultipliers = new double[33]; private double[] lateGameMultipliers = new double[33]; private int[] pieceTypeGameProgressImpact = new int[14] { 0, 0, 1, 1, 2, 4, 0, 0, 0, 1, 1, 2, 4, 0 }; private void PrecalculateMultipliers() { if (BOARD_MANAGER_ID == ENGINE_VALS.PARALLEL_BOARDS - 1) SNAPSHOT_WRITLINE_REPLACEMENT(); for (int i = 0; i < 25; i++) { earlyGameMultipliers[i] = EGMultiplierFunction(i); lateGameMultipliers[i] = LGMultiplierFunction(i); if (BOARD_MANAGER_ID == ENGINE_VALS.PARALLEL_BOARDS - 1) SNAPSHOT_WRITLINE_REPLACEMENT("[" + i + "] "+ earlyGameMultipliers[i] + " | "+ middleGameMultipliers[i] + " | "+ lateGameMultipliers[i]); } } private double MultiplierFunction(double pVal, double pXShift) { double d = Math.Exp(1d /6d * (pVal - pXShift)); return 5 * (d /Math.Pow(d + 1, 2d)); } private double EGMultiplierFunction(double pVal) { return Math.Clamp(1 /16d * (pVal - 4d), 0d, 1d); } private double LGMultiplierFunction(double pVal) { return Math.Clamp(1 /-16d * (pVal - 4d) + 1d, 0d, 1d); } private double EGMultiplierFunction2(double pVal) { return Math.Clamp(1 /32d * pVal, 0d, 1d); } private double LGMultiplierFunction2(double pVal) { return Math.Clamp(1 /-32d * pVal + 1d, 0d, 1d); } private void TuneWithTxtFile(string pTXTName) { List<TLM_ChessGame> gameDataset = new List<TLM_ChessGame>(); string tPath = PathManager.GetTXTPath(pTXTName); string[] tStrs = File.ReadAllLines(tPath); List<string> tGames = new List<string>(); foreach (string s in tStrs) if (s.Contains(';') && s.Replace(" ", "") != "") tGames.Add(s); foreach (string s in tGames) { TLM_ChessGame tGame = CGFF.GetGame(s); LoadFenString(tGame.startFen); foreach (int hMove in tGame.hashedMoves) { List<Move> moveOptionList = new List<Move>(); GetLegalMoves(ref moveOptionList); int tL = moveOptionList.Count; for (int j = 0; j < tL; j++) { Move tMove = moveOptionList[j]; if (tMove.moveHash == hMove) { tGame.actualMoves.Add(tMove); PlainMakeMove(tMove); tL = -1; break; } } if (tL != -1) break; } gameDataset.Add(tGame); } SNAPSHOT_WRITLINE_REPLACEMENT("[TLM TEXEL TUNER] " + tGames.Count + " Games Loaded In!"); BOT_MAIN.curTEXELPARAMS = new int[TEXEL_PARAMS]; BOT_MAIN.ParallelTexelTuning(gameDataset); } private void LoadBestTexelParamsIn() { int[] ttt = new int[778]; ttt[0] = 82; ttt[1] = 341; ttt[2] = 416; ttt[3] = 470; ttt[4] = 1106; ttt[5] = 102; ttt[6] = 302; ttt[7] = 304; ttt[8] = 518; ttt[9] = 960; SetupTexelEvaluationParams(ttt); } private void SetupTexelEvaluationParams(int[] pParams) { texelPieceEvaluationsV2EG[8] = -(texelPieceEvaluationsV2EG[1] = pParams[0]); texelPieceEvaluationsV2EG[9] = -(texelPieceEvaluationsV2EG[2] = pParams[1]); texelPieceEvaluationsV2EG[10] = -(texelPieceEvaluationsV2EG[3] = pParams[2]); texelPieceEvaluationsV2EG[11] = -(texelPieceEvaluationsV2EG[4] = pParams[3]); texelPieceEvaluationsV2EG[12] = -(texelPieceEvaluationsV2EG[5] = pParams[4]); texelPieceEvaluationsV2LG[8] = -(texelPieceEvaluationsV2LG[1] = pParams[5]); texelPieceEvaluationsV2LG[9] = -(texelPieceEvaluationsV2LG[2] = pParams[6]); texelPieceEvaluationsV2LG[10] = -(texelPieceEvaluationsV2LG[3] = pParams[7]); texelPieceEvaluationsV2LG[11] = -(texelPieceEvaluationsV2LG[4] = pParams[8]); texelPieceEvaluationsV2LG[12] = -(texelPieceEvaluationsV2LG[5] = pParams[9]); int c = 10; for (int p = 1; p < 7; p++) { for (int s = 0; s < 64; s++) { texelTuningRuntimePositionalValsV2EG[p + 7][blackSidedSquares[s]] = -(texelTuningRuntimePositionalValsV2EG[p][s] = pParams[c++]); texelTuningRuntimePositionalValsV2LG[p + 7][blackSidedSquares[s]] = -(texelTuningRuntimePositionalValsV2LG[p][s] = pParams[c++]); } } return; for (int p = 2; p < 7; p++) { for (int a = 0; a < 15; a++) { if (a != 14) { texelMobilityDiagonalEG[p + 7, a] = -(texelMobilityDiagonalEG[p, a] = pParams[c++]); texelMobilityDiagonalLG[p + 7, a] = -(texelMobilityDiagonalLG[p, a] = pParams[c++]); } texelMobilityStraightEG[p + 7, a] = -(texelMobilityStraightEG[p, a] = pParams[c++]); texelMobilityStraightLG[p + 7, a] = -(texelMobilityStraightLG[p, a] = pParams[c++]); } } for (int i = 0; i < 12; i++) { texelKingSafetySREvaluationsPT1EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT2EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT3EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT4EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT5EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT6EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT1LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT2LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT3LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT4LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT5LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT6LG[i] = pParams[c++]; } } private void PrintDefinedTexelParams(int[] pParams) { int c = 0; for (int t = 0; t < 3; t++) { SNAPSHOT_WRITLINE_REPLACEMENT(TEXELPRINT_GAMEPARTS[t]); for (int p = 0; p < 6; p++) { SNAPSHOT_WRITLINE_REPLACEMENT(TEXELPRINT_PIECES[p]); texelTuningVals[t, p] = new int[64]; for (int s = 0; s < 64; s++) { if (s % 8 == 0 && s != 0) SNAPSHOT_WRITLINE_REPLACEMENT(); SNAPSHOT_WRITLINE_REPLACEMENT((texelTuningVals[t, p][s] = pParams[c++]) + ", "); } SNAPSHOT_WRITLINE_REPLACEMENT(); } } piecePositionEvals = GetInterpolatedProcessedValues(texelTuningVals); } public void TLMTuning(List<TLM_ChessGame> pDataset) { int tGameDataSetLen = pDataset.Count; int[,][] tRatio = new int[33, 6][]; int[,][] tTotalMoves = new int[33, 6][]; double[,][] tSummedRatios = new double[33, 6][]; double[,][] tSummedDataAmount = new double[33, 6][]; double[,][] tTuningResults = new double[33, 6][]; for (int t = 1; t < 33; t++) { for (int p = 0; p < 6; p++) { tRatio[t, p] = new int[64]; tTotalMoves[t, p] = new int[64]; tSummedRatios[t, p] = new double[64]; tSummedDataAmount[t, p] = new double[64]; tTuningResults[t, p] = new double[64]; } } for (int j = 0; j < tGameDataSetLen; j++) { TLM_ChessGame tGame = pDataset[j]; int tGR = tGame.gameResult - 1; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count - 5; for (int i = 0; i < tL; i++) { if (tGame.isMoveNonTactical[i]) { int tPieceAmount = ULONG_OPERATIONS.CountBits(allPieceBitboard); for (int s = 0; s < 64; s++) { int tPT = pieceTypeArray[s] - 1; if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, s)) { tTotalMoves[tPieceAmount, tPT][s]++; tRatio[tPieceAmount, tPT][s] += tGR; } else if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, s)) { int b = blackSidedSquares[s]; tTotalMoves[tPieceAmount, tPT][b]++; tRatio[tPieceAmount, tPT][b] += tGR; } } } PlainMakeMove(tGame.actualMoves[i]); } } double[,] allMultipliers = new double[33, 33]; for (int sh = 0; sh < 33; sh++) { for (int i = 0; i < 33; i++) { allMultipliers[sh, i] = MultiplierFunction(i, sh); } } for (int t = 1; t < 33; t++) { for (int p = 0; p < 6; p++) { for (int s = 0; s < 64; s++) { for (int t2 = 1; t2 < 33; t2++) { double cmult = allMultipliers[t, t2]; tSummedRatios[t, p][s] += tRatio[t2, p][s] * cmult; tSummedDataAmount[t, p][s] += tTotalMoves[t2, p][s] * cmult; } tTuningResults[t, p][s] = TTT(tSummedRatios[t, p][s], tSummedDataAmount[t, p][s]); } } } int c = 0; int[] tparams = new int[1152]; for (int t = 1; t < 33; t += 15) { if (t == 31) t = 32; SNAPSHOT_WRITLINE_REPLACEMENT("PieceCount = " + t + ": "); for (int p = 0; p < 6; p++) { SNAPSHOT_WRITLINE_REPLACEMENT(TEXELPRINT_PIECES[p]); for (int s = 0; s < 64; s++) { if (s % 8 == 0 && s != 0) SNAPSHOT_WRITLINE_REPLACEMENT(); SNAPSHOT_WRITLINE_REPLACEMENT((tparams[c++] = (int)(tTuningResults[t, p][s] * 100)).ToString().Replace(",", ".") + "("+ (int)tSummedDataAmount[t, p][s] + ")"+ ", "); } SNAPSHOT_WRITLINE_REPLACEMENT(); } } string tS = "PARAMS: {"; for (int i = 0; i < tparams.Length; i++) tS += tparams[i] + ","; tS = tS.Substring(0, tS.Length - 1) + "}\n"; SNAPSHOT_WRITLINE_REPLACEMENT(tS); TexelTuning(pDataset, tparams); } private double TTT(double d1, double d2) { if (d2 == 0) return 0; return d1 /d2; } public void TexelTuning(List<TLM_ChessGame> pDataset, int[] pCurBestParams) { Stopwatch sw = Stopwatch.StartNew(); string tPath = PathManager.GetTXTPath("OTHER/TEXEL_TUNING"); int paramCount = pCurBestParams.Length; double bestAvrgCost = CalculateAverageTexelCost(pDataset, pCurBestParams); SNAPSHOT_WRITLINE_REPLACEMENT("CUR PARAMS COST: " + bestAvrgCost); int packetSize = Math.Clamp(paramCount /ENGINE_VALS.CPU_CORES, 1, 100000); paramsLowerLimits = new int[paramCount]; paramsUpperLimits = new int[paramCount]; for (int i = 0; i < paramCount; i++) { int lim = i < 10 ? 100000 : 200; paramsLowerLimits[i] = -lim; paramsUpperLimits[i] = lim; } SNAPSHOT_WRITLINE_REPLACEMENT("PARAM-COUNT: " + paramCount); SNAPSHOT_WRITLINE_REPLACEMENT("PACKET-SIZE: " + packetSize); while (packetSize <= paramCount) { BOT_MAIN.TEXELfinished = 0; int lM = 0, tC = 0; ulong tUL = 0ul; for (int m = packetSize; lM < paramCount; m += packetSize) { if (m > paramCount) m = paramCount; tUL = ULONG_OPERATIONS.SetBitToOne(tUL, ++tC); lM = m; } tC = lM = 0; for (int m = packetSize; lM < paramCount; m += packetSize) { if (m > paramCount) m = paramCount; tC++; BOT_MAIN.boardManagers[tC].SetPlayTexelVals(pDataset, lM, m, pCurBestParams, paramsLowerLimits, paramsUpperLimits, tC, tUL); ThreadPool.QueueUserWorkItem(new WaitCallback(BOT_MAIN.boardManagers[tC].TexelTuningThreadedPackage)); lM = m; } packetSize = paramCount + 1; int tmod = 0; while (tC != BOT_MAIN.TEXELfinished) { if (++tmod % 20 == 0) { WriteTexelParamsToTXT(tPath, BOT_MAIN.curTEXELPARAMS); SNAPSHOT_WRITLINE_REPLACEMENT(CalculateAverageTexelCost(pDataset, BOT_MAIN.curTEXELPARAMS) + " | "+ BOT_MAIN.TEXELadjustmentsmade); SNAPSHOT_WRITLINE_REPLACEMENT(ULONG_OPERATIONS.GetBitVisualization(BOT_MAIN.TEXELfinishedwithoutimpovement)); } Thread.Sleep(100); } SNAPSHOT_WRITLINE_REPLACEMENT("One Thread Generation FINISHED! :) :) :)"); pCurBestParams = BOT_MAIN.curTEXELPARAMS; } sw.Stop(); WriteTexelParamsToTXT(tPath, BOT_MAIN.curTEXELPARAMS); SNAPSHOT_WRITLINE_REPLACEMENT("END COST: " + CalculateAverageTexelCost(pDataset, BOT_MAIN.curTEXELPARAMS)); SNAPSHOT_WRITLINE_REPLACEMENT(BOT_MAIN.TEXELadjustmentsmade); SNAPSHOT_WRITLINE_REPLACEMENT(sw.ElapsedMilliseconds); } public void TexelTuningThreadedPackage(object obj) { SNAPSHOT_WRITLINE_REPLACEMENT("Started CThreadID [" + customThreadID + "] which is handling Params ["+ threadFrom + "] - ["+ threadTo + "]"); bool firstIter = true; do { double bestAvrgCost = CalculateAverageTexelCost(threadDataset, threadParams); int adjust_val = firstIter ? 512 : 8; do { adjust_val /= 2; bool improvedAvrgCost = true; while (improvedAvrgCost) { improvedAvrgCost = false; for (int i = threadFrom; i < threadTo; i++) { bool improvedWithThisParam = true; int tadjustval = adjust_val; bool lastTimeMaximized = false, lastTimeMinimized = false; while (improvedWithThisParam) { improvedWithThisParam = false; int[] curParams = (int[])threadParams.Clone(); int paramBefore = curParams[i]; curParams[i] = Math.Clamp(paramBefore + adjust_val, paramsLowerLimits[i], paramsUpperLimits[i]); double curAvrgCost = CalculateAverageTexelCost(threadDataset, curParams); if (curAvrgCost < bestAvrgCost) { improvedAvrgCost = true; improvedWithThisParam = true; SNAPSHOT_WRITLINE_REPLACEMENT("Improved Param [" + i + "] at CThreadID ["+ customThreadID + "]: +"+ adjust_val + " ("+ GetDoublePrecentageString(bestAvrgCost - curAvrgCost) + ")"); bestAvrgCost = curAvrgCost; threadParams = curParams; BOT_MAIN.TEXELadjustmentsmade++; BOT_MAIN.TEXELfinishedwithoutimpovement = ulAllThreadIDsUnfinished; if (lastTimeMaximized) { adjust_val *= 4; lastTimeMaximized = false; } else lastTimeMaximized = true; lastTimeMinimized = false; } else { curParams[i] = Math.Clamp(paramBefore - adjust_val, paramsLowerLimits[i], paramsUpperLimits[i]); curAvrgCost = CalculateAverageTexelCost(threadDataset, curParams); if (curAvrgCost < bestAvrgCost) { improvedAvrgCost = true; improvedWithThisParam = true; SNAPSHOT_WRITLINE_REPLACEMENT("Improved Param [" + i + "] at CThreadID ["+ customThreadID + "]: -"+ adjust_val + " ("+ GetDoublePrecentageString(bestAvrgCost - curAvrgCost) + ")"); bestAvrgCost = curAvrgCost; threadParams = curParams; BOT_MAIN.TEXELadjustmentsmade++; BOT_MAIN.TEXELfinishedwithoutimpovement = ulAllThreadIDsUnfinished; if (lastTimeMinimized) { adjust_val *= 4; lastTimeMinimized = false; } else lastTimeMinimized = true; lastTimeMaximized = false; } } if (adjust_val != 1) adjust_val /= 2; for (int j = threadFrom; j < threadTo; j++) { BOT_MAIN.curTEXELPARAMS[j] = threadParams[j]; } threadParams = (int[])BOT_MAIN.curTEXELPARAMS.Clone(); bestAvrgCost = CalculateAverageTexelCost(threadDataset, threadParams); } adjust_val = tadjustval; } } } while (adjust_val != 1); BOT_MAIN.TEXELfinishedwithoutimpovement = ULONG_OPERATIONS.SetBitToZero(BOT_MAIN.TEXELfinishedwithoutimpovement, customThreadID); SNAPSHOT_WRITLINE_REPLACEMENT("FULLY FINISHED " + customThreadID + ". IMPROVEMENT THREAD PACKAGE CYCLE"); firstIter = false; } while (BOT_MAIN.TEXELfinishedwithoutimpovement != 0); BOT_MAIN.TEXELfinished++; } private void WriteTexelParamsToTXT(string pPath, int[] pParams) { try { string tS = "PARAMS: {"; for (int i = 0; i < pParams.Length; i++) tS += pParams[i] + ","; tS = tS.Substring(0, tS.Length - 1) + "}\n"; File.AppendAllText(pPath, tS); } catch { SNAPSHOT_WRITLINE_REPLACEMENT("Mal wieder TXT zu lange gebraucht um zu aktualisieren."); } } private double costSum = 0d; private int texelCostMovesEvaluated = 0; private double CalculateAverageTexelCost(List<TLM_ChessGame> tDataset, int[] pParams, bool pFullCost = true) { costSum = 0d; texelCostMovesEvaluated = 0; SetupTexelEvaluationParams(pParams); int tGameDataSetLen = tDataset.Count; int start = 0, end = tGameDataSetLen; if (!pFullCost) { end = (start = globalRandom.Next(0, end - 256)) + 256; } for (int j = start; j < end; j++) { TLM_ChessGame tGame = tDataset[j]; double tGR = tGame.gameResult; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count - 5; texelCostMovesEvaluated += tL; for (int i = 0; i < tL; i++) { costSum += TexelCost(tGR - TexelTuningSigmoid(TexelEvaluate())); PlainMakeMove(tGame.actualMoves[i]); } } return costSum /texelCostMovesEvaluated; } private double CalculateAverageTexelCostThreadedVersionLEGACYDOESNTWORK(List<TLM_ChessGame> tDataset, int[] pParams) { Stopwatch sw = Stopwatch.StartNew(); BOT_MAIN.TEXELcostSum = 0d; BOT_MAIN.TEXELfinished = 0; BOT_MAIN.TEXELcostMovesEvaluated = 0; int tGameDataSetLen = tDataset.Count; int gamesPerThread = tGameDataSetLen /ENGINE_VALS.CPU_CORES; for (int i = 0; i < ENGINE_VALS.CPU_CORES - 1; i++) { } for (int i = 0; i < ENGINE_VALS.CPU_CORES - 1; i++) { } while (BOT_MAIN.TEXELfinished != ENGINE_VALS.CPU_CORES) Thread.Sleep(1); sw.Stop(); return BOT_MAIN.TEXELcostSum /BOT_MAIN.TEXELcostMovesEvaluated; } public void SetPlayThroughVals(List<TLM_ChessGame> pDataset, int pFrom, int pTo) { threadDataset = pDataset; threadFrom = pFrom; threadTo = pTo; } public void SetPlayTexelVals(List<TLM_ChessGame> pDataset, int pFrom, int pTo, int[] pTexelParams, int[] pLowerLimits, int[] pUpperLimits, int pThreadID, ulong pUL) { threadDataset = pDataset; threadFrom = pFrom; threadTo = pTo; threadParams = pTexelParams; paramsLowerLimits = pLowerLimits; paramsUpperLimits = pUpperLimits; customThreadID = pThreadID; ulAllThreadIDsUnfinished = pUL; } public void PlayThroughSetOfGames(object obj) { SNAPSHOT_WRITLINE_REPLACEMENT(threadFrom + "->"+ threadTo); int sortedOut = 0; for (int j = threadFrom; j < threadTo; j++) { TLM_ChessGame tGame = threadDataset[j]; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count; for (int i = 0; i < tL; i++) { int tQuietEval = isWhiteToMove ? QuiescenceWhite(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, 0, PreMinimaxCheckCheckWhite(), NULL_MOVE) : QuiescenceBlack(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, 0, PreMinimaxCheckCheckBlack(), NULL_MOVE); bool tB; tGame.isMoveNonTactical.Add(tB = (Evaluate() == tQuietEval && i > 4)); if (!tB) sortedOut++; PlainMakeMove(tGame.actualMoves[i]); } } BOT_MAIN.TEXELsortedout += sortedOut; BOT_MAIN.TEXELfinished++; } public void CalculateAverageTexelCostThreadFunction(object obj) { SetupTexelEvaluationParams(threadParams); double d = 0d; for (int j = threadFrom; j < threadTo; j++) { TLM_ChessGame tGame = threadDataset[j]; double tGR = tGame.gameResult; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count - 5; BOT_MAIN.TEXELcostMovesEvaluated += tL; for (int i = 0; i < tL; i++) { d += TexelCost(tGR - TexelTuningSigmoid(TexelEvaluate())); PlainMakeMove(tGame.actualMoves[i]); } } BOT_MAIN.TEXELcostSum += d; BOT_MAIN.TEXELfinished++; } private void ConsoleWriteLineTuneArray<T>(T[,][] pArr) { for (int j = 0; j < 3; j++) { SNAPSHOT_WRITLINE_REPLACEMENT("{"); for (int k = 0; k < 6; k++) { SNAPSHOT_WRITLINE_REPLACEMENT("{"); for (int s = 0; s < 64; s++) SNAPSHOT_WRITLINE_REPLACEMENT(pArr[j, k][s] + ", "); SNAPSHOT_WRITLINE_REPLACEMENT("\n}"); } SNAPSHOT_WRITLINE_REPLACEMENT("}"); } } private void Tune(string pGameCGFF, double pLearningRate) { TLM_ChessGame tGame = CGFF.GetGame(pGameCGFF); LoadFenString(tGame.startFen); double tDGameResult = tGame.gameResult; foreach (int hMove in tGame.hashedMoves) { Tune(tDGameResult, pLearningRate); List<Move> moveOptionList = new List<Move>(); GetLegalMoves(ref moveOptionList); int tL = moveOptionList.Count; for (int i = 0; i < tL; i++) { Move tMove = moveOptionList[i]; if (tMove.moveHash == hMove) { PlainMakeMove(tMove); tL = -1; break; } } if (tL != -1) break; } } private void Tune(double pGameResult, double pLearningRate) { int tPC = ULONG_OPERATIONS.CountBits(allPieceBitboard); double oneThroughPieceCount = 1d /tPC; double egMult = earlyGameMultipliers[tPC], mgMult = middleGameMultipliers[tPC], lgMult = lateGameMultipliers[tPC]; double tTexelResult = TexelEvaluateF(); double tSigmoidedTexelResult = TexelSigmoid(tTexelResult); double tDif = tSigmoidedTexelResult - pGameResult; double tM = oneThroughPieceCount * TexelCostDerivative(tDif) * TexelSigmoidDerivative(tTexelResult) * pLearningRate; sumCostVals += lastCostVal = TexelCost(tDif); costCalculations++; for (int i = 0; i < 64; i++) { if (ULONG_OPERATIONS.IsBitZero(allPieceBitboard, i)) continue; int tPT = pieceTypeArray[i] - 1, tI = i; if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, i)) tI = blackSidedSquares[i]; texelTuningAdjustIterations[tPT, tI]++; } } private double TexelEvaluateF() { texelTuningRuntimeVals = GetInterpolatedProcessedValues(texelTuningVals); return TexelEvaluate(); } private int TexelEvaluate() { int tEvalEG = 0, tEvalLG = 0, tProgress = 0; ulong[] attkULs = new ulong[14]; for (int p = 0; p < 64; p++) { if (((int)(allPieceBitboard >> p) & 1) == 0) continue; int aPT = pieceTypeArray[p], tPT = aPT + 7 * ((int)(blackPieceBitboard >> p) & 1); tEvalEG += texelTuningRuntimePositionalValsV2EG[tPT][p] + texelPieceEvaluationsV2EG[tPT]; tEvalLG += texelTuningRuntimePositionalValsV2LG[tPT][p] + texelPieceEvaluationsV2LG[tPT]; tProgress += pieceTypeGameProgressImpact[tPT]; } if (tProgress > 24) tProgress = 24; return (int)(earlyGameMultipliers[tProgress] * tEvalEG + lateGameMultipliers[tProgress] * tEvalLG); } private const double TexelK = 0.2; private double TexelTuningSigmoid(double pVal) { return 2d /(1 + Math.Pow(10, -TexelK * pVal /400)); } private double TexelSigmoid(double pVal) { return 2d /(Math.Exp(-0.04d * pVal) + 1d); } private double TexelSigmoidDerivative(double pVal) { double d = Math.Exp(-0.04d * pVal); return 2d * d /(25d * (d + 1d) * (d + 1d)); } private double TexelCost(double pVal) { return pVal * pVal; } private double TexelCostDerivative(double pVal) { return 2 * pVal; } private char[] fenPieces = new char[7] { 'z', 'p', 'n', 'b', 'r', 'q', 'k' }; private string[] squareNames = new string[64] { "a1", "b1", "c1", "d1", "e1", "f1", "g1", "h1", "a2", "b2", "c2", "d2", "e2", "f2", "g2", "h2", "a3", "b3", "c3", "d3", "e3", "f3", "g3", "h3", "a4", "b4", "c4", "d4", "e4", "f4", "g4", "h4", "a5", "b5", "c5", "d5", "e5", "f5", "g5", "h5", "a6", "b6", "c6", "d6", "e6", "f6", "g6", "h6", "a7", "b7", "c7", "d7", "e7", "f7", "g7", "h7", "a8", "b8", "c8", "d8", "e8", "f8", "g8", "h8"}; public string CreateFenString() { string rFEN = ""; for (int i = 7; i >= 0; i--) { int t = 0; for (int j = 0; j < 8; j++) { int sq = i * 8 + j; if (pieceTypeArray[sq] != 0) { if (t != 0) rFEN += t; t = 0; } if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, sq)) { switch (pieceTypeArray[sq]) { case 0: t++; SNAPSHOT_WRITLINE_REPLACEMENT("???"); break; case 1: rFEN += 'P'; break; case 2: rFEN += 'N'; break; case 3: rFEN += 'B'; break; case 4: rFEN += 'R'; break; case 5: rFEN += 'Q'; break; case 6: rFEN += 'K'; break; } } else { switch (pieceTypeArray[sq]) { case 0: t++; break; case 1: rFEN += 'p'; break; case 2: rFEN += 'n'; break; case 3: rFEN += 'b'; break; case 4: rFEN += 'r'; break; case 5: rFEN += 'q'; break; case 6: rFEN += 'k'; break; } } } if (t != 0) rFEN += t; if (i != 0) rFEN += "/"; } rFEN += (isWhiteToMove ? " w": " b"); rFEN += (whiteCastleRightKingSide ? " K": " "); rFEN += (whiteCastleRightQueenSide ? "Q": ""); rFEN += (blackCastleRightKingSide ? "k": ""); rFEN += (blackCastleRightQueenSide ? "q": ""); if (!whiteCastleRightKingSide && !whiteCastleRightQueenSide && !blackCastleRightKingSide && !blackCastleRightQueenSide) rFEN += "-"; if (enPassantSquare < 64) rFEN += " "+ squareNames[enPassantSquare] + " "; else rFEN += " - "; return rFEN + fiftyMoveRuleCounter + " "+ ((happenedHalfMoves - happenedHalfMoves % 2) /2); } public void LoadFenString(string fenStr) { debugFEN = fenStr; lastMadeMove = NULL_MOVE; zobristKey = 0ul; whitePieceBitboard = blackPieceBitboard = allPieceBitboard = 0ul; for (int i = 0; i < 64; i++) pieceTypeArray[i] = 0; string[] spaceSpl = fenStr.Split(' '); string[] rowSpl = spaceSpl[0].Split('/'); string epstr = spaceSpl[3]; if (epstr == "-") enPassantSquare = 65; else enPassantSquare = (epstr[0] - 'a') + 8 * (epstr[1] - '1'); isWhiteToMove = true; if (spaceSpl[1] == "b") isWhiteToMove = false; if (!isWhiteToMove) zobristKey ^= blackTurnHash; string crstr = spaceSpl[2]; whiteCastleRightKingSide = whiteCastleRightQueenSide = blackCastleRightKingSide = blackCastleRightQueenSide = false; int crStrL = crstr.Length; for (int i = 0; i < crStrL; i++) { switch (crstr[i]) { case 'K': whiteCastleRightKingSide = true; break; case 'Q': whiteCastleRightQueenSide = true; break; case 'k': blackCastleRightKingSide = true; break; case 'q': blackCastleRightQueenSide = true; break; } } fiftyMoveRuleCounter = Convert.ToInt32(spaceSpl[4]); happenedHalfMoves = Convert.ToInt32(spaceSpl[5]) * 2; if (!isWhiteToMove) happenedHalfMoves++; int tSq = 0; for (int i = rowSpl.Length; i-- > 0;) { string tStr = rowSpl[i]; int tStrLen = tStr.Length; for (int c = 0; c < tStrLen; c++) { char tChar = tStr[c]; if (Char.IsDigit(tChar)) tSq += tChar - '0'; else { bool tCol = Char.IsLower(tChar); if (tCol) blackPieceBitboard = ULONG_OPERATIONS.SetBitToOne(blackPieceBitboard, tSq); else whitePieceBitboard = ULONG_OPERATIONS.SetBitToOne(whitePieceBitboard, tSq); if (tChar == 'k') blackKingSquare = tSq; else if (tChar == 'K') whiteKingSquare = tSq; pieceTypeArray[tSq] = Array.IndexOf(fenPieces, Char.ToLower(tChar)); if (tCol) zobristKey ^= pieceHashesBlack[tSq, pieceTypeArray[tSq]]; else zobristKey ^= pieceHashesWhite[tSq, pieceTypeArray[tSq]]; tSq++; } } } if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; zobristKey ^= enPassantSquareHashes[enPassantSquare]; allPieceBitboard = whitePieceBitboard | blackPieceBitboard; if (zobristKey == 16260251586586513106) moveHashList.Clear(); else { moveHashList.Clear(); moveHashList.Add(1); moveHashList.Add(2); moveHashList.Add(3); } } private ulong[,] pieceHashesWhite = new ulong[64, 7], pieceHashesBlack = new ulong[64, 7]; private ulong blackTurnHash, whiteKingSideRochadeRightHash, whiteQueenSideRochadeRightHash, blackKingSideRochadeRightHash, blackQueenSideRochadeRightHash; private ulong[] enPassantSquareHashes = new ulong[66]; private Dictionary<ulong, int> singleCheckCaseBackup = new Dictionary<ulong, int>(); private void InitZobrist() { Random rng = new Random(31415926); for (int sq = 0; sq < 64; sq++) { enPassantSquareHashes[sq] = ULONG_OPERATIONS.GetRandomULONG(rng); for (int it = 1; it < 7; it++) { pieceHashesWhite[sq, it] = ULONG_OPERATIONS.GetRandomULONG(rng); pieceHashesBlack[sq, it] = ULONG_OPERATIONS.GetRandomULONG(rng); } } blackTurnHash = ULONG_OPERATIONS.GetRandomULONG(rng); whiteKingSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); whiteQueenSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); blackKingSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); blackQueenSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); } public void SetKnightMasks(ulong[] uls) { knightSquareBitboards = uls; } public void SetKingMasks(ulong[] uls) { kingSquareBitboards = uls; } private Move[,] whiteEnPassantMoves = new Move[64, 64]; private Move[,] blackEnPassantMoves = new Move[64, 64]; private bool[] epValidationArray = new bool[64] { false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true , true , true , true , true , true , true , true, true , true , true , true , true , true , true , true, true , true , true , true , true , true , true , true, true , true , true , true , true , true , true , true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false }; private ulong[] kingSafetyRing1 = new ulong[64], kingSafetyRing2 = new ulong[64]; private ulong[] kingSafetySpecialRingW = new ulong[64], kingSafetySpecialRingB = new ulong[64]; private ulong[] rowPrecalcs = new ulong[8], columnPrecalcs = new ulong[8]; const ulong columnUL = 0x101010101010101, rowUL = 0b11111111; private void PrecalculateKingSafetyBitboards() { for (int i = 0; i < 8; i++) { rowPrecalcs[i] = rowUL << (8 * i); columnPrecalcs[i] = columnUL << i; } for (int i = 0; i < 64; i++) { int tMod = i % 8; int tRow = (i - tMod) /8; ulong tULC = columnPrecalcs[tMod], tULR = rowPrecalcs[tRow]; ulong tULC2 = columnPrecalcs[tMod], tULR2 = rowPrecalcs[tRow]; if (tMod < 7) tULC |= columnPrecalcs[tMod + 1]; if (tMod > 0) tULC |= columnPrecalcs[tMod - 1]; if (tRow < 7) tULR |= rowPrecalcs[tRow + 1]; if (tRow > 0) tULR |= rowPrecalcs[tRow - 1]; if (tMod < 6) tULC2 |= columnPrecalcs[tMod + 2]; if (tMod > 1) tULC2 |= columnPrecalcs[tMod - 2]; if (tRow < 6) tULR2 |= rowPrecalcs[tRow + 2]; if (tRow > 1) tULR2 |= rowPrecalcs[tRow - 2]; tULR2 |= tULR; tULC2 |= tULC; kingSafetyRing1[i] = ULONG_OPERATIONS.SetBitToZero(tULR & tULC, i); kingSafetyRing2[i] = ULONG_OPERATIONS.SetBitsToZero(tULR2 & tULC2, i, i + 1, i - 1, i + 7, i + 8, i + 9, i - 7, i - 8, i - 9); } for (int i = 0; i < 64; i++) { if (i < 56) kingSafetySpecialRingW[i] = ULONG_OPERATIONS.SetBitToZero(kingSafetyRing1[i] | kingSafetyRing1[i + 8], i); else kingSafetySpecialRingW[i] = kingSafetyRing1[i]; if (i > 7) kingSafetySpecialRingB[i] = ULONG_OPERATIONS.SetBitToZero(kingSafetyRing1[i] | kingSafetyRing1[i - 8], i); else kingSafetySpecialRingB[i] = kingSafetyRing1[i]; } } private void PrecalculateEnPassantMoves() { for (int i = 0; i < 64; i++) { if (!epValidationArray[i]) continue; for (int j = 0; j < 64; j++) { if (i == j) continue; if (Math.Abs(i - j) > 9) continue; if (!epValidationArray[j]) continue; whiteEnPassantMoves[i, j] = new Move(false, i, j, j - 8); blackEnPassantMoves[i, j] = new Move(false, i, j, j + 8); } } } private void PawnAttackBitboards() { for (int sq = 0; sq < 64; sq++) { ulong u = 0ul; if (sq % 8 != 0) u = ULONG_OPERATIONS.SetBitToOne(u, sq + 7); if (sq % 8 != 7) u = ULONG_OPERATIONS.SetBitToOne(u, sq + 9); whitePawnAttackSquareBitboards[sq] = u; u = 0ul; if (sq % 8 != 0 && sq - 9 > -1) u = ULONG_OPERATIONS.SetBitToOne(u, sq - 9); if (sq % 8 != 7 && sq - 7 > -1) u = ULONG_OPERATIONS.SetBitToOne(u, sq - 7); blackPawnAttackSquareBitboards[sq] = u; } } private int[] squareConnectivesPrecalculationArray = new int[4096]; public int[] squareConnectivesCrossDirsPrecalculationArray { get; set; } = new int[4096]; private ulong[] squareConnectivesPrecalculationRayArray = new ulong[4096]; private ulong[] squareConnectivesPrecalculationLineArray = new ulong[4096]; private List<Dictionary<ulong, int>> rayCollidingSquareCalculations = new List<Dictionary<ulong, int>>(); private readonly int[] maxIntWithSpecifiedBitcount = new int[8] { 0, 0b1, 0b11, 0b111, 0b1111, 0b11111, 0b111111, 0b1111111 }; private List<ulong> differentRays = new List<ulong>(); private void SquareConnectivesPrecalculations() { for (int square = 0; square < 64; square++) { rayCollidingSquareCalculations.Add(new Dictionary<ulong, int>()); rayCollidingSquareCalculations[square].Add(0ul, square); for (int square2 = 0; square2 < 64; square2++) { if (square == square2) continue; int t = 0, t2 = 0, difSign = Math.Sign(square2 - square), itSq = square, g = 0; ulong tRay = 0ul, tExclRay = 0ul; List<int> tRayInts = new List<int>(); if (difSign == -1) g = 7; if (square % 8 == square2 % 8) { t2 = t = 1; while ((itSq += difSign * 8) < 64 && itSq > -1) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } } else if ((square - square % 8) == (square2 - square2 % 8)) { t = 1; t2 = -1; while ((itSq += difSign) % 8 != g && itSq > -1 && itSq < 64) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } } else { int dif = Math.Abs(square2 - square); if (dif % 7 == 0) { t = 2; t2 = 2; g = (difSign == 1) ? 7 : 0; while ((itSq += difSign * 7) % 8 != g && itSq < 64 && itSq > -1) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } if (ULONG_OPERATIONS.IsBitZero(tRay, square2)) { t2 = t = 0; tRay = 0ul; } } else if (dif % 9 == 0) { t = 2; t2 = -2; if (square == 0 && square2 == 63 || square == 63 && square2 == 0) SNAPSHOT_WRITLINE_REPLACEMENT("!"); while ((itSq += difSign * 9) % 8 != g && itSq < 64 && itSq > -1) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } if (ULONG_OPERATIONS.IsBitZero(tRay, square2)) { t2 = t = 0; tRay = 0ul; } } } if (square == 0 && square2 == 63) { t2 = t = 2; tRayInts.Clear(); tExclRay = tRay = ULONG_OPERATIONS.SetBitsToOne(0ul, 9, 18, 27, 36, 45, 54, 63); tRayInts = new List<int>() { 9, 18, 27, 36, 45, 54, 63 }; } else if (square2 == 0 && square == 63) { t = 2; tRayInts.Clear(); t2 = -2; tExclRay = tRay = ULONG_OPERATIONS.SetBitsToOne(0ul, 0, 9, 18, 27, 36, 45, 54); tRayInts = new List<int>() { 54, 45, 36, 27, 18, 9, 0 }; } if (tRay != 0ul && !differentRays.Contains(tRay)) { differentRays.Add(tRay); int ccount, combI = maxIntWithSpecifiedBitcount[ccount = ULONG_OPERATIONS.CountBits(tRay)]; do { ulong curAllPieceBitboard = 0ul; int solution = square; for (int j = 0; j < ccount; j++) { if (((combI >> j) & 1) == 1) { curAllPieceBitboard = ULONG_OPERATIONS.SetBitToOne(curAllPieceBitboard, tRayInts[j]); if (solution == square) solution = tRayInts[j]; } } rayCollidingSquareCalculations[square].Add(curAllPieceBitboard, solution); } while (--combI != 0); } squareConnectivesPrecalculationArray[square << 6 | square2] = t; squareConnectivesPrecalculationRayArray[square << 6 | square2] = tRay; squareConnectivesCrossDirsPrecalculationArray[square << 6 | square2] = t2; if (t != 0) squareConnectivesPrecalculationLineArray[square << 6 | square2] = (square == 0 && square2 == 63 || square2 == 0 && square == 63) ? tExclRay : ULONG_OPERATIONS.SetBitToOne(tExclRay, square2); if (squareConnectivesPrecalculationLineArray[square << 6 | square2] == 0ul && ULONG_OPERATIONS.IsBitOne(knightSquareBitboards[square], square2)) squareConnectivesPrecalculationLineArray[square << 6 | square2] = 1ul << square2; } differentRays.Clear(); } } public void SNAPSHOT_WRITLINE_REPLACEMENT() { } public void SNAPSHOT_WRITLINE_REPLACEMENT(object pStr) { } private string GetDoublePrecentageString(double pVal) { return ((int)(pVal * 1_000_000) /10_000d) + "%"; } private string ReplaceAllULONGIsBitOne(string pCode) { const string METHOD_NAME = "ULONG_OPERATIONS.IsBitOne"; int METHOD_NAME_LEN = METHOD_NAME.Length, iterations = 0; int pIndex = pCode.IndexOf(METHOD_NAME); while (pIndex != -1 && ++iterations < 10_000) { List<int> paramIndexes = new List<int>(); int openedBracketCount = 1, closedBracketCount = 0, a = METHOD_NAME_LEN + pIndex; string tpCode = pCode.Substring(0, pIndex); paramIndexes.Add(a + 1); while (++a < pCode.Length) { switch (pCode[a]) { case '(': openedBracketCount++; break; case ')': if (++closedBracketCount == openedBracketCount) { pIndex = a; a = int.MaxValue - 5; } break; case ',': if (openedBracketCount - closedBracketCount == 1) paramIndexes.Add(a + 1); break; } } if (openedBracketCount == closedBracketCount && paramIndexes.Count == 2) { tpCode += "((int)("+ pCode.Substring(paramIndexes[0], paramIndexes[1] - paramIndexes[0] - 1) + (pCode[paramIndexes[1]] == ' ' ? " >> (": " >> (") + pCode.Substring(paramIndexes[1], pIndex - paramIndexes[1]) + ")) & 1) == 1"+ pCode.Substring(pIndex + 1, pCode.Length - pIndex - 1); } pIndex = (pCode = tpCode).IndexOf(METHOD_NAME); } SNAPSHOT_WRITLINE_REPLACEMENT(iterations + " ITERATIONS"); return pCode; } private string ReplaceAllULONGIsBitZero(string pCode) { const string METHOD_NAME = "ULONG_OPERATIONS.IsBitZero"; int METHOD_NAME_LEN = METHOD_NAME.Length, iterations = 0; int pIndex = pCode.IndexOf(METHOD_NAME); while (pIndex != -1 && ++iterations < 10_000) { List<int> paramIndexes = new List<int>(); int openedBracketCount = 1, closedBracketCount = 0, a = METHOD_NAME_LEN + pIndex; string tpCode = pCode.Substring(0, pIndex); paramIndexes.Add(a + 1); while (++a < pCode.Length) { switch (pCode[a]) { case '(': openedBracketCount++; break; case ')': if (++closedBracketCount == openedBracketCount) { pIndex = a; a = int.MaxValue - 5; } break; case ',': if (openedBracketCount - closedBracketCount == 1) paramIndexes.Add(a + 1); break; } } if (openedBracketCount == closedBracketCount && paramIndexes.Count == 2) { tpCode += "((int)("+ pCode.Substring(paramIndexes[0], paramIndexes[1] - paramIndexes[0] - 1) + (pCode[paramIndexes[1]] == ' ' ? " >>": " >> ") + pCode.Substring(paramIndexes[1], pIndex - paramIndexes[1]) + ") & 1) == 0"+ pCode.Substring(pIndex + 1, pCode.Length - pIndex - 1); } pIndex = (pCode = tpCode).IndexOf(METHOD_NAME); } SNAPSHOT_WRITLINE_REPLACEMENT(iterations + " ITERATIONS"); return pCode; } private string GetThreeDigitSeperatedInteger(int pInt) { string s = pInt.ToString(), r = s[0].ToString(); int t = s.Length % 3; for (int i = 1; i < s.Length; i++) { if (i % 3 == t) r += "."; r += s[i]; } s = ""; for (int i = 0; i < r.Length; i++) s += r[i]; return s; } public double GetAverageDepth() { return (double)depths /(double)searches; } }
public class SNAPSHOT_V01_00_012 : IBoardManager  { public int TEXEL_PARAMS { get; } = 778; private const int BESTMOVE_SORT_VAL = -2_000_000_000; private const int CAPTURE_SORT_VAL = -1_000_000_000; private const int KILLERMOVE_SORT_VAL = -1000; private readonly int[,] MVVLVA_TABLE = new int[7, 7] { { 0, 0, 0, 0, 0, 0, 0 }, { 0, 1500, 1400, 1300, 1200, 1100, 1000 }, { 0, 3500, 3400, 3300, 3200, 3100, 3000 }, { 0, 4500, 4400, 4300, 4200, 4100, 4000 }, { 0, 5500, 5400, 5300, 5200, 5100, 5000 }, { 0, 9500, 9400, 9300, 9200, 9100, 9000 }, { 0, 0, 0, 0, 0, 0, 0 }}; private int BOARD_MANAGER_ID = -1; private bool debugSearchDepthResults = false; private bool debugSortResults = false; private RookMovement rookMovement; private BishopMovement bishopMovement; private QueenMovement queenMovement; private KnightMovement knightMovement; private KingMovement kingMovement; private WhitePawnMovement whitePawnMovement; private BlackPawnMovement blackPawnMovement; private Rays rays; public List<Move> moveOptionList { get; set; } private int[] pieceTypeArray = new int[64]; public ulong whitePieceBitboard, blackPieceBitboard, allPieceBitboard; private ulong zobristKey; private int whiteKingSquare, blackKingSquare, enPassantSquare = 65, happenedHalfMoves = 0, fiftyMoveRuleCounter = 0; private bool whiteCastleRightKingSide, whiteCastleRightQueenSide, blackCastleRightKingSide, blackCastleRightQueenSide; private bool isWhiteToMove; private const ulong WHITE_KING_ROCHADE = 96, WHITE_QUEEN_ROCHADE = 14, BLACK_KING_ROCHADE = 6917529027641081856, BLACK_QUEEN_ROCHADE = 1008806316530991104, WHITE_QUEEN_ATTK_ROCHADE = 12, BLACK_QUEEN_ATTK_ROCHADE = 864691128455135232; private readonly Move mWHITE_KING_ROCHADE = new Move(4, 6, 7, 5), mWHITE_QUEEN_ROCHADE = new Move(4, 2, 0, 3), mBLACK_KING_ROCHADE = new Move(60, 62, 63, 61), mBLACK_QUEEN_ROCHADE = new Move(60, 58, 56, 59); private ulong[] knightSquareBitboards = new ulong[64]; private ulong[] whitePawnAttackSquareBitboards = new ulong[64]; private ulong[] blackPawnAttackSquareBitboards = new ulong[64]; private ulong[] kingSquareBitboards = new ulong[64]; private bool[,] pieceTypeAbilities = new bool[7, 3] { { false, false, false }, { false, false, false }, { false, false, false }, { false, false, true }, { false, true, false }, { false, true, true }, { false, false, false } }; private List<int> moveHashList = new List<int>(); private ulong[] curSearchZobristKeyLine = Array.Empty<ulong>(); private Move[] debugMoveList = new Move[128]; private string debugFEN = ""; private Stopwatch globalTimer = Stopwatch.StartNew(); private Move lastMadeMove; private int depths, searches; private Random globalRandom = new Random(); public SNAPSHOT_V01_00_012(string fen) { Setup(fen); } public void Setup(string pFen) { Stopwatch setupStopwatch = Stopwatch.StartNew(); BOARD_MANAGER_ID = BOT_MAIN.curBoardManagerID; for (int i = 0; i < 33; i++) for (int j = 0; j < 14; j++) piecePositionEvals[i, j] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; for (int i = 0; i < 33; i++) for (int j = 0; j < 14; j++) texelTuningRuntimeVals[i, j] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; for (int i = 0; i < 3; i++) for (int j = 0; j < 6; j++) texelTuningVals[i, j] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; for (int i = 0; i < 14; i++) { texelTuningRuntimePositionalValsV2EG[i] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; texelTuningRuntimePositionalValsV2LG[i] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; } PrecalculateKingSafetyBitboards(); PrecalculateMultipliers(); GetLowNoisePositionalEvaluation(globalRandom); MinimaxRoot(1L); SetupConsoleWrite("[PRECALCS] Zobrist Hashing"); InitZobrist(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Knight Movement"); knightMovement = new KnightMovement(this); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Square Connectives"); SquareConnectivesPrecalculations(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Pawn Attack Bitboards"); PawnAttackBitboards(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Rays"); rays = new Rays(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); queenMovement = new QueenMovement(this); SetupConsoleWrite("[PRECALCS] Rook Movement"); rookMovement = new RookMovement(this, queenMovement); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Bishop Movement"); bishopMovement = new BishopMovement(this, queenMovement); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] King Movement"); kingMovement = new KingMovement(this); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Pawn Movement"); whitePawnMovement = new WhitePawnMovement(this); blackPawnMovement = new BlackPawnMovement(this); PrecalculateEnPassantMoves(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWriteLine("[DONE]\n\n"); LoadFenString(pFen); LoadBestTexelParamsIn(); setupStopwatch.Stop(); } private void SetupConsoleWriteLine(string pStr) { if (BOT_MAIN.isFirstBoardManagerInitialized) return; SNAPSHOT_WRITLINE_REPLACEMENT(pStr); } private void SetupConsoleWrite(string pStr) { if (BOT_MAIN.isFirstBoardManagerInitialized) return; SNAPSHOT_WRITLINE_REPLACEMENT(pStr); } public void GetLowNoisePositionalEvaluation(System.Random rng) { int[,][] digitArray = new int[3, 6][]; for (int i = 0; i < 3; i++) for (int j = 0; j < 6; j++) digitArray[i, j] = GetRand64IntArray(rng, -5, 6); lowNoisePositionEvals1 = GetInterpolatedProcessedValues(digitArray); int[,][] digitArray2 = new int[3, 6][]; for (int i = 0; i < 3; i++) for (int j = 0; j < 6; j++) digitArray2[i, j] = GetRand64IntArray(rng, -5, 6); lowNoisePositionEvals2 = GetInterpolatedProcessedValues(digitArray2); } private int[] GetRand64IntArray(System.Random rng, int pMin, int pMax) { return new int[64] { rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax) }; } private string GetAIArrayValuesStringRepresentation(int[,][] pArr) { string r = "int[,][] ReLe_AI_RESULT_VALS = new int[3, 6][] {"; for (int i = 0; i < 3; i++) { r += "{"; for (int j = 0; j < 5; j++) { r += GetIntArray64LStringRepresentation(pArr[i, j]) + ","; } r += GetIntArray64LStringRepresentation(pArr[i, 5]) + "},"; } return r.Substring(0, r.Length - 1) + "};"; } private string GetIntArray64LStringRepresentation(int[] p64LArr) { if (p64LArr == null) return ""; string r = "new int[64]{"; for (int i = 0; i < 63; i++) { r += p64LArr[i] + ","; } return r + p64LArr[63] + "}"; } public void TempStuff() { } private string[] gameResultStrings = new string[5] { "Black Has Won!", "Draw!", "White Has Won!", "Non Existant Result!", "Game is Ongoing!"}; private int[,][] lowNoisePositionEvals1, lowNoisePositionEvals2; public void ThreadSelfPlay(object obj) { PlayGameAgainstItself(obj); } public void PlayGameAgainstItself(object obj, string pStartFEN = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1", long tickLimitForEngine = ENGINE_VALS.SELF_PLAY_THINK_TIME) { int ttGState; while (BOT_MAIN.goalGameCount > BOT_MAIN.gamesPlayed) { try { string tGameStr; GetLowNoisePositionalEvaluation(globalRandom); LoadFenString(tGameStr = pStartFEN); tGameStr += ";"; int tGState = 3, tmc = 0; bool lowNoiceDecider = globalRandom.NextDouble() < 0.5d; while (tGState == 3) { piecePositionEvals = lowNoiceDecider ? lowNoisePositionEvals1 : lowNoisePositionEvals2; MinimaxRoot(tickLimitForEngine); Move tM = transpositionTable[zobristKey].bestMove; PlainMakeMove(tM); tGameStr += NuCRe.GetNuCRe(tM.moveHash) + ","; BOT_MAIN.movesPlayed++; tGState = GameState(isWhiteToMove); lowNoiceDecider = !lowNoiceDecider; tmc++; } ttGState = tGState; tGameStr += ttGState + 1; SNAPSHOT_WRITLINE_REPLACEMENT(tGameStr); BOT_MAIN.gamesPlayedResultArray[ttGState + 1]++; BOT_MAIN.gamesPlayed++; BOT_MAIN.selfPlayGameStrings.Add(tGameStr); } catch (Exception tE) { SNAPSHOT_WRITLINE_REPLACEMENT(tE.ToString()); } } } public void PlayGameOnConsoleAgainstHuman(string pStartFEN = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1", bool pHumanPlaysWhite = true, long tickLimitForEngine = 10_000_000L) { debugSearchDepthResults = true; LoadFenString(pStartFEN); if (!(pHumanPlaysWhite ^ isWhiteToMove)) { var pVS = Console.ReadLine(); if (pVS == null) return; Move tm = GetMoveOfString(pVS.ToString()); SNAPSHOT_WRITLINE_REPLACEMENT(tm); PlainMakeMove(tm); } int tGState = 3; while (tGState == 3) { MinimaxRoot(tickLimitForEngine); PlayThroughZobristTree(); Move tM = transpositionTable[zobristKey].bestMove; SNAPSHOT_WRITLINE_REPLACEMENT(tM); SNAPSHOT_WRITLINE_REPLACEMENT(CreateFenString()); PlainMakeMove(tM); tGState = GameState(isWhiteToMove); if (tGState != 3 || tM == NULL_MOVE) break; var pV = ""; tM = NULL_MOVE; do { pV = Console.ReadLine(); if (pV == null) continue; tM = GetMoveOfString(pV.ToString()); SNAPSHOT_WRITLINE_REPLACEMENT(tM); } while (tM == NULL_MOVE); PlainMakeMove(tM); tGState = GameState(isWhiteToMove); } } private void PlayThroughZobristTree() { SetJumpState(); SNAPSHOT_WRITLINE_REPLACEMENT("\n- - - - - - - - - - - - -"); int tC = 1; Dictionary<ulong, bool> usedULs = new Dictionary<ulong, bool>(); while (transpositionTable.TryGetValue(zobristKey, out TranspositionEntry tM)) { if (usedULs.ContainsKey(zobristKey)) { SNAPSHOT_WRITLINE_REPLACEMENT(tC + ": AT LEAST ONE REPETION; REST NOT VISIBLE"); break; } SNAPSHOT_WRITLINE_REPLACEMENT(tC + ": "+ tM.bestMove + " > "); usedULs.Add(zobristKey, true); PlainMakeMove(tM.bestMove); tC++; } SNAPSHOT_WRITLINE_REPLACEMENT("- - - - - - - - - - - - -\n"); LoadJumpState(); } public Move? ReturnNextMove(Move? lastMove, long pThinkingTime) { if (lastMove != null) PlainMakeMove(lastMove); if (GameState(isWhiteToMove) != 3) return null; MinimaxRoot(pThinkingTime); if (!transpositionTable.ContainsKey(zobristKey)) return null; Move tm = transpositionTable[zobristKey].bestMove; PlainMakeMove(tm); return tm; } private int[] jmpSt_pieceTypeArray; private ulong jmpSt_whitePieceBitboard, jmpSt_blackPieceBitboard; private ulong jmpSt_zobristKey; private int jmpSt_whiteKingSquare, jmpSt_blackKingSquare, jmpSt_enPassantSquare, jmpSt_happenedHalfMoves, jmpSt_fiftyMoveRuleCounter; private bool jmpSt_whiteCastleRightKingSide, jmpSt_whiteCastleRightQueenSide, jmpSt_blackCastleRightKingSide, jmpSt_blackCastleRightQueenSide; private bool jmpSt_isWhiteToMove; private ulong[] jmpSt_curSearchZobristKeyLine; private int[] jmpSt_moveHashList; public void LoadJumpState() { pieceTypeArray = (int[])jmpSt_pieceTypeArray.Clone(); whitePieceBitboard = jmpSt_whitePieceBitboard; blackPieceBitboard = jmpSt_blackPieceBitboard; zobristKey = jmpSt_zobristKey; whiteKingSquare = jmpSt_whiteKingSquare; blackKingSquare = jmpSt_blackKingSquare; enPassantSquare = jmpSt_enPassantSquare; happenedHalfMoves = jmpSt_happenedHalfMoves; fiftyMoveRuleCounter = jmpSt_fiftyMoveRuleCounter; whiteCastleRightKingSide = jmpSt_whiteCastleRightKingSide; whiteCastleRightQueenSide = jmpSt_whiteCastleRightQueenSide; blackCastleRightKingSide = jmpSt_blackCastleRightKingSide; blackCastleRightQueenSide = jmpSt_blackCastleRightQueenSide; isWhiteToMove = jmpSt_isWhiteToMove; curSearchZobristKeyLine = (ulong[])jmpSt_curSearchZobristKeyLine.Clone(); allPieceBitboard = blackPieceBitboard | whitePieceBitboard; moveHashList = jmpSt_moveHashList.ToList(); } public void SetJumpState() { jmpSt_pieceTypeArray = (int[])pieceTypeArray.Clone(); jmpSt_whitePieceBitboard = whitePieceBitboard; jmpSt_blackPieceBitboard = blackPieceBitboard; jmpSt_zobristKey = zobristKey; jmpSt_whiteKingSquare = whiteKingSquare; jmpSt_blackKingSquare = blackKingSquare; jmpSt_enPassantSquare = enPassantSquare; jmpSt_happenedHalfMoves = happenedHalfMoves; jmpSt_fiftyMoveRuleCounter = fiftyMoveRuleCounter; jmpSt_whiteCastleRightKingSide = whiteCastleRightKingSide; jmpSt_whiteCastleRightQueenSide = whiteCastleRightQueenSide; jmpSt_blackCastleRightKingSide = blackCastleRightKingSide; jmpSt_blackCastleRightQueenSide = blackCastleRightQueenSide; jmpSt_isWhiteToMove = isWhiteToMove; jmpSt_curSearchZobristKeyLine = (ulong[])curSearchZobristKeyLine.Clone(); jmpSt_moveHashList = moveHashList.ToArray(); } private int PreMinimaxCheckCheckWhite() { ulong bitShiftedKingPos = 1ul << whiteKingSquare; int curR = -1; for (int p = 0; p < 64; p++) { if (ULONG_OPERATIONS.IsBitZero(blackPieceBitboard, p)) continue; int tPT; switch (tPT = pieceTypeArray[p]) { case 1: if ((bitShiftedKingPos & blackPawnAttackSquareBitboards[p]) != 0ul) return p; break; case 2: if ((bitShiftedKingPos & knightSquareBitboards[p]) != 0ul) return p; break; case 6: break; default: if ((squareConnectivesPrecalculationLineArray[whiteKingSquare << 6 | p] & allPieceBitboard) == (1ul << p) && pieceTypeAbilities[tPT, squareConnectivesPrecalculationArray[whiteKingSquare << 6 | p]]) { if (curR != -1) return -779; curR = p; } break; } } return curR; } private int PreMinimaxCheckCheckBlack() { ulong bitShiftedKingPos = 1ul << blackKingSquare; int curR = -1; for (int p = 0; p < 64; p++) { if (ULONG_OPERATIONS.IsBitZero(whitePieceBitboard, p)) continue; int tPT; switch (tPT = pieceTypeArray[p]) { case 1: if ((bitShiftedKingPos & whitePawnAttackSquareBitboards[p]) != 0ul) return p; break; case 2: if ((bitShiftedKingPos & knightSquareBitboards[p]) != 0ul) return p; break; case 6: break; default: if ((squareConnectivesPrecalculationLineArray[blackKingSquare << 6 | p] & allPieceBitboard) == (1ul << p) && pieceTypeAbilities[tPT, squareConnectivesPrecalculationArray[blackKingSquare << 6 | p]]) { if (curR != -1) return -779; curR = p; } break; } } return curR; } private int LecacyLeafCheckingPieceCheckWhite(int pStartPos, int pEndPos, int pPieceType) { int tI, tPossibleAttackPiece; if (pPieceType == 1) { if (ULONG_OPERATIONS.IsBitOne(blackPawnAttackSquareBitboards[pEndPos], whiteKingSquare)) return pEndPos; } else if (pPieceType == 2) { if (ULONG_OPERATIONS.IsBitOne(knightSquareBitboards[pEndPos], whiteKingSquare)) return pEndPos; } else if (pPieceType != 6) { tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | pEndPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; } tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | pStartPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; return -1; } private int LecacyLeafCheckingPieceCheckBlack(int pStartPos, int pEndPos, int pPieceType) { int tI, tPossibleAttackPiece; if (pPieceType == 1) { if (ULONG_OPERATIONS.IsBitOne(whitePawnAttackSquareBitboards[pEndPos], blackKingSquare)) return pEndPos; } else if (pPieceType == 2) { if (ULONG_OPERATIONS.IsBitOne(knightSquareBitboards[pEndPos], blackKingSquare)) return pEndPos; } else if (pPieceType != 6) { tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | pEndPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; } tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | pStartPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; return -1; } public void GetLegalMoves(ref List<Move> pMoveList) { int attk; if (isWhiteToMove) { attk = PreMinimaxCheckCheckWhite(); if (attk == -779) GetLegalWhiteMovesSpecialDoubleCheckCase(ref pMoveList); else GetLegalWhiteMoves(attk, ref pMoveList); } else { attk = PreMinimaxCheckCheckBlack(); if (attk == -779) GetLegalBlackMovesSpecialDoubleCheckCase(ref pMoveList); else GetLegalBlackMoves(attk, ref pMoveList); } } private void GetLegalWhiteMoves(int pCheckingPieceSquare, ref List<Move> pMoveList) { if (pCheckingPieceSquare == -779) { GetLegalWhiteMovesSpecialDoubleCheckCase(ref pMoveList); return; } moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= blackPawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, whiteKingSquare); if (curCheckCount == 0) { if (whiteCastleRightKingSide && ((allPieceBitboard | oppAttkBitboard) & WHITE_KING_ROCHADE) == 0ul) pMoveList.Add(mWHITE_KING_ROCHADE); if (whiteCastleRightQueenSide && (allPieceBitboard & WHITE_QUEEN_ROCHADE | oppAttkBitboard & WHITE_QUEEN_ATTK_ROCHADE) == 0ul) pMoveList.Add(mWHITE_QUEEN_ROCHADE); if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, whitePieceBitboard, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[whiteKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare + 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, whitePieceBitboard, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveList(whiteKingSquare, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalWhiteCaptures(int pCheckingPieceSquare, ref List<Move> pMoveList) { if (pCheckingPieceSquare == -779) { GetLegalWhiteCapturesSpecialDoubleCheckCase(ref pMoveList); return; } moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= blackPawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, whiteKingSquare); if (curCheckCount == 0) { if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & blackPieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[whiteKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare + 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & blackPieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveListOnlyCaptures(whiteKingSquare, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalWhiteMovesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= blackPawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveList(whiteKingSquare, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalWhiteCapturesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= blackPawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveListOnlyCaptures(whiteKingSquare, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalBlackMoves(int pCheckingPieceSquare, ref List<Move> pMoveList) { if (pCheckingPieceSquare == -779) { GetLegalBlackMovesSpecialDoubleCheckCase(ref pMoveList); return; } moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= whitePawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, blackKingSquare); if (curCheckCount == 0) { if (blackCastleRightKingSide && ((allPieceBitboard | oppAttkBitboard) & BLACK_KING_ROCHADE) == 0ul) pMoveList.Add(mBLACK_KING_ROCHADE); if (blackCastleRightQueenSide && (allPieceBitboard & BLACK_QUEEN_ROCHADE | oppAttkBitboard & BLACK_QUEEN_ATTK_ROCHADE) == 0ul) pMoveList.Add(mBLACK_QUEEN_ROCHADE); if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveList(p, blackKingSquare, blackPieceBitboard, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[blackKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare - 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveList(p, blackKingSquare, blackPieceBitboard, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveList(blackKingSquare, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); } private void GetLegalBlackCaptures(int pCheckingPieceSquare, ref List<Move> pMoveList) { if (pCheckingPieceSquare == -779) { GetLegalBlackCapturesSpecialDoubleCheckCase(ref pMoveList); return; } moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= whitePawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, blackKingSquare); if (curCheckCount == 0) { if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & whitePieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[blackKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare - 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & whitePieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveListOnlyCaptures(blackKingSquare, ~oppAttkBitboard & whitePieceBitboard); } private void GetLegalBlackMovesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= whitePawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveList(blackKingSquare, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); } private void GetLegalBlackCapturesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= whitePawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveListOnlyCaptures(blackKingSquare, ~oppAttkBitboard & whitePieceBitboard); } public Move GetMoveOfString(string pMove) { int tSP, tEP; string[] tSpl = pMove.Split(','); if (Char.IsNumber(pMove[0])) { tSP = Convert.ToInt32(tSpl[0]); tEP = Convert.ToInt32(tSpl[1]); } else { tSP = SQUARES.NumberNotation(tSpl[0]); tEP = SQUARES.NumberNotation(tSpl[1]); } int tPT = pieceTypeArray[tSP]; bool tIC = ULONG_OPERATIONS.IsBitOne(allPieceBitboard, tEP), tIEP = enPassantSquare == tEP && tPT == 1; if (tSpl.Length == 3) return new Move(tSP, tEP, tPT, Convert.ToInt32(tSpl[2]), tIC); if (tIEP) return new Move(true, tSP, tEP, isWhiteToMove ? tEP - 8 : tEP + 8); if (tPT == 1 && Math.Abs(tSP - tEP) > 11) return new Move(tSP, tEP, 1, false, isWhiteToMove ? tSP + 8 : tSP - 8); if (tPT == 6 && (Math.Abs(tSP - tEP) == 2 || Math.Abs(tSP - tEP) == 3)) { if (isWhiteToMove) return tEP == 6 ? mWHITE_KING_ROCHADE : mWHITE_QUEEN_ROCHADE; return tEP == 62 ? mBLACK_KING_ROCHADE : mBLACK_QUEEN_ROCHADE; } return new Move(tSP, tEP, tPT, tIC); } public void PlainMakeMove(string pMoveName) { PlainMakeMove(GetMoveOfString(pMoveName)); } public void PlainMakeMove(Move pMove) { lastMadeMove = pMove; if (isWhiteToMove) WhiteMakeMove(pMove); else BlackMakeMove(pMove); debugFEN = CreateFenString(); } public void WhiteMakeMove(Move pMove) { int tEndPos = pMove.endPos, tStartPos = pMove.startPos, tPieceType = pMove.pieceType, tPTI = pieceTypeArray[tEndPos]; fiftyMoveRuleCounter++; whitePieceBitboard ^= pMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey ^= blackTurnHash ^ enPassantSquareHashes[enPassantSquare] ^ pieceHashesWhite[tStartPos, tPieceType] ^ pieceHashesWhite[tEndPos, tPieceType]; enPassantSquare = 65; isWhiteToMove = false; switch (pMove.moveTypeID) { case 0: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 1: fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 2: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 3: whiteKingSquare = tEndPos; if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 4: if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 5: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 6: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 7: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[whiteKingSquare = tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 8: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 9: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = pMove.enPassantOption]; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 11: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; whiteKingSquare = tEndPos; pieceTypeArray[pMove.rochadeEndPos] = 4; pieceTypeArray[pMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesWhite[pMove.rochadeStartPos, 4] ^ pieceHashesWhite[pMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 12: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[pMove.enPassantOption] = 0; zobristKey ^= pieceHashesBlack[pMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 13: fiftyMoveRuleCounter = 0; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; zobristKey ^= pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, pMove.promotionType]; break; case 14: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, tPTI] ^ pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, pMove.promotionType]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; } moveHashList.Add(pMove.moveHash); if (pMove.isCapture || tPieceType == 1) { curSearchZobristKeyLine = Array.Empty<ulong>(); return; } ulong[] u = new ulong[(tPTI = curSearchZobristKeyLine.Length) + 1]; for (int i = tPTI; i-- > 0;) u[i] = curSearchZobristKeyLine[i]; u[tPTI] = zobristKey; curSearchZobristKeyLine = u; } public void BlackMakeMove(Move pMove) { int tEndPos = pMove.endPos, tStartPos = pMove.startPos, tPieceType = pMove.pieceType, tPTI = pieceTypeArray[tEndPos]; fiftyMoveRuleCounter++; blackPieceBitboard ^= pMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey ^= blackTurnHash ^ enPassantSquareHashes[enPassantSquare] ^ pieceHashesBlack[tStartPos, tPieceType] ^ pieceHashesBlack[tEndPos, tPieceType]; enPassantSquare = 65; isWhiteToMove = true; switch (pMove.moveTypeID) { case 0: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 1: fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 2: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 3: blackKingSquare = tEndPos; if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 4: if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 5: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 6: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 7: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[blackKingSquare = tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 8: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 9: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = pMove.enPassantOption]; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 11: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; blackKingSquare = tEndPos; pieceTypeArray[pMove.rochadeEndPos] = 4; pieceTypeArray[pMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesBlack[pMove.rochadeStartPos, 4] ^ pieceHashesBlack[pMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 12: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[pMove.enPassantOption] = 0; zobristKey ^= pieceHashesWhite[pMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 13: fiftyMoveRuleCounter = 0; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, pMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 14: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } zobristKey ^= pieceHashesWhite[tEndPos, tPTI] ^ pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, pMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; } moveHashList.Add(pMove.moveHash); if (pMove.isCapture || tPieceType == 1) { curSearchZobristKeyLine = Array.Empty<ulong>(); return; } ulong[] u = new ulong[(tPTI = curSearchZobristKeyLine.Length) + 1]; for (int i = tPTI; i-- > 0;) u[i] = curSearchZobristKeyLine[i]; u[tPTI] = zobristKey; curSearchZobristKeyLine = u; } public void WhiteUndoMove(Move pMove) { } private const int WHITE_CHECKMATE_VAL = 100000, BLACK_CHECKMATE_VAL = -100000, CHECK_EXTENSION_LENGTH = -12, MAX_QUIESCENCE_TOTAL_LENGTH = -32; private readonly Move NULL_MOVE = new Move(0, 0, 0); private int curSearchDepth = 0, curSubSearchDepth = -1; public int MinimaxRoot(long pTime) { evalCount = 0; searches++; int baseLineLen = 0; long tTimestamp = globalTimer.ElapsedTicks + pTime; ClearHeuristics(); transpositionTable.Clear(); ulong[] tZobristKeyLine = Array.Empty<ulong>(); if (curSearchZobristKeyLine != null) { baseLineLen = curSearchZobristKeyLine.Length; tZobristKeyLine = new ulong[baseLineLen]; Array.Copy(curSearchZobristKeyLine, tZobristKeyLine, baseLineLen); } int perftScore, tattk = isWhiteToMove ? PreMinimaxCheckCheckWhite() : PreMinimaxCheckCheckBlack(), pDepth = 1; (string, int) bookMoveTuple = TLMDatabase.SearchForNextBookMove(moveHashList); if (bookMoveTuple.Item2 != 0) { int actualMoveHash = NuCRe.GetNumber(bookMoveTuple.Item1); List<Move> tMoves = new List<Move>(); GetLegalMoves(ref tMoves); int tL = tMoves.Count; for (int i = 0; i < tL; i++) { if (tMoves[i].moveHash == actualMoveHash) { if (debugSearchDepthResults) { SNAPSHOT_WRITLINE_REPLACEMENT("TLM_DB_Count: " + bookMoveTuple.Item2); SNAPSHOT_WRITLINE_REPLACEMENT(">> " + tMoves[i]); } transpositionTable.Add(zobristKey, new TranspositionEntry(tMoves[i], Array.Empty<int>())); return 0; } } } do { curSearchDepth = pDepth; curSubSearchDepth = pDepth - 1; ulong[] completeZobristHistory = new ulong[baseLineLen + pDepth - CHECK_EXTENSION_LENGTH + 1]; for (int i = 0; i < baseLineLen; i++) completeZobristHistory[i] = curSearchZobristKeyLine[i]; curSearchZobristKeyLine = completeZobristHistory; if (isWhiteToMove) { if (tattk == -1) perftScore = MinimaxWhite(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); else perftScore = MinimaxWhite(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); } else { if (tattk == -1) perftScore = MinimaxBlack(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); else perftScore = MinimaxBlack(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); } if (debugSearchDepthResults && pTime != 1L) { int tNpS = Convert.ToInt32((double)evalCount * 10_000_000d /(double)(pTime - tTimestamp + globalTimer.ElapsedTicks)); int tSearchEval = perftScore; int timeForSearchSoFar = (int)((pTime - tTimestamp + globalTimer.ElapsedTicks) /10000d); Move tBestMove = transpositionTable[zobristKey].bestMove; SNAPSHOT_WRITLINE_REPLACEMENT((tSearchEval >= 0 ? "+": "") + tSearchEval); SNAPSHOT_WRITLINE_REPLACEMENT(" " + tBestMove + "  ["); SNAPSHOT_WRITLINE_REPLACEMENT("Depth = " + pDepth + ", "); SNAPSHOT_WRITLINE_REPLACEMENT("Evals = " + GetThreeDigitSeperatedInteger(evalCount) + ", "); SNAPSHOT_WRITLINE_REPLACEMENT("Time = " + GetThreeDigitSeperatedInteger(timeForSearchSoFar) + "ms, "); SNAPSHOT_WRITLINE_REPLACEMENT("NpS = " + GetThreeDigitSeperatedInteger(tNpS) + "]"); } pDepth++; } while (globalTimer.ElapsedTicks < tTimestamp && pDepth < 179); depths += pDepth - 1; BOT_MAIN.depthsSearched += pDepth - 1; BOT_MAIN.searchesFinished++; BOT_MAIN.evaluationsMade += evalCount; curSearchZobristKeyLine = tZobristKeyLine; return perftScore; } private int[] squareToRankArray = new int[64] { 0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1, 2,2,2,2,2,2,2,2, 3,3,3,3,3,3,3,3, 4,4,4,4,4,4,4,4, 5,5,5,5,5,5,5,5, 6,6,6,6,6,6,6,6, 7,7,7,7,7,7,7,7 }; private bool WhiteIsPositionTheSpecialCase(Move pLastMove, int pCheckingSquare) { if (pLastMove.isPromotion && pLastMove.isCapture && (pLastMove.promotionType == 4 || pLastMove.promotionType == 5)) { if(pLastMove.startPos % 8 == pCheckingSquare % 8 && pLastMove.startPos == whiteKingSquare + 8) return true; if (squareToRankArray[pLastMove.startPos] == squareToRankArray[pCheckingSquare] && pLastMove.endPos == whiteKingSquare - 8) return true; } return false; } private bool BlackIsPositionTheSpecialCase(Move pLastMove, int pCheckingSquare) { if (pLastMove.isPromotion && pLastMove.isCapture && (pLastMove.promotionType == 4 || pLastMove.promotionType == 5)) { if (pLastMove.startPos % 8 == pCheckingSquare % 8 && pLastMove.startPos == blackKingSquare - 8) return true; if (squareToRankArray[pLastMove.startPos] == squareToRankArray[pCheckingSquare] && pLastMove.endPos == blackKingSquare + 8) return true; } return false; } private int MinimaxWhite(int pPly, int pAlpha, int pBeta, int pDepth, int pRepetitionHistoryPly, int pCheckingSquare, Move pLastMove) { if (IsDrawByRepetition(pRepetitionHistoryPly - 4)) return 0; if ((pDepth <= 0 && pCheckingSquare == -1) || pDepth < CHECK_EXTENSION_LENGTH) return QuiescenceWhite(pPly, pAlpha, pBeta, pDepth - 1, pCheckingSquare, pLastMove); List<Move> moveOptionList = new List<Move>(); Move bestMove = NULL_MOVE; if (WhiteIsPositionTheSpecialCase(pLastMove, pCheckingSquare)) GetLegalWhiteMovesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalWhiteMoves(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tWhiteKingSquare = whiteKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1, curEval = BLACK_CHECKMATE_VAL - pDepth; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = true; double[] moveSortingArray = new double[molc]; int[] moveSortingArrayIndexes = new int[molc], thisSearchMoveSortingArrayForTransposEntry = new int[molc]; transpositionTable.TryGetValue(zobristKey, out TranspositionEntry transposEntry); if (transposEntry == null) { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; } } else { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove == transposEntry.bestMove) moveSortingArray[m] = BESTMOVE_SORT_VAL; else if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; if (transposEntry.moveGenOrderedEvalLength > m) moveSortingArray[m] -= transposEntry.moveGenOrderedEvals[m]; } } Array.Sort(moveSortingArray, moveSortingArrayIndexes); for (int m = 0; m < molc; m++) { int tActualIndex = moveSortingArrayIndexes[m]; Move curMove = moveOptionList[tActualIndex]; if (debugSortResults && pDepth == curSubSearchDepth) { SNAPSHOT_WRITLINE_REPLACEMENT(moveSortingArray[m] + " | "+ curMove); } int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; whitePieceBitboard = tWPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesWhite[tStartPos, tPieceType] ^ pieceHashesWhite[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 0: blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 1: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 2: blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 3: whiteKingSquare = tEndPos; if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 4: blackPieceBitboard = tBPB; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 5: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[whiteKingSquare = tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = curMove.enPassantOption]; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 11: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; whiteKingSquare = tEndPos; blackPieceBitboard = tBPB; pieceTypeArray[curMove.rochadeEndPos] = 4; pieceTypeArray[curMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesWhite[curMove.rochadeStartPos, 4] ^ pieceHashesWhite[curMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | curMove.rochadeEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << curMove.rochadeEndPos)) tCheckPos = curMove.rochadeEndPos; break; case 12: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesBlack[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 13: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; zobristKey ^= pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, curMove.promotionType]; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; case 14: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, tPTI] ^ pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, curMove.promotionType]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } curSearchZobristKeyLine[pRepetitionHistoryPly] = zobristKey; debugMoveList[pPly] = curMove; int tEval = MinimaxBlack(pPly + 1, pAlpha, pBeta, pDepth - 1, pRepetitionHistoryPly + 1, tCheckPos, curMove); thisSearchMoveSortingArrayForTransposEntry[tActualIndex] = tEval; pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 3: whiteKingSquare = tWhiteKingSquare; break; case 7: whiteKingSquare = tWhiteKingSquare; break; case 10: enPassantSquare = 65; break; case 11: whiteKingSquare = tWhiteKingSquare; pieceTypeArray[curMove.rochadeStartPos] = 4; pieceTypeArray[curMove.rochadeEndPos] = 0; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 13: pieceTypeArray[tStartPos] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval > curEval) { bestMove = curMove; curEval = tEval; } if (pAlpha < curEval) pAlpha = curEval; if (curEval >= pBeta) { if (!curMove.isCapture) { killerMoveHeuristic[curMove.moveHash] = true; if (pDepth > 0) historyHeuristic[curMove.moveHash] += pDepth * pDepth; } break; } } isWhiteToMove = true; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; if (molc == 0 && pCheckingSquare == -1) curEval = 0; if (!transpositionTable.ContainsKey(zobristKey)) transpositionTable.Add(zobristKey, new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry)); else transpositionTable[zobristKey] = new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry); return curEval; } private int QuiescenceWhite(int pPly, int pAlpha, int pBeta, int pDepth, int pCheckingSquare, Move pLastMove) { int standPat = TexelEvaluate(); if (standPat >= pBeta || pDepth < MAX_QUIESCENCE_TOTAL_LENGTH) return pBeta; if (standPat > pAlpha) pAlpha = standPat; List<Move> moveOptionList = new List<Move>(); if (WhiteIsPositionTheSpecialCase(pLastMove, pCheckingSquare)) GetLegalWhiteCapturesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalWhiteCaptures(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tWhiteKingSquare = whiteKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = true; for (int m = 0; m < molc; m++) { Move curMove = moveOptionList[m]; int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; whitePieceBitboard = tWPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesWhite[tStartPos, tPieceType] ^ pieceHashesWhite[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 5: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[whiteKingSquare = tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 12: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesBlack[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 14: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, tPTI] ^ pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, curMove.promotionType]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } debugMoveList[pPly] = curMove; int tEval = QuiescenceBlack(pPly + 1, pAlpha, pBeta, pDepth - 1, tCheckPos, curMove); pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 7: whiteKingSquare = tWhiteKingSquare; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval >= pBeta) return pBeta; if (pAlpha < tEval) pAlpha = tEval; } isWhiteToMove = true; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; return pAlpha; } private int MinimaxBlack(int pPly, int pAlpha, int pBeta, int pDepth, int pRepetitionHistoryPly, int pCheckingSquare, Move pLastMove) { if (IsDrawByRepetition(pRepetitionHistoryPly - 4)) return 0; if ((pDepth <= 0 && pCheckingSquare == -1) || pDepth < CHECK_EXTENSION_LENGTH) return QuiescenceBlack(pPly, pAlpha, pBeta, pDepth - 1, pCheckingSquare, pLastMove); List<Move> moveOptionList = new List<Move>(); Move bestMove = NULL_MOVE; if (BlackIsPositionTheSpecialCase(pLastMove, pCheckingSquare)) GetLegalBlackMovesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalBlackMoves(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tBlackKingSquare = blackKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1, curEval = WHITE_CHECKMATE_VAL + pDepth; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = false; double[] moveSortingArray = new double[molc]; int[] moveSortingArrayIndexes = new int[molc], thisSearchMoveSortingArrayForTransposEntry = new int[molc]; transpositionTable.TryGetValue(zobristKey, out TranspositionEntry transposEntry); if (transposEntry == null) { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; } } else { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove == transposEntry.bestMove) moveSortingArray[m] = BESTMOVE_SORT_VAL; else if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; if (transposEntry.moveGenOrderedEvalLength > m) moveSortingArray[m] -= transposEntry.moveGenOrderedEvals[m]; } } Array.Sort(moveSortingArray, moveSortingArrayIndexes); for (int m = 0; m < molc; m++) { int tActualIndex = moveSortingArrayIndexes[m]; Move curMove = moveOptionList[tActualIndex]; if (debugSortResults && pDepth == curSearchDepth) { SNAPSHOT_WRITLINE_REPLACEMENT("=== " + moveSortingArray[m] + " | "+ curMove); } int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; blackPieceBitboard = tBPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesBlack[tStartPos, tPieceType] ^ pieceHashesBlack[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 0: whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 1: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 2: whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 3: blackKingSquare = tEndPos; if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 4: whitePieceBitboard = tWPB; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 5: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[blackKingSquare = tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = curMove.enPassantOption]; whitePieceBitboard = tWPB; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 11: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; blackKingSquare = tEndPos; whitePieceBitboard = tWPB; pieceTypeArray[curMove.rochadeEndPos] = 4; pieceTypeArray[curMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesBlack[curMove.rochadeStartPos, 4] ^ pieceHashesBlack[curMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | curMove.rochadeEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << curMove.rochadeEndPos)) tCheckPos = curMove.rochadeEndPos; break; case 12: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesWhite[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 13: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, curMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; case 14: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } zobristKey ^= pieceHashesWhite[tEndPos, tPTI] ^ pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, curMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } curSearchZobristKeyLine[pRepetitionHistoryPly] = zobristKey; debugMoveList[pPly] = curMove; int tEval = MinimaxWhite(pPly + 1, pAlpha, pBeta, pDepth - 1, pRepetitionHistoryPly + 1, tCheckPos, curMove); thisSearchMoveSortingArrayForTransposEntry[tActualIndex] = tEval; pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 3: blackKingSquare = tBlackKingSquare; break; case 7: blackKingSquare = tBlackKingSquare; break; case 10: enPassantSquare = 65; break; case 11: blackKingSquare = tBlackKingSquare; pieceTypeArray[curMove.rochadeStartPos] = 4; pieceTypeArray[curMove.rochadeEndPos] = 0; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 13: pieceTypeArray[tStartPos] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval < curEval) { bestMove = curMove; curEval = tEval; } if (pBeta > curEval) pBeta = curEval; if (curEval <= pAlpha) { if (!curMove.isCapture) { killerMoveHeuristic[curMove.moveHash] = true; if (pDepth > 0) historyHeuristic[curMove.moveHash] += pDepth * pDepth; } break; } } isWhiteToMove = false; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; if (molc == 0 && pCheckingSquare == -1) curEval = 0; if (!transpositionTable.ContainsKey(zobristKey)) transpositionTable.Add(zobristKey, new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry)); else transpositionTable[zobristKey] = new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry); return curEval; } private int QuiescenceBlack(int pPly, int pAlpha, int pBeta, int pDepth, int pCheckingSquare, Move pLastMove) { int standPat = TexelEvaluate(); if (standPat <= pAlpha || pDepth < MAX_QUIESCENCE_TOTAL_LENGTH) return pAlpha; if (standPat < pBeta) pBeta = standPat; List<Move> moveOptionList = new List<Move>(); if (BlackIsPositionTheSpecialCase(pLastMove, pCheckingSquare)) GetLegalBlackCapturesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalBlackCaptures(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tBlackKingSquare = blackKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = false; for (int m = 0; m < molc; m++) { Move curMove = moveOptionList[m]; int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; blackPieceBitboard = tBPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesBlack[tStartPos, tPieceType] ^ pieceHashesBlack[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 5: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[blackKingSquare = tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 12: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesWhite[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 14: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } zobristKey ^= pieceHashesWhite[tEndPos, tPTI] ^ pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, curMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } debugMoveList[pPly] = curMove; int tEval = QuiescenceWhite(pPly + 1, pAlpha, pBeta, pDepth - 1, tCheckPos, curMove); pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 7: blackKingSquare = tBlackKingSquare; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval <= pAlpha) return pAlpha; if (pBeta > tEval) pBeta = tEval; } isWhiteToMove = false; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; return pBeta; } private bool[] killerMoveHeuristic = new bool[262_144]; private int[] historyHeuristic = new int[262_144]; public void ClearHeuristics() { for (int i = 0; i < 262_144; i++) { killerMoveHeuristic[i] = false; historyHeuristic[i] = 0; } } private Dictionary<ulong, TranspositionEntry> transpositionTable = new Dictionary<ulong, TranspositionEntry>(); private int[] pieceEvals = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[,][] piecePositionEvals = new int[33, 14][]; private int evalCount = 0; private int Evaluate() { evalCount++; if (fiftyMoveRuleCounter > 99) return 0; int tEval = 0, tPT, pieceCount = ULONG_OPERATIONS.CountBits(allPieceBitboard); for (int p = 0; p < 64; p++) tEval += pieceEvals[tPT = pieceTypeArray[p] + 7 * ((int)(blackPieceBitboard >> p) & 1)] + piecePositionEvals[pieceCount, tPT][p]; return tEval; } public int GameState(bool pWhiteKingCouldBeAttacked) { if (IsDrawByRepetition(curSearchZobristKeyLine.Length - 5) || fiftyMoveRuleCounter > 99) return 0; int t; List<Move> tMoves = new List<Move>(); GetLegalMoves(ref tMoves); if (pWhiteKingCouldBeAttacked) { t = PreMinimaxCheckCheckWhite(); if (t == -1) return tMoves.Count == 0 ? 0 : 3; else if (tMoves.Count == 0) return -1; } else { t = PreMinimaxCheckCheckBlack(); if (t == -1) return tMoves.Count == 0 ? 0 : 3; else if (tMoves.Count == 0) return 1; } return 3; } private bool IsDrawByRepetition(int pPlyOfFirstPossibleRepeatedPosition) { int tC = 0; for (int i = pPlyOfFirstPossibleRepeatedPosition; i >= 0; i -= 2) { if (curSearchZobristKeyLine[i] == zobristKey) if (++tC == 2) return true; } return false; } private const int RELE_MAX_MOVE_COUNT_PER_GAME = 500; public double ReLePlayGame(int[,][] pEvalPositionValuesWhite, int[,][] pEvalPositionValuesBlack, long thinkingTimePerMove) { int[,][] processedValuesWhite = InitReLeAgent(pEvalPositionValuesWhite), processedValuesBlack = InitReLeAgent(pEvalPositionValuesBlack); int tGS, mc = 0; do { if (IsDrawByRepetition(curSearchZobristKeyLine.Length - 5)) return 0d; piecePositionEvals = isWhiteToMove ? processedValuesWhite : processedValuesBlack; MinimaxRoot(thinkingTimePerMove); if (transpositionTable.Count == 0) { SNAPSHOT_WRITLINE_REPLACEMENT("?!"); return 0d; } PlainMakeMove(transpositionTable[zobristKey].bestMove); tGS = GameState(isWhiteToMove); transpositionTable.Clear(); if (tGS != 3) break; } while (mc++ < RELE_MAX_MOVE_COUNT_PER_GAME); if (tGS == 3 || tGS == 0) return 0d; else if (tGS == 1) return 0.1d * (double)(RELE_MAX_MOVE_COUNT_PER_GAME - mc); return 0.1d * (double)(-RELE_MAX_MOVE_COUNT_PER_GAME + mc); } public int[,][] InitReLeAgent(int[,][] pEvalPositionValues) { return GetInterpolatedProcessedValues(pEvalPositionValues); } private int[,][] GetInterpolatedProcessedValues(int[,][] pEvalPositionValues) { int[,][] processedValues = new int[33, 14][]; for (int i = 0; i < 32; i++) { int ip1 = i + 1; processedValues[ip1, 7] = processedValues[ip1, 0] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; processedValues[ip1, 8] = SwapArrayViewingSide(processedValues[ip1, 1] = MultiplyArraysWithVal(pEvalPositionValues[0, 0], pEvalPositionValues[1, 0], pEvalPositionValues[2, 0], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 9] = SwapArrayViewingSide(processedValues[ip1, 2] = MultiplyArraysWithVal(pEvalPositionValues[0, 1], pEvalPositionValues[1, 1], pEvalPositionValues[2, 1], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 10] = SwapArrayViewingSide(processedValues[ip1, 3] = MultiplyArraysWithVal(pEvalPositionValues[0, 2], pEvalPositionValues[1, 2], pEvalPositionValues[2, 2], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 11] = SwapArrayViewingSide(processedValues[ip1, 4] = MultiplyArraysWithVal(pEvalPositionValues[0, 3], pEvalPositionValues[1, 3], pEvalPositionValues[2, 3], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 12] = SwapArrayViewingSide(processedValues[ip1, 5] = MultiplyArraysWithVal(pEvalPositionValues[0, 4], pEvalPositionValues[1, 4], pEvalPositionValues[2, 4], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 13] = SwapArrayViewingSide(processedValues[ip1, 6] = MultiplyArraysWithVal(pEvalPositionValues[0, 5], pEvalPositionValues[1, 5], pEvalPositionValues[2, 5], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); } return processedValues; } private double[,][] GetInterpolatedProcessedValues(double[,][] pEvalPositionValues) { double[,][] processedValues = new double[33, 14][]; for (int i = 0; i < 32; i++) { int ip1 = i + 1; processedValues[ip1, 7] = processedValues[ip1, 0] = new double[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; processedValues[ip1, 8] = SwapArrayViewingSide(processedValues[ip1, 1] = MultiplyArraysWithVal(pEvalPositionValues[0, 0], pEvalPositionValues[1, 0], pEvalPositionValues[2, 0], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 9] = SwapArrayViewingSide(processedValues[ip1, 2] = MultiplyArraysWithVal(pEvalPositionValues[0, 1], pEvalPositionValues[1, 1], pEvalPositionValues[2, 1], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 10] = SwapArrayViewingSide(processedValues[ip1, 3] = MultiplyArraysWithVal(pEvalPositionValues[0, 2], pEvalPositionValues[1, 2], pEvalPositionValues[2, 2], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 11] = SwapArrayViewingSide(processedValues[ip1, 4] = MultiplyArraysWithVal(pEvalPositionValues[0, 3], pEvalPositionValues[1, 3], pEvalPositionValues[2, 3], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 12] = SwapArrayViewingSide(processedValues[ip1, 5] = MultiplyArraysWithVal(pEvalPositionValues[0, 4], pEvalPositionValues[1, 4], pEvalPositionValues[2, 4], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 13] = SwapArrayViewingSide(processedValues[ip1, 6] = MultiplyArraysWithVal(pEvalPositionValues[0, 5], pEvalPositionValues[1, 5], pEvalPositionValues[2, 5], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); } return processedValues; } private double[] MultiplyArraysWithVal(double[] pArr1, double[] pArr2, double[] pArr3, double pVal1, double pVal2, double pVal3) { int tL = pArr1.Length; double[] rArr = new double[tL]; for (int i = 0; i < tL; i++) { rArr[i] = pArr1[i] * pVal1 + pArr2[i] * pVal2 + pArr3[i] * pVal3; } return rArr; } private int[] MultiplyArraysWithVal(int[] pArr1, int[] pArr2, int[] pArr3, double pVal1, double pVal2, double pVal3) { int tL = pArr1.Length; int[] rArr = new int[tL]; for (int i = 0; i < tL; i++) { rArr[i] = (int)(pArr1[i] * pVal1 + pArr2[i] * pVal2 + pArr3[i] * pVal3); } return rArr; } private int[] SwapArrayViewingSideAndNegate(int[] pArr) { return new int[64] { -pArr[56], -pArr[57], -pArr[58], -pArr[59], -pArr[60], -pArr[61], -pArr[62], -pArr[63], -pArr[48], -pArr[49], -pArr[50], -pArr[51], -pArr[52], -pArr[53], -pArr[54], -pArr[55], -pArr[40], -pArr[41], -pArr[42], -pArr[43], -pArr[44], -pArr[45], -pArr[46], -pArr[47], -pArr[32], -pArr[33], -pArr[34], -pArr[35], -pArr[36], -pArr[37], -pArr[38], -pArr[39], -pArr[24], -pArr[25], -pArr[26], -pArr[27], -pArr[28], -pArr[29], -pArr[30], -pArr[31], -pArr[16], -pArr[17], -pArr[18], -pArr[19], -pArr[20], -pArr[21], -pArr[22], -pArr[23], -pArr[8], -pArr[9], -pArr[10], -pArr[11], -pArr[12], -pArr[13], -pArr[14], -pArr[15], -pArr[0], -pArr[1], -pArr[2], -pArr[3], -pArr[4], -pArr[5], -pArr[6], -pArr[7] }; } private int[] SwapArrayViewingSide(int[] pArr) { return new int[64] { pArr[56], pArr[57], pArr[58], pArr[59], pArr[60], pArr[61], pArr[62], pArr[63], pArr[48], pArr[49], pArr[50], pArr[51], pArr[52], pArr[53], pArr[54], pArr[55], pArr[40], pArr[41], pArr[42], pArr[43], pArr[44], pArr[45], pArr[46], pArr[47], pArr[32], pArr[33], pArr[34], pArr[35], pArr[36], pArr[37], pArr[38], pArr[39], pArr[24], pArr[25], pArr[26], pArr[27], pArr[28], pArr[29], pArr[30], pArr[31], pArr[16], pArr[17], pArr[18], pArr[19], pArr[20], pArr[21], pArr[22], pArr[23], pArr[8], pArr[9], pArr[10], pArr[11], pArr[12], pArr[13], pArr[14], pArr[15], pArr[0], pArr[1], pArr[2], pArr[3], pArr[4], pArr[5], pArr[6], pArr[7] }; } private double[] SwapArrayViewingSide(double[] pArr) { return new double[64] { pArr[56], pArr[57], pArr[58], pArr[59], pArr[60], pArr[61], pArr[62], pArr[63], pArr[48], pArr[49], pArr[50], pArr[51], pArr[52], pArr[53], pArr[54], pArr[55], pArr[40], pArr[41], pArr[42], pArr[43], pArr[44], pArr[45], pArr[46], pArr[47], pArr[32], pArr[33], pArr[34], pArr[35], pArr[36], pArr[37], pArr[38], pArr[39], pArr[24], pArr[25], pArr[26], pArr[27], pArr[28], pArr[29], pArr[30], pArr[31], pArr[16], pArr[17], pArr[18], pArr[19], pArr[20], pArr[21], pArr[22], pArr[23], pArr[8], pArr[9], pArr[10], pArr[11], pArr[12], pArr[13], pArr[14], pArr[15], pArr[0], pArr[1], pArr[2], pArr[3], pArr[4], pArr[5], pArr[6], pArr[7] }; } private int[,][] texelTuningRuntimeVals = new int[33, 14][]; private int[,][] texelTuningVals = new int[3, 6][]; private int[,] texelTuningAdjustIterations = new int[6, 64]; private int[][] texelTuningRuntimePositionalValsV2EG = new int[14][]; private int[][] texelTuningRuntimePositionalValsV2LG = new int[14][]; private int[] texelPieceEvaluationsV2EG = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[] texelPieceEvaluationsV2LG = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[] texelKingSafetyR1EvaluationsEG = new int[9]; private int[] texelKingSafetyR2EvaluationsEG = new int[17]; private int[] texelKingSafetyR1EvaluationsLG = new int[9]; private int[] texelKingSafetyR2EvaluationsLG = new int[17]; private int[] texelKingSafetySREvaluationsPT1EG = new int[12]; private int[] texelKingSafetySREvaluationsPT2EG = new int[12]; private int[] texelKingSafetySREvaluationsPT3EG = new int[12]; private int[] texelKingSafetySREvaluationsPT4EG = new int[12]; private int[] texelKingSafetySREvaluationsPT5EG = new int[12]; private int[] texelKingSafetySREvaluationsPT6EG = new int[12]; private int[] texelKingSafetySREvaluationsPT1LG = new int[12]; private int[] texelKingSafetySREvaluationsPT2LG = new int[12]; private int[] texelKingSafetySREvaluationsPT3LG = new int[12]; private int[] texelKingSafetySREvaluationsPT4LG = new int[12]; private int[] texelKingSafetySREvaluationsPT5LG = new int[12]; private int[] texelKingSafetySREvaluationsPT6LG = new int[12]; private int[,] texelMobilityStraightEG = new int[14, 15], texelMobilityStraightLG = new int[14, 15]; private int[,] texelMobilityDiagonalEG = new int[14, 14], texelMobilityDiagonalLG = new int[14, 14]; private int[] texelPieceEvaluations = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[] blackSidedSquares = new int[64] { 56, 57, 58, 59, 60, 61, 62, 63, 48, 49, 50, 51, 52, 53, 54, 55, 40, 41, 42, 43, 44, 45, 46, 47, 32, 33, 34, 35, 36, 37, 38, 39, 24, 25, 26, 27, 28, 29, 30, 31, 16, 17, 18, 19, 20, 21, 22, 23, 08, 09, 10, 11, 12, 13, 14, 15, 00, 01, 02, 03, 04, 05, 06, 07 }; private int[,] T_Pawns = new int[3, 64] { { 0, 0, 0, 0, 0, 0, 0, 0, 98, 134, 61, 95, 68, 126, 34, -11, -6, 7, 26, 31, 65, 56, 25, -20, -14, 13, 6, 21, 23, 12, 17, -23, -27, -2, -5, 12, 17, 6, 10, -25, -26, -4, -4, -10, 3, 3, 33, -12, -35, -1, -20, -23, -15, 24, 38, -22, 0, 0, 0, 0, 0, 0, 0, 0, } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { 0, 0, 0, 0, 0, 0, 0, 0, 178, 173, 158, 134, 147, 132, 165, 187, 94, 100, 85, 67, 56, 53, 82, 84, 32, 24, 13, 5, -2, 4, 17, 17, 13, 9, -3, -7, -7, -8, 3, -1, 4, 7, -6, 1, 0, -5, -1, -8, 13, 8, 8, 10, 13, 0, 2, -7, 0, 0, 0, 0, 0, 0, 0, 0, } }; private int[,] T_Knights = new int[3, 64] { { -167, -89, -34, -49, 61, -97, -15, -107, -73, -41, 72, 36, 23, 62, 7, -17, -47, 60, 37, 65, 84, 129, 73, 44, -9, 17, 19, 53, 37, 69, 18, 22, -13, 4, 16, 13, 28, 19, 21, -8, -23, -9, 12, 10, 19, 17, 25, -16, -29, -53, -12, -3, -1, 18, -14, -19, -105, -21, -58, -33, -17, -28, -19, -23 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -58, -38, -13, -28, -31, -27, -63, -99, -25, -8, -25, -2, -9, -25, -24, -52, -24, -20, 10, 9, -1, -9, -19, -41, -17, 3, 22, 22, 22, 11, 8, -18, -18, -6, 16, 25, 16, 17, 4, -18, -23, -3, -1, 15, 10, -3, -20, -22, -42, -20, -10, -5, -2, -20, -23, -44, -29, -51, -23, -15, -22, -18, -50, -64 } }; private int[,] T_Bishops = new int[3, 64] { { -29, 4, -82, -37, -25, -42, 7, -8, -26, 16, -18, -13, 30, 59, 18, -47, -16, 37, 43, 40, 35, 50, 37, -2, -4, 5, 19, 50, 37, 37, 7, -2, -6, 13, 13, 26, 34, 12, 10, 4, 0, 15, 15, 15, 14, 27, 18, 10, 4, 15, 16, 0, 7, 21, 33, 1, -33, -3, -14, -21, -13, -12, -39, -21 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -14, -21, -11, -8, -7, -9, -17, -24, -8, -4, 7, -12, -3, -13, -4, -14, 2, -8, 0, -1, -2, 6, 0, 4, -3, 9, 12, 9, 14, 10, 3, 2, -6, 3, 13, 19, 7, 10, -3, -9, -12, -3, 8, 10, 13, 3, -7, -15, -14, -18, -7, -1, 4, -9, -15, -27, -23, -9, -23, -5, -9, -16, -5, -17 } }; private int[,] T_Rooks = new int[3, 64] { { 32, 42, 32, 51, 63, 9, 31, 43, 27, 32, 58, 62, 80, 67, 26, 44, -5, 19, 26, 36, 17, 45, 61, 16, -24, -11, 7, 26, 24, 35, -8, -20, -36, -26, -12, -1, 9, -7, 6, -23, -45, -25, -16, -17, 3, 0, -5, -33, -44, -16, -20, -9, -1, 11, -6, -71, -19, -13, 1, 17, 16, 7, -37, -26 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { 13, 10, 18, 15, 12, 12, 8, 5, 11, 13, 13, 11, -3, 3, 8, 3, 7, 7, 7, 5, 4, -3, -5, -3, 4, 3, 13, 1, 2, 1, -1, 2, 3, 5, 8, 4, -5, -6, -8, -11, -4, 0, -5, -1, -7, -12, -8, -16, -6, -6, 0, 2, -9, -9, -11, -3, -9, 2, 3, -1, -5, -13, 4, -20 } }; private int[,] T_Queens = new int[3, 64] { { -28, 0, 29, 12, 59, 44, 43, 45, -24, -39, -5, 1, -16, 57, 28, 54, -13, -17, 7, 8, 29, 56, 47, 57, -27, -27, -16, -16, -1, 17, -2, 1, -9, -26, -9, -10, -2, -4, 3, -3, -14, 2, -11, -2, -5, 2, 14, 5, -35, -8, 11, 2, 8, 15, -3, 1, -1, -18, -9, 10, -15, -25, -31, -50 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -9, 22, 22, 27, 27, 19, 10, 20, -17, 20, 32, 41, 58, 25, 30, 0, -20, 6, 9, 49, 47, 35, 19, 9, 3, 22, 24, 45, 57, 40, 57, 36, -18, 28, 19, 47, 31, 34, 39, 23, -16, -27, 15, 6, 9, 17, 10, 5, -22, -23, -30, -16, -16, -23, -36, -32, -33, -28, -22, -43, -5, -32, -20, -41 } }; private int[,] T_Kings = new int[3, 64] { { -65, 23, 16, -15, -56, -34, 2, 13, 29, -1, -20, -7, -8, -4, -38, -29, -9, 24, 2, -16, -20, 6, 22, -22, -17, -20, -12, -27, -30, -25, -14, -36, -49, -1, -27, -39, -46, -44, -33, -51, -14, -14, -22, -46, -44, -30, -15, -27, 1, 7, -8, -64, -43, -16, 9, 8, -15, 36, 12, -54, 8, -28, 24, 14 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -74, -35, -18, -18, -11, 15, 4, -17, -12, 17, 14, 17, 17, 38, 23, 11, 10, 17, 23, 15, 20, 45, 44, 13, -8, 22, 24, 27, 26, 33, 26, 3, -18, -4, 21, 24, 27, 23, 9, -11, -19, -3, 11, 21, 23, 16, 7, -9, -27, -11, 4, 13, 14, 4, -5, -17, -53, -34, -21, -11, -28, -14, -24, -43 } }; private int[] paramsLowerLimits = new int[5] { -10000, -10000, -10000, -10000, -10000 }; private int[] paramsUpperLimits = new int[5] { 10000, 10000, 10000, 10000, 10000 }; private List<TLM_ChessGame> threadDataset; private int threadFrom, threadTo; private int[] threadParams; private int customThreadID = 0; private ulong ulAllThreadIDsUnfinished = 0; private double lastCostVal = 0d; private double sumCostVals = 0d; private int costCalculations = 0; private readonly string[] TEXELPRINT_GAMEPARTS = new string[3] { "Early Game: ", "Mid Game: ", "Late Game: "}; private readonly string[] TEXELPRINT_PIECES = new string[6] { "Bauer: ", "Springer: ", "Lufer: ", "Turm: ", "Dame: ", "Knig: "}; private double[] earlyGameMultipliers = new double[33]; private double[] middleGameMultipliers = new double[33]; private double[] lateGameMultipliers = new double[33]; private int[] pieceTypeGameProgressImpact = new int[14] { 0, 0, 1, 1, 2, 4, 0, 0, 0, 1, 1, 2, 4, 0 }; private void PrecalculateMultipliers() { if (BOARD_MANAGER_ID == ENGINE_VALS.PARALLEL_BOARDS - 1) SNAPSHOT_WRITLINE_REPLACEMENT(); for (int i = 0; i < 25; i++) { earlyGameMultipliers[i] = EGMultiplierFunction(i); lateGameMultipliers[i] = LGMultiplierFunction(i); if (BOARD_MANAGER_ID == ENGINE_VALS.PARALLEL_BOARDS - 1) SNAPSHOT_WRITLINE_REPLACEMENT("[" + i + "] "+ earlyGameMultipliers[i] + " | "+ middleGameMultipliers[i] + " | "+ lateGameMultipliers[i]); } } private double MultiplierFunction(double pVal, double pXShift) { double d = Math.Exp(1d /6d * (pVal - pXShift)); return 5 * (d /Math.Pow(d + 1, 2d)); } private double EGMultiplierFunction(double pVal) { return Math.Clamp(1 /16d * (pVal - 4d), 0d, 1d); } private double LGMultiplierFunction(double pVal) { return Math.Clamp(1 /-16d * (pVal - 4d) + 1d, 0d, 1d); } private double EGMultiplierFunction2(double pVal) { return Math.Clamp(1 /32d * pVal, 0d, 1d); } private double LGMultiplierFunction2(double pVal) { return Math.Clamp(1 /-32d * pVal + 1d, 0d, 1d); } private void TuneWithTxtFile(string pTXTName) { List<TLM_ChessGame> gameDataset = new List<TLM_ChessGame>(); string tPath = PathManager.GetTXTPath(pTXTName); string[] tStrs = File.ReadAllLines(tPath); List<string> tGames = new List<string>(); foreach (string s in tStrs) if (s.Contains(';') && s.Replace(" ", "") != "") tGames.Add(s); foreach (string s in tGames) { TLM_ChessGame tGame = CGFF.GetGame(s); LoadFenString(tGame.startFen); foreach (int hMove in tGame.hashedMoves) { List<Move> moveOptionList = new List<Move>(); GetLegalMoves(ref moveOptionList); int tL = moveOptionList.Count; for (int j = 0; j < tL; j++) { Move tMove = moveOptionList[j]; if (tMove.moveHash == hMove) { tGame.actualMoves.Add(tMove); PlainMakeMove(tMove); tL = -1; break; } } if (tL != -1) break; } gameDataset.Add(tGame); } SNAPSHOT_WRITLINE_REPLACEMENT("[TLM TEXEL TUNER] " + tGames.Count + " Games Loaded In!"); BOT_MAIN.curTEXELPARAMS = new int[TEXEL_PARAMS]; BOT_MAIN.ParallelTexelTuning(gameDataset); } private void LoadBestTexelParamsIn() { int[] ttt = new int[778] { 82, 341, 416, 470, 1106, 102, 302, 304, 518, 960, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, -46, 0, -20, 0, 64, -21, -71, 37, 29, 6, 98, 13, 44, 0, -26, -14, -36, -20, 94, 16, 60, 10, -62, -19, -38, -8, -28, 14, -26, -4, -32, -28, -52, 30, 56, -40, -72, -22, 100, 4, -98, -34, 6, -49, 32, -10, 72, 20, 84, -56, -60, -112, 128, -28, 152, 34, 26, -52, 200, -56, 76, 44, -56, -113, -156, 188, -39, 28, 200, -90, -60, -86, 100, -178, -119, -200, 200, 200, -20, -22, -78, -158, -200, 196, 200, -200, -200, -200, 104, 200, 138, -122, 200, 200, 124, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 200, 156, -37, -68, -148, -200, 200, -70, 72, 76, -31, -200, -21, 178, -200, 200, 200, -200, 123, -188, -6, 164, -74, 24, -28, -8, 71, -50, -112, -200, -8, -44, 27, -23, -50, 19, 19, 41, 150, 152, 4, -98, -36, -34, 174, -106, -16, 17, 141, -48, -108, 162, 6, -112, -52, 76, 68, 8, -86, 68, -176, 189, 81, 162, -200, 152, -41, 128, 172, -173, -144, 56, 22, 94, -28, 32, 16, -63, 36, -200, -200, -200, -22, 56, -116, 76, -36, -30, 100, 52, -166, -114, 142, -52, -44, -200, -18, -72, 60, 200, -160, 96, 46, -200, -28, -32, -44, 132, 60, -200, -137, -200, -176, 200, -200, -200, 4, 200, -200, 72, 200, -78, 200, 160, -105, 200, 96, -114, 200, 200, -88, -24, 11, -34, 184, 26, 83, -140, 10, -16, -72, -200, 12, -200, 46, -200, 11, 82, 66, -102, 22, -184, 32, 114, 140, -26, -18, -36, 66, 100, 25, -24, 133, -96, 50, 2, 80, 184, 43, -136, 44, 124, -148, 180, 69, -126, -200, 6, 78, -96, 89, -68, 200, -116, 114, 158, 5, -154, 115, 200, -152, -171, 41, -80, -23, 137, 98, -80, 40, -42, 200, 52, 146, 200, 6, -112, 32, 200, 132, 4, 90, -200, -200, 104, 67, -56, 186, 124, 140, 97, -144, 200, -4, -160, -117, -200, 24, -80, 200, 28, -46, -24, -52, -200, -200, 72, 20, 34, 200, -16, 88, 56, 200, -146, 120, 174, 200, -200, -86, 125, 172, -70, 4, 124, -72, 0, -2, 70, -14, 48, -32, 200, 80, 24, -132, 74, -44, 184, -4, -136, 0, -16, 20, -18, -32, 96, 92, 56, 2, 174, 196, -200, -56, -116, 88, 200, -8, 168, -13, 74, -106, 200, -182, 80, 82, -128, -16, 90, -200, 66, -88, 58, -16, 80, -34, 96, -95, -96, -200, 76, 26, -72, 32, -27, -108, 164, 200, -36, -93, -10, -56, 22, 36, 74, -200, -96, 200, 88, -88, 156, -92, 96, -200, 200, 191, -8, 62, -8, -100, 136, -72, -36, 200, -64, -114, 153, -110, 174, 46, 108, 142, 121, -200, 108, -200, 74, -4, 104, -200, 116, 82, 200, -76, 176, -200, 76, -8, 200, 46, 29, -86, 12, -24, -80, -12, 200, 124, -16, 54, 104, 200, -94, 140, 36, 32, -64, 24, -178, 15, -200, 0, -200, 4, -32, -124, 148, 176, 192, 90, 164, -91, 200, 172, -200, 64, 34, 40, -200, 0, -200, 12, -124, 48, -200, -56, 184, -8, -184, 0, 200, -16, 200, -8, 180, -18, -20, 24, -200, -58, 174, -200, 40, -4, -200, -24, 200, 54, 200, -24, -32, 37, 192, 48, 44, 26, 200, -22, 200, -145, -200, 30, 86, 54, 200, -102, -34, 94, -98, 92, -200, -76, 196, -18, -200, -180, 16, 186, -92, -200, -200, 164, -200, 62, 192, 159, -112, -12, -70, 184, 104, 200, -200, -148, -4, 86, -144, 200, -100, 200, 200, -104, 114, 132, -168, 12, 56, -10, 82, 200, -200, -200, -196, -6, 52, -200, 84, 200, -192, 128, 200, -200, -200, 200, 88, 168, -32, -84, 172, 52, -172, 0, -40, 68, -186, 42, 96, -200, -198, 200, -56, -176, 88, 0, 86, 16, -124, -46, 40, -16, -4, 54, -184, 200, 58, -200, 77, -200, -44, 102, 0, -50, -10, -92, 100, -86, 8, 20, -20, -200, 38, -200, -49, -4, 2, -200, 78, 0, -40, -92, 32, 0, -164, -88, -38, -138, -118, 29, -34, -200, -200, -200, -71, -200, 200, -200, -108, -200, 0, 192, -24, 104, -200, 200, 190, -28, -200, -200, -200, 128, -96, 200, 200, 200, 200, -200, -200, 177, -24, 200, 132, 200, -190, 200, -130, 200, 148, 200, 200, -200, -100, 200, -196, -200, 90, 200, -200, 200, 200, -200, -200, -200, -200, -200, 118, -200, 85, -200, 166, 199, -200 }; SetupTexelEvaluationParams(ttt); } private void SetupTexelEvaluationParams(int[] pParams) { texelPieceEvaluationsV2EG[8] = -(texelPieceEvaluationsV2EG[1] = pParams[0]); texelPieceEvaluationsV2EG[9] = -(texelPieceEvaluationsV2EG[2] = pParams[1]); texelPieceEvaluationsV2EG[10] = -(texelPieceEvaluationsV2EG[3] = pParams[2]); texelPieceEvaluationsV2EG[11] = -(texelPieceEvaluationsV2EG[4] = pParams[3]); texelPieceEvaluationsV2EG[12] = -(texelPieceEvaluationsV2EG[5] = pParams[4]); texelPieceEvaluationsV2LG[8] = -(texelPieceEvaluationsV2LG[1] = pParams[5]); texelPieceEvaluationsV2LG[9] = -(texelPieceEvaluationsV2LG[2] = pParams[6]); texelPieceEvaluationsV2LG[10] = -(texelPieceEvaluationsV2LG[3] = pParams[7]); texelPieceEvaluationsV2LG[11] = -(texelPieceEvaluationsV2LG[4] = pParams[8]); texelPieceEvaluationsV2LG[12] = -(texelPieceEvaluationsV2LG[5] = pParams[9]); int c = 10; for (int p = 1; p < 7; p++) { for (int s = 0; s < 64; s++) { texelTuningRuntimePositionalValsV2EG[p + 7][blackSidedSquares[s]] = -(texelTuningRuntimePositionalValsV2EG[p][s] = pParams[c++]); texelTuningRuntimePositionalValsV2LG[p + 7][blackSidedSquares[s]] = -(texelTuningRuntimePositionalValsV2LG[p][s] = pParams[c++]); } } return; for (int p = 2; p < 7; p++) { for (int a = 0; a < 15; a++) { if (a != 14) { texelMobilityDiagonalEG[p + 7, a] = -(texelMobilityDiagonalEG[p, a] = pParams[c++]); texelMobilityDiagonalLG[p + 7, a] = -(texelMobilityDiagonalLG[p, a] = pParams[c++]); } texelMobilityStraightEG[p + 7, a] = -(texelMobilityStraightEG[p, a] = pParams[c++]); texelMobilityStraightLG[p + 7, a] = -(texelMobilityStraightLG[p, a] = pParams[c++]); } } for (int i = 0; i < 12; i++) { texelKingSafetySREvaluationsPT1EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT2EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT3EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT4EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT5EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT6EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT1LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT2LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT3LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT4LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT5LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT6LG[i] = pParams[c++]; } } private void PrintDefinedTexelParams(int[] pParams) { int c = 0; for (int t = 0; t < 3; t++) { SNAPSHOT_WRITLINE_REPLACEMENT(TEXELPRINT_GAMEPARTS[t]); for (int p = 0; p < 6; p++) { SNAPSHOT_WRITLINE_REPLACEMENT(TEXELPRINT_PIECES[p]); texelTuningVals[t, p] = new int[64]; for (int s = 0; s < 64; s++) { if (s % 8 == 0 && s != 0) SNAPSHOT_WRITLINE_REPLACEMENT(); SNAPSHOT_WRITLINE_REPLACEMENT((texelTuningVals[t, p][s] = pParams[c++]) + ", "); } SNAPSHOT_WRITLINE_REPLACEMENT(); } } piecePositionEvals = GetInterpolatedProcessedValues(texelTuningVals); } public void TLMTuning(List<TLM_ChessGame> pDataset) { int tGameDataSetLen = pDataset.Count; int[,][] tRatio = new int[33, 6][]; int[,][] tTotalMoves = new int[33, 6][]; double[,][] tSummedRatios = new double[33, 6][]; double[,][] tSummedDataAmount = new double[33, 6][]; double[,][] tTuningResults = new double[33, 6][]; for (int t = 1; t < 33; t++) { for (int p = 0; p < 6; p++) { tRatio[t, p] = new int[64]; tTotalMoves[t, p] = new int[64]; tSummedRatios[t, p] = new double[64]; tSummedDataAmount[t, p] = new double[64]; tTuningResults[t, p] = new double[64]; } } for (int j = 0; j < tGameDataSetLen; j++) { TLM_ChessGame tGame = pDataset[j]; int tGR = tGame.gameResult - 1; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count - 5; for (int i = 0; i < tL; i++) { if (tGame.isMoveNonTactical[i]) { int tPieceAmount = ULONG_OPERATIONS.CountBits(allPieceBitboard); for (int s = 0; s < 64; s++) { int tPT = pieceTypeArray[s] - 1; if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, s)) { tTotalMoves[tPieceAmount, tPT][s]++; tRatio[tPieceAmount, tPT][s] += tGR; } else if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, s)) { int b = blackSidedSquares[s]; tTotalMoves[tPieceAmount, tPT][b]++; tRatio[tPieceAmount, tPT][b] += tGR; } } } PlainMakeMove(tGame.actualMoves[i]); } } double[,] allMultipliers = new double[33, 33]; for (int sh = 0; sh < 33; sh++) { for (int i = 0; i < 33; i++) { allMultipliers[sh, i] = MultiplierFunction(i, sh); } } for (int t = 1; t < 33; t++) { for (int p = 0; p < 6; p++) { for (int s = 0; s < 64; s++) { for (int t2 = 1; t2 < 33; t2++) { double cmult = allMultipliers[t, t2]; tSummedRatios[t, p][s] += tRatio[t2, p][s] * cmult; tSummedDataAmount[t, p][s] += tTotalMoves[t2, p][s] * cmult; } tTuningResults[t, p][s] = TTT(tSummedRatios[t, p][s], tSummedDataAmount[t, p][s]); } } } int c = 0; int[] tparams = new int[1152]; for (int t = 1; t < 33; t += 15) { if (t == 31) t = 32; SNAPSHOT_WRITLINE_REPLACEMENT("PieceCount = " + t + ": "); for (int p = 0; p < 6; p++) { SNAPSHOT_WRITLINE_REPLACEMENT(TEXELPRINT_PIECES[p]); for (int s = 0; s < 64; s++) { if (s % 8 == 0 && s != 0) SNAPSHOT_WRITLINE_REPLACEMENT(); SNAPSHOT_WRITLINE_REPLACEMENT((tparams[c++] = (int)(tTuningResults[t, p][s] * 100)).ToString().Replace(",", ".") + "("+ (int)tSummedDataAmount[t, p][s] + ")"+ ", "); } SNAPSHOT_WRITLINE_REPLACEMENT(); } } string tS = "PARAMS: {"; for (int i = 0; i < tparams.Length; i++) tS += tparams[i] + ","; tS = tS.Substring(0, tS.Length - 1) + "}\n"; SNAPSHOT_WRITLINE_REPLACEMENT(tS); TexelTuning(pDataset, tparams); } private double TTT(double d1, double d2) { if (d2 == 0) return 0; return d1 /d2; } public void TexelTuning(List<TLM_ChessGame> pDataset, int[] pCurBestParams) { Stopwatch sw = Stopwatch.StartNew(); string tPath = PathManager.GetTXTPath("OTHER/TEXEL_TUNING"); int paramCount = pCurBestParams.Length; double bestAvrgCost = CalculateAverageTexelCost(pDataset, pCurBestParams); SNAPSHOT_WRITLINE_REPLACEMENT("CUR PARAMS COST: " + bestAvrgCost); int packetSize = Math.Clamp(paramCount /ENGINE_VALS.CPU_CORES, 1, 100000); paramsLowerLimits = new int[paramCount]; paramsUpperLimits = new int[paramCount]; for (int i = 0; i < paramCount; i++) { int lim = i < 10 ? 100000 : 200; paramsLowerLimits[i] = -lim; paramsUpperLimits[i] = lim; } SNAPSHOT_WRITLINE_REPLACEMENT("PARAM-COUNT: " + paramCount); SNAPSHOT_WRITLINE_REPLACEMENT("PACKET-SIZE: " + packetSize); while (packetSize <= paramCount) { BOT_MAIN.TEXELfinished = 0; int lM = 0, tC = 0; ulong tUL = 0ul; for (int m = packetSize; lM < paramCount; m += packetSize) { if (m > paramCount) m = paramCount; tUL = ULONG_OPERATIONS.SetBitToOne(tUL, ++tC); lM = m; } tC = lM = 0; for (int m = packetSize; lM < paramCount; m += packetSize) { if (m > paramCount) m = paramCount; tC++; BOT_MAIN.boardManagers[tC].SetPlayTexelVals(pDataset, lM, m, pCurBestParams, paramsLowerLimits, paramsUpperLimits, tC, tUL); ThreadPool.QueueUserWorkItem(new WaitCallback(BOT_MAIN.boardManagers[tC].TexelTuningThreadedPackage)); lM = m; } packetSize = paramCount + 1; int tmod = 0; while (tC != BOT_MAIN.TEXELfinished) { if (++tmod % 20 == 0) { WriteTexelParamsToTXT(tPath, BOT_MAIN.curTEXELPARAMS); SNAPSHOT_WRITLINE_REPLACEMENT(CalculateAverageTexelCost(pDataset, BOT_MAIN.curTEXELPARAMS) + " | "+ BOT_MAIN.TEXELadjustmentsmade); SNAPSHOT_WRITLINE_REPLACEMENT(ULONG_OPERATIONS.GetBitVisualization(BOT_MAIN.TEXELfinishedwithoutimpovement)); } Thread.Sleep(100); } SNAPSHOT_WRITLINE_REPLACEMENT("One Thread Generation FINISHED! :) :) :)"); pCurBestParams = BOT_MAIN.curTEXELPARAMS; } sw.Stop(); WriteTexelParamsToTXT(tPath, BOT_MAIN.curTEXELPARAMS); SNAPSHOT_WRITLINE_REPLACEMENT("END COST: " + CalculateAverageTexelCost(pDataset, BOT_MAIN.curTEXELPARAMS)); SNAPSHOT_WRITLINE_REPLACEMENT(BOT_MAIN.TEXELadjustmentsmade); SNAPSHOT_WRITLINE_REPLACEMENT(sw.ElapsedMilliseconds); } public void TexelTuningThreadedPackage(object obj) { SNAPSHOT_WRITLINE_REPLACEMENT("Started CThreadID [" + customThreadID + "] which is handling Params ["+ threadFrom + "] - ["+ threadTo + "]"); bool firstIter = true; do { double bestAvrgCost = CalculateAverageTexelCost(threadDataset, threadParams); int adjust_val = firstIter ? 512 : 8; do { adjust_val /= 2; bool improvedAvrgCost = true; while (improvedAvrgCost) { improvedAvrgCost = false; for (int i = threadFrom; i < threadTo; i++) { bool improvedWithThisParam = true; int tadjustval = adjust_val; bool lastTimeMaximized = false, lastTimeMinimized = false; while (improvedWithThisParam) { improvedWithThisParam = false; int[] curParams = (int[])threadParams.Clone(); int paramBefore = curParams[i]; curParams[i] = Math.Clamp(paramBefore + adjust_val, paramsLowerLimits[i], paramsUpperLimits[i]); double curAvrgCost = CalculateAverageTexelCost(threadDataset, curParams); if (curAvrgCost < bestAvrgCost) { improvedAvrgCost = true; improvedWithThisParam = true; SNAPSHOT_WRITLINE_REPLACEMENT("Improved Param [" + i + "] at CThreadID ["+ customThreadID + "]: +"+ adjust_val + " ("+ GetDoublePrecentageString(bestAvrgCost - curAvrgCost) + ")"); bestAvrgCost = curAvrgCost; threadParams = curParams; BOT_MAIN.TEXELadjustmentsmade++; BOT_MAIN.TEXELfinishedwithoutimpovement = ulAllThreadIDsUnfinished; if (lastTimeMaximized) { adjust_val *= 4; lastTimeMaximized = false; } else lastTimeMaximized = true; lastTimeMinimized = false; } else { curParams[i] = Math.Clamp(paramBefore - adjust_val, paramsLowerLimits[i], paramsUpperLimits[i]); curAvrgCost = CalculateAverageTexelCost(threadDataset, curParams); if (curAvrgCost < bestAvrgCost) { improvedAvrgCost = true; improvedWithThisParam = true; SNAPSHOT_WRITLINE_REPLACEMENT("Improved Param [" + i + "] at CThreadID ["+ customThreadID + "]: -"+ adjust_val + " ("+ GetDoublePrecentageString(bestAvrgCost - curAvrgCost) + ")"); bestAvrgCost = curAvrgCost; threadParams = curParams; BOT_MAIN.TEXELadjustmentsmade++; BOT_MAIN.TEXELfinishedwithoutimpovement = ulAllThreadIDsUnfinished; if (lastTimeMinimized) { adjust_val *= 4; lastTimeMinimized = false; } else lastTimeMinimized = true; lastTimeMaximized = false; } } if (adjust_val != 1) adjust_val /= 2; for (int j = threadFrom; j < threadTo; j++) { BOT_MAIN.curTEXELPARAMS[j] = threadParams[j]; } threadParams = (int[])BOT_MAIN.curTEXELPARAMS.Clone(); bestAvrgCost = CalculateAverageTexelCost(threadDataset, threadParams); } adjust_val = tadjustval; } } } while (adjust_val != 1); BOT_MAIN.TEXELfinishedwithoutimpovement = ULONG_OPERATIONS.SetBitToZero(BOT_MAIN.TEXELfinishedwithoutimpovement, customThreadID); SNAPSHOT_WRITLINE_REPLACEMENT("FULLY FINISHED " + customThreadID + ". IMPROVEMENT THREAD PACKAGE CYCLE"); firstIter = false; } while (BOT_MAIN.TEXELfinishedwithoutimpovement != 0); BOT_MAIN.TEXELfinished++; } private void WriteTexelParamsToTXT(string pPath, int[] pParams) { try { string tS = "PARAMS: {"; for (int i = 0; i < pParams.Length; i++) tS += pParams[i] + ","; tS = tS.Substring(0, tS.Length - 1) + "}\n"; File.AppendAllText(pPath, tS); } catch { SNAPSHOT_WRITLINE_REPLACEMENT("Mal wieder TXT zu lange gebraucht um zu aktualisieren."); } } private double costSum = 0d; private int texelCostMovesEvaluated = 0; private double CalculateAverageTexelCost(List<TLM_ChessGame> tDataset, int[] pParams, bool pFullCost = true) { costSum = 0d; texelCostMovesEvaluated = 0; SetupTexelEvaluationParams(pParams); int tGameDataSetLen = tDataset.Count; int start = 0, end = tGameDataSetLen; if (!pFullCost) { end = (start = globalRandom.Next(0, end - 256)) + 256; } for (int j = start; j < end; j++) { TLM_ChessGame tGame = tDataset[j]; double tGR = tGame.gameResult; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count - 5; texelCostMovesEvaluated += tL; for (int i = 0; i < tL; i++) { costSum += TexelCost(tGR - TexelTuningSigmoid(TexelEvaluate())); PlainMakeMove(tGame.actualMoves[i]); } } return costSum /texelCostMovesEvaluated; } private double CalculateAverageTexelCostThreadedVersionLEGACYDOESNTWORK(List<TLM_ChessGame> tDataset, int[] pParams) { Stopwatch sw = Stopwatch.StartNew(); BOT_MAIN.TEXELcostSum = 0d; BOT_MAIN.TEXELfinished = 0; BOT_MAIN.TEXELcostMovesEvaluated = 0; int tGameDataSetLen = tDataset.Count; int gamesPerThread = tGameDataSetLen /ENGINE_VALS.CPU_CORES; for (int i = 0; i < ENGINE_VALS.CPU_CORES - 1; i++) { } for (int i = 0; i < ENGINE_VALS.CPU_CORES - 1; i++) { } while (BOT_MAIN.TEXELfinished != ENGINE_VALS.CPU_CORES) Thread.Sleep(1); sw.Stop(); return BOT_MAIN.TEXELcostSum /BOT_MAIN.TEXELcostMovesEvaluated; } public void SetPlayThroughVals(List<TLM_ChessGame> pDataset, int pFrom, int pTo) { threadDataset = pDataset; threadFrom = pFrom; threadTo = pTo; } public void SetPlayTexelVals(List<TLM_ChessGame> pDataset, int pFrom, int pTo, int[] pTexelParams, int[] pLowerLimits, int[] pUpperLimits, int pThreadID, ulong pUL) { threadDataset = pDataset; threadFrom = pFrom; threadTo = pTo; threadParams = pTexelParams; paramsLowerLimits = pLowerLimits; paramsUpperLimits = pUpperLimits; customThreadID = pThreadID; ulAllThreadIDsUnfinished = pUL; } public void PlayThroughSetOfGames(object obj) { SNAPSHOT_WRITLINE_REPLACEMENT(threadFrom + "->"+ threadTo); int sortedOut = 0; for (int j = threadFrom; j < threadTo; j++) { TLM_ChessGame tGame = threadDataset[j]; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count; for (int i = 0; i < tL; i++) { int tQuietEval = isWhiteToMove ? QuiescenceWhite(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, 0, PreMinimaxCheckCheckWhite(), NULL_MOVE) : QuiescenceBlack(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, 0, PreMinimaxCheckCheckBlack(), NULL_MOVE); bool tB; tGame.isMoveNonTactical.Add(tB = (Evaluate() == tQuietEval && i > 4)); if (!tB) sortedOut++; PlainMakeMove(tGame.actualMoves[i]); } } BOT_MAIN.TEXELsortedout += sortedOut; BOT_MAIN.TEXELfinished++; } public void CalculateAverageTexelCostThreadFunction(object obj) { SetupTexelEvaluationParams(threadParams); double d = 0d; for (int j = threadFrom; j < threadTo; j++) { TLM_ChessGame tGame = threadDataset[j]; double tGR = tGame.gameResult; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count - 5; BOT_MAIN.TEXELcostMovesEvaluated += tL; for (int i = 0; i < tL; i++) { d += TexelCost(tGR - TexelTuningSigmoid(TexelEvaluate())); PlainMakeMove(tGame.actualMoves[i]); } } BOT_MAIN.TEXELcostSum += d; BOT_MAIN.TEXELfinished++; } private void ConsoleWriteLineTuneArray<T>(T[,][] pArr) { for (int j = 0; j < 3; j++) { SNAPSHOT_WRITLINE_REPLACEMENT("{"); for (int k = 0; k < 6; k++) { SNAPSHOT_WRITLINE_REPLACEMENT("{"); for (int s = 0; s < 64; s++) SNAPSHOT_WRITLINE_REPLACEMENT(pArr[j, k][s] + ", "); SNAPSHOT_WRITLINE_REPLACEMENT("\n}"); } SNAPSHOT_WRITLINE_REPLACEMENT("}"); } } private void Tune(string pGameCGFF, double pLearningRate) { TLM_ChessGame tGame = CGFF.GetGame(pGameCGFF); LoadFenString(tGame.startFen); double tDGameResult = tGame.gameResult; foreach (int hMove in tGame.hashedMoves) { Tune(tDGameResult, pLearningRate); List<Move> moveOptionList = new List<Move>(); GetLegalMoves(ref moveOptionList); int tL = moveOptionList.Count; for (int i = 0; i < tL; i++) { Move tMove = moveOptionList[i]; if (tMove.moveHash == hMove) { PlainMakeMove(tMove); tL = -1; break; } } if (tL != -1) break; } } private void Tune(double pGameResult, double pLearningRate) { int tPC = ULONG_OPERATIONS.CountBits(allPieceBitboard); double oneThroughPieceCount = 1d /tPC; double egMult = earlyGameMultipliers[tPC], mgMult = middleGameMultipliers[tPC], lgMult = lateGameMultipliers[tPC]; double tTexelResult = TexelEvaluateF(); double tSigmoidedTexelResult = TexelSigmoid(tTexelResult); double tDif = tSigmoidedTexelResult - pGameResult; double tM = oneThroughPieceCount * TexelCostDerivative(tDif) * TexelSigmoidDerivative(tTexelResult) * pLearningRate; sumCostVals += lastCostVal = TexelCost(tDif); costCalculations++; for (int i = 0; i < 64; i++) { if (ULONG_OPERATIONS.IsBitZero(allPieceBitboard, i)) continue; int tPT = pieceTypeArray[i] - 1, tI = i; if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, i)) tI = blackSidedSquares[i]; texelTuningAdjustIterations[tPT, tI]++; } } private double TexelEvaluateF() { texelTuningRuntimeVals = GetInterpolatedProcessedValues(texelTuningVals); return TexelEvaluate(); } private int TexelEvaluate() { int tEvalEG = 0, tEvalLG = 0, tProgress = 0; ulong[] attkULs = new ulong[14]; for (int p = 0; p < 64; p++) { if (((int)(allPieceBitboard >> p) & 1) == 0) continue; int aPT = pieceTypeArray[p], tPT = aPT + 7 * ((int)(blackPieceBitboard >> p) & 1); tEvalEG += texelTuningRuntimePositionalValsV2EG[tPT][p] + texelPieceEvaluationsV2EG[tPT]; tEvalLG += texelTuningRuntimePositionalValsV2LG[tPT][p] + texelPieceEvaluationsV2LG[tPT]; tProgress += pieceTypeGameProgressImpact[tPT]; } if (tProgress > 24) tProgress = 24; return (int)(earlyGameMultipliers[tProgress] * tEvalEG + lateGameMultipliers[tProgress] * tEvalLG); } private const double TexelK = 0.2; private double TexelTuningSigmoid(double pVal) { return 2d /(1 + Math.Pow(10, -TexelK * pVal /400)); } private double TexelSigmoid(double pVal) { return 2d /(Math.Exp(-0.04d * pVal) + 1d); } private double TexelSigmoidDerivative(double pVal) { double d = Math.Exp(-0.04d * pVal); return 2d * d /(25d * (d + 1d) * (d + 1d)); } private double TexelCost(double pVal) { return pVal * pVal; } private double TexelCostDerivative(double pVal) { return 2 * pVal; } private char[] fenPieces = new char[7] { 'z', 'p', 'n', 'b', 'r', 'q', 'k' }; private string[] squareNames = new string[64] { "a1", "b1", "c1", "d1", "e1", "f1", "g1", "h1", "a2", "b2", "c2", "d2", "e2", "f2", "g2", "h2", "a3", "b3", "c3", "d3", "e3", "f3", "g3", "h3", "a4", "b4", "c4", "d4", "e4", "f4", "g4", "h4", "a5", "b5", "c5", "d5", "e5", "f5", "g5", "h5", "a6", "b6", "c6", "d6", "e6", "f6", "g6", "h6", "a7", "b7", "c7", "d7", "e7", "f7", "g7", "h7", "a8", "b8", "c8", "d8", "e8", "f8", "g8", "h8"}; public string CreateFenString() { string rFEN = ""; for (int i = 7; i >= 0; i--) { int t = 0; for (int j = 0; j < 8; j++) { int sq = i * 8 + j; if (pieceTypeArray[sq] != 0) { if (t != 0) rFEN += t; t = 0; } if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, sq)) { switch (pieceTypeArray[sq]) { case 0: t++; SNAPSHOT_WRITLINE_REPLACEMENT("???"); break; case 1: rFEN += 'P'; break; case 2: rFEN += 'N'; break; case 3: rFEN += 'B'; break; case 4: rFEN += 'R'; break; case 5: rFEN += 'Q'; break; case 6: rFEN += 'K'; break; } } else { switch (pieceTypeArray[sq]) { case 0: t++; break; case 1: rFEN += 'p'; break; case 2: rFEN += 'n'; break; case 3: rFEN += 'b'; break; case 4: rFEN += 'r'; break; case 5: rFEN += 'q'; break; case 6: rFEN += 'k'; break; } } } if (t != 0) rFEN += t; if (i != 0) rFEN += "/"; } rFEN += (isWhiteToMove ? " w": " b"); rFEN += (whiteCastleRightKingSide ? " K": " "); rFEN += (whiteCastleRightQueenSide ? "Q": ""); rFEN += (blackCastleRightKingSide ? "k": ""); rFEN += (blackCastleRightQueenSide ? "q": ""); if (!whiteCastleRightKingSide && !whiteCastleRightQueenSide && !blackCastleRightKingSide && !blackCastleRightQueenSide) rFEN += "-"; if (enPassantSquare < 64) rFEN += " "+ squareNames[enPassantSquare] + " "; else rFEN += " - "; return rFEN + fiftyMoveRuleCounter + " "+ ((happenedHalfMoves - happenedHalfMoves % 2) /2); } public void LoadFenString(string fenStr) { debugFEN = fenStr; lastMadeMove = NULL_MOVE; zobristKey = 0ul; whitePieceBitboard = blackPieceBitboard = allPieceBitboard = 0ul; for (int i = 0; i < 64; i++) pieceTypeArray[i] = 0; string[] spaceSpl = fenStr.Split(' '); string[] rowSpl = spaceSpl[0].Split('/'); string epstr = spaceSpl[3]; if (epstr == "-") enPassantSquare = 65; else enPassantSquare = (epstr[0] - 'a') + 8 * (epstr[1] - '1'); isWhiteToMove = true; if (spaceSpl[1] == "b") isWhiteToMove = false; if (!isWhiteToMove) zobristKey ^= blackTurnHash; string crstr = spaceSpl[2]; whiteCastleRightKingSide = whiteCastleRightQueenSide = blackCastleRightKingSide = blackCastleRightQueenSide = false; int crStrL = crstr.Length; for (int i = 0; i < crStrL; i++) { switch (crstr[i]) { case 'K': whiteCastleRightKingSide = true; break; case 'Q': whiteCastleRightQueenSide = true; break; case 'k': blackCastleRightKingSide = true; break; case 'q': blackCastleRightQueenSide = true; break; } } fiftyMoveRuleCounter = Convert.ToInt32(spaceSpl[4]); happenedHalfMoves = Convert.ToInt32(spaceSpl[5]) * 2; if (!isWhiteToMove) happenedHalfMoves++; int tSq = 0; for (int i = rowSpl.Length; i-- > 0;) { string tStr = rowSpl[i]; int tStrLen = tStr.Length; for (int c = 0; c < tStrLen; c++) { char tChar = tStr[c]; if (Char.IsDigit(tChar)) tSq += tChar - '0'; else { bool tCol = Char.IsLower(tChar); if (tCol) blackPieceBitboard = ULONG_OPERATIONS.SetBitToOne(blackPieceBitboard, tSq); else whitePieceBitboard = ULONG_OPERATIONS.SetBitToOne(whitePieceBitboard, tSq); if (tChar == 'k') blackKingSquare = tSq; else if (tChar == 'K') whiteKingSquare = tSq; pieceTypeArray[tSq] = Array.IndexOf(fenPieces, Char.ToLower(tChar)); if (tCol) zobristKey ^= pieceHashesBlack[tSq, pieceTypeArray[tSq]]; else zobristKey ^= pieceHashesWhite[tSq, pieceTypeArray[tSq]]; tSq++; } } } if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; zobristKey ^= enPassantSquareHashes[enPassantSquare]; allPieceBitboard = whitePieceBitboard | blackPieceBitboard; if (zobristKey == 16260251586586513106) moveHashList.Clear(); else { moveHashList.Clear(); moveHashList.Add(1); moveHashList.Add(2); moveHashList.Add(3); } } private ulong[,] pieceHashesWhite = new ulong[64, 7], pieceHashesBlack = new ulong[64, 7]; private ulong blackTurnHash, whiteKingSideRochadeRightHash, whiteQueenSideRochadeRightHash, blackKingSideRochadeRightHash, blackQueenSideRochadeRightHash; private ulong[] enPassantSquareHashes = new ulong[66]; private Dictionary<ulong, int> singleCheckCaseBackup = new Dictionary<ulong, int>(); private void InitZobrist() { Random rng = new Random(31415926); for (int sq = 0; sq < 64; sq++) { enPassantSquareHashes[sq] = ULONG_OPERATIONS.GetRandomULONG(rng); for (int it = 1; it < 7; it++) { pieceHashesWhite[sq, it] = ULONG_OPERATIONS.GetRandomULONG(rng); pieceHashesBlack[sq, it] = ULONG_OPERATIONS.GetRandomULONG(rng); } } blackTurnHash = ULONG_OPERATIONS.GetRandomULONG(rng); whiteKingSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); whiteQueenSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); blackKingSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); blackQueenSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); } public void SetKnightMasks(ulong[] uls) { knightSquareBitboards = uls; } public void SetKingMasks(ulong[] uls) { kingSquareBitboards = uls; } private Move[,] whiteEnPassantMoves = new Move[64, 64]; private Move[,] blackEnPassantMoves = new Move[64, 64]; private bool[] epValidationArray = new bool[64] { false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true , true , true , true , true , true , true , true, true , true , true , true , true , true , true , true, true , true , true , true , true , true , true , true, true , true , true , true , true , true , true , true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false }; private ulong[] kingSafetyRing1 = new ulong[64], kingSafetyRing2 = new ulong[64]; private ulong[] kingSafetySpecialRingW = new ulong[64], kingSafetySpecialRingB = new ulong[64]; private ulong[] rowPrecalcs = new ulong[8], columnPrecalcs = new ulong[8]; const ulong columnUL = 0x101010101010101, rowUL = 0b11111111; private void PrecalculateKingSafetyBitboards() { for (int i = 0; i < 8; i++) { rowPrecalcs[i] = rowUL << (8 * i); columnPrecalcs[i] = columnUL << i; } for (int i = 0; i < 64; i++) { int tMod = i % 8; int tRow = (i - tMod) /8; ulong tULC = columnPrecalcs[tMod], tULR = rowPrecalcs[tRow]; ulong tULC2 = columnPrecalcs[tMod], tULR2 = rowPrecalcs[tRow]; if (tMod < 7) tULC |= columnPrecalcs[tMod + 1]; if (tMod > 0) tULC |= columnPrecalcs[tMod - 1]; if (tRow < 7) tULR |= rowPrecalcs[tRow + 1]; if (tRow > 0) tULR |= rowPrecalcs[tRow - 1]; if (tMod < 6) tULC2 |= columnPrecalcs[tMod + 2]; if (tMod > 1) tULC2 |= columnPrecalcs[tMod - 2]; if (tRow < 6) tULR2 |= rowPrecalcs[tRow + 2]; if (tRow > 1) tULR2 |= rowPrecalcs[tRow - 2]; tULR2 |= tULR; tULC2 |= tULC; kingSafetyRing1[i] = ULONG_OPERATIONS.SetBitToZero(tULR & tULC, i); kingSafetyRing2[i] = ULONG_OPERATIONS.SetBitsToZero(tULR2 & tULC2, i, i + 1, i - 1, i + 7, i + 8, i + 9, i - 7, i - 8, i - 9); } for (int i = 0; i < 64; i++) { if (i < 56) kingSafetySpecialRingW[i] = ULONG_OPERATIONS.SetBitToZero(kingSafetyRing1[i] | kingSafetyRing1[i + 8], i); else kingSafetySpecialRingW[i] = kingSafetyRing1[i]; if (i > 7) kingSafetySpecialRingB[i] = ULONG_OPERATIONS.SetBitToZero(kingSafetyRing1[i] | kingSafetyRing1[i - 8], i); else kingSafetySpecialRingB[i] = kingSafetyRing1[i]; } } private void PrecalculateEnPassantMoves() { for (int i = 0; i < 64; i++) { if (!epValidationArray[i]) continue; for (int j = 0; j < 64; j++) { if (i == j) continue; if (Math.Abs(i - j) > 9) continue; if (!epValidationArray[j]) continue; whiteEnPassantMoves[i, j] = new Move(false, i, j, j - 8); blackEnPassantMoves[i, j] = new Move(false, i, j, j + 8); } } } private void PawnAttackBitboards() { for (int sq = 0; sq < 64; sq++) { ulong u = 0ul; if (sq % 8 != 0) u = ULONG_OPERATIONS.SetBitToOne(u, sq + 7); if (sq % 8 != 7) u = ULONG_OPERATIONS.SetBitToOne(u, sq + 9); whitePawnAttackSquareBitboards[sq] = u; u = 0ul; if (sq % 8 != 0 && sq - 9 > -1) u = ULONG_OPERATIONS.SetBitToOne(u, sq - 9); if (sq % 8 != 7 && sq - 7 > -1) u = ULONG_OPERATIONS.SetBitToOne(u, sq - 7); blackPawnAttackSquareBitboards[sq] = u; } } private int[] squareConnectivesPrecalculationArray = new int[4096]; public int[] squareConnectivesCrossDirsPrecalculationArray { get; set; } = new int[4096]; private ulong[] squareConnectivesPrecalculationRayArray = new ulong[4096]; private ulong[] squareConnectivesPrecalculationLineArray = new ulong[4096]; private List<Dictionary<ulong, int>> rayCollidingSquareCalculations = new List<Dictionary<ulong, int>>(); private readonly int[] maxIntWithSpecifiedBitcount = new int[8] { 0, 0b1, 0b11, 0b111, 0b1111, 0b11111, 0b111111, 0b1111111 }; private List<ulong> differentRays = new List<ulong>(); private void SquareConnectivesPrecalculations() { for (int square = 0; square < 64; square++) { rayCollidingSquareCalculations.Add(new Dictionary<ulong, int>()); rayCollidingSquareCalculations[square].Add(0ul, square); for (int square2 = 0; square2 < 64; square2++) { if (square == square2) continue; int t = 0, t2 = 0, difSign = Math.Sign(square2 - square), itSq = square, g = 0; ulong tRay = 0ul, tExclRay = 0ul; List<int> tRayInts = new List<int>(); if (difSign == -1) g = 7; if (square % 8 == square2 % 8) { t2 = t = 1; while ((itSq += difSign * 8) < 64 && itSq > -1) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } } else if ((square - square % 8) == (square2 - square2 % 8)) { t = 1; t2 = -1; while ((itSq += difSign) % 8 != g && itSq > -1 && itSq < 64) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } } else { int dif = Math.Abs(square2 - square); if (dif % 7 == 0) { t = 2; t2 = 2; g = (difSign == 1) ? 7 : 0; while ((itSq += difSign * 7) % 8 != g && itSq < 64 && itSq > -1) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } if (ULONG_OPERATIONS.IsBitZero(tRay, square2)) { t2 = t = 0; tRay = 0ul; } } else if (dif % 9 == 0) { t = 2; t2 = -2; if (square == 0 && square2 == 63 || square == 63 && square2 == 0) SNAPSHOT_WRITLINE_REPLACEMENT("!"); while ((itSq += difSign * 9) % 8 != g && itSq < 64 && itSq > -1) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } if (ULONG_OPERATIONS.IsBitZero(tRay, square2)) { t2 = t = 0; tRay = 0ul; } } } if (square == 0 && square2 == 63) { t2 = t = 2; tRayInts.Clear(); tExclRay = tRay = ULONG_OPERATIONS.SetBitsToOne(0ul, 9, 18, 27, 36, 45, 54, 63); tRayInts = new List<int>() { 9, 18, 27, 36, 45, 54, 63 }; } else if (square2 == 0 && square == 63) { t = 2; tRayInts.Clear(); t2 = -2; tExclRay = tRay = ULONG_OPERATIONS.SetBitsToOne(0ul, 0, 9, 18, 27, 36, 45, 54); tRayInts = new List<int>() { 54, 45, 36, 27, 18, 9, 0 }; } if (tRay != 0ul && !differentRays.Contains(tRay)) { differentRays.Add(tRay); int ccount, combI = maxIntWithSpecifiedBitcount[ccount = ULONG_OPERATIONS.CountBits(tRay)]; do { ulong curAllPieceBitboard = 0ul; int solution = square; for (int j = 0; j < ccount; j++) { if (((combI >> j) & 1) == 1) { curAllPieceBitboard = ULONG_OPERATIONS.SetBitToOne(curAllPieceBitboard, tRayInts[j]); if (solution == square) solution = tRayInts[j]; } } rayCollidingSquareCalculations[square].Add(curAllPieceBitboard, solution); } while (--combI != 0); } squareConnectivesPrecalculationArray[square << 6 | square2] = t; squareConnectivesPrecalculationRayArray[square << 6 | square2] = tRay; squareConnectivesCrossDirsPrecalculationArray[square << 6 | square2] = t2; if (t != 0) squareConnectivesPrecalculationLineArray[square << 6 | square2] = (square == 0 && square2 == 63 || square2 == 0 && square == 63) ? tExclRay : ULONG_OPERATIONS.SetBitToOne(tExclRay, square2); if (squareConnectivesPrecalculationLineArray[square << 6 | square2] == 0ul && ULONG_OPERATIONS.IsBitOne(knightSquareBitboards[square], square2)) squareConnectivesPrecalculationLineArray[square << 6 | square2] = 1ul << square2; } differentRays.Clear(); } } public void SNAPSHOT_WRITLINE_REPLACEMENT() { } public void SNAPSHOT_WRITLINE_REPLACEMENT(object pStr) { } private string GetDoublePrecentageString(double pVal) { return ((int)(pVal * 1_000_000) /10_000d) + "%"; } private string ReplaceAllULONGIsBitOne(string pCode) { const string METHOD_NAME = "ULONG_OPERATIONS.IsBitOne"; int METHOD_NAME_LEN = METHOD_NAME.Length, iterations = 0; int pIndex = pCode.IndexOf(METHOD_NAME); while (pIndex != -1 && ++iterations < 10_000) { List<int> paramIndexes = new List<int>(); int openedBracketCount = 1, closedBracketCount = 0, a = METHOD_NAME_LEN + pIndex; string tpCode = pCode.Substring(0, pIndex); paramIndexes.Add(a + 1); while (++a < pCode.Length) { switch (pCode[a]) { case '(': openedBracketCount++; break; case ')': if (++closedBracketCount == openedBracketCount) { pIndex = a; a = int.MaxValue - 5; } break; case ',': if (openedBracketCount - closedBracketCount == 1) paramIndexes.Add(a + 1); break; } } if (openedBracketCount == closedBracketCount && paramIndexes.Count == 2) { tpCode += "((int)("+ pCode.Substring(paramIndexes[0], paramIndexes[1] - paramIndexes[0] - 1) + (pCode[paramIndexes[1]] == ' ' ? " >> (": " >> (") + pCode.Substring(paramIndexes[1], pIndex - paramIndexes[1]) + ")) & 1) == 1"+ pCode.Substring(pIndex + 1, pCode.Length - pIndex - 1); } pIndex = (pCode = tpCode).IndexOf(METHOD_NAME); } SNAPSHOT_WRITLINE_REPLACEMENT(iterations + " ITERATIONS"); return pCode; } private string ReplaceAllULONGIsBitZero(string pCode) { const string METHOD_NAME = "ULONG_OPERATIONS.IsBitZero"; int METHOD_NAME_LEN = METHOD_NAME.Length, iterations = 0; int pIndex = pCode.IndexOf(METHOD_NAME); while (pIndex != -1 && ++iterations < 10_000) { List<int> paramIndexes = new List<int>(); int openedBracketCount = 1, closedBracketCount = 0, a = METHOD_NAME_LEN + pIndex; string tpCode = pCode.Substring(0, pIndex); paramIndexes.Add(a + 1); while (++a < pCode.Length) { switch (pCode[a]) { case '(': openedBracketCount++; break; case ')': if (++closedBracketCount == openedBracketCount) { pIndex = a; a = int.MaxValue - 5; } break; case ',': if (openedBracketCount - closedBracketCount == 1) paramIndexes.Add(a + 1); break; } } if (openedBracketCount == closedBracketCount && paramIndexes.Count == 2) { tpCode += "((int)("+ pCode.Substring(paramIndexes[0], paramIndexes[1] - paramIndexes[0] - 1) + (pCode[paramIndexes[1]] == ' ' ? " >>": " >> ") + pCode.Substring(paramIndexes[1], pIndex - paramIndexes[1]) + ") & 1) == 0"+ pCode.Substring(pIndex + 1, pCode.Length - pIndex - 1); } pIndex = (pCode = tpCode).IndexOf(METHOD_NAME); } SNAPSHOT_WRITLINE_REPLACEMENT(iterations + " ITERATIONS"); return pCode; } private string GetThreeDigitSeperatedInteger(int pInt) { string s = pInt.ToString(), r = s[0].ToString(); int t = s.Length % 3; for (int i = 1; i < s.Length; i++) { if (i % 3 == t) r += "."; r += s[i]; } s = ""; for (int i = 0; i < r.Length; i++) s += r[i]; return s; } public double GetAverageDepth() { return (double)depths /(double)searches; } }
public class SNAPSHOT_V01_00_013 : IBoardManager  { public int TEXEL_PARAMS { get; } = 778; private const int BESTMOVE_SORT_VAL = -2_000_000_000; private const int CAPTURE_SORT_VAL = -1_000_000_000; private const int KILLERMOVE_SORT_VAL = -1000; private readonly int[,] MVVLVA_TABLE = new int[7, 7] { { 0, 0, 0, 0, 0, 0, 0 }, { 0, 1500, 1400, 1300, 1200, 1100, 1000 }, { 0, 3500, 3400, 3300, 3200, 3100, 3000 }, { 0, 4500, 4400, 4300, 4200, 4100, 4000 }, { 0, 5500, 5400, 5300, 5200, 5100, 5000 }, { 0, 9500, 9400, 9300, 9200, 9100, 9000 }, { 0, 0, 0, 0, 0, 0, 0 }}; private int BOARD_MANAGER_ID = -1; private bool debugSearchDepthResults = false; private bool debugSortResults = false; private RookMovement rookMovement; private BishopMovement bishopMovement; private QueenMovement queenMovement; private KnightMovement knightMovement; private KingMovement kingMovement; private WhitePawnMovement whitePawnMovement; private BlackPawnMovement blackPawnMovement; private Rays rays; public List<Move> moveOptionList { get; set; } private int[] pieceTypeArray = new int[64]; public ulong whitePieceBitboard, blackPieceBitboard, allPieceBitboard; private ulong zobristKey; private int whiteKingSquare, blackKingSquare, enPassantSquare = 65, happenedHalfMoves = 0, fiftyMoveRuleCounter = 0; private bool whiteCastleRightKingSide, whiteCastleRightQueenSide, blackCastleRightKingSide, blackCastleRightQueenSide; private bool isWhiteToMove; private const ulong WHITE_KING_ROCHADE = 96, WHITE_QUEEN_ROCHADE = 14, BLACK_KING_ROCHADE = 6917529027641081856, BLACK_QUEEN_ROCHADE = 1008806316530991104, WHITE_QUEEN_ATTK_ROCHADE = 12, BLACK_QUEEN_ATTK_ROCHADE = 864691128455135232; private readonly Move mWHITE_KING_ROCHADE = new Move(4, 6, 7, 5), mWHITE_QUEEN_ROCHADE = new Move(4, 2, 0, 3), mBLACK_KING_ROCHADE = new Move(60, 62, 63, 61), mBLACK_QUEEN_ROCHADE = new Move(60, 58, 56, 59); private ulong[] knightSquareBitboards = new ulong[64]; private ulong[] whitePawnAttackSquareBitboards = new ulong[64]; private ulong[] blackPawnAttackSquareBitboards = new ulong[64]; private ulong[] kingSquareBitboards = new ulong[64]; private bool[,] pieceTypeAbilities = new bool[7, 3] { { false, false, false }, { false, false, false }, { false, false, false }, { false, false, true }, { false, true, false }, { false, true, true }, { false, false, false } }; private List<int> moveHashList = new List<int>(); private ulong[] curSearchZobristKeyLine = Array.Empty<ulong>(); private Move[] debugMoveList = new Move[128]; private string debugFEN = ""; private Stopwatch globalTimer = Stopwatch.StartNew(); private Move lastMadeMove; private int depths, searches; private Random globalRandom = new Random(); public SNAPSHOT_V01_00_013(string fen) { Setup(fen); } public void Setup(string pFen) { Stopwatch setupStopwatch = Stopwatch.StartNew(); BOARD_MANAGER_ID = BOT_MAIN.curBoardManagerID; for (int i = 0; i < 33; i++) for (int j = 0; j < 14; j++) piecePositionEvals[i, j] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; for (int i = 0; i < 33; i++) for (int j = 0; j < 14; j++) texelTuningRuntimeVals[i, j] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; for (int i = 0; i < 3; i++) for (int j = 0; j < 6; j++) texelTuningVals[i, j] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; for (int i = 0; i < 14; i++) { texelTuningRuntimePositionalValsV2EG[i] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; texelTuningRuntimePositionalValsV2LG[i] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; } PrecalculateKingSafetyBitboards(); PrecalculateMultipliers(); GetLowNoisePositionalEvaluation(globalRandom); MinimaxRoot(1L); SetupConsoleWrite("[PRECALCS] Zobrist Hashing"); InitZobrist(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Knight Movement"); knightMovement = new KnightMovement(this); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Square Connectives"); SquareConnectivesPrecalculations(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Pawn Attack Bitboards"); PawnAttackBitboards(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Rays"); rays = new Rays(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); queenMovement = new QueenMovement(this); SetupConsoleWrite("[PRECALCS] Rook Movement"); rookMovement = new RookMovement(this, queenMovement); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Bishop Movement"); bishopMovement = new BishopMovement(this, queenMovement); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] King Movement"); kingMovement = new KingMovement(this); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Pawn Movement"); whitePawnMovement = new WhitePawnMovement(this); blackPawnMovement = new BlackPawnMovement(this); PrecalculateEnPassantMoves(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWriteLine("[DONE]\n\n"); LoadFenString(pFen); LoadBestTexelParamsIn(); setupStopwatch.Stop(); } private void SetupConsoleWriteLine(string pStr) { if (BOT_MAIN.isFirstBoardManagerInitialized) return; SNAPSHOT_WRITLINE_REPLACEMENT(pStr); } private void SetupConsoleWrite(string pStr) { if (BOT_MAIN.isFirstBoardManagerInitialized) return; SNAPSHOT_WRITLINE_REPLACEMENT(pStr); } public void GetLowNoisePositionalEvaluation(System.Random rng) { int[,][] digitArray = new int[3, 6][]; for (int i = 0; i < 3; i++) for (int j = 0; j < 6; j++) digitArray[i, j] = GetRand64IntArray(rng, -5, 6); lowNoisePositionEvals1 = GetInterpolatedProcessedValues(digitArray); int[,][] digitArray2 = new int[3, 6][]; for (int i = 0; i < 3; i++) for (int j = 0; j < 6; j++) digitArray2[i, j] = GetRand64IntArray(rng, -5, 6); lowNoisePositionEvals2 = GetInterpolatedProcessedValues(digitArray2); } private int[] GetRand64IntArray(System.Random rng, int pMin, int pMax) { return new int[64] { rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax) }; } private string GetAIArrayValuesStringRepresentation(int[,][] pArr) { string r = "int[,][] ReLe_AI_RESULT_VALS = new int[3, 6][] {"; for (int i = 0; i < 3; i++) { r += "{"; for (int j = 0; j < 5; j++) { r += GetIntArray64LStringRepresentation(pArr[i, j]) + ","; } r += GetIntArray64LStringRepresentation(pArr[i, 5]) + "},"; } return r.Substring(0, r.Length - 1) + "};"; } private string GetIntArray64LStringRepresentation(int[] p64LArr) { if (p64LArr == null) return ""; string r = "new int[64]{"; for (int i = 0; i < 63; i++) { r += p64LArr[i] + ","; } return r + p64LArr[63] + "}"; } public void TempStuff() { } private string[] gameResultStrings = new string[5] { "Black Has Won!", "Draw!", "White Has Won!", "Non Existant Result!", "Game is Ongoing!"}; private int[,][] lowNoisePositionEvals1, lowNoisePositionEvals2; public void ThreadSelfPlay(object obj) { PlayGameAgainstItself(obj); } public void PlayGameAgainstItself(object obj, string pStartFEN = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1", long tickLimitForEngine = ENGINE_VALS.SELF_PLAY_THINK_TIME) { int ttGState; while (BOT_MAIN.goalGameCount > BOT_MAIN.gamesPlayed) { try { string tGameStr; GetLowNoisePositionalEvaluation(globalRandom); LoadFenString(tGameStr = pStartFEN); tGameStr += ";"; int tGState = 3, tmc = 0; bool lowNoiceDecider = globalRandom.NextDouble() < 0.5d; while (tGState == 3) { piecePositionEvals = lowNoiceDecider ? lowNoisePositionEvals1 : lowNoisePositionEvals2; MinimaxRoot(tickLimitForEngine); Move tM = transpositionTable[zobristKey].bestMove; PlainMakeMove(tM); tGameStr += NuCRe.GetNuCRe(tM.moveHash) + ","; BOT_MAIN.movesPlayed++; tGState = GameState(isWhiteToMove); lowNoiceDecider = !lowNoiceDecider; tmc++; } ttGState = tGState; tGameStr += ttGState + 1; SNAPSHOT_WRITLINE_REPLACEMENT(tGameStr); BOT_MAIN.gamesPlayedResultArray[ttGState + 1]++; BOT_MAIN.gamesPlayed++; BOT_MAIN.selfPlayGameStrings.Add(tGameStr); } catch (Exception tE) { SNAPSHOT_WRITLINE_REPLACEMENT(tE.ToString()); } } } public void PlayGameOnConsoleAgainstHuman(string pStartFEN = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1", bool pHumanPlaysWhite = true, long tickLimitForEngine = 10_000_000L) { debugSearchDepthResults = true; LoadFenString(pStartFEN); if (!(pHumanPlaysWhite ^ isWhiteToMove)) { var pVS = Console.ReadLine(); if (pVS == null) return; Move tm = GetMoveOfString(pVS.ToString()); SNAPSHOT_WRITLINE_REPLACEMENT(tm); PlainMakeMove(tm); } int tGState = 3; while (tGState == 3) { MinimaxRoot(tickLimitForEngine); PlayThroughZobristTree(); Move tM = transpositionTable[zobristKey].bestMove; SNAPSHOT_WRITLINE_REPLACEMENT(tM); SNAPSHOT_WRITLINE_REPLACEMENT(CreateFenString()); PlainMakeMove(tM); tGState = GameState(isWhiteToMove); if (tGState != 3 || tM == NULL_MOVE) break; var pV = ""; tM = NULL_MOVE; do { pV = Console.ReadLine(); if (pV == null) continue; tM = GetMoveOfString(pV.ToString()); SNAPSHOT_WRITLINE_REPLACEMENT(tM); } while (tM == NULL_MOVE); PlainMakeMove(tM); tGState = GameState(isWhiteToMove); } } private void PlayThroughZobristTree() { SetJumpState(); SNAPSHOT_WRITLINE_REPLACEMENT("\n- - - - - - - - - - - - -"); int tC = 1; Dictionary<ulong, bool> usedULs = new Dictionary<ulong, bool>(); while (transpositionTable.TryGetValue(zobristKey, out TranspositionEntry tM)) { if (usedULs.ContainsKey(zobristKey)) { SNAPSHOT_WRITLINE_REPLACEMENT(tC + ": AT LEAST ONE REPETION; REST NOT VISIBLE"); break; } SNAPSHOT_WRITLINE_REPLACEMENT(tC + ": "+ tM.bestMove + " > "); usedULs.Add(zobristKey, true); PlainMakeMove(tM.bestMove); tC++; } SNAPSHOT_WRITLINE_REPLACEMENT("- - - - - - - - - - - - -\n"); LoadJumpState(); } public Move? ReturnNextMove(Move? lastMove, long pThinkingTime) { if (lastMove != null) PlainMakeMove(lastMove); if (GameState(isWhiteToMove) != 3) return null; MinimaxRoot(pThinkingTime); if (!transpositionTable.ContainsKey(zobristKey)) return null; Move tm = transpositionTable[zobristKey].bestMove; PlainMakeMove(tm); return tm; } private int[] jmpSt_pieceTypeArray; private ulong jmpSt_whitePieceBitboard, jmpSt_blackPieceBitboard; private ulong jmpSt_zobristKey; private int jmpSt_whiteKingSquare, jmpSt_blackKingSquare, jmpSt_enPassantSquare, jmpSt_happenedHalfMoves, jmpSt_fiftyMoveRuleCounter; private bool jmpSt_whiteCastleRightKingSide, jmpSt_whiteCastleRightQueenSide, jmpSt_blackCastleRightKingSide, jmpSt_blackCastleRightQueenSide; private bool jmpSt_isWhiteToMove; private ulong[] jmpSt_curSearchZobristKeyLine; private int[] jmpSt_moveHashList; public void LoadJumpState() { pieceTypeArray = (int[])jmpSt_pieceTypeArray.Clone(); whitePieceBitboard = jmpSt_whitePieceBitboard; blackPieceBitboard = jmpSt_blackPieceBitboard; zobristKey = jmpSt_zobristKey; whiteKingSquare = jmpSt_whiteKingSquare; blackKingSquare = jmpSt_blackKingSquare; enPassantSquare = jmpSt_enPassantSquare; happenedHalfMoves = jmpSt_happenedHalfMoves; fiftyMoveRuleCounter = jmpSt_fiftyMoveRuleCounter; whiteCastleRightKingSide = jmpSt_whiteCastleRightKingSide; whiteCastleRightQueenSide = jmpSt_whiteCastleRightQueenSide; blackCastleRightKingSide = jmpSt_blackCastleRightKingSide; blackCastleRightQueenSide = jmpSt_blackCastleRightQueenSide; isWhiteToMove = jmpSt_isWhiteToMove; curSearchZobristKeyLine = (ulong[])jmpSt_curSearchZobristKeyLine.Clone(); allPieceBitboard = blackPieceBitboard | whitePieceBitboard; moveHashList = jmpSt_moveHashList.ToList(); } public void SetJumpState() { jmpSt_pieceTypeArray = (int[])pieceTypeArray.Clone(); jmpSt_whitePieceBitboard = whitePieceBitboard; jmpSt_blackPieceBitboard = blackPieceBitboard; jmpSt_zobristKey = zobristKey; jmpSt_whiteKingSquare = whiteKingSquare; jmpSt_blackKingSquare = blackKingSquare; jmpSt_enPassantSquare = enPassantSquare; jmpSt_happenedHalfMoves = happenedHalfMoves; jmpSt_fiftyMoveRuleCounter = fiftyMoveRuleCounter; jmpSt_whiteCastleRightKingSide = whiteCastleRightKingSide; jmpSt_whiteCastleRightQueenSide = whiteCastleRightQueenSide; jmpSt_blackCastleRightKingSide = blackCastleRightKingSide; jmpSt_blackCastleRightQueenSide = blackCastleRightQueenSide; jmpSt_isWhiteToMove = isWhiteToMove; jmpSt_curSearchZobristKeyLine = (ulong[])curSearchZobristKeyLine.Clone(); jmpSt_moveHashList = moveHashList.ToArray(); } private int PreMinimaxCheckCheckWhite() { ulong bitShiftedKingPos = 1ul << whiteKingSquare; int curR = -1; for (int p = 0; p < 64; p++) { if (ULONG_OPERATIONS.IsBitZero(blackPieceBitboard, p)) continue; int tPT; switch (tPT = pieceTypeArray[p]) { case 1: if ((bitShiftedKingPos & blackPawnAttackSquareBitboards[p]) != 0ul) return p; break; case 2: if ((bitShiftedKingPos & knightSquareBitboards[p]) != 0ul) return p; break; case 6: break; default: if ((squareConnectivesPrecalculationLineArray[whiteKingSquare << 6 | p] & allPieceBitboard) == (1ul << p) && pieceTypeAbilities[tPT, squareConnectivesPrecalculationArray[whiteKingSquare << 6 | p]]) { if (curR != -1) return -779; curR = p; } break; } } return curR; } private int PreMinimaxCheckCheckBlack() { ulong bitShiftedKingPos = 1ul << blackKingSquare; int curR = -1; for (int p = 0; p < 64; p++) { if (ULONG_OPERATIONS.IsBitZero(whitePieceBitboard, p)) continue; int tPT; switch (tPT = pieceTypeArray[p]) { case 1: if ((bitShiftedKingPos & whitePawnAttackSquareBitboards[p]) != 0ul) return p; break; case 2: if ((bitShiftedKingPos & knightSquareBitboards[p]) != 0ul) return p; break; case 6: break; default: if ((squareConnectivesPrecalculationLineArray[blackKingSquare << 6 | p] & allPieceBitboard) == (1ul << p) && pieceTypeAbilities[tPT, squareConnectivesPrecalculationArray[blackKingSquare << 6 | p]]) { if (curR != -1) return -779; curR = p; } break; } } return curR; } private int LecacyLeafCheckingPieceCheckWhite(int pStartPos, int pEndPos, int pPieceType) { int tI, tPossibleAttackPiece; if (pPieceType == 1) { if (ULONG_OPERATIONS.IsBitOne(blackPawnAttackSquareBitboards[pEndPos], whiteKingSquare)) return pEndPos; } else if (pPieceType == 2) { if (ULONG_OPERATIONS.IsBitOne(knightSquareBitboards[pEndPos], whiteKingSquare)) return pEndPos; } else if (pPieceType != 6) { tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | pEndPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; } tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | pStartPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; return -1; } private int LecacyLeafCheckingPieceCheckBlack(int pStartPos, int pEndPos, int pPieceType) { int tI, tPossibleAttackPiece; if (pPieceType == 1) { if (ULONG_OPERATIONS.IsBitOne(whitePawnAttackSquareBitboards[pEndPos], blackKingSquare)) return pEndPos; } else if (pPieceType == 2) { if (ULONG_OPERATIONS.IsBitOne(knightSquareBitboards[pEndPos], blackKingSquare)) return pEndPos; } else if (pPieceType != 6) { tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | pEndPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; } tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | pStartPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; return -1; } public void GetLegalMoves(ref List<Move> pMoveList) { int attk; if (isWhiteToMove) { attk = PreMinimaxCheckCheckWhite(); if (attk == -779) GetLegalWhiteMovesSpecialDoubleCheckCase(ref pMoveList); else GetLegalWhiteMoves(attk, ref pMoveList); } else { attk = PreMinimaxCheckCheckBlack(); if (attk == -779) GetLegalBlackMovesSpecialDoubleCheckCase(ref pMoveList); else GetLegalBlackMoves(attk, ref pMoveList); } } private void GetLegalWhiteMoves(int pCheckingPieceSquare, ref List<Move> pMoveList) { if (pCheckingPieceSquare == -779) { GetLegalWhiteMovesSpecialDoubleCheckCase(ref pMoveList); return; } moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= blackPawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, whiteKingSquare); if (curCheckCount == 0) { if (whiteCastleRightKingSide && ((allPieceBitboard | oppAttkBitboard) & WHITE_KING_ROCHADE) == 0ul) pMoveList.Add(mWHITE_KING_ROCHADE); if (whiteCastleRightQueenSide && (allPieceBitboard & WHITE_QUEEN_ROCHADE | oppAttkBitboard & WHITE_QUEEN_ATTK_ROCHADE) == 0ul) pMoveList.Add(mWHITE_QUEEN_ROCHADE); if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, whitePieceBitboard, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[whiteKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare + 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, whitePieceBitboard, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveList(whiteKingSquare, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalWhiteCaptures(int pCheckingPieceSquare, ref List<Move> pMoveList) { if (pCheckingPieceSquare == -779) { GetLegalWhiteCapturesSpecialDoubleCheckCase(ref pMoveList); return; } moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= blackPawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, whiteKingSquare); if (curCheckCount == 0) { if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & blackPieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[whiteKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare + 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & blackPieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveListOnlyCaptures(whiteKingSquare, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalWhiteMovesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= blackPawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveList(whiteKingSquare, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalWhiteCapturesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= blackPawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveListOnlyCaptures(whiteKingSquare, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalBlackMoves(int pCheckingPieceSquare, ref List<Move> pMoveList) { if (pCheckingPieceSquare == -779) { GetLegalBlackMovesSpecialDoubleCheckCase(ref pMoveList); return; } moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= whitePawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, blackKingSquare); if (curCheckCount == 0) { if (blackCastleRightKingSide && ((allPieceBitboard | oppAttkBitboard) & BLACK_KING_ROCHADE) == 0ul) pMoveList.Add(mBLACK_KING_ROCHADE); if (blackCastleRightQueenSide && (allPieceBitboard & BLACK_QUEEN_ROCHADE | oppAttkBitboard & BLACK_QUEEN_ATTK_ROCHADE) == 0ul) pMoveList.Add(mBLACK_QUEEN_ROCHADE); if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveList(p, blackKingSquare, blackPieceBitboard, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[blackKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare - 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveList(p, blackKingSquare, blackPieceBitboard, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveList(blackKingSquare, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); } private void GetLegalBlackCaptures(int pCheckingPieceSquare, ref List<Move> pMoveList) { if (pCheckingPieceSquare == -779) { GetLegalBlackCapturesSpecialDoubleCheckCase(ref pMoveList); return; } moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= whitePawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, blackKingSquare); if (curCheckCount == 0) { if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & whitePieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[blackKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare - 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & whitePieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveListOnlyCaptures(blackKingSquare, ~oppAttkBitboard & whitePieceBitboard); } private void GetLegalBlackMovesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= whitePawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveList(blackKingSquare, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); } private void GetLegalBlackCapturesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= whitePawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveListOnlyCaptures(blackKingSquare, ~oppAttkBitboard & whitePieceBitboard); } public Move GetMoveOfString(string pMove) { int tSP, tEP; string[] tSpl = pMove.Split(','); if (Char.IsNumber(pMove[0])) { tSP = Convert.ToInt32(tSpl[0]); tEP = Convert.ToInt32(tSpl[1]); } else { tSP = SQUARES.NumberNotation(tSpl[0]); tEP = SQUARES.NumberNotation(tSpl[1]); } int tPT = pieceTypeArray[tSP]; bool tIC = ULONG_OPERATIONS.IsBitOne(allPieceBitboard, tEP), tIEP = enPassantSquare == tEP && tPT == 1; if (tSpl.Length == 3) return new Move(tSP, tEP, tPT, Convert.ToInt32(tSpl[2]), tIC); if (tIEP) return new Move(true, tSP, tEP, isWhiteToMove ? tEP - 8 : tEP + 8); if (tPT == 1 && Math.Abs(tSP - tEP) > 11) return new Move(tSP, tEP, 1, false, isWhiteToMove ? tSP + 8 : tSP - 8); if (tPT == 6 && (Math.Abs(tSP - tEP) == 2 || Math.Abs(tSP - tEP) == 3)) { if (isWhiteToMove) return tEP == 6 ? mWHITE_KING_ROCHADE : mWHITE_QUEEN_ROCHADE; return tEP == 62 ? mBLACK_KING_ROCHADE : mBLACK_QUEEN_ROCHADE; } return new Move(tSP, tEP, tPT, tIC); } public void PlainMakeMove(string pMoveName) { PlainMakeMove(GetMoveOfString(pMoveName)); } public void PlainMakeMove(Move pMove) { lastMadeMove = pMove; if (isWhiteToMove) WhiteMakeMove(pMove); else BlackMakeMove(pMove); debugFEN = CreateFenString(); } public void WhiteMakeMove(Move pMove) { int tEndPos = pMove.endPos, tStartPos = pMove.startPos, tPieceType = pMove.pieceType, tPTI = pieceTypeArray[tEndPos]; fiftyMoveRuleCounter++; whitePieceBitboard ^= pMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey ^= blackTurnHash ^ enPassantSquareHashes[enPassantSquare] ^ pieceHashesWhite[tStartPos, tPieceType] ^ pieceHashesWhite[tEndPos, tPieceType]; enPassantSquare = 65; isWhiteToMove = false; switch (pMove.moveTypeID) { case 0: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 1: fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 2: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 3: whiteKingSquare = tEndPos; if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 4: if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 5: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 6: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 7: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[whiteKingSquare = tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 8: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 9: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = pMove.enPassantOption]; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 11: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; whiteKingSquare = tEndPos; pieceTypeArray[pMove.rochadeEndPos] = 4; pieceTypeArray[pMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesWhite[pMove.rochadeStartPos, 4] ^ pieceHashesWhite[pMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 12: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[pMove.enPassantOption] = 0; zobristKey ^= pieceHashesBlack[pMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 13: fiftyMoveRuleCounter = 0; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; zobristKey ^= pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, pMove.promotionType]; break; case 14: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, tPTI] ^ pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, pMove.promotionType]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; } moveHashList.Add(pMove.moveHash); if (pMove.isCapture || tPieceType == 1) { curSearchZobristKeyLine = Array.Empty<ulong>(); return; } ulong[] u = new ulong[(tPTI = curSearchZobristKeyLine.Length) + 1]; for (int i = tPTI; i-- > 0;) u[i] = curSearchZobristKeyLine[i]; u[tPTI] = zobristKey; curSearchZobristKeyLine = u; } public void BlackMakeMove(Move pMove) { int tEndPos = pMove.endPos, tStartPos = pMove.startPos, tPieceType = pMove.pieceType, tPTI = pieceTypeArray[tEndPos]; fiftyMoveRuleCounter++; blackPieceBitboard ^= pMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey ^= blackTurnHash ^ enPassantSquareHashes[enPassantSquare] ^ pieceHashesBlack[tStartPos, tPieceType] ^ pieceHashesBlack[tEndPos, tPieceType]; enPassantSquare = 65; isWhiteToMove = true; switch (pMove.moveTypeID) { case 0: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 1: fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 2: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 3: blackKingSquare = tEndPos; if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 4: if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 5: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 6: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 7: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[blackKingSquare = tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 8: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 9: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = pMove.enPassantOption]; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 11: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; blackKingSquare = tEndPos; pieceTypeArray[pMove.rochadeEndPos] = 4; pieceTypeArray[pMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesBlack[pMove.rochadeStartPos, 4] ^ pieceHashesBlack[pMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 12: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[pMove.enPassantOption] = 0; zobristKey ^= pieceHashesWhite[pMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 13: fiftyMoveRuleCounter = 0; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, pMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 14: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } zobristKey ^= pieceHashesWhite[tEndPos, tPTI] ^ pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, pMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; } moveHashList.Add(pMove.moveHash); if (pMove.isCapture || tPieceType == 1) { curSearchZobristKeyLine = Array.Empty<ulong>(); return; } ulong[] u = new ulong[(tPTI = curSearchZobristKeyLine.Length) + 1]; for (int i = tPTI; i-- > 0;) u[i] = curSearchZobristKeyLine[i]; u[tPTI] = zobristKey; curSearchZobristKeyLine = u; } public void WhiteUndoMove(Move pMove) { } private const int WHITE_CHECKMATE_VAL = 100000, BLACK_CHECKMATE_VAL = -100000, CHECK_EXTENSION_LENGTH = -12, MAX_QUIESCENCE_TOTAL_LENGTH = -32; private readonly Move NULL_MOVE = new Move(0, 0, 0); private int curSearchDepth = 0, curSubSearchDepth = -1; public int MinimaxRoot(long pTime) { evalCount = 0; searches++; int baseLineLen = 0; long tTimestamp = globalTimer.ElapsedTicks + pTime; ClearHeuristics(); transpositionTable.Clear(); ulong[] tZobristKeyLine = Array.Empty<ulong>(); if (curSearchZobristKeyLine != null) { baseLineLen = curSearchZobristKeyLine.Length; tZobristKeyLine = new ulong[baseLineLen]; Array.Copy(curSearchZobristKeyLine, tZobristKeyLine, baseLineLen); } int perftScore, tattk = isWhiteToMove ? PreMinimaxCheckCheckWhite() : PreMinimaxCheckCheckBlack(), pDepth = 1; (string, int) bookMoveTuple = TLMDatabase.SearchForNextBookMove(moveHashList); if (bookMoveTuple.Item2 != 0) { int actualMoveHash = NuCRe.GetNumber(bookMoveTuple.Item1); List<Move> tMoves = new List<Move>(); GetLegalMoves(ref tMoves); int tL = tMoves.Count; for (int i = 0; i < tL; i++) { if (tMoves[i].moveHash == actualMoveHash) { if (debugSearchDepthResults) { SNAPSHOT_WRITLINE_REPLACEMENT("TLM_DB_Count: " + bookMoveTuple.Item2); SNAPSHOT_WRITLINE_REPLACEMENT(">> " + tMoves[i]); } transpositionTable.Add(zobristKey, new TranspositionEntry(tMoves[i], Array.Empty<int>())); return 0; } } } do { curSearchDepth = pDepth; curSubSearchDepth = pDepth - 1; ulong[] completeZobristHistory = new ulong[baseLineLen + pDepth - CHECK_EXTENSION_LENGTH + 1]; for (int i = 0; i < baseLineLen; i++) completeZobristHistory[i] = curSearchZobristKeyLine[i]; curSearchZobristKeyLine = completeZobristHistory; if (isWhiteToMove) { if (tattk == -1) perftScore = MinimaxWhite(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); else perftScore = MinimaxWhite(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); } else { if (tattk == -1) perftScore = MinimaxBlack(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); else perftScore = MinimaxBlack(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); } if (debugSearchDepthResults && pTime != 1L) { int tNpS = Convert.ToInt32((double)evalCount * 10_000_000d /(double)(pTime - tTimestamp + globalTimer.ElapsedTicks)); int tSearchEval = perftScore; int timeForSearchSoFar = (int)((pTime - tTimestamp + globalTimer.ElapsedTicks) /10000d); Move tBestMove = transpositionTable[zobristKey].bestMove; SNAPSHOT_WRITLINE_REPLACEMENT((tSearchEval >= 0 ? "+": "") + tSearchEval); SNAPSHOT_WRITLINE_REPLACEMENT(" " + tBestMove + "  ["); SNAPSHOT_WRITLINE_REPLACEMENT("Depth = " + pDepth + ", "); SNAPSHOT_WRITLINE_REPLACEMENT("Evals = " + GetThreeDigitSeperatedInteger(evalCount) + ", "); SNAPSHOT_WRITLINE_REPLACEMENT("Time = " + GetThreeDigitSeperatedInteger(timeForSearchSoFar) + "ms, "); SNAPSHOT_WRITLINE_REPLACEMENT("NpS = " + GetThreeDigitSeperatedInteger(tNpS) + "]"); } pDepth++; } while (globalTimer.ElapsedTicks < tTimestamp && pDepth < 179); depths += pDepth - 1; BOT_MAIN.depthsSearched += pDepth - 1; BOT_MAIN.searchesFinished++; BOT_MAIN.evaluationsMade += evalCount; curSearchZobristKeyLine = tZobristKeyLine; return perftScore; } private int[] squareToRankArray = new int[64] { 0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1, 2,2,2,2,2,2,2,2, 3,3,3,3,3,3,3,3, 4,4,4,4,4,4,4,4, 5,5,5,5,5,5,5,5, 6,6,6,6,6,6,6,6, 7,7,7,7,7,7,7,7 }; private bool WhiteIsPositionTheSpecialCase(Move pLastMove, int pCheckingSquare) { if (pLastMove.isPromotion && pLastMove.isCapture && (pLastMove.promotionType == 4 || pLastMove.promotionType == 5)) { if(pLastMove.startPos % 8 == pCheckingSquare % 8 && pLastMove.startPos == whiteKingSquare + 8) return true; if (squareToRankArray[pLastMove.startPos] == squareToRankArray[pCheckingSquare] && pLastMove.endPos == whiteKingSquare - 8) return true; } return false; } private bool BlackIsPositionTheSpecialCase(Move pLastMove, int pCheckingSquare) { if (pLastMove.isPromotion && pLastMove.isCapture && (pLastMove.promotionType == 4 || pLastMove.promotionType == 5)) { if (pLastMove.startPos % 8 == pCheckingSquare % 8 && pLastMove.startPos == blackKingSquare - 8) return true; if (pCheckingSquare != -1 && squareToRankArray[pLastMove.startPos] == squareToRankArray[pCheckingSquare] && pLastMove.endPos == blackKingSquare + 8) return true; } return false; } private int MinimaxWhite(int pPly, int pAlpha, int pBeta, int pDepth, int pRepetitionHistoryPly, int pCheckingSquare, Move pLastMove) { if (IsDrawByRepetition(pRepetitionHistoryPly - 4)) return 0; if ((pDepth <= 0 && pCheckingSquare == -1) || pDepth < CHECK_EXTENSION_LENGTH) return QuiescenceWhite(pPly, pAlpha, pBeta, pDepth - 1, pCheckingSquare, pLastMove); List<Move> moveOptionList = new List<Move>(); Move bestMove = NULL_MOVE; if (WhiteIsPositionTheSpecialCase(pLastMove, pCheckingSquare)) GetLegalWhiteMovesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalWhiteMoves(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tWhiteKingSquare = whiteKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1, curEval = BLACK_CHECKMATE_VAL - pDepth; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = true; double[] moveSortingArray = new double[molc]; int[] moveSortingArrayIndexes = new int[molc], thisSearchMoveSortingArrayForTransposEntry = new int[molc]; transpositionTable.TryGetValue(zobristKey, out TranspositionEntry transposEntry); if (transposEntry == null) { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; } } else { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove == transposEntry.bestMove) moveSortingArray[m] = BESTMOVE_SORT_VAL; else if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; if (transposEntry.moveGenOrderedEvalLength > m) moveSortingArray[m] -= transposEntry.moveGenOrderedEvals[m]; } } Array.Sort(moveSortingArray, moveSortingArrayIndexes); for (int m = 0; m < molc; m++) { int tActualIndex = moveSortingArrayIndexes[m]; Move curMove = moveOptionList[tActualIndex]; if (debugSortResults && pDepth == curSubSearchDepth) { SNAPSHOT_WRITLINE_REPLACEMENT(moveSortingArray[m] + " | "+ curMove); } int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; whitePieceBitboard = tWPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesWhite[tStartPos, tPieceType] ^ pieceHashesWhite[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 0: blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 1: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 2: blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 3: whiteKingSquare = tEndPos; if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 4: blackPieceBitboard = tBPB; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 5: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[whiteKingSquare = tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = curMove.enPassantOption]; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 11: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; whiteKingSquare = tEndPos; blackPieceBitboard = tBPB; pieceTypeArray[curMove.rochadeEndPos] = 4; pieceTypeArray[curMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesWhite[curMove.rochadeStartPos, 4] ^ pieceHashesWhite[curMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | curMove.rochadeEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << curMove.rochadeEndPos)) tCheckPos = curMove.rochadeEndPos; break; case 12: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesBlack[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 13: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; zobristKey ^= pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, curMove.promotionType]; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; case 14: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, tPTI] ^ pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, curMove.promotionType]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } curSearchZobristKeyLine[pRepetitionHistoryPly] = zobristKey; debugMoveList[pPly] = curMove; int tEval = MinimaxBlack(pPly + 1, pAlpha, pBeta, pDepth - 1, pRepetitionHistoryPly + 1, tCheckPos, curMove); thisSearchMoveSortingArrayForTransposEntry[tActualIndex] = tEval; pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 3: whiteKingSquare = tWhiteKingSquare; break; case 7: whiteKingSquare = tWhiteKingSquare; break; case 10: enPassantSquare = 65; break; case 11: whiteKingSquare = tWhiteKingSquare; pieceTypeArray[curMove.rochadeStartPos] = 4; pieceTypeArray[curMove.rochadeEndPos] = 0; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 13: pieceTypeArray[tStartPos] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval > curEval) { bestMove = curMove; curEval = tEval; } if (pAlpha < curEval) pAlpha = curEval; if (curEval >= pBeta) { if (!curMove.isCapture) { killerMoveHeuristic[curMove.moveHash] = true; if (pDepth > 0) historyHeuristic[curMove.moveHash] += pDepth * pDepth; } break; } } isWhiteToMove = true; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; if (molc == 0 && pCheckingSquare == -1) curEval = 0; if (!transpositionTable.ContainsKey(zobristKey)) transpositionTable.Add(zobristKey, new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry)); else transpositionTable[zobristKey] = new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry); return curEval; } private int QuiescenceWhite(int pPly, int pAlpha, int pBeta, int pDepth, int pCheckingSquare, Move pLastMove) { int standPat = TexelEvaluate(); if (standPat >= pBeta || pDepth < MAX_QUIESCENCE_TOTAL_LENGTH) return pBeta; if (standPat > pAlpha) pAlpha = standPat; List<Move> moveOptionList = new List<Move>(); if (WhiteIsPositionTheSpecialCase(pLastMove, pCheckingSquare)) GetLegalWhiteCapturesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalWhiteCaptures(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tWhiteKingSquare = whiteKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = true; for (int m = 0; m < molc; m++) { Move curMove = moveOptionList[m]; int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; whitePieceBitboard = tWPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesWhite[tStartPos, tPieceType] ^ pieceHashesWhite[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 5: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[whiteKingSquare = tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 12: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesBlack[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 14: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, tPTI] ^ pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, curMove.promotionType]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } debugMoveList[pPly] = curMove; int tEval = QuiescenceBlack(pPly + 1, pAlpha, pBeta, pDepth - 1, tCheckPos, curMove); pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 7: whiteKingSquare = tWhiteKingSquare; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval >= pBeta) return pBeta; if (pAlpha < tEval) pAlpha = tEval; } isWhiteToMove = true; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; return pAlpha; } private int MinimaxBlack(int pPly, int pAlpha, int pBeta, int pDepth, int pRepetitionHistoryPly, int pCheckingSquare, Move pLastMove) { if (IsDrawByRepetition(pRepetitionHistoryPly - 4)) return 0; if ((pDepth <= 0 && pCheckingSquare == -1) || pDepth < CHECK_EXTENSION_LENGTH) return QuiescenceBlack(pPly, pAlpha, pBeta, pDepth - 1, pCheckingSquare, pLastMove); List<Move> moveOptionList = new List<Move>(); Move bestMove = NULL_MOVE; if (BlackIsPositionTheSpecialCase(pLastMove, pCheckingSquare)) GetLegalBlackMovesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalBlackMoves(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tBlackKingSquare = blackKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1, curEval = WHITE_CHECKMATE_VAL + pDepth; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = false; double[] moveSortingArray = new double[molc]; int[] moveSortingArrayIndexes = new int[molc], thisSearchMoveSortingArrayForTransposEntry = new int[molc]; transpositionTable.TryGetValue(zobristKey, out TranspositionEntry transposEntry); if (transposEntry == null) { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; } } else { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove == transposEntry.bestMove) moveSortingArray[m] = BESTMOVE_SORT_VAL; else if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; if (transposEntry.moveGenOrderedEvalLength > m) moveSortingArray[m] -= transposEntry.moveGenOrderedEvals[m]; } } Array.Sort(moveSortingArray, moveSortingArrayIndexes); for (int m = 0; m < molc; m++) { int tActualIndex = moveSortingArrayIndexes[m]; Move curMove = moveOptionList[tActualIndex]; if (debugSortResults && pDepth == curSearchDepth) { SNAPSHOT_WRITLINE_REPLACEMENT("=== " + moveSortingArray[m] + " | "+ curMove); } int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; blackPieceBitboard = tBPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesBlack[tStartPos, tPieceType] ^ pieceHashesBlack[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 0: whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 1: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 2: whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 3: blackKingSquare = tEndPos; if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 4: whitePieceBitboard = tWPB; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 5: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[blackKingSquare = tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = curMove.enPassantOption]; whitePieceBitboard = tWPB; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 11: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; blackKingSquare = tEndPos; whitePieceBitboard = tWPB; pieceTypeArray[curMove.rochadeEndPos] = 4; pieceTypeArray[curMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesBlack[curMove.rochadeStartPos, 4] ^ pieceHashesBlack[curMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | curMove.rochadeEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << curMove.rochadeEndPos)) tCheckPos = curMove.rochadeEndPos; break; case 12: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesWhite[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 13: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, curMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; case 14: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } zobristKey ^= pieceHashesWhite[tEndPos, tPTI] ^ pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, curMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } curSearchZobristKeyLine[pRepetitionHistoryPly] = zobristKey; debugMoveList[pPly] = curMove; int tEval = MinimaxWhite(pPly + 1, pAlpha, pBeta, pDepth - 1, pRepetitionHistoryPly + 1, tCheckPos, curMove); thisSearchMoveSortingArrayForTransposEntry[tActualIndex] = tEval; pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 3: blackKingSquare = tBlackKingSquare; break; case 7: blackKingSquare = tBlackKingSquare; break; case 10: enPassantSquare = 65; break; case 11: blackKingSquare = tBlackKingSquare; pieceTypeArray[curMove.rochadeStartPos] = 4; pieceTypeArray[curMove.rochadeEndPos] = 0; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 13: pieceTypeArray[tStartPos] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval < curEval) { bestMove = curMove; curEval = tEval; } if (pBeta > curEval) pBeta = curEval; if (curEval <= pAlpha) { if (!curMove.isCapture) { killerMoveHeuristic[curMove.moveHash] = true; if (pDepth > 0) historyHeuristic[curMove.moveHash] += pDepth * pDepth; } break; } } isWhiteToMove = false; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; if (molc == 0 && pCheckingSquare == -1) curEval = 0; if (!transpositionTable.ContainsKey(zobristKey)) transpositionTable.Add(zobristKey, new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry)); else transpositionTable[zobristKey] = new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry); return curEval; } private int QuiescenceBlack(int pPly, int pAlpha, int pBeta, int pDepth, int pCheckingSquare, Move pLastMove) { int standPat = TexelEvaluate(); if (standPat <= pAlpha || pDepth < MAX_QUIESCENCE_TOTAL_LENGTH) return pAlpha; if (standPat < pBeta) pBeta = standPat; List<Move> moveOptionList = new List<Move>(); if (BlackIsPositionTheSpecialCase(pLastMove, pCheckingSquare)) GetLegalBlackCapturesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalBlackCaptures(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tBlackKingSquare = blackKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = false; for (int m = 0; m < molc; m++) { Move curMove = moveOptionList[m]; int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; blackPieceBitboard = tBPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesBlack[tStartPos, tPieceType] ^ pieceHashesBlack[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 5: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[blackKingSquare = tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 12: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesWhite[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 14: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } zobristKey ^= pieceHashesWhite[tEndPos, tPTI] ^ pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, curMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } debugMoveList[pPly] = curMove; int tEval = QuiescenceWhite(pPly + 1, pAlpha, pBeta, pDepth - 1, tCheckPos, curMove); pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 7: blackKingSquare = tBlackKingSquare; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval <= pAlpha) return pAlpha; if (pBeta > tEval) pBeta = tEval; } isWhiteToMove = false; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; return pBeta; } private bool[] killerMoveHeuristic = new bool[262_144]; private int[] historyHeuristic = new int[262_144]; public void ClearHeuristics() { for (int i = 0; i < 262_144; i++) { killerMoveHeuristic[i] = false; historyHeuristic[i] = 0; } } private Dictionary<ulong, TranspositionEntry> transpositionTable = new Dictionary<ulong, TranspositionEntry>(); private int[] pieceEvals = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[,][] piecePositionEvals = new int[33, 14][]; private int evalCount = 0; private int Evaluate() { evalCount++; if (fiftyMoveRuleCounter > 99) return 0; int tEval = 0, tPT, pieceCount = ULONG_OPERATIONS.CountBits(allPieceBitboard); for (int p = 0; p < 64; p++) tEval += pieceEvals[tPT = pieceTypeArray[p] + 7 * ((int)(blackPieceBitboard >> p) & 1)] + piecePositionEvals[pieceCount, tPT][p]; return tEval; } public int GameState(bool pWhiteKingCouldBeAttacked) { if (IsDrawByRepetition(curSearchZobristKeyLine.Length - 5) || fiftyMoveRuleCounter > 99) return 0; int t; List<Move> tMoves = new List<Move>(); GetLegalMoves(ref tMoves); if (pWhiteKingCouldBeAttacked) { t = PreMinimaxCheckCheckWhite(); if (t == -1) return tMoves.Count == 0 ? 0 : 3; else if (tMoves.Count == 0) return -1; } else { t = PreMinimaxCheckCheckBlack(); if (t == -1) return tMoves.Count == 0 ? 0 : 3; else if (tMoves.Count == 0) return 1; } return 3; } private bool IsDrawByRepetition(int pPlyOfFirstPossibleRepeatedPosition) { int tC = 0; for (int i = pPlyOfFirstPossibleRepeatedPosition; i >= 0; i -= 2) { if (curSearchZobristKeyLine[i] == zobristKey) if (++tC == 2) return true; } return false; } private const int RELE_MAX_MOVE_COUNT_PER_GAME = 500; public double ReLePlayGame(int[,][] pEvalPositionValuesWhite, int[,][] pEvalPositionValuesBlack, long thinkingTimePerMove) { int[,][] processedValuesWhite = InitReLeAgent(pEvalPositionValuesWhite), processedValuesBlack = InitReLeAgent(pEvalPositionValuesBlack); int tGS, mc = 0; do { if (IsDrawByRepetition(curSearchZobristKeyLine.Length - 5)) return 0d; piecePositionEvals = isWhiteToMove ? processedValuesWhite : processedValuesBlack; MinimaxRoot(thinkingTimePerMove); if (transpositionTable.Count == 0) { SNAPSHOT_WRITLINE_REPLACEMENT("?!"); return 0d; } PlainMakeMove(transpositionTable[zobristKey].bestMove); tGS = GameState(isWhiteToMove); transpositionTable.Clear(); if (tGS != 3) break; } while (mc++ < RELE_MAX_MOVE_COUNT_PER_GAME); if (tGS == 3 || tGS == 0) return 0d; else if (tGS == 1) return 0.1d * (double)(RELE_MAX_MOVE_COUNT_PER_GAME - mc); return 0.1d * (double)(-RELE_MAX_MOVE_COUNT_PER_GAME + mc); } public int[,][] InitReLeAgent(int[,][] pEvalPositionValues) { return GetInterpolatedProcessedValues(pEvalPositionValues); } private int[,][] GetInterpolatedProcessedValues(int[,][] pEvalPositionValues) { int[,][] processedValues = new int[33, 14][]; for (int i = 0; i < 32; i++) { int ip1 = i + 1; processedValues[ip1, 7] = processedValues[ip1, 0] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; processedValues[ip1, 8] = SwapArrayViewingSide(processedValues[ip1, 1] = MultiplyArraysWithVal(pEvalPositionValues[0, 0], pEvalPositionValues[1, 0], pEvalPositionValues[2, 0], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 9] = SwapArrayViewingSide(processedValues[ip1, 2] = MultiplyArraysWithVal(pEvalPositionValues[0, 1], pEvalPositionValues[1, 1], pEvalPositionValues[2, 1], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 10] = SwapArrayViewingSide(processedValues[ip1, 3] = MultiplyArraysWithVal(pEvalPositionValues[0, 2], pEvalPositionValues[1, 2], pEvalPositionValues[2, 2], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 11] = SwapArrayViewingSide(processedValues[ip1, 4] = MultiplyArraysWithVal(pEvalPositionValues[0, 3], pEvalPositionValues[1, 3], pEvalPositionValues[2, 3], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 12] = SwapArrayViewingSide(processedValues[ip1, 5] = MultiplyArraysWithVal(pEvalPositionValues[0, 4], pEvalPositionValues[1, 4], pEvalPositionValues[2, 4], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 13] = SwapArrayViewingSide(processedValues[ip1, 6] = MultiplyArraysWithVal(pEvalPositionValues[0, 5], pEvalPositionValues[1, 5], pEvalPositionValues[2, 5], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); } return processedValues; } private double[,][] GetInterpolatedProcessedValues(double[,][] pEvalPositionValues) { double[,][] processedValues = new double[33, 14][]; for (int i = 0; i < 32; i++) { int ip1 = i + 1; processedValues[ip1, 7] = processedValues[ip1, 0] = new double[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; processedValues[ip1, 8] = SwapArrayViewingSide(processedValues[ip1, 1] = MultiplyArraysWithVal(pEvalPositionValues[0, 0], pEvalPositionValues[1, 0], pEvalPositionValues[2, 0], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 9] = SwapArrayViewingSide(processedValues[ip1, 2] = MultiplyArraysWithVal(pEvalPositionValues[0, 1], pEvalPositionValues[1, 1], pEvalPositionValues[2, 1], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 10] = SwapArrayViewingSide(processedValues[ip1, 3] = MultiplyArraysWithVal(pEvalPositionValues[0, 2], pEvalPositionValues[1, 2], pEvalPositionValues[2, 2], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 11] = SwapArrayViewingSide(processedValues[ip1, 4] = MultiplyArraysWithVal(pEvalPositionValues[0, 3], pEvalPositionValues[1, 3], pEvalPositionValues[2, 3], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 12] = SwapArrayViewingSide(processedValues[ip1, 5] = MultiplyArraysWithVal(pEvalPositionValues[0, 4], pEvalPositionValues[1, 4], pEvalPositionValues[2, 4], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 13] = SwapArrayViewingSide(processedValues[ip1, 6] = MultiplyArraysWithVal(pEvalPositionValues[0, 5], pEvalPositionValues[1, 5], pEvalPositionValues[2, 5], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); } return processedValues; } private double[] MultiplyArraysWithVal(double[] pArr1, double[] pArr2, double[] pArr3, double pVal1, double pVal2, double pVal3) { int tL = pArr1.Length; double[] rArr = new double[tL]; for (int i = 0; i < tL; i++) { rArr[i] = pArr1[i] * pVal1 + pArr2[i] * pVal2 + pArr3[i] * pVal3; } return rArr; } private int[] MultiplyArraysWithVal(int[] pArr1, int[] pArr2, int[] pArr3, double pVal1, double pVal2, double pVal3) { int tL = pArr1.Length; int[] rArr = new int[tL]; for (int i = 0; i < tL; i++) { rArr[i] = (int)(pArr1[i] * pVal1 + pArr2[i] * pVal2 + pArr3[i] * pVal3); } return rArr; } private int[] SwapArrayViewingSideAndNegate(int[] pArr) { return new int[64] { -pArr[56], -pArr[57], -pArr[58], -pArr[59], -pArr[60], -pArr[61], -pArr[62], -pArr[63], -pArr[48], -pArr[49], -pArr[50], -pArr[51], -pArr[52], -pArr[53], -pArr[54], -pArr[55], -pArr[40], -pArr[41], -pArr[42], -pArr[43], -pArr[44], -pArr[45], -pArr[46], -pArr[47], -pArr[32], -pArr[33], -pArr[34], -pArr[35], -pArr[36], -pArr[37], -pArr[38], -pArr[39], -pArr[24], -pArr[25], -pArr[26], -pArr[27], -pArr[28], -pArr[29], -pArr[30], -pArr[31], -pArr[16], -pArr[17], -pArr[18], -pArr[19], -pArr[20], -pArr[21], -pArr[22], -pArr[23], -pArr[8], -pArr[9], -pArr[10], -pArr[11], -pArr[12], -pArr[13], -pArr[14], -pArr[15], -pArr[0], -pArr[1], -pArr[2], -pArr[3], -pArr[4], -pArr[5], -pArr[6], -pArr[7] }; } private int[] SwapArrayViewingSide(int[] pArr) { return new int[64] { pArr[56], pArr[57], pArr[58], pArr[59], pArr[60], pArr[61], pArr[62], pArr[63], pArr[48], pArr[49], pArr[50], pArr[51], pArr[52], pArr[53], pArr[54], pArr[55], pArr[40], pArr[41], pArr[42], pArr[43], pArr[44], pArr[45], pArr[46], pArr[47], pArr[32], pArr[33], pArr[34], pArr[35], pArr[36], pArr[37], pArr[38], pArr[39], pArr[24], pArr[25], pArr[26], pArr[27], pArr[28], pArr[29], pArr[30], pArr[31], pArr[16], pArr[17], pArr[18], pArr[19], pArr[20], pArr[21], pArr[22], pArr[23], pArr[8], pArr[9], pArr[10], pArr[11], pArr[12], pArr[13], pArr[14], pArr[15], pArr[0], pArr[1], pArr[2], pArr[3], pArr[4], pArr[5], pArr[6], pArr[7] }; } private double[] SwapArrayViewingSide(double[] pArr) { return new double[64] { pArr[56], pArr[57], pArr[58], pArr[59], pArr[60], pArr[61], pArr[62], pArr[63], pArr[48], pArr[49], pArr[50], pArr[51], pArr[52], pArr[53], pArr[54], pArr[55], pArr[40], pArr[41], pArr[42], pArr[43], pArr[44], pArr[45], pArr[46], pArr[47], pArr[32], pArr[33], pArr[34], pArr[35], pArr[36], pArr[37], pArr[38], pArr[39], pArr[24], pArr[25], pArr[26], pArr[27], pArr[28], pArr[29], pArr[30], pArr[31], pArr[16], pArr[17], pArr[18], pArr[19], pArr[20], pArr[21], pArr[22], pArr[23], pArr[8], pArr[9], pArr[10], pArr[11], pArr[12], pArr[13], pArr[14], pArr[15], pArr[0], pArr[1], pArr[2], pArr[3], pArr[4], pArr[5], pArr[6], pArr[7] }; } private int[,][] texelTuningRuntimeVals = new int[33, 14][]; private int[,][] texelTuningVals = new int[3, 6][]; private int[,] texelTuningAdjustIterations = new int[6, 64]; private int[][] texelTuningRuntimePositionalValsV2EG = new int[14][]; private int[][] texelTuningRuntimePositionalValsV2LG = new int[14][]; private int[] texelPieceEvaluationsV2EG = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[] texelPieceEvaluationsV2LG = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[] texelKingSafetyR1EvaluationsEG = new int[9]; private int[] texelKingSafetyR2EvaluationsEG = new int[17]; private int[] texelKingSafetyR1EvaluationsLG = new int[9]; private int[] texelKingSafetyR2EvaluationsLG = new int[17]; private int[] texelKingSafetySREvaluationsPT1EG = new int[12]; private int[] texelKingSafetySREvaluationsPT2EG = new int[12]; private int[] texelKingSafetySREvaluationsPT3EG = new int[12]; private int[] texelKingSafetySREvaluationsPT4EG = new int[12]; private int[] texelKingSafetySREvaluationsPT5EG = new int[12]; private int[] texelKingSafetySREvaluationsPT6EG = new int[12]; private int[] texelKingSafetySREvaluationsPT1LG = new int[12]; private int[] texelKingSafetySREvaluationsPT2LG = new int[12]; private int[] texelKingSafetySREvaluationsPT3LG = new int[12]; private int[] texelKingSafetySREvaluationsPT4LG = new int[12]; private int[] texelKingSafetySREvaluationsPT5LG = new int[12]; private int[] texelKingSafetySREvaluationsPT6LG = new int[12]; private int[,] texelMobilityStraightEG = new int[14, 15], texelMobilityStraightLG = new int[14, 15]; private int[,] texelMobilityDiagonalEG = new int[14, 14], texelMobilityDiagonalLG = new int[14, 14]; private int[] texelPieceEvaluations = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[] blackSidedSquares = new int[64] { 56, 57, 58, 59, 60, 61, 62, 63, 48, 49, 50, 51, 52, 53, 54, 55, 40, 41, 42, 43, 44, 45, 46, 47, 32, 33, 34, 35, 36, 37, 38, 39, 24, 25, 26, 27, 28, 29, 30, 31, 16, 17, 18, 19, 20, 21, 22, 23, 08, 09, 10, 11, 12, 13, 14, 15, 00, 01, 02, 03, 04, 05, 06, 07 }; private int[,] T_Pawns = new int[3, 64] { { 0, 0, 0, 0, 0, 0, 0, 0, 98, 134, 61, 95, 68, 126, 34, -11, -6, 7, 26, 31, 65, 56, 25, -20, -14, 13, 6, 21, 23, 12, 17, -23, -27, -2, -5, 12, 17, 6, 10, -25, -26, -4, -4, -10, 3, 3, 33, -12, -35, -1, -20, -23, -15, 24, 38, -22, 0, 0, 0, 0, 0, 0, 0, 0, } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { 0, 0, 0, 0, 0, 0, 0, 0, 178, 173, 158, 134, 147, 132, 165, 187, 94, 100, 85, 67, 56, 53, 82, 84, 32, 24, 13, 5, -2, 4, 17, 17, 13, 9, -3, -7, -7, -8, 3, -1, 4, 7, -6, 1, 0, -5, -1, -8, 13, 8, 8, 10, 13, 0, 2, -7, 0, 0, 0, 0, 0, 0, 0, 0, } }; private int[,] T_Knights = new int[3, 64] { { -167, -89, -34, -49, 61, -97, -15, -107, -73, -41, 72, 36, 23, 62, 7, -17, -47, 60, 37, 65, 84, 129, 73, 44, -9, 17, 19, 53, 37, 69, 18, 22, -13, 4, 16, 13, 28, 19, 21, -8, -23, -9, 12, 10, 19, 17, 25, -16, -29, -53, -12, -3, -1, 18, -14, -19, -105, -21, -58, -33, -17, -28, -19, -23 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -58, -38, -13, -28, -31, -27, -63, -99, -25, -8, -25, -2, -9, -25, -24, -52, -24, -20, 10, 9, -1, -9, -19, -41, -17, 3, 22, 22, 22, 11, 8, -18, -18, -6, 16, 25, 16, 17, 4, -18, -23, -3, -1, 15, 10, -3, -20, -22, -42, -20, -10, -5, -2, -20, -23, -44, -29, -51, -23, -15, -22, -18, -50, -64 } }; private int[,] T_Bishops = new int[3, 64] { { -29, 4, -82, -37, -25, -42, 7, -8, -26, 16, -18, -13, 30, 59, 18, -47, -16, 37, 43, 40, 35, 50, 37, -2, -4, 5, 19, 50, 37, 37, 7, -2, -6, 13, 13, 26, 34, 12, 10, 4, 0, 15, 15, 15, 14, 27, 18, 10, 4, 15, 16, 0, 7, 21, 33, 1, -33, -3, -14, -21, -13, -12, -39, -21 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -14, -21, -11, -8, -7, -9, -17, -24, -8, -4, 7, -12, -3, -13, -4, -14, 2, -8, 0, -1, -2, 6, 0, 4, -3, 9, 12, 9, 14, 10, 3, 2, -6, 3, 13, 19, 7, 10, -3, -9, -12, -3, 8, 10, 13, 3, -7, -15, -14, -18, -7, -1, 4, -9, -15, -27, -23, -9, -23, -5, -9, -16, -5, -17 } }; private int[,] T_Rooks = new int[3, 64] { { 32, 42, 32, 51, 63, 9, 31, 43, 27, 32, 58, 62, 80, 67, 26, 44, -5, 19, 26, 36, 17, 45, 61, 16, -24, -11, 7, 26, 24, 35, -8, -20, -36, -26, -12, -1, 9, -7, 6, -23, -45, -25, -16, -17, 3, 0, -5, -33, -44, -16, -20, -9, -1, 11, -6, -71, -19, -13, 1, 17, 16, 7, -37, -26 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { 13, 10, 18, 15, 12, 12, 8, 5, 11, 13, 13, 11, -3, 3, 8, 3, 7, 7, 7, 5, 4, -3, -5, -3, 4, 3, 13, 1, 2, 1, -1, 2, 3, 5, 8, 4, -5, -6, -8, -11, -4, 0, -5, -1, -7, -12, -8, -16, -6, -6, 0, 2, -9, -9, -11, -3, -9, 2, 3, -1, -5, -13, 4, -20 } }; private int[,] T_Queens = new int[3, 64] { { -28, 0, 29, 12, 59, 44, 43, 45, -24, -39, -5, 1, -16, 57, 28, 54, -13, -17, 7, 8, 29, 56, 47, 57, -27, -27, -16, -16, -1, 17, -2, 1, -9, -26, -9, -10, -2, -4, 3, -3, -14, 2, -11, -2, -5, 2, 14, 5, -35, -8, 11, 2, 8, 15, -3, 1, -1, -18, -9, 10, -15, -25, -31, -50 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -9, 22, 22, 27, 27, 19, 10, 20, -17, 20, 32, 41, 58, 25, 30, 0, -20, 6, 9, 49, 47, 35, 19, 9, 3, 22, 24, 45, 57, 40, 57, 36, -18, 28, 19, 47, 31, 34, 39, 23, -16, -27, 15, 6, 9, 17, 10, 5, -22, -23, -30, -16, -16, -23, -36, -32, -33, -28, -22, -43, -5, -32, -20, -41 } }; private int[,] T_Kings = new int[3, 64] { { -65, 23, 16, -15, -56, -34, 2, 13, 29, -1, -20, -7, -8, -4, -38, -29, -9, 24, 2, -16, -20, 6, 22, -22, -17, -20, -12, -27, -30, -25, -14, -36, -49, -1, -27, -39, -46, -44, -33, -51, -14, -14, -22, -46, -44, -30, -15, -27, 1, 7, -8, -64, -43, -16, 9, 8, -15, 36, 12, -54, 8, -28, 24, 14 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -74, -35, -18, -18, -11, 15, 4, -17, -12, 17, 14, 17, 17, 38, 23, 11, 10, 17, 23, 15, 20, 45, 44, 13, -8, 22, 24, 27, 26, 33, 26, 3, -18, -4, 21, 24, 27, 23, 9, -11, -19, -3, 11, 21, 23, 16, 7, -9, -27, -11, 4, 13, 14, 4, -5, -17, -53, -34, -21, -11, -28, -14, -24, -43 } }; private int[] paramsLowerLimits = new int[5] { -10000, -10000, -10000, -10000, -10000 }; private int[] paramsUpperLimits = new int[5] { 10000, 10000, 10000, 10000, 10000 }; private List<TLM_ChessGame> threadDataset; private int threadFrom, threadTo; private int[] threadParams; private int customThreadID = 0; private ulong ulAllThreadIDsUnfinished = 0; private double lastCostVal = 0d; private double sumCostVals = 0d; private int costCalculations = 0; private readonly string[] TEXELPRINT_GAMEPARTS = new string[3] { "Early Game: ", "Mid Game: ", "Late Game: "}; private readonly string[] TEXELPRINT_PIECES = new string[6] { "Bauer: ", "Springer: ", "Lufer: ", "Turm: ", "Dame: ", "Knig: "}; private double[] earlyGameMultipliers = new double[33]; private double[] middleGameMultipliers = new double[33]; private double[] lateGameMultipliers = new double[33]; private int[] pieceTypeGameProgressImpact = new int[14] { 0, 0, 1, 1, 2, 4, 0, 0, 0, 1, 1, 2, 4, 0 }; private void PrecalculateMultipliers() { if (BOARD_MANAGER_ID == ENGINE_VALS.PARALLEL_BOARDS - 1) SNAPSHOT_WRITLINE_REPLACEMENT(); for (int i = 0; i < 25; i++) { earlyGameMultipliers[i] = EGMultiplierFunction(i); lateGameMultipliers[i] = LGMultiplierFunction(i); if (BOARD_MANAGER_ID == ENGINE_VALS.PARALLEL_BOARDS - 1) SNAPSHOT_WRITLINE_REPLACEMENT("[" + i + "] "+ earlyGameMultipliers[i] + " | "+ middleGameMultipliers[i] + " | "+ lateGameMultipliers[i]); } } private double MultiplierFunction(double pVal, double pXShift) { double d = Math.Exp(1d /6d * (pVal - pXShift)); return 5 * (d /Math.Pow(d + 1, 2d)); } private double EGMultiplierFunction(double pVal) { return Math.Clamp(1 /16d * (pVal - 4d), 0d, 1d); } private double LGMultiplierFunction(double pVal) { return Math.Clamp(1 /-16d * (pVal - 4d) + 1d, 0d, 1d); } private double EGMultiplierFunction2(double pVal) { return Math.Clamp(1 /32d * pVal, 0d, 1d); } private double LGMultiplierFunction2(double pVal) { return Math.Clamp(1 /-32d * pVal + 1d, 0d, 1d); } private void TuneWithTxtFile(string pTXTName) { List<TLM_ChessGame> gameDataset = new List<TLM_ChessGame>(); string tPath = PathManager.GetTXTPath(pTXTName); string[] tStrs = File.ReadAllLines(tPath); List<string> tGames = new List<string>(); foreach (string s in tStrs) if (s.Contains(';') && s.Replace(" ", "") != "") tGames.Add(s); foreach (string s in tGames) { TLM_ChessGame tGame = CGFF.GetGame(s); LoadFenString(tGame.startFen); foreach (int hMove in tGame.hashedMoves) { List<Move> moveOptionList = new List<Move>(); GetLegalMoves(ref moveOptionList); int tL = moveOptionList.Count; for (int j = 0; j < tL; j++) { Move tMove = moveOptionList[j]; if (tMove.moveHash == hMove) { tGame.actualMoves.Add(tMove); PlainMakeMove(tMove); tL = -1; break; } } if (tL != -1) break; } gameDataset.Add(tGame); } SNAPSHOT_WRITLINE_REPLACEMENT("[TLM TEXEL TUNER] " + tGames.Count + " Games Loaded In!"); BOT_MAIN.curTEXELPARAMS = new int[TEXEL_PARAMS]; BOT_MAIN.ParallelTexelTuning(gameDataset); } private void LoadBestTexelParamsIn() { int[] ttt = new int[778] { 82, 341, 416, 470, 1106, 102, 302, 304, 518, 960, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, -46, 0, -20, 0, 64, -21, -71, 37, 29, 6, 98, 13, 44, 0, -26, -14, -36, -20, 94, 16, 60, 10, -62, -19, -38, -8, -28, 14, -26, -4, -32, -28, -52, 30, 56, -40, -72, -22, 100, 4, -98, -34, 6, -49, 32, -10, 72, 20, 84, -56, -60, -112, 128, -28, 152, 34, 26, -52, 200, -56, 76, 44, -56, -113, -156, 188, -39, 28, 200, -90, -60, -86, 100, -178, -119, -200, 200, 200, -20, -22, -78, -158, -200, 196, 200, -200, -200, -200, 104, 200, 138, -122, 200, 200, 124, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 200, 156, -37, -68, -148, -200, 200, -70, 72, 76, -31, -200, -21, 178, -200, 200, 200, -200, 123, -188, -6, 164, -74, 24, -28, -8, 71, -50, -112, -200, -8, -44, 27, -23, -50, 19, 19, 41, 150, 152, 4, -98, -36, -34, 174, -106, -16, 17, 141, -48, -108, 162, 6, -112, -52, 76, 68, 8, -86, 68, -176, 189, 81, 162, -200, 152, -41, 128, 172, -173, -144, 56, 22, 94, -28, 32, 16, -63, 36, -200, -200, -200, -22, 56, -116, 76, -36, -30, 100, 52, -166, -114, 142, -52, -44, -200, -18, -72, 60, 200, -160, 96, 46, -200, -28, -32, -44, 132, 60, -200, -137, -200, -176, 200, -200, -200, 4, 200, -200, 72, 200, -78, 200, 160, -105, 200, 96, -114, 200, 200, -88, -24, 11, -34, 184, 26, 83, -140, 10, -16, -72, -200, 12, -200, 46, -200, 11, 82, 66, -102, 22, -184, 32, 114, 140, -26, -18, -36, 66, 100, 25, -24, 133, -96, 50, 2, 80, 184, 43, -136, 44, 124, -148, 180, 69, -126, -200, 6, 78, -96, 89, -68, 200, -116, 114, 158, 5, -154, 115, 200, -152, -171, 41, -80, -23, 137, 98, -80, 40, -42, 200, 52, 146, 200, 6, -112, 32, 200, 132, 4, 90, -200, -200, 104, 67, -56, 186, 124, 140, 97, -144, 200, -4, -160, -117, -200, 24, -80, 200, 28, -46, -24, -52, -200, -200, 72, 20, 34, 200, -16, 88, 56, 200, -146, 120, 174, 200, -200, -86, 125, 172, -70, 4, 124, -72, 0, -2, 70, -14, 48, -32, 200, 80, 24, -132, 74, -44, 184, -4, -136, 0, -16, 20, -18, -32, 96, 92, 56, 2, 174, 196, -200, -56, -116, 88, 200, -8, 168, -13, 74, -106, 200, -182, 80, 82, -128, -16, 90, -200, 66, -88, 58, -16, 80, -34, 96, -95, -96, -200, 76, 26, -72, 32, -27, -108, 164, 200, -36, -93, -10, -56, 22, 36, 74, -200, -96, 200, 88, -88, 156, -92, 96, -200, 200, 191, -8, 62, -8, -100, 136, -72, -36, 200, -64, -114, 153, -110, 174, 46, 108, 142, 121, -200, 108, -200, 74, -4, 104, -200, 116, 82, 200, -76, 176, -200, 76, -8, 200, 46, 29, -86, 12, -24, -80, -12, 200, 124, -16, 54, 104, 200, -94, 140, 36, 32, -64, 24, -178, 15, -200, 0, -200, 4, -32, -124, 148, 176, 192, 90, 164, -91, 200, 172, -200, 64, 34, 40, -200, 0, -200, 12, -124, 48, -200, -56, 184, -8, -184, 0, 200, -16, 200, -8, 180, -18, -20, 24, -200, -58, 174, -200, 40, -4, -200, -24, 200, 54, 200, -24, -32, 37, 192, 48, 44, 26, 200, -22, 200, -145, -200, 30, 86, 54, 200, -102, -34, 94, -98, 92, -200, -76, 196, -18, -200, -180, 16, 186, -92, -200, -200, 164, -200, 62, 192, 159, -112, -12, -70, 184, 104, 200, -200, -148, -4, 86, -144, 200, -100, 200, 200, -104, 114, 132, -168, 12, 56, -10, 82, 200, -200, -200, -196, -6, 52, -200, 84, 200, -192, 128, 200, -200, -200, 200, 88, 168, -32, -84, 172, 52, -172, 0, -40, 68, -186, 42, 96, -200, -198, 200, -56, -176, 88, 0, 86, 16, -124, -46, 40, -16, -4, 54, -184, 200, 58, -200, 77, -200, -44, 102, 0, -50, -10, -92, 100, -86, 8, 20, -20, -200, 38, -200, -49, -4, 2, -200, 78, 0, -40, -92, 32, 0, -164, -88, -38, -138, -118, 29, -34, -200, -200, -200, -71, -200, 200, -200, -108, -200, 0, 192, -24, 104, -200, 200, 190, -28, -200, -200, -200, 128, -96, 200, 200, 200, 200, -200, -200, 177, -24, 200, 132, 200, -190, 200, -130, 200, 148, 200, 200, -200, -100, 200, -196, -200, 90, 200, -200, 200, 200, -200, -200, -200, -200, -200, 118, -200, 85, -200, 166, 199, -200 }; SetupTexelEvaluationParams(ttt); } private void SetupTexelEvaluationParams(int[] pParams) { texelPieceEvaluationsV2EG[8] = -(texelPieceEvaluationsV2EG[1] = pParams[0]); texelPieceEvaluationsV2EG[9] = -(texelPieceEvaluationsV2EG[2] = pParams[1]); texelPieceEvaluationsV2EG[10] = -(texelPieceEvaluationsV2EG[3] = pParams[2]); texelPieceEvaluationsV2EG[11] = -(texelPieceEvaluationsV2EG[4] = pParams[3]); texelPieceEvaluationsV2EG[12] = -(texelPieceEvaluationsV2EG[5] = pParams[4]); texelPieceEvaluationsV2LG[8] = -(texelPieceEvaluationsV2LG[1] = pParams[5]); texelPieceEvaluationsV2LG[9] = -(texelPieceEvaluationsV2LG[2] = pParams[6]); texelPieceEvaluationsV2LG[10] = -(texelPieceEvaluationsV2LG[3] = pParams[7]); texelPieceEvaluationsV2LG[11] = -(texelPieceEvaluationsV2LG[4] = pParams[8]); texelPieceEvaluationsV2LG[12] = -(texelPieceEvaluationsV2LG[5] = pParams[9]); int c = 10; for (int p = 1; p < 7; p++) { for (int s = 0; s < 64; s++) { texelTuningRuntimePositionalValsV2EG[p + 7][blackSidedSquares[s]] = -(texelTuningRuntimePositionalValsV2EG[p][s] = pParams[c++]); texelTuningRuntimePositionalValsV2LG[p + 7][blackSidedSquares[s]] = -(texelTuningRuntimePositionalValsV2LG[p][s] = pParams[c++]); } } return; for (int p = 2; p < 7; p++) { for (int a = 0; a < 15; a++) { if (a != 14) { texelMobilityDiagonalEG[p + 7, a] = -(texelMobilityDiagonalEG[p, a] = pParams[c++]); texelMobilityDiagonalLG[p + 7, a] = -(texelMobilityDiagonalLG[p, a] = pParams[c++]); } texelMobilityStraightEG[p + 7, a] = -(texelMobilityStraightEG[p, a] = pParams[c++]); texelMobilityStraightLG[p + 7, a] = -(texelMobilityStraightLG[p, a] = pParams[c++]); } } for (int i = 0; i < 12; i++) { texelKingSafetySREvaluationsPT1EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT2EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT3EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT4EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT5EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT6EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT1LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT2LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT3LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT4LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT5LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT6LG[i] = pParams[c++]; } } private void PrintDefinedTexelParams(int[] pParams) { int c = 0; for (int t = 0; t < 3; t++) { SNAPSHOT_WRITLINE_REPLACEMENT(TEXELPRINT_GAMEPARTS[t]); for (int p = 0; p < 6; p++) { SNAPSHOT_WRITLINE_REPLACEMENT(TEXELPRINT_PIECES[p]); texelTuningVals[t, p] = new int[64]; for (int s = 0; s < 64; s++) { if (s % 8 == 0 && s != 0) SNAPSHOT_WRITLINE_REPLACEMENT(); SNAPSHOT_WRITLINE_REPLACEMENT((texelTuningVals[t, p][s] = pParams[c++]) + ", "); } SNAPSHOT_WRITLINE_REPLACEMENT(); } } piecePositionEvals = GetInterpolatedProcessedValues(texelTuningVals); } public void TLMTuning(List<TLM_ChessGame> pDataset) { int tGameDataSetLen = pDataset.Count; int[,][] tRatio = new int[33, 6][]; int[,][] tTotalMoves = new int[33, 6][]; double[,][] tSummedRatios = new double[33, 6][]; double[,][] tSummedDataAmount = new double[33, 6][]; double[,][] tTuningResults = new double[33, 6][]; for (int t = 1; t < 33; t++) { for (int p = 0; p < 6; p++) { tRatio[t, p] = new int[64]; tTotalMoves[t, p] = new int[64]; tSummedRatios[t, p] = new double[64]; tSummedDataAmount[t, p] = new double[64]; tTuningResults[t, p] = new double[64]; } } for (int j = 0; j < tGameDataSetLen; j++) { TLM_ChessGame tGame = pDataset[j]; int tGR = tGame.gameResult - 1; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count - 5; for (int i = 0; i < tL; i++) { if (tGame.isMoveNonTactical[i]) { int tPieceAmount = ULONG_OPERATIONS.CountBits(allPieceBitboard); for (int s = 0; s < 64; s++) { int tPT = pieceTypeArray[s] - 1; if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, s)) { tTotalMoves[tPieceAmount, tPT][s]++; tRatio[tPieceAmount, tPT][s] += tGR; } else if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, s)) { int b = blackSidedSquares[s]; tTotalMoves[tPieceAmount, tPT][b]++; tRatio[tPieceAmount, tPT][b] += tGR; } } } PlainMakeMove(tGame.actualMoves[i]); } } double[,] allMultipliers = new double[33, 33]; for (int sh = 0; sh < 33; sh++) { for (int i = 0; i < 33; i++) { allMultipliers[sh, i] = MultiplierFunction(i, sh); } } for (int t = 1; t < 33; t++) { for (int p = 0; p < 6; p++) { for (int s = 0; s < 64; s++) { for (int t2 = 1; t2 < 33; t2++) { double cmult = allMultipliers[t, t2]; tSummedRatios[t, p][s] += tRatio[t2, p][s] * cmult; tSummedDataAmount[t, p][s] += tTotalMoves[t2, p][s] * cmult; } tTuningResults[t, p][s] = TTT(tSummedRatios[t, p][s], tSummedDataAmount[t, p][s]); } } } int c = 0; int[] tparams = new int[1152]; for (int t = 1; t < 33; t += 15) { if (t == 31) t = 32; SNAPSHOT_WRITLINE_REPLACEMENT("PieceCount = " + t + ": "); for (int p = 0; p < 6; p++) { SNAPSHOT_WRITLINE_REPLACEMENT(TEXELPRINT_PIECES[p]); for (int s = 0; s < 64; s++) { if (s % 8 == 0 && s != 0) SNAPSHOT_WRITLINE_REPLACEMENT(); SNAPSHOT_WRITLINE_REPLACEMENT((tparams[c++] = (int)(tTuningResults[t, p][s] * 100)).ToString().Replace(",", ".") + "("+ (int)tSummedDataAmount[t, p][s] + ")"+ ", "); } SNAPSHOT_WRITLINE_REPLACEMENT(); } } string tS = "PARAMS: {"; for (int i = 0; i < tparams.Length; i++) tS += tparams[i] + ","; tS = tS.Substring(0, tS.Length - 1) + "}\n"; SNAPSHOT_WRITLINE_REPLACEMENT(tS); TexelTuning(pDataset, tparams); } private double TTT(double d1, double d2) { if (d2 == 0) return 0; return d1 /d2; } public void TexelTuning(List<TLM_ChessGame> pDataset, int[] pCurBestParams) { Stopwatch sw = Stopwatch.StartNew(); string tPath = PathManager.GetTXTPath("OTHER/TEXEL_TUNING"); int paramCount = pCurBestParams.Length; double bestAvrgCost = CalculateAverageTexelCost(pDataset, pCurBestParams); SNAPSHOT_WRITLINE_REPLACEMENT("CUR PARAMS COST: " + bestAvrgCost); int packetSize = Math.Clamp(paramCount /ENGINE_VALS.CPU_CORES, 1, 100000); paramsLowerLimits = new int[paramCount]; paramsUpperLimits = new int[paramCount]; for (int i = 0; i < paramCount; i++) { int lim = i < 10 ? 100000 : 200; paramsLowerLimits[i] = -lim; paramsUpperLimits[i] = lim; } SNAPSHOT_WRITLINE_REPLACEMENT("PARAM-COUNT: " + paramCount); SNAPSHOT_WRITLINE_REPLACEMENT("PACKET-SIZE: " + packetSize); while (packetSize <= paramCount) { BOT_MAIN.TEXELfinished = 0; int lM = 0, tC = 0; ulong tUL = 0ul; for (int m = packetSize; lM < paramCount; m += packetSize) { if (m > paramCount) m = paramCount; tUL = ULONG_OPERATIONS.SetBitToOne(tUL, ++tC); lM = m; } tC = lM = 0; for (int m = packetSize; lM < paramCount; m += packetSize) { if (m > paramCount) m = paramCount; tC++; BOT_MAIN.boardManagers[tC].SetPlayTexelVals(pDataset, lM, m, pCurBestParams, paramsLowerLimits, paramsUpperLimits, tC, tUL); ThreadPool.QueueUserWorkItem(new WaitCallback(BOT_MAIN.boardManagers[tC].TexelTuningThreadedPackage)); lM = m; } packetSize = paramCount + 1; int tmod = 0; while (tC != BOT_MAIN.TEXELfinished) { if (++tmod % 20 == 0) { WriteTexelParamsToTXT(tPath, BOT_MAIN.curTEXELPARAMS); SNAPSHOT_WRITLINE_REPLACEMENT(CalculateAverageTexelCost(pDataset, BOT_MAIN.curTEXELPARAMS) + " | "+ BOT_MAIN.TEXELadjustmentsmade); SNAPSHOT_WRITLINE_REPLACEMENT(ULONG_OPERATIONS.GetBitVisualization(BOT_MAIN.TEXELfinishedwithoutimpovement)); } Thread.Sleep(100); } SNAPSHOT_WRITLINE_REPLACEMENT("One Thread Generation FINISHED! :) :) :)"); pCurBestParams = BOT_MAIN.curTEXELPARAMS; } sw.Stop(); WriteTexelParamsToTXT(tPath, BOT_MAIN.curTEXELPARAMS); SNAPSHOT_WRITLINE_REPLACEMENT("END COST: " + CalculateAverageTexelCost(pDataset, BOT_MAIN.curTEXELPARAMS)); SNAPSHOT_WRITLINE_REPLACEMENT(BOT_MAIN.TEXELadjustmentsmade); SNAPSHOT_WRITLINE_REPLACEMENT(sw.ElapsedMilliseconds); } public void TexelTuningThreadedPackage(object obj) { SNAPSHOT_WRITLINE_REPLACEMENT("Started CThreadID [" + customThreadID + "] which is handling Params ["+ threadFrom + "] - ["+ threadTo + "]"); bool firstIter = true; do { double bestAvrgCost = CalculateAverageTexelCost(threadDataset, threadParams); int adjust_val = firstIter ? 512 : 8; do { adjust_val /= 2; bool improvedAvrgCost = true; while (improvedAvrgCost) { improvedAvrgCost = false; for (int i = threadFrom; i < threadTo; i++) { bool improvedWithThisParam = true; int tadjustval = adjust_val; bool lastTimeMaximized = false, lastTimeMinimized = false; while (improvedWithThisParam) { improvedWithThisParam = false; int[] curParams = (int[])threadParams.Clone(); int paramBefore = curParams[i]; curParams[i] = Math.Clamp(paramBefore + adjust_val, paramsLowerLimits[i], paramsUpperLimits[i]); double curAvrgCost = CalculateAverageTexelCost(threadDataset, curParams); if (curAvrgCost < bestAvrgCost) { improvedAvrgCost = true; improvedWithThisParam = true; SNAPSHOT_WRITLINE_REPLACEMENT("Improved Param [" + i + "] at CThreadID ["+ customThreadID + "]: +"+ adjust_val + " ("+ GetDoublePrecentageString(bestAvrgCost - curAvrgCost) + ")"); bestAvrgCost = curAvrgCost; threadParams = curParams; BOT_MAIN.TEXELadjustmentsmade++; BOT_MAIN.TEXELfinishedwithoutimpovement = ulAllThreadIDsUnfinished; if (lastTimeMaximized) { adjust_val *= 4; lastTimeMaximized = false; } else lastTimeMaximized = true; lastTimeMinimized = false; } else { curParams[i] = Math.Clamp(paramBefore - adjust_val, paramsLowerLimits[i], paramsUpperLimits[i]); curAvrgCost = CalculateAverageTexelCost(threadDataset, curParams); if (curAvrgCost < bestAvrgCost) { improvedAvrgCost = true; improvedWithThisParam = true; SNAPSHOT_WRITLINE_REPLACEMENT("Improved Param [" + i + "] at CThreadID ["+ customThreadID + "]: -"+ adjust_val + " ("+ GetDoublePrecentageString(bestAvrgCost - curAvrgCost) + ")"); bestAvrgCost = curAvrgCost; threadParams = curParams; BOT_MAIN.TEXELadjustmentsmade++; BOT_MAIN.TEXELfinishedwithoutimpovement = ulAllThreadIDsUnfinished; if (lastTimeMinimized) { adjust_val *= 4; lastTimeMinimized = false; } else lastTimeMinimized = true; lastTimeMaximized = false; } } if (adjust_val != 1) adjust_val /= 2; for (int j = threadFrom; j < threadTo; j++) { BOT_MAIN.curTEXELPARAMS[j] = threadParams[j]; } threadParams = (int[])BOT_MAIN.curTEXELPARAMS.Clone(); bestAvrgCost = CalculateAverageTexelCost(threadDataset, threadParams); } adjust_val = tadjustval; } } } while (adjust_val != 1); BOT_MAIN.TEXELfinishedwithoutimpovement = ULONG_OPERATIONS.SetBitToZero(BOT_MAIN.TEXELfinishedwithoutimpovement, customThreadID); SNAPSHOT_WRITLINE_REPLACEMENT("FULLY FINISHED " + customThreadID + ". IMPROVEMENT THREAD PACKAGE CYCLE"); firstIter = false; } while (BOT_MAIN.TEXELfinishedwithoutimpovement != 0); BOT_MAIN.TEXELfinished++; } private void WriteTexelParamsToTXT(string pPath, int[] pParams) { try { string tS = "PARAMS: {"; for (int i = 0; i < pParams.Length; i++) tS += pParams[i] + ","; tS = tS.Substring(0, tS.Length - 1) + "}\n"; File.AppendAllText(pPath, tS); } catch { SNAPSHOT_WRITLINE_REPLACEMENT("Mal wieder TXT zu lange gebraucht um zu aktualisieren."); } } private double costSum = 0d; private int texelCostMovesEvaluated = 0; private double CalculateAverageTexelCost(List<TLM_ChessGame> tDataset, int[] pParams, bool pFullCost = true) { costSum = 0d; texelCostMovesEvaluated = 0; SetupTexelEvaluationParams(pParams); int tGameDataSetLen = tDataset.Count; int start = 0, end = tGameDataSetLen; if (!pFullCost) { end = (start = globalRandom.Next(0, end - 256)) + 256; } for (int j = start; j < end; j++) { TLM_ChessGame tGame = tDataset[j]; double tGR = tGame.gameResult; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count - 5; texelCostMovesEvaluated += tL; for (int i = 0; i < tL; i++) { costSum += TexelCost(tGR - TexelTuningSigmoid(TexelEvaluate())); PlainMakeMove(tGame.actualMoves[i]); } } return costSum /texelCostMovesEvaluated; } private double CalculateAverageTexelCostThreadedVersionLEGACYDOESNTWORK(List<TLM_ChessGame> tDataset, int[] pParams) { Stopwatch sw = Stopwatch.StartNew(); BOT_MAIN.TEXELcostSum = 0d; BOT_MAIN.TEXELfinished = 0; BOT_MAIN.TEXELcostMovesEvaluated = 0; int tGameDataSetLen = tDataset.Count; int gamesPerThread = tGameDataSetLen /ENGINE_VALS.CPU_CORES; for (int i = 0; i < ENGINE_VALS.CPU_CORES - 1; i++) { } for (int i = 0; i < ENGINE_VALS.CPU_CORES - 1; i++) { } while (BOT_MAIN.TEXELfinished != ENGINE_VALS.CPU_CORES) Thread.Sleep(1); sw.Stop(); return BOT_MAIN.TEXELcostSum /BOT_MAIN.TEXELcostMovesEvaluated; } public void SetPlayThroughVals(List<TLM_ChessGame> pDataset, int pFrom, int pTo) { threadDataset = pDataset; threadFrom = pFrom; threadTo = pTo; } public void SetPlayTexelVals(List<TLM_ChessGame> pDataset, int pFrom, int pTo, int[] pTexelParams, int[] pLowerLimits, int[] pUpperLimits, int pThreadID, ulong pUL) { threadDataset = pDataset; threadFrom = pFrom; threadTo = pTo; threadParams = pTexelParams; paramsLowerLimits = pLowerLimits; paramsUpperLimits = pUpperLimits; customThreadID = pThreadID; ulAllThreadIDsUnfinished = pUL; } public void PlayThroughSetOfGames(object obj) { SNAPSHOT_WRITLINE_REPLACEMENT(threadFrom + "->"+ threadTo); int sortedOut = 0; for (int j = threadFrom; j < threadTo; j++) { TLM_ChessGame tGame = threadDataset[j]; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count; for (int i = 0; i < tL; i++) { int tQuietEval = isWhiteToMove ? QuiescenceWhite(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, 0, PreMinimaxCheckCheckWhite(), NULL_MOVE) : QuiescenceBlack(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, 0, PreMinimaxCheckCheckBlack(), NULL_MOVE); bool tB; tGame.isMoveNonTactical.Add(tB = (Evaluate() == tQuietEval && i > 4)); if (!tB) sortedOut++; PlainMakeMove(tGame.actualMoves[i]); } } BOT_MAIN.TEXELsortedout += sortedOut; BOT_MAIN.TEXELfinished++; } public void CalculateAverageTexelCostThreadFunction(object obj) { SetupTexelEvaluationParams(threadParams); double d = 0d; for (int j = threadFrom; j < threadTo; j++) { TLM_ChessGame tGame = threadDataset[j]; double tGR = tGame.gameResult; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count - 5; BOT_MAIN.TEXELcostMovesEvaluated += tL; for (int i = 0; i < tL; i++) { d += TexelCost(tGR - TexelTuningSigmoid(TexelEvaluate())); PlainMakeMove(tGame.actualMoves[i]); } } BOT_MAIN.TEXELcostSum += d; BOT_MAIN.TEXELfinished++; } private void ConsoleWriteLineTuneArray<T>(T[,][] pArr) { for (int j = 0; j < 3; j++) { SNAPSHOT_WRITLINE_REPLACEMENT("{"); for (int k = 0; k < 6; k++) { SNAPSHOT_WRITLINE_REPLACEMENT("{"); for (int s = 0; s < 64; s++) SNAPSHOT_WRITLINE_REPLACEMENT(pArr[j, k][s] + ", "); SNAPSHOT_WRITLINE_REPLACEMENT("\n}"); } SNAPSHOT_WRITLINE_REPLACEMENT("}"); } } private void Tune(string pGameCGFF, double pLearningRate) { TLM_ChessGame tGame = CGFF.GetGame(pGameCGFF); LoadFenString(tGame.startFen); double tDGameResult = tGame.gameResult; foreach (int hMove in tGame.hashedMoves) { Tune(tDGameResult, pLearningRate); List<Move> moveOptionList = new List<Move>(); GetLegalMoves(ref moveOptionList); int tL = moveOptionList.Count; for (int i = 0; i < tL; i++) { Move tMove = moveOptionList[i]; if (tMove.moveHash == hMove) { PlainMakeMove(tMove); tL = -1; break; } } if (tL != -1) break; } } private void Tune(double pGameResult, double pLearningRate) { int tPC = ULONG_OPERATIONS.CountBits(allPieceBitboard); double oneThroughPieceCount = 1d /tPC; double egMult = earlyGameMultipliers[tPC], mgMult = middleGameMultipliers[tPC], lgMult = lateGameMultipliers[tPC]; double tTexelResult = TexelEvaluateF(); double tSigmoidedTexelResult = TexelSigmoid(tTexelResult); double tDif = tSigmoidedTexelResult - pGameResult; double tM = oneThroughPieceCount * TexelCostDerivative(tDif) * TexelSigmoidDerivative(tTexelResult) * pLearningRate; sumCostVals += lastCostVal = TexelCost(tDif); costCalculations++; for (int i = 0; i < 64; i++) { if (ULONG_OPERATIONS.IsBitZero(allPieceBitboard, i)) continue; int tPT = pieceTypeArray[i] - 1, tI = i; if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, i)) tI = blackSidedSquares[i]; texelTuningAdjustIterations[tPT, tI]++; } } private double TexelEvaluateF() { texelTuningRuntimeVals = GetInterpolatedProcessedValues(texelTuningVals); return TexelEvaluate(); } private int TexelEvaluate() { int tEvalEG = 0, tEvalLG = 0, tProgress = 0; ulong[] attkULs = new ulong[14]; for (int p = 0; p < 64; p++) { if (((int)(allPieceBitboard >> p) & 1) == 0) continue; int aPT = pieceTypeArray[p], tPT = aPT + 7 * ((int)(blackPieceBitboard >> p) & 1); tEvalEG += texelTuningRuntimePositionalValsV2EG[tPT][p] + texelPieceEvaluationsV2EG[tPT]; tEvalLG += texelTuningRuntimePositionalValsV2LG[tPT][p] + texelPieceEvaluationsV2LG[tPT]; tProgress += pieceTypeGameProgressImpact[tPT]; } if (tProgress > 24) tProgress = 24; return (int)(earlyGameMultipliers[tProgress] * tEvalEG + lateGameMultipliers[tProgress] * tEvalLG); } private const double TexelK = 0.2; private double TexelTuningSigmoid(double pVal) { return 2d /(1 + Math.Pow(10, -TexelK * pVal /400)); } private double TexelSigmoid(double pVal) { return 2d /(Math.Exp(-0.04d * pVal) + 1d); } private double TexelSigmoidDerivative(double pVal) { double d = Math.Exp(-0.04d * pVal); return 2d * d /(25d * (d + 1d) * (d + 1d)); } private double TexelCost(double pVal) { return pVal * pVal; } private double TexelCostDerivative(double pVal) { return 2 * pVal; } private char[] fenPieces = new char[7] { 'z', 'p', 'n', 'b', 'r', 'q', 'k' }; private string[] squareNames = new string[64] { "a1", "b1", "c1", "d1", "e1", "f1", "g1", "h1", "a2", "b2", "c2", "d2", "e2", "f2", "g2", "h2", "a3", "b3", "c3", "d3", "e3", "f3", "g3", "h3", "a4", "b4", "c4", "d4", "e4", "f4", "g4", "h4", "a5", "b5", "c5", "d5", "e5", "f5", "g5", "h5", "a6", "b6", "c6", "d6", "e6", "f6", "g6", "h6", "a7", "b7", "c7", "d7", "e7", "f7", "g7", "h7", "a8", "b8", "c8", "d8", "e8", "f8", "g8", "h8"}; public string CreateFenString() { string rFEN = ""; for (int i = 7; i >= 0; i--) { int t = 0; for (int j = 0; j < 8; j++) { int sq = i * 8 + j; if (pieceTypeArray[sq] != 0) { if (t != 0) rFEN += t; t = 0; } if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, sq)) { switch (pieceTypeArray[sq]) { case 0: t++; SNAPSHOT_WRITLINE_REPLACEMENT("???"); break; case 1: rFEN += 'P'; break; case 2: rFEN += 'N'; break; case 3: rFEN += 'B'; break; case 4: rFEN += 'R'; break; case 5: rFEN += 'Q'; break; case 6: rFEN += 'K'; break; } } else { switch (pieceTypeArray[sq]) { case 0: t++; break; case 1: rFEN += 'p'; break; case 2: rFEN += 'n'; break; case 3: rFEN += 'b'; break; case 4: rFEN += 'r'; break; case 5: rFEN += 'q'; break; case 6: rFEN += 'k'; break; } } } if (t != 0) rFEN += t; if (i != 0) rFEN += "/"; } rFEN += (isWhiteToMove ? " w": " b"); rFEN += (whiteCastleRightKingSide ? " K": " "); rFEN += (whiteCastleRightQueenSide ? "Q": ""); rFEN += (blackCastleRightKingSide ? "k": ""); rFEN += (blackCastleRightQueenSide ? "q": ""); if (!whiteCastleRightKingSide && !whiteCastleRightQueenSide && !blackCastleRightKingSide && !blackCastleRightQueenSide) rFEN += "-"; if (enPassantSquare < 64) rFEN += " "+ squareNames[enPassantSquare] + " "; else rFEN += " - "; return rFEN + fiftyMoveRuleCounter + " "+ ((happenedHalfMoves - happenedHalfMoves % 2) /2); } public void LoadFenString(string fenStr) { debugFEN = fenStr; lastMadeMove = NULL_MOVE; zobristKey = 0ul; whitePieceBitboard = blackPieceBitboard = allPieceBitboard = 0ul; for (int i = 0; i < 64; i++) pieceTypeArray[i] = 0; string[] spaceSpl = fenStr.Split(' '); string[] rowSpl = spaceSpl[0].Split('/'); string epstr = spaceSpl[3]; if (epstr == "-") enPassantSquare = 65; else enPassantSquare = (epstr[0] - 'a') + 8 * (epstr[1] - '1'); isWhiteToMove = true; if (spaceSpl[1] == "b") isWhiteToMove = false; if (!isWhiteToMove) zobristKey ^= blackTurnHash; string crstr = spaceSpl[2]; whiteCastleRightKingSide = whiteCastleRightQueenSide = blackCastleRightKingSide = blackCastleRightQueenSide = false; int crStrL = crstr.Length; for (int i = 0; i < crStrL; i++) { switch (crstr[i]) { case 'K': whiteCastleRightKingSide = true; break; case 'Q': whiteCastleRightQueenSide = true; break; case 'k': blackCastleRightKingSide = true; break; case 'q': blackCastleRightQueenSide = true; break; } } fiftyMoveRuleCounter = Convert.ToInt32(spaceSpl[4]); happenedHalfMoves = Convert.ToInt32(spaceSpl[5]) * 2; if (!isWhiteToMove) happenedHalfMoves++; int tSq = 0; for (int i = rowSpl.Length; i-- > 0;) { string tStr = rowSpl[i]; int tStrLen = tStr.Length; for (int c = 0; c < tStrLen; c++) { char tChar = tStr[c]; if (Char.IsDigit(tChar)) tSq += tChar - '0'; else { bool tCol = Char.IsLower(tChar); if (tCol) blackPieceBitboard = ULONG_OPERATIONS.SetBitToOne(blackPieceBitboard, tSq); else whitePieceBitboard = ULONG_OPERATIONS.SetBitToOne(whitePieceBitboard, tSq); if (tChar == 'k') blackKingSquare = tSq; else if (tChar == 'K') whiteKingSquare = tSq; pieceTypeArray[tSq] = Array.IndexOf(fenPieces, Char.ToLower(tChar)); if (tCol) zobristKey ^= pieceHashesBlack[tSq, pieceTypeArray[tSq]]; else zobristKey ^= pieceHashesWhite[tSq, pieceTypeArray[tSq]]; tSq++; } } } if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; zobristKey ^= enPassantSquareHashes[enPassantSquare]; allPieceBitboard = whitePieceBitboard | blackPieceBitboard; if (zobristKey == 16260251586586513106) moveHashList.Clear(); else { moveHashList.Clear(); moveHashList.Add(1); moveHashList.Add(2); moveHashList.Add(3); } } private ulong[,] pieceHashesWhite = new ulong[64, 7], pieceHashesBlack = new ulong[64, 7]; private ulong blackTurnHash, whiteKingSideRochadeRightHash, whiteQueenSideRochadeRightHash, blackKingSideRochadeRightHash, blackQueenSideRochadeRightHash; private ulong[] enPassantSquareHashes = new ulong[66]; private Dictionary<ulong, int> singleCheckCaseBackup = new Dictionary<ulong, int>(); private void InitZobrist() { Random rng = new Random(31415926); for (int sq = 0; sq < 64; sq++) { enPassantSquareHashes[sq] = ULONG_OPERATIONS.GetRandomULONG(rng); for (int it = 1; it < 7; it++) { pieceHashesWhite[sq, it] = ULONG_OPERATIONS.GetRandomULONG(rng); pieceHashesBlack[sq, it] = ULONG_OPERATIONS.GetRandomULONG(rng); } } blackTurnHash = ULONG_OPERATIONS.GetRandomULONG(rng); whiteKingSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); whiteQueenSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); blackKingSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); blackQueenSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); } public void SetKnightMasks(ulong[] uls) { knightSquareBitboards = uls; } public void SetKingMasks(ulong[] uls) { kingSquareBitboards = uls; } private Move[,] whiteEnPassantMoves = new Move[64, 64]; private Move[,] blackEnPassantMoves = new Move[64, 64]; private bool[] epValidationArray = new bool[64] { false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true , true , true , true , true , true , true , true, true , true , true , true , true , true , true , true, true , true , true , true , true , true , true , true, true , true , true , true , true , true , true , true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false }; private ulong[] kingSafetyRing1 = new ulong[64], kingSafetyRing2 = new ulong[64]; private ulong[] kingSafetySpecialRingW = new ulong[64], kingSafetySpecialRingB = new ulong[64]; private ulong[] rowPrecalcs = new ulong[8], columnPrecalcs = new ulong[8]; const ulong columnUL = 0x101010101010101, rowUL = 0b11111111; private void PrecalculateKingSafetyBitboards() { for (int i = 0; i < 8; i++) { rowPrecalcs[i] = rowUL << (8 * i); columnPrecalcs[i] = columnUL << i; } for (int i = 0; i < 64; i++) { int tMod = i % 8; int tRow = (i - tMod) /8; ulong tULC = columnPrecalcs[tMod], tULR = rowPrecalcs[tRow]; ulong tULC2 = columnPrecalcs[tMod], tULR2 = rowPrecalcs[tRow]; if (tMod < 7) tULC |= columnPrecalcs[tMod + 1]; if (tMod > 0) tULC |= columnPrecalcs[tMod - 1]; if (tRow < 7) tULR |= rowPrecalcs[tRow + 1]; if (tRow > 0) tULR |= rowPrecalcs[tRow - 1]; if (tMod < 6) tULC2 |= columnPrecalcs[tMod + 2]; if (tMod > 1) tULC2 |= columnPrecalcs[tMod - 2]; if (tRow < 6) tULR2 |= rowPrecalcs[tRow + 2]; if (tRow > 1) tULR2 |= rowPrecalcs[tRow - 2]; tULR2 |= tULR; tULC2 |= tULC; kingSafetyRing1[i] = ULONG_OPERATIONS.SetBitToZero(tULR & tULC, i); kingSafetyRing2[i] = ULONG_OPERATIONS.SetBitsToZero(tULR2 & tULC2, i, i + 1, i - 1, i + 7, i + 8, i + 9, i - 7, i - 8, i - 9); } for (int i = 0; i < 64; i++) { if (i < 56) kingSafetySpecialRingW[i] = ULONG_OPERATIONS.SetBitToZero(kingSafetyRing1[i] | kingSafetyRing1[i + 8], i); else kingSafetySpecialRingW[i] = kingSafetyRing1[i]; if (i > 7) kingSafetySpecialRingB[i] = ULONG_OPERATIONS.SetBitToZero(kingSafetyRing1[i] | kingSafetyRing1[i - 8], i); else kingSafetySpecialRingB[i] = kingSafetyRing1[i]; } } private void PrecalculateEnPassantMoves() { for (int i = 0; i < 64; i++) { if (!epValidationArray[i]) continue; for (int j = 0; j < 64; j++) { if (i == j) continue; if (Math.Abs(i - j) > 9) continue; if (!epValidationArray[j]) continue; whiteEnPassantMoves[i, j] = new Move(false, i, j, j - 8); blackEnPassantMoves[i, j] = new Move(false, i, j, j + 8); } } } private void PawnAttackBitboards() { for (int sq = 0; sq < 64; sq++) { ulong u = 0ul; if (sq % 8 != 0) u = ULONG_OPERATIONS.SetBitToOne(u, sq + 7); if (sq % 8 != 7) u = ULONG_OPERATIONS.SetBitToOne(u, sq + 9); whitePawnAttackSquareBitboards[sq] = u; u = 0ul; if (sq % 8 != 0 && sq - 9 > -1) u = ULONG_OPERATIONS.SetBitToOne(u, sq - 9); if (sq % 8 != 7 && sq - 7 > -1) u = ULONG_OPERATIONS.SetBitToOne(u, sq - 7); blackPawnAttackSquareBitboards[sq] = u; } } private int[] squareConnectivesPrecalculationArray = new int[4096]; public int[] squareConnectivesCrossDirsPrecalculationArray { get; set; } = new int[4096]; private ulong[] squareConnectivesPrecalculationRayArray = new ulong[4096]; private ulong[] squareConnectivesPrecalculationLineArray = new ulong[4096]; private List<Dictionary<ulong, int>> rayCollidingSquareCalculations = new List<Dictionary<ulong, int>>(); private readonly int[] maxIntWithSpecifiedBitcount = new int[8] { 0, 0b1, 0b11, 0b111, 0b1111, 0b11111, 0b111111, 0b1111111 }; private List<ulong> differentRays = new List<ulong>(); private void SquareConnectivesPrecalculations() { for (int square = 0; square < 64; square++) { rayCollidingSquareCalculations.Add(new Dictionary<ulong, int>()); rayCollidingSquareCalculations[square].Add(0ul, square); for (int square2 = 0; square2 < 64; square2++) { if (square == square2) continue; int t = 0, t2 = 0, difSign = Math.Sign(square2 - square), itSq = square, g = 0; ulong tRay = 0ul, tExclRay = 0ul; List<int> tRayInts = new List<int>(); if (difSign == -1) g = 7; if (square % 8 == square2 % 8) { t2 = t = 1; while ((itSq += difSign * 8) < 64 && itSq > -1) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } } else if ((square - square % 8) == (square2 - square2 % 8)) { t = 1; t2 = -1; while ((itSq += difSign) % 8 != g && itSq > -1 && itSq < 64) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } } else { int dif = Math.Abs(square2 - square); if (dif % 7 == 0) { t = 2; t2 = 2; g = (difSign == 1) ? 7 : 0; while ((itSq += difSign * 7) % 8 != g && itSq < 64 && itSq > -1) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } if (ULONG_OPERATIONS.IsBitZero(tRay, square2)) { t2 = t = 0; tRay = 0ul; } } else if (dif % 9 == 0) { t = 2; t2 = -2; if (square == 0 && square2 == 63 || square == 63 && square2 == 0) SNAPSHOT_WRITLINE_REPLACEMENT("!"); while ((itSq += difSign * 9) % 8 != g && itSq < 64 && itSq > -1) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } if (ULONG_OPERATIONS.IsBitZero(tRay, square2)) { t2 = t = 0; tRay = 0ul; } } } if (square == 0 && square2 == 63) { t2 = t = 2; tRayInts.Clear(); tExclRay = tRay = ULONG_OPERATIONS.SetBitsToOne(0ul, 9, 18, 27, 36, 45, 54, 63); tRayInts = new List<int>() { 9, 18, 27, 36, 45, 54, 63 }; } else if (square2 == 0 && square == 63) { t = 2; tRayInts.Clear(); t2 = -2; tExclRay = tRay = ULONG_OPERATIONS.SetBitsToOne(0ul, 0, 9, 18, 27, 36, 45, 54); tRayInts = new List<int>() { 54, 45, 36, 27, 18, 9, 0 }; } if (tRay != 0ul && !differentRays.Contains(tRay)) { differentRays.Add(tRay); int ccount, combI = maxIntWithSpecifiedBitcount[ccount = ULONG_OPERATIONS.CountBits(tRay)]; do { ulong curAllPieceBitboard = 0ul; int solution = square; for (int j = 0; j < ccount; j++) { if (((combI >> j) & 1) == 1) { curAllPieceBitboard = ULONG_OPERATIONS.SetBitToOne(curAllPieceBitboard, tRayInts[j]); if (solution == square) solution = tRayInts[j]; } } rayCollidingSquareCalculations[square].Add(curAllPieceBitboard, solution); } while (--combI != 0); } squareConnectivesPrecalculationArray[square << 6 | square2] = t; squareConnectivesPrecalculationRayArray[square << 6 | square2] = tRay; squareConnectivesCrossDirsPrecalculationArray[square << 6 | square2] = t2; if (t != 0) squareConnectivesPrecalculationLineArray[square << 6 | square2] = (square == 0 && square2 == 63 || square2 == 0 && square == 63) ? tExclRay : ULONG_OPERATIONS.SetBitToOne(tExclRay, square2); if (squareConnectivesPrecalculationLineArray[square << 6 | square2] == 0ul && ULONG_OPERATIONS.IsBitOne(knightSquareBitboards[square], square2)) squareConnectivesPrecalculationLineArray[square << 6 | square2] = 1ul << square2; } differentRays.Clear(); } } public void SNAPSHOT_WRITLINE_REPLACEMENT() { } public void SNAPSHOT_WRITLINE_REPLACEMENT(object pStr) { } private string GetDoublePrecentageString(double pVal) { return ((int)(pVal * 1_000_000) /10_000d) + "%"; } private string ReplaceAllULONGIsBitOne(string pCode) { const string METHOD_NAME = "ULONG_OPERATIONS.IsBitOne"; int METHOD_NAME_LEN = METHOD_NAME.Length, iterations = 0; int pIndex = pCode.IndexOf(METHOD_NAME); while (pIndex != -1 && ++iterations < 10_000) { List<int> paramIndexes = new List<int>(); int openedBracketCount = 1, closedBracketCount = 0, a = METHOD_NAME_LEN + pIndex; string tpCode = pCode.Substring(0, pIndex); paramIndexes.Add(a + 1); while (++a < pCode.Length) { switch (pCode[a]) { case '(': openedBracketCount++; break; case ')': if (++closedBracketCount == openedBracketCount) { pIndex = a; a = int.MaxValue - 5; } break; case ',': if (openedBracketCount - closedBracketCount == 1) paramIndexes.Add(a + 1); break; } } if (openedBracketCount == closedBracketCount && paramIndexes.Count == 2) { tpCode += "((int)("+ pCode.Substring(paramIndexes[0], paramIndexes[1] - paramIndexes[0] - 1) + (pCode[paramIndexes[1]] == ' ' ? " >> (": " >> (") + pCode.Substring(paramIndexes[1], pIndex - paramIndexes[1]) + ")) & 1) == 1"+ pCode.Substring(pIndex + 1, pCode.Length - pIndex - 1); } pIndex = (pCode = tpCode).IndexOf(METHOD_NAME); } SNAPSHOT_WRITLINE_REPLACEMENT(iterations + " ITERATIONS"); return pCode; } private string ReplaceAllULONGIsBitZero(string pCode) { const string METHOD_NAME = "ULONG_OPERATIONS.IsBitZero"; int METHOD_NAME_LEN = METHOD_NAME.Length, iterations = 0; int pIndex = pCode.IndexOf(METHOD_NAME); while (pIndex != -1 && ++iterations < 10_000) { List<int> paramIndexes = new List<int>(); int openedBracketCount = 1, closedBracketCount = 0, a = METHOD_NAME_LEN + pIndex; string tpCode = pCode.Substring(0, pIndex); paramIndexes.Add(a + 1); while (++a < pCode.Length) { switch (pCode[a]) { case '(': openedBracketCount++; break; case ')': if (++closedBracketCount == openedBracketCount) { pIndex = a; a = int.MaxValue - 5; } break; case ',': if (openedBracketCount - closedBracketCount == 1) paramIndexes.Add(a + 1); break; } } if (openedBracketCount == closedBracketCount && paramIndexes.Count == 2) { tpCode += "((int)("+ pCode.Substring(paramIndexes[0], paramIndexes[1] - paramIndexes[0] - 1) + (pCode[paramIndexes[1]] == ' ' ? " >>": " >> ") + pCode.Substring(paramIndexes[1], pIndex - paramIndexes[1]) + ") & 1) == 0"+ pCode.Substring(pIndex + 1, pCode.Length - pIndex - 1); } pIndex = (pCode = tpCode).IndexOf(METHOD_NAME); } SNAPSHOT_WRITLINE_REPLACEMENT(iterations + " ITERATIONS"); return pCode; } private string GetThreeDigitSeperatedInteger(int pInt) { string s = pInt.ToString(), r = s[0].ToString(); int t = s.Length % 3; for (int i = 1; i < s.Length; i++) { if (i % 3 == t) r += "."; r += s[i]; } s = ""; for (int i = 0; i < r.Length; i++) s += r[i]; return s; } public double GetAverageDepth() { return (double)depths /(double)searches; } }
public class SNAPSHOT_V01_00_014 : IBoardManager  { public int TEXEL_PARAMS { get; } = 778; private const int BESTMOVE_SORT_VAL = -2_000_000_000; private const int CAPTURE_SORT_VAL = -1_000_000_000; private const int KILLERMOVE_SORT_VAL = -1000; private readonly int[,] MVVLVA_TABLE = new int[7, 7] { { 0, 0, 0, 0, 0, 0, 0 }, { 0, 1500, 1400, 1300, 1200, 1100, 1000 }, { 0, 3500, 3400, 3300, 3200, 3100, 3000 }, { 0, 4500, 4400, 4300, 4200, 4100, 4000 }, { 0, 5500, 5400, 5300, 5200, 5100, 5000 }, { 0, 9500, 9400, 9300, 9200, 9100, 9000 }, { 0, 0, 0, 0, 0, 0, 0 }}; private int BOARD_MANAGER_ID = -1; private bool debugSearchDepthResults = false; private bool debugSortResults = false; private RookMovement rookMovement; private BishopMovement bishopMovement; private QueenMovement queenMovement; private KnightMovement knightMovement; private KingMovement kingMovement; private WhitePawnMovement whitePawnMovement; private BlackPawnMovement blackPawnMovement; private Rays rays; public List<Move> moveOptionList { get; set; } private int[] pieceTypeArray = new int[64]; public ulong whitePieceBitboard, blackPieceBitboard, allPieceBitboard; private ulong zobristKey; private int whiteKingSquare, blackKingSquare, enPassantSquare = 65, happenedHalfMoves = 0, fiftyMoveRuleCounter = 0; private bool whiteCastleRightKingSide, whiteCastleRightQueenSide, blackCastleRightKingSide, blackCastleRightQueenSide; private bool isWhiteToMove; private const ulong WHITE_KING_ROCHADE = 96, WHITE_QUEEN_ROCHADE = 14, BLACK_KING_ROCHADE = 6917529027641081856, BLACK_QUEEN_ROCHADE = 1008806316530991104, WHITE_QUEEN_ATTK_ROCHADE = 12, BLACK_QUEEN_ATTK_ROCHADE = 864691128455135232; private readonly Move mWHITE_KING_ROCHADE = new Move(4, 6, 7, 5), mWHITE_QUEEN_ROCHADE = new Move(4, 2, 0, 3), mBLACK_KING_ROCHADE = new Move(60, 62, 63, 61), mBLACK_QUEEN_ROCHADE = new Move(60, 58, 56, 59); private ulong[] knightSquareBitboards = new ulong[64]; private ulong[] whitePawnAttackSquareBitboards = new ulong[64]; private ulong[] blackPawnAttackSquareBitboards = new ulong[64]; private ulong[] kingSquareBitboards = new ulong[64]; private bool[,] pieceTypeAbilities = new bool[7, 3] { { false, false, false }, { false, false, false }, { false, false, false }, { false, false, true }, { false, true, false }, { false, true, true }, { false, false, false } }; private List<int> moveHashList = new List<int>(); private ulong[] curSearchZobristKeyLine = Array.Empty<ulong>(); private Move[] debugMoveList = new Move[128]; private string debugFEN = ""; private Stopwatch globalTimer = Stopwatch.StartNew(); private Move lastMadeMove; private int depths, searches; private Random globalRandom = new Random(); public SNAPSHOT_V01_00_014(string fen) { Setup(fen); } public void Setup(string pFen) { Stopwatch setupStopwatch = Stopwatch.StartNew(); BOARD_MANAGER_ID = BOT_MAIN.curBoardManagerID; for (int i = 0; i < 33; i++) for (int j = 0; j < 14; j++) piecePositionEvals[i, j] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; for (int i = 0; i < 33; i++) for (int j = 0; j < 14; j++) texelTuningRuntimeVals[i, j] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; for (int i = 0; i < 3; i++) for (int j = 0; j < 6; j++) texelTuningVals[i, j] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; for (int i = 0; i < 14; i++) { texelTuningRuntimePositionalValsV2EG[i] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; texelTuningRuntimePositionalValsV2LG[i] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; } PrecalculateKingSafetyBitboards(); PrecalculateMultipliers(); GetLowNoisePositionalEvaluation(globalRandom); MinimaxRoot(1L); SetupConsoleWrite("[PRECALCS] Zobrist Hashing"); InitZobrist(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Knight Movement"); knightMovement = new KnightMovement(this); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Square Connectives"); SquareConnectivesPrecalculations(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Pawn Attack Bitboards"); PawnAttackBitboards(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Rays"); rays = new Rays(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); queenMovement = new QueenMovement(this); SetupConsoleWrite("[PRECALCS] Rook Movement"); rookMovement = new RookMovement(this, queenMovement); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Bishop Movement"); bishopMovement = new BishopMovement(this, queenMovement); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] King Movement"); kingMovement = new KingMovement(this); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Pawn Movement"); whitePawnMovement = new WhitePawnMovement(this); blackPawnMovement = new BlackPawnMovement(this); PrecalculateEnPassantMoves(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWriteLine("[DONE]\n\n"); LoadFenString(pFen); LoadBestTexelParamsIn(); setupStopwatch.Stop(); } private void SetupConsoleWriteLine(string pStr) { if (BOT_MAIN.isFirstBoardManagerInitialized) return; SNAPSHOT_WRITLINE_REPLACEMENT(pStr); } private void SetupConsoleWrite(string pStr) { if (BOT_MAIN.isFirstBoardManagerInitialized) return; SNAPSHOT_WRITLINE_REPLACEMENT(pStr); } public void GetLowNoisePositionalEvaluation(System.Random rng) { int[,][] digitArray = new int[3, 6][]; for (int i = 0; i < 3; i++) for (int j = 0; j < 6; j++) digitArray[i, j] = GetRand64IntArray(rng, -5, 6); lowNoisePositionEvals1 = GetInterpolatedProcessedValues(digitArray); int[,][] digitArray2 = new int[3, 6][]; for (int i = 0; i < 3; i++) for (int j = 0; j < 6; j++) digitArray2[i, j] = GetRand64IntArray(rng, -5, 6); lowNoisePositionEvals2 = GetInterpolatedProcessedValues(digitArray2); } private int[] GetRand64IntArray(System.Random rng, int pMin, int pMax) { return new int[64] { rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax) }; } private string GetAIArrayValuesStringRepresentation(int[,][] pArr) { string r = "int[,][] ReLe_AI_RESULT_VALS = new int[3, 6][] {"; for (int i = 0; i < 3; i++) { r += "{"; for (int j = 0; j < 5; j++) { r += GetIntArray64LStringRepresentation(pArr[i, j]) + ","; } r += GetIntArray64LStringRepresentation(pArr[i, 5]) + "},"; } return r.Substring(0, r.Length - 1) + "};"; } private string GetIntArray64LStringRepresentation(int[] p64LArr) { if (p64LArr == null) return ""; string r = "new int[64]{"; for (int i = 0; i < 63; i++) { r += p64LArr[i] + ","; } return r + p64LArr[63] + "}"; } public void TempStuff() { } private string[] gameResultStrings = new string[5] { "Black Has Won!", "Draw!", "White Has Won!", "Non Existant Result!", "Game is Ongoing!"}; private int[,][] lowNoisePositionEvals1, lowNoisePositionEvals2; public void ThreadSelfPlay(object obj) { PlayGameAgainstItself(obj); } public void PlayGameAgainstItself(object obj, string pStartFEN = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1", long tickLimitForEngine = ENGINE_VALS.SELF_PLAY_THINK_TIME) { int ttGState; while (BOT_MAIN.goalGameCount > BOT_MAIN.gamesPlayed) { try { string tGameStr; GetLowNoisePositionalEvaluation(globalRandom); LoadFenString(tGameStr = pStartFEN); tGameStr += ";"; int tGState = 3, tmc = 0; bool lowNoiceDecider = globalRandom.NextDouble() < 0.5d; while (tGState == 3) { piecePositionEvals = lowNoiceDecider ? lowNoisePositionEvals1 : lowNoisePositionEvals2; MinimaxRoot(tickLimitForEngine); Move tM = transpositionTable[zobristKey].bestMove; PlainMakeMove(tM); tGameStr += NuCRe.GetNuCRe(tM.moveHash) + ","; BOT_MAIN.movesPlayed++; tGState = GameState(isWhiteToMove); lowNoiceDecider = !lowNoiceDecider; tmc++; } ttGState = tGState; tGameStr += ttGState + 1; SNAPSHOT_WRITLINE_REPLACEMENT(tGameStr); BOT_MAIN.gamesPlayedResultArray[ttGState + 1]++; BOT_MAIN.gamesPlayed++; BOT_MAIN.selfPlayGameStrings.Add(tGameStr); } catch (Exception tE) { SNAPSHOT_WRITLINE_REPLACEMENT(tE.ToString()); } } } public void PlayGameOnConsoleAgainstHuman(string pStartFEN = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1", bool pHumanPlaysWhite = true, long tickLimitForEngine = 10_000_000L) { debugSearchDepthResults = true; LoadFenString(pStartFEN); if (!(pHumanPlaysWhite ^ isWhiteToMove)) { var pVS = Console.ReadLine(); if (pVS == null) return; Move tm = GetMoveOfString(pVS.ToString()); SNAPSHOT_WRITLINE_REPLACEMENT(tm); PlainMakeMove(tm); } int tGState = 3; while (tGState == 3) { MinimaxRoot(tickLimitForEngine); PlayThroughZobristTree(); Move tM = transpositionTable[zobristKey].bestMove; SNAPSHOT_WRITLINE_REPLACEMENT(tM); SNAPSHOT_WRITLINE_REPLACEMENT(CreateFenString()); PlainMakeMove(tM); tGState = GameState(isWhiteToMove); if (tGState != 3 || tM == NULL_MOVE) break; var pV = ""; tM = NULL_MOVE; do { pV = Console.ReadLine(); if (pV == null) continue; tM = GetMoveOfString(pV.ToString()); SNAPSHOT_WRITLINE_REPLACEMENT(tM); } while (tM == NULL_MOVE); PlainMakeMove(tM); tGState = GameState(isWhiteToMove); } } private void PlayThroughZobristTree() { SetJumpState(); SNAPSHOT_WRITLINE_REPLACEMENT("\n- - - - - - - - - - - - -"); int tC = 1; Dictionary<ulong, bool> usedULs = new Dictionary<ulong, bool>(); while (transpositionTable.TryGetValue(zobristKey, out TranspositionEntry tM)) { if (usedULs.ContainsKey(zobristKey)) { SNAPSHOT_WRITLINE_REPLACEMENT(tC + ": AT LEAST ONE REPETION; REST NOT VISIBLE"); break; } SNAPSHOT_WRITLINE_REPLACEMENT(tC + ": "+ tM.bestMove + " > "); usedULs.Add(zobristKey, true); PlainMakeMove(tM.bestMove); tC++; } SNAPSHOT_WRITLINE_REPLACEMENT("- - - - - - - - - - - - -\n"); LoadJumpState(); } public Move? ReturnNextMove(Move? lastMove, long pThinkingTime) { if (lastMove != null) PlainMakeMove(lastMove); if (GameState(isWhiteToMove) != 3) return null; MinimaxRoot(pThinkingTime); if (!transpositionTable.ContainsKey(zobristKey)) return null; Move tm = transpositionTable[zobristKey].bestMove; PlainMakeMove(tm); return tm; } private int[] jmpSt_pieceTypeArray; private ulong jmpSt_whitePieceBitboard, jmpSt_blackPieceBitboard; private ulong jmpSt_zobristKey; private int jmpSt_whiteKingSquare, jmpSt_blackKingSquare, jmpSt_enPassantSquare, jmpSt_happenedHalfMoves, jmpSt_fiftyMoveRuleCounter; private bool jmpSt_whiteCastleRightKingSide, jmpSt_whiteCastleRightQueenSide, jmpSt_blackCastleRightKingSide, jmpSt_blackCastleRightQueenSide; private bool jmpSt_isWhiteToMove; private ulong[] jmpSt_curSearchZobristKeyLine; private int[] jmpSt_moveHashList; public void LoadJumpState() { pieceTypeArray = (int[])jmpSt_pieceTypeArray.Clone(); whitePieceBitboard = jmpSt_whitePieceBitboard; blackPieceBitboard = jmpSt_blackPieceBitboard; zobristKey = jmpSt_zobristKey; whiteKingSquare = jmpSt_whiteKingSquare; blackKingSquare = jmpSt_blackKingSquare; enPassantSquare = jmpSt_enPassantSquare; happenedHalfMoves = jmpSt_happenedHalfMoves; fiftyMoveRuleCounter = jmpSt_fiftyMoveRuleCounter; whiteCastleRightKingSide = jmpSt_whiteCastleRightKingSide; whiteCastleRightQueenSide = jmpSt_whiteCastleRightQueenSide; blackCastleRightKingSide = jmpSt_blackCastleRightKingSide; blackCastleRightQueenSide = jmpSt_blackCastleRightQueenSide; isWhiteToMove = jmpSt_isWhiteToMove; curSearchZobristKeyLine = (ulong[])jmpSt_curSearchZobristKeyLine.Clone(); allPieceBitboard = blackPieceBitboard | whitePieceBitboard; moveHashList = jmpSt_moveHashList.ToList(); } public void SetJumpState() { jmpSt_pieceTypeArray = (int[])pieceTypeArray.Clone(); jmpSt_whitePieceBitboard = whitePieceBitboard; jmpSt_blackPieceBitboard = blackPieceBitboard; jmpSt_zobristKey = zobristKey; jmpSt_whiteKingSquare = whiteKingSquare; jmpSt_blackKingSquare = blackKingSquare; jmpSt_enPassantSquare = enPassantSquare; jmpSt_happenedHalfMoves = happenedHalfMoves; jmpSt_fiftyMoveRuleCounter = fiftyMoveRuleCounter; jmpSt_whiteCastleRightKingSide = whiteCastleRightKingSide; jmpSt_whiteCastleRightQueenSide = whiteCastleRightQueenSide; jmpSt_blackCastleRightKingSide = blackCastleRightKingSide; jmpSt_blackCastleRightQueenSide = blackCastleRightQueenSide; jmpSt_isWhiteToMove = isWhiteToMove; jmpSt_curSearchZobristKeyLine = (ulong[])curSearchZobristKeyLine.Clone(); jmpSt_moveHashList = moveHashList.ToArray(); } private int PreMinimaxCheckCheckWhite() { ulong bitShiftedKingPos = 1ul << whiteKingSquare; int curR = -1; for (int p = 0; p < 64; p++) { if (ULONG_OPERATIONS.IsBitZero(blackPieceBitboard, p)) continue; int tPT; switch (tPT = pieceTypeArray[p]) { case 1: if ((bitShiftedKingPos & blackPawnAttackSquareBitboards[p]) != 0ul) return p; break; case 2: if ((bitShiftedKingPos & knightSquareBitboards[p]) != 0ul) return p; break; case 6: break; default: if ((squareConnectivesPrecalculationLineArray[whiteKingSquare << 6 | p] & allPieceBitboard) == (1ul << p) && pieceTypeAbilities[tPT, squareConnectivesPrecalculationArray[whiteKingSquare << 6 | p]]) { if (curR != -1) return -779; curR = p; } break; } } return curR; } private int PreMinimaxCheckCheckBlack() { ulong bitShiftedKingPos = 1ul << blackKingSquare; int curR = -1; for (int p = 0; p < 64; p++) { if (ULONG_OPERATIONS.IsBitZero(whitePieceBitboard, p)) continue; int tPT; switch (tPT = pieceTypeArray[p]) { case 1: if ((bitShiftedKingPos & whitePawnAttackSquareBitboards[p]) != 0ul) return p; break; case 2: if ((bitShiftedKingPos & knightSquareBitboards[p]) != 0ul) return p; break; case 6: break; default: if ((squareConnectivesPrecalculationLineArray[blackKingSquare << 6 | p] & allPieceBitboard) == (1ul << p) && pieceTypeAbilities[tPT, squareConnectivesPrecalculationArray[blackKingSquare << 6 | p]]) { if (curR != -1) return -779; curR = p; } break; } } return curR; } private int LecacyLeafCheckingPieceCheckWhite(int pStartPos, int pEndPos, int pPieceType) { int tI, tPossibleAttackPiece; if (pPieceType == 1) { if (ULONG_OPERATIONS.IsBitOne(blackPawnAttackSquareBitboards[pEndPos], whiteKingSquare)) return pEndPos; } else if (pPieceType == 2) { if (ULONG_OPERATIONS.IsBitOne(knightSquareBitboards[pEndPos], whiteKingSquare)) return pEndPos; } else if (pPieceType != 6) { tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | pEndPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; } tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | pStartPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; return -1; } private int LecacyLeafCheckingPieceCheckBlack(int pStartPos, int pEndPos, int pPieceType) { int tI, tPossibleAttackPiece; if (pPieceType == 1) { if (ULONG_OPERATIONS.IsBitOne(whitePawnAttackSquareBitboards[pEndPos], blackKingSquare)) return pEndPos; } else if (pPieceType == 2) { if (ULONG_OPERATIONS.IsBitOne(knightSquareBitboards[pEndPos], blackKingSquare)) return pEndPos; } else if (pPieceType != 6) { tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | pEndPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; } tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | pStartPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; return -1; } public void GetLegalMoves(ref List<Move> pMoveList) { int attk; if (isWhiteToMove) { attk = PreMinimaxCheckCheckWhite(); if (attk == -779) GetLegalWhiteMovesSpecialDoubleCheckCase(ref pMoveList); else GetLegalWhiteMoves(attk, ref pMoveList); } else { attk = PreMinimaxCheckCheckBlack(); if (attk == -779) GetLegalBlackMovesSpecialDoubleCheckCase(ref pMoveList); else GetLegalBlackMoves(attk, ref pMoveList); } } private void GetLegalWhiteMoves(int pCheckingPieceSquare, ref List<Move> pMoveList) { if (pCheckingPieceSquare == -779) { GetLegalWhiteMovesSpecialDoubleCheckCase(ref pMoveList); return; } moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= blackPawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, whiteKingSquare); if (curCheckCount == 0) { if (whiteCastleRightKingSide && ((allPieceBitboard | oppAttkBitboard) & WHITE_KING_ROCHADE) == 0ul) pMoveList.Add(mWHITE_KING_ROCHADE); if (whiteCastleRightQueenSide && (allPieceBitboard & WHITE_QUEEN_ROCHADE | oppAttkBitboard & WHITE_QUEEN_ATTK_ROCHADE) == 0ul) pMoveList.Add(mWHITE_QUEEN_ROCHADE); if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, whitePieceBitboard, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[whiteKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare + 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, whitePieceBitboard, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveList(whiteKingSquare, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalWhiteCaptures(int pCheckingPieceSquare, ref List<Move> pMoveList) { if (pCheckingPieceSquare == -779) { GetLegalWhiteCapturesSpecialDoubleCheckCase(ref pMoveList); return; } moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= blackPawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, whiteKingSquare); if (curCheckCount == 0) { if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & blackPieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[whiteKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare + 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & blackPieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveListOnlyCaptures(whiteKingSquare, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalWhiteMovesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= blackPawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveList(whiteKingSquare, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalWhiteCapturesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= blackPawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveListOnlyCaptures(whiteKingSquare, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalBlackMoves(int pCheckingPieceSquare, ref List<Move> pMoveList) { if (pCheckingPieceSquare == -779) { GetLegalBlackMovesSpecialDoubleCheckCase(ref pMoveList); return; } moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= whitePawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, blackKingSquare); if (curCheckCount == 0) { if (blackCastleRightKingSide && ((allPieceBitboard | oppAttkBitboard) & BLACK_KING_ROCHADE) == 0ul) pMoveList.Add(mBLACK_KING_ROCHADE); if (blackCastleRightQueenSide && (allPieceBitboard & BLACK_QUEEN_ROCHADE | oppAttkBitboard & BLACK_QUEEN_ATTK_ROCHADE) == 0ul) pMoveList.Add(mBLACK_QUEEN_ROCHADE); if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveList(p, blackKingSquare, blackPieceBitboard, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[blackKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare - 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveList(p, blackKingSquare, blackPieceBitboard, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveList(blackKingSquare, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); } private void GetLegalBlackCaptures(int pCheckingPieceSquare, ref List<Move> pMoveList) { if (pCheckingPieceSquare == -779) { GetLegalBlackCapturesSpecialDoubleCheckCase(ref pMoveList); return; } moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= whitePawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, blackKingSquare); if (curCheckCount == 0) { if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & whitePieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[blackKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare - 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & whitePieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveListOnlyCaptures(blackKingSquare, ~oppAttkBitboard & whitePieceBitboard); } private void GetLegalBlackMovesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= whitePawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveList(blackKingSquare, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); } private void GetLegalBlackCapturesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= whitePawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveListOnlyCaptures(blackKingSquare, ~oppAttkBitboard & whitePieceBitboard); } public Move GetMoveOfString(string pMove) { int tSP, tEP; string[] tSpl = pMove.Split(','); if (Char.IsNumber(pMove[0])) { tSP = Convert.ToInt32(tSpl[0]); tEP = Convert.ToInt32(tSpl[1]); } else { tSP = SQUARES.NumberNotation(tSpl[0]); tEP = SQUARES.NumberNotation(tSpl[1]); } int tPT = pieceTypeArray[tSP]; bool tIC = ULONG_OPERATIONS.IsBitOne(allPieceBitboard, tEP), tIEP = enPassantSquare == tEP && tPT == 1; if (tSpl.Length == 3) return new Move(tSP, tEP, tPT, Convert.ToInt32(tSpl[2]), tIC); if (tIEP) return new Move(true, tSP, tEP, isWhiteToMove ? tEP - 8 : tEP + 8); if (tPT == 1 && Math.Abs(tSP - tEP) > 11) return new Move(tSP, tEP, 1, false, isWhiteToMove ? tSP + 8 : tSP - 8); if (tPT == 6 && (Math.Abs(tSP - tEP) == 2 || Math.Abs(tSP - tEP) == 3)) { if (isWhiteToMove) return tEP == 6 ? mWHITE_KING_ROCHADE : mWHITE_QUEEN_ROCHADE; return tEP == 62 ? mBLACK_KING_ROCHADE : mBLACK_QUEEN_ROCHADE; } return new Move(tSP, tEP, tPT, tIC); } public void PlainMakeMove(string pMoveName) { PlainMakeMove(GetMoveOfString(pMoveName)); } public void PlainMakeMove(Move pMove) { lastMadeMove = pMove; if (isWhiteToMove) WhiteMakeMove(pMove); else BlackMakeMove(pMove); debugFEN = CreateFenString(); } public void WhiteMakeMove(Move pMove) { int tEndPos = pMove.endPos, tStartPos = pMove.startPos, tPieceType = pMove.pieceType, tPTI = pieceTypeArray[tEndPos]; fiftyMoveRuleCounter++; whitePieceBitboard ^= pMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey ^= blackTurnHash ^ enPassantSquareHashes[enPassantSquare] ^ pieceHashesWhite[tStartPos, tPieceType] ^ pieceHashesWhite[tEndPos, tPieceType]; enPassantSquare = 65; isWhiteToMove = false; switch (pMove.moveTypeID) { case 0: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 1: fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 2: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 3: whiteKingSquare = tEndPos; if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 4: if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 5: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 6: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 7: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[whiteKingSquare = tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 8: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 9: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = pMove.enPassantOption]; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 11: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; whiteKingSquare = tEndPos; pieceTypeArray[pMove.rochadeEndPos] = 4; pieceTypeArray[pMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesWhite[pMove.rochadeStartPos, 4] ^ pieceHashesWhite[pMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 12: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[pMove.enPassantOption] = 0; zobristKey ^= pieceHashesBlack[pMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 13: fiftyMoveRuleCounter = 0; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; zobristKey ^= pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, pMove.promotionType]; break; case 14: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, tPTI] ^ pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, pMove.promotionType]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; } moveHashList.Add(pMove.moveHash); if (pMove.isCapture || tPieceType == 1) { curSearchZobristKeyLine = Array.Empty<ulong>(); return; } ulong[] u = new ulong[(tPTI = curSearchZobristKeyLine.Length) + 1]; for (int i = tPTI; i-- > 0;) u[i] = curSearchZobristKeyLine[i]; u[tPTI] = zobristKey; curSearchZobristKeyLine = u; } public void BlackMakeMove(Move pMove) { int tEndPos = pMove.endPos, tStartPos = pMove.startPos, tPieceType = pMove.pieceType, tPTI = pieceTypeArray[tEndPos]; fiftyMoveRuleCounter++; blackPieceBitboard ^= pMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey ^= blackTurnHash ^ enPassantSquareHashes[enPassantSquare] ^ pieceHashesBlack[tStartPos, tPieceType] ^ pieceHashesBlack[tEndPos, tPieceType]; enPassantSquare = 65; isWhiteToMove = true; switch (pMove.moveTypeID) { case 0: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 1: fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 2: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 3: blackKingSquare = tEndPos; if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 4: if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 5: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 6: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 7: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[blackKingSquare = tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 8: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 9: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = pMove.enPassantOption]; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 11: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; blackKingSquare = tEndPos; pieceTypeArray[pMove.rochadeEndPos] = 4; pieceTypeArray[pMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesBlack[pMove.rochadeStartPos, 4] ^ pieceHashesBlack[pMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 12: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[pMove.enPassantOption] = 0; zobristKey ^= pieceHashesWhite[pMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 13: fiftyMoveRuleCounter = 0; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, pMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 14: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } zobristKey ^= pieceHashesWhite[tEndPos, tPTI] ^ pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, pMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; } moveHashList.Add(pMove.moveHash); if (pMove.isCapture || tPieceType == 1) { curSearchZobristKeyLine = Array.Empty<ulong>(); return; } ulong[] u = new ulong[(tPTI = curSearchZobristKeyLine.Length) + 1]; for (int i = tPTI; i-- > 0;) u[i] = curSearchZobristKeyLine[i]; u[tPTI] = zobristKey; curSearchZobristKeyLine = u; } public void WhiteUndoMove(Move pMove) { } private const int WHITE_CHECKMATE_VAL = 100000, BLACK_CHECKMATE_VAL = -100000, CHECK_EXTENSION_LENGTH = -12, MAX_QUIESCENCE_TOTAL_LENGTH = -32; private readonly Move NULL_MOVE = new Move(0, 0, 0); private int curSearchDepth = 0, curSubSearchDepth = -1; public int MinimaxRoot(long pTime) { evalCount = 0; searches++; int baseLineLen = 0; long tTimestamp = globalTimer.ElapsedTicks + pTime; ClearHeuristics(); transpositionTable.Clear(); ulong[] tZobristKeyLine = Array.Empty<ulong>(); if (curSearchZobristKeyLine != null) { baseLineLen = curSearchZobristKeyLine.Length; tZobristKeyLine = new ulong[baseLineLen]; Array.Copy(curSearchZobristKeyLine, tZobristKeyLine, baseLineLen); } int perftScore, tattk = isWhiteToMove ? PreMinimaxCheckCheckWhite() : PreMinimaxCheckCheckBlack(), pDepth = 1; (string, int) bookMoveTuple = TLMDatabase.SearchForNextBookMove(moveHashList); if (bookMoveTuple.Item2 != 0) { int actualMoveHash = NuCRe.GetNumber(bookMoveTuple.Item1); List<Move> tMoves = new List<Move>(); GetLegalMoves(ref tMoves); int tL = tMoves.Count; for (int i = 0; i < tL; i++) { if (tMoves[i].moveHash == actualMoveHash) { if (debugSearchDepthResults) { SNAPSHOT_WRITLINE_REPLACEMENT("TLM_DB_Count: " + bookMoveTuple.Item2); SNAPSHOT_WRITLINE_REPLACEMENT(">> " + tMoves[i]); } transpositionTable.Add(zobristKey, new TranspositionEntry(tMoves[i], Array.Empty<int>())); return 0; } } } do { curSearchDepth = pDepth; curSubSearchDepth = pDepth - 1; ulong[] completeZobristHistory = new ulong[baseLineLen + pDepth - CHECK_EXTENSION_LENGTH + 1]; for (int i = 0; i < baseLineLen; i++) completeZobristHistory[i] = curSearchZobristKeyLine[i]; curSearchZobristKeyLine = completeZobristHistory; if (isWhiteToMove) { if (tattk == -1) perftScore = MinimaxWhite(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); else perftScore = MinimaxWhite(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); } else { if (tattk == -1) perftScore = MinimaxBlack(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); else perftScore = MinimaxBlack(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); } if (debugSearchDepthResults && pTime != 1L) { int tNpS = Convert.ToInt32((double)evalCount * 10_000_000d /(double)(pTime - tTimestamp + globalTimer.ElapsedTicks)); int tSearchEval = perftScore; int timeForSearchSoFar = (int)((pTime - tTimestamp + globalTimer.ElapsedTicks) /10000d); Move tBestMove = transpositionTable[zobristKey].bestMove; SNAPSHOT_WRITLINE_REPLACEMENT((tSearchEval >= 0 ? "+": "") + tSearchEval); SNAPSHOT_WRITLINE_REPLACEMENT(" " + tBestMove + "  ["); SNAPSHOT_WRITLINE_REPLACEMENT("Depth = " + pDepth + ", "); SNAPSHOT_WRITLINE_REPLACEMENT("Evals = " + GetThreeDigitSeperatedInteger(evalCount) + ", "); SNAPSHOT_WRITLINE_REPLACEMENT("Time = " + GetThreeDigitSeperatedInteger(timeForSearchSoFar) + "ms, "); SNAPSHOT_WRITLINE_REPLACEMENT("NpS = " + GetThreeDigitSeperatedInteger(tNpS) + "]"); } pDepth++; } while (globalTimer.ElapsedTicks < tTimestamp && pDepth < 179); depths += pDepth - 1; BOT_MAIN.depthsSearched += pDepth - 1; BOT_MAIN.searchesFinished++; BOT_MAIN.evaluationsMade += evalCount; curSearchZobristKeyLine = tZobristKeyLine; return perftScore; } private int[] squareToRankArray = new int[64] { 0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1, 2,2,2,2,2,2,2,2, 3,3,3,3,3,3,3,3, 4,4,4,4,4,4,4,4, 5,5,5,5,5,5,5,5, 6,6,6,6,6,6,6,6, 7,7,7,7,7,7,7,7 }; private bool WhiteIsPositionTheSpecialCase(Move pLastMove, int pCheckingSquare) { if (pLastMove.isPromotion && pLastMove.isCapture && (pLastMove.promotionType == 4 || pLastMove.promotionType == 5)) { if(pLastMove.startPos % 8 == pCheckingSquare % 8 && pLastMove.startPos == whiteKingSquare + 8) return true; if (squareToRankArray[pLastMove.startPos] == squareToRankArray[pCheckingSquare] && pLastMove.endPos == whiteKingSquare - 8) return true; } return false; } private bool BlackIsPositionTheSpecialCase(Move pLastMove, int pCheckingSquare) { if (pLastMove.isPromotion && pLastMove.isCapture && (pLastMove.promotionType == 4 || pLastMove.promotionType == 5)) { if (pLastMove.startPos % 8 == pCheckingSquare % 8 && pLastMove.startPos == blackKingSquare - 8) return true; if (pCheckingSquare != -1 && squareToRankArray[pLastMove.startPos] == squareToRankArray[pCheckingSquare] && pLastMove.endPos == blackKingSquare + 8) return true; } return false; } private int MinimaxWhite(int pPly, int pAlpha, int pBeta, int pDepth, int pRepetitionHistoryPly, int pCheckingSquare, Move pLastMove) { if (IsDrawByRepetition(pRepetitionHistoryPly - 4)) return 0; if ((pDepth <= 0 && pCheckingSquare == -1) || pDepth < CHECK_EXTENSION_LENGTH) return QuiescenceWhite(pPly, pAlpha, pBeta, pDepth - 1, pCheckingSquare, pLastMove); List<Move> moveOptionList = new List<Move>(); Move bestMove = NULL_MOVE; if (WhiteIsPositionTheSpecialCase(pLastMove, pCheckingSquare)) GetLegalWhiteMovesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalWhiteMoves(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tWhiteKingSquare = whiteKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1, curEval = BLACK_CHECKMATE_VAL - pDepth; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = true; double[] moveSortingArray = new double[molc]; int[] moveSortingArrayIndexes = new int[molc], thisSearchMoveSortingArrayForTransposEntry = new int[molc]; transpositionTable.TryGetValue(zobristKey, out TranspositionEntry transposEntry); if (transposEntry == null) { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; } } else { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove == transposEntry.bestMove) moveSortingArray[m] = BESTMOVE_SORT_VAL; else if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; if (transposEntry.moveGenOrderedEvalLength > m) moveSortingArray[m] -= transposEntry.moveGenOrderedEvals[m]; } } Array.Sort(moveSortingArray, moveSortingArrayIndexes); for (int m = 0; m < molc; m++) { int tActualIndex = moveSortingArrayIndexes[m]; Move curMove = moveOptionList[tActualIndex]; if (debugSortResults && pDepth == curSubSearchDepth) { SNAPSHOT_WRITLINE_REPLACEMENT(moveSortingArray[m] + " | "+ curMove); } int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; whitePieceBitboard = tWPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesWhite[tStartPos, tPieceType] ^ pieceHashesWhite[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 0: blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 1: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 2: blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 3: whiteKingSquare = tEndPos; if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 4: blackPieceBitboard = tBPB; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 5: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[whiteKingSquare = tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = curMove.enPassantOption]; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 11: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; whiteKingSquare = tEndPos; blackPieceBitboard = tBPB; pieceTypeArray[curMove.rochadeEndPos] = 4; pieceTypeArray[curMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesWhite[curMove.rochadeStartPos, 4] ^ pieceHashesWhite[curMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | curMove.rochadeEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << curMove.rochadeEndPos)) tCheckPos = curMove.rochadeEndPos; break; case 12: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesBlack[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 13: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; zobristKey ^= pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, curMove.promotionType]; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; case 14: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, tPTI] ^ pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, curMove.promotionType]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } curSearchZobristKeyLine[pRepetitionHistoryPly] = zobristKey; debugMoveList[pPly] = curMove; int tEval = MinimaxBlack(pPly + 1, pAlpha, pBeta, pDepth - 1, pRepetitionHistoryPly + 1, tCheckPos, curMove); thisSearchMoveSortingArrayForTransposEntry[tActualIndex] = tEval; pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 3: whiteKingSquare = tWhiteKingSquare; break; case 7: whiteKingSquare = tWhiteKingSquare; break; case 10: enPassantSquare = 65; break; case 11: whiteKingSquare = tWhiteKingSquare; pieceTypeArray[curMove.rochadeStartPos] = 4; pieceTypeArray[curMove.rochadeEndPos] = 0; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 13: pieceTypeArray[tStartPos] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval > curEval) { bestMove = curMove; curEval = tEval; } if (pAlpha < curEval) pAlpha = curEval; if (curEval >= pBeta) { if (!curMove.isCapture) { killerMoveHeuristic[curMove.moveHash] = true; if (pDepth > 0) historyHeuristic[curMove.moveHash] += pDepth * pDepth; } break; } } isWhiteToMove = true; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; if (molc == 0 && pCheckingSquare == -1) curEval = 0; if (!transpositionTable.ContainsKey(zobristKey)) transpositionTable.Add(zobristKey, new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry)); else transpositionTable[zobristKey] = new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry); return curEval; } private int QuiescenceWhite(int pPly, int pAlpha, int pBeta, int pDepth, int pCheckingSquare, Move pLastMove) { int standPat = TexelEvaluate(); if (standPat >= pBeta || pDepth < MAX_QUIESCENCE_TOTAL_LENGTH) return pBeta; if (standPat > pAlpha) pAlpha = standPat; List<Move> moveOptionList = new List<Move>(); if (WhiteIsPositionTheSpecialCase(pLastMove, pCheckingSquare)) GetLegalWhiteCapturesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalWhiteCaptures(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tWhiteKingSquare = whiteKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = true; for (int m = 0; m < molc; m++) { Move curMove = moveOptionList[m]; int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; whitePieceBitboard = tWPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesWhite[tStartPos, tPieceType] ^ pieceHashesWhite[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 5: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[whiteKingSquare = tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 12: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesBlack[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 14: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, tPTI] ^ pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, curMove.promotionType]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } debugMoveList[pPly] = curMove; int tEval = QuiescenceBlack(pPly + 1, pAlpha, pBeta, pDepth - 1, tCheckPos, curMove); pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 7: whiteKingSquare = tWhiteKingSquare; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval >= pBeta) return pBeta; if (pAlpha < tEval) pAlpha = tEval; } isWhiteToMove = true; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; return pAlpha; } private int MinimaxBlack(int pPly, int pAlpha, int pBeta, int pDepth, int pRepetitionHistoryPly, int pCheckingSquare, Move pLastMove) { if (IsDrawByRepetition(pRepetitionHistoryPly - 4)) return 0; if ((pDepth <= 0 && pCheckingSquare == -1) || pDepth < CHECK_EXTENSION_LENGTH) return QuiescenceBlack(pPly, pAlpha, pBeta, pDepth - 1, pCheckingSquare, pLastMove); List<Move> moveOptionList = new List<Move>(); Move bestMove = NULL_MOVE; if (BlackIsPositionTheSpecialCase(pLastMove, pCheckingSquare)) GetLegalBlackMovesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalBlackMoves(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tBlackKingSquare = blackKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1, curEval = WHITE_CHECKMATE_VAL + pDepth; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = false; double[] moveSortingArray = new double[molc]; int[] moveSortingArrayIndexes = new int[molc], thisSearchMoveSortingArrayForTransposEntry = new int[molc]; transpositionTable.TryGetValue(zobristKey, out TranspositionEntry transposEntry); if (transposEntry == null) { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; } } else { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove == transposEntry.bestMove) moveSortingArray[m] = BESTMOVE_SORT_VAL; else if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; if (transposEntry.moveGenOrderedEvalLength > m) moveSortingArray[m] -= transposEntry.moveGenOrderedEvals[m]; } } Array.Sort(moveSortingArray, moveSortingArrayIndexes); for (int m = 0; m < molc; m++) { int tActualIndex = moveSortingArrayIndexes[m]; Move curMove = moveOptionList[tActualIndex]; if (debugSortResults && pDepth == curSearchDepth) { SNAPSHOT_WRITLINE_REPLACEMENT("=== " + moveSortingArray[m] + " | "+ curMove); } int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; blackPieceBitboard = tBPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesBlack[tStartPos, tPieceType] ^ pieceHashesBlack[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 0: whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 1: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 2: whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 3: blackKingSquare = tEndPos; if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 4: whitePieceBitboard = tWPB; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 5: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[blackKingSquare = tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = curMove.enPassantOption]; whitePieceBitboard = tWPB; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 11: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; blackKingSquare = tEndPos; whitePieceBitboard = tWPB; pieceTypeArray[curMove.rochadeEndPos] = 4; pieceTypeArray[curMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesBlack[curMove.rochadeStartPos, 4] ^ pieceHashesBlack[curMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | curMove.rochadeEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << curMove.rochadeEndPos)) tCheckPos = curMove.rochadeEndPos; break; case 12: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesWhite[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 13: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, curMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; case 14: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } zobristKey ^= pieceHashesWhite[tEndPos, tPTI] ^ pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, curMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } curSearchZobristKeyLine[pRepetitionHistoryPly] = zobristKey; debugMoveList[pPly] = curMove; int tEval = MinimaxWhite(pPly + 1, pAlpha, pBeta, pDepth - 1, pRepetitionHistoryPly + 1, tCheckPos, curMove); thisSearchMoveSortingArrayForTransposEntry[tActualIndex] = tEval; pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 3: blackKingSquare = tBlackKingSquare; break; case 7: blackKingSquare = tBlackKingSquare; break; case 10: enPassantSquare = 65; break; case 11: blackKingSquare = tBlackKingSquare; pieceTypeArray[curMove.rochadeStartPos] = 4; pieceTypeArray[curMove.rochadeEndPos] = 0; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 13: pieceTypeArray[tStartPos] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval < curEval) { bestMove = curMove; curEval = tEval; } if (pBeta > curEval) pBeta = curEval; if (curEval <= pAlpha) { if (!curMove.isCapture) { killerMoveHeuristic[curMove.moveHash] = true; if (pDepth > 0) historyHeuristic[curMove.moveHash] += pDepth * pDepth; } break; } } isWhiteToMove = false; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; if (molc == 0 && pCheckingSquare == -1) curEval = 0; if (!transpositionTable.ContainsKey(zobristKey)) transpositionTable.Add(zobristKey, new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry)); else transpositionTable[zobristKey] = new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry); return curEval; } private int QuiescenceBlack(int pPly, int pAlpha, int pBeta, int pDepth, int pCheckingSquare, Move pLastMove) { int standPat = TexelEvaluate(); if (standPat <= pAlpha || pDepth < MAX_QUIESCENCE_TOTAL_LENGTH) return pAlpha; if (standPat < pBeta) pBeta = standPat; List<Move> moveOptionList = new List<Move>(); if (BlackIsPositionTheSpecialCase(pLastMove, pCheckingSquare)) GetLegalBlackCapturesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalBlackCaptures(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tBlackKingSquare = blackKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = false; for (int m = 0; m < molc; m++) { Move curMove = moveOptionList[m]; int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; blackPieceBitboard = tBPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesBlack[tStartPos, tPieceType] ^ pieceHashesBlack[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 5: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[blackKingSquare = tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 12: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesWhite[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 14: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } zobristKey ^= pieceHashesWhite[tEndPos, tPTI] ^ pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, curMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } debugMoveList[pPly] = curMove; int tEval = QuiescenceWhite(pPly + 1, pAlpha, pBeta, pDepth - 1, tCheckPos, curMove); pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 7: blackKingSquare = tBlackKingSquare; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval <= pAlpha) return pAlpha; if (pBeta > tEval) pBeta = tEval; } isWhiteToMove = false; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; return pBeta; } private bool[] killerMoveHeuristic = new bool[262_144]; private int[] historyHeuristic = new int[262_144]; public void ClearHeuristics() { for (int i = 0; i < 262_144; i++) { killerMoveHeuristic[i] = false; historyHeuristic[i] = 0; } } private Dictionary<ulong, TranspositionEntry> transpositionTable = new Dictionary<ulong, TranspositionEntry>(); private int[] pieceEvals = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[,][] piecePositionEvals = new int[33, 14][]; private int evalCount = 0; private int Evaluate() { evalCount++; if (fiftyMoveRuleCounter > 99) return 0; int tEval = 0, tPT, pieceCount = ULONG_OPERATIONS.CountBits(allPieceBitboard); for (int p = 0; p < 64; p++) tEval += pieceEvals[tPT = pieceTypeArray[p] + 7 * ((int)(blackPieceBitboard >> p) & 1)] + piecePositionEvals[pieceCount, tPT][p]; return tEval; } public int GameState(bool pWhiteKingCouldBeAttacked) { if (IsDrawByRepetition(curSearchZobristKeyLine.Length - 5) || fiftyMoveRuleCounter > 99) return 0; int t; List<Move> tMoves = new List<Move>(); GetLegalMoves(ref tMoves); if (pWhiteKingCouldBeAttacked) { t = PreMinimaxCheckCheckWhite(); if (t == -1) return tMoves.Count == 0 ? 0 : 3; else if (tMoves.Count == 0) return -1; } else { t = PreMinimaxCheckCheckBlack(); if (t == -1) return tMoves.Count == 0 ? 0 : 3; else if (tMoves.Count == 0) return 1; } return 3; } private bool IsDrawByRepetition(int pPlyOfFirstPossibleRepeatedPosition) { int tC = 0; for (int i = pPlyOfFirstPossibleRepeatedPosition; i >= 0; i -= 2) { if (curSearchZobristKeyLine[i] == zobristKey) if (++tC == 2) return true; } return false; } private const int RELE_MAX_MOVE_COUNT_PER_GAME = 500; public double ReLePlayGame(int[,][] pEvalPositionValuesWhite, int[,][] pEvalPositionValuesBlack, long thinkingTimePerMove) { int[,][] processedValuesWhite = InitReLeAgent(pEvalPositionValuesWhite), processedValuesBlack = InitReLeAgent(pEvalPositionValuesBlack); int tGS, mc = 0; do { if (IsDrawByRepetition(curSearchZobristKeyLine.Length - 5)) return 0d; piecePositionEvals = isWhiteToMove ? processedValuesWhite : processedValuesBlack; MinimaxRoot(thinkingTimePerMove); if (transpositionTable.Count == 0) { SNAPSHOT_WRITLINE_REPLACEMENT("?!"); return 0d; } PlainMakeMove(transpositionTable[zobristKey].bestMove); tGS = GameState(isWhiteToMove); transpositionTable.Clear(); if (tGS != 3) break; } while (mc++ < RELE_MAX_MOVE_COUNT_PER_GAME); if (tGS == 3 || tGS == 0) return 0d; else if (tGS == 1) return 0.1d * (double)(RELE_MAX_MOVE_COUNT_PER_GAME - mc); return 0.1d * (double)(-RELE_MAX_MOVE_COUNT_PER_GAME + mc); } public int[,][] InitReLeAgent(int[,][] pEvalPositionValues) { return GetInterpolatedProcessedValues(pEvalPositionValues); } private int[,][] GetInterpolatedProcessedValues(int[,][] pEvalPositionValues) { int[,][] processedValues = new int[33, 14][]; for (int i = 0; i < 32; i++) { int ip1 = i + 1; processedValues[ip1, 7] = processedValues[ip1, 0] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; processedValues[ip1, 8] = SwapArrayViewingSide(processedValues[ip1, 1] = MultiplyArraysWithVal(pEvalPositionValues[0, 0], pEvalPositionValues[1, 0], pEvalPositionValues[2, 0], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 9] = SwapArrayViewingSide(processedValues[ip1, 2] = MultiplyArraysWithVal(pEvalPositionValues[0, 1], pEvalPositionValues[1, 1], pEvalPositionValues[2, 1], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 10] = SwapArrayViewingSide(processedValues[ip1, 3] = MultiplyArraysWithVal(pEvalPositionValues[0, 2], pEvalPositionValues[1, 2], pEvalPositionValues[2, 2], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 11] = SwapArrayViewingSide(processedValues[ip1, 4] = MultiplyArraysWithVal(pEvalPositionValues[0, 3], pEvalPositionValues[1, 3], pEvalPositionValues[2, 3], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 12] = SwapArrayViewingSide(processedValues[ip1, 5] = MultiplyArraysWithVal(pEvalPositionValues[0, 4], pEvalPositionValues[1, 4], pEvalPositionValues[2, 4], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 13] = SwapArrayViewingSide(processedValues[ip1, 6] = MultiplyArraysWithVal(pEvalPositionValues[0, 5], pEvalPositionValues[1, 5], pEvalPositionValues[2, 5], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); } return processedValues; } private double[,][] GetInterpolatedProcessedValues(double[,][] pEvalPositionValues) { double[,][] processedValues = new double[33, 14][]; for (int i = 0; i < 32; i++) { int ip1 = i + 1; processedValues[ip1, 7] = processedValues[ip1, 0] = new double[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; processedValues[ip1, 8] = SwapArrayViewingSide(processedValues[ip1, 1] = MultiplyArraysWithVal(pEvalPositionValues[0, 0], pEvalPositionValues[1, 0], pEvalPositionValues[2, 0], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 9] = SwapArrayViewingSide(processedValues[ip1, 2] = MultiplyArraysWithVal(pEvalPositionValues[0, 1], pEvalPositionValues[1, 1], pEvalPositionValues[2, 1], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 10] = SwapArrayViewingSide(processedValues[ip1, 3] = MultiplyArraysWithVal(pEvalPositionValues[0, 2], pEvalPositionValues[1, 2], pEvalPositionValues[2, 2], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 11] = SwapArrayViewingSide(processedValues[ip1, 4] = MultiplyArraysWithVal(pEvalPositionValues[0, 3], pEvalPositionValues[1, 3], pEvalPositionValues[2, 3], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 12] = SwapArrayViewingSide(processedValues[ip1, 5] = MultiplyArraysWithVal(pEvalPositionValues[0, 4], pEvalPositionValues[1, 4], pEvalPositionValues[2, 4], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 13] = SwapArrayViewingSide(processedValues[ip1, 6] = MultiplyArraysWithVal(pEvalPositionValues[0, 5], pEvalPositionValues[1, 5], pEvalPositionValues[2, 5], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); } return processedValues; } private double[] MultiplyArraysWithVal(double[] pArr1, double[] pArr2, double[] pArr3, double pVal1, double pVal2, double pVal3) { int tL = pArr1.Length; double[] rArr = new double[tL]; for (int i = 0; i < tL; i++) { rArr[i] = pArr1[i] * pVal1 + pArr2[i] * pVal2 + pArr3[i] * pVal3; } return rArr; } private int[] MultiplyArraysWithVal(int[] pArr1, int[] pArr2, int[] pArr3, double pVal1, double pVal2, double pVal3) { int tL = pArr1.Length; int[] rArr = new int[tL]; for (int i = 0; i < tL; i++) { rArr[i] = (int)(pArr1[i] * pVal1 + pArr2[i] * pVal2 + pArr3[i] * pVal3); } return rArr; } private int[] SwapArrayViewingSideAndNegate(int[] pArr) { return new int[64] { -pArr[56], -pArr[57], -pArr[58], -pArr[59], -pArr[60], -pArr[61], -pArr[62], -pArr[63], -pArr[48], -pArr[49], -pArr[50], -pArr[51], -pArr[52], -pArr[53], -pArr[54], -pArr[55], -pArr[40], -pArr[41], -pArr[42], -pArr[43], -pArr[44], -pArr[45], -pArr[46], -pArr[47], -pArr[32], -pArr[33], -pArr[34], -pArr[35], -pArr[36], -pArr[37], -pArr[38], -pArr[39], -pArr[24], -pArr[25], -pArr[26], -pArr[27], -pArr[28], -pArr[29], -pArr[30], -pArr[31], -pArr[16], -pArr[17], -pArr[18], -pArr[19], -pArr[20], -pArr[21], -pArr[22], -pArr[23], -pArr[8], -pArr[9], -pArr[10], -pArr[11], -pArr[12], -pArr[13], -pArr[14], -pArr[15], -pArr[0], -pArr[1], -pArr[2], -pArr[3], -pArr[4], -pArr[5], -pArr[6], -pArr[7] }; } private int[] SwapArrayViewingSide(int[] pArr) { return new int[64] { pArr[56], pArr[57], pArr[58], pArr[59], pArr[60], pArr[61], pArr[62], pArr[63], pArr[48], pArr[49], pArr[50], pArr[51], pArr[52], pArr[53], pArr[54], pArr[55], pArr[40], pArr[41], pArr[42], pArr[43], pArr[44], pArr[45], pArr[46], pArr[47], pArr[32], pArr[33], pArr[34], pArr[35], pArr[36], pArr[37], pArr[38], pArr[39], pArr[24], pArr[25], pArr[26], pArr[27], pArr[28], pArr[29], pArr[30], pArr[31], pArr[16], pArr[17], pArr[18], pArr[19], pArr[20], pArr[21], pArr[22], pArr[23], pArr[8], pArr[9], pArr[10], pArr[11], pArr[12], pArr[13], pArr[14], pArr[15], pArr[0], pArr[1], pArr[2], pArr[3], pArr[4], pArr[5], pArr[6], pArr[7] }; } private double[] SwapArrayViewingSide(double[] pArr) { return new double[64] { pArr[56], pArr[57], pArr[58], pArr[59], pArr[60], pArr[61], pArr[62], pArr[63], pArr[48], pArr[49], pArr[50], pArr[51], pArr[52], pArr[53], pArr[54], pArr[55], pArr[40], pArr[41], pArr[42], pArr[43], pArr[44], pArr[45], pArr[46], pArr[47], pArr[32], pArr[33], pArr[34], pArr[35], pArr[36], pArr[37], pArr[38], pArr[39], pArr[24], pArr[25], pArr[26], pArr[27], pArr[28], pArr[29], pArr[30], pArr[31], pArr[16], pArr[17], pArr[18], pArr[19], pArr[20], pArr[21], pArr[22], pArr[23], pArr[8], pArr[9], pArr[10], pArr[11], pArr[12], pArr[13], pArr[14], pArr[15], pArr[0], pArr[1], pArr[2], pArr[3], pArr[4], pArr[5], pArr[6], pArr[7] }; } private int[,][] texelTuningRuntimeVals = new int[33, 14][]; private int[,][] texelTuningVals = new int[3, 6][]; private int[,] texelTuningAdjustIterations = new int[6, 64]; private int[][] texelTuningRuntimePositionalValsV2EG = new int[14][]; private int[][] texelTuningRuntimePositionalValsV2LG = new int[14][]; private int[] texelPieceEvaluationsV2EG = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[] texelPieceEvaluationsV2LG = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[] texelKingSafetyR1EvaluationsEG = new int[9]; private int[] texelKingSafetyR2EvaluationsEG = new int[17]; private int[] texelKingSafetyR1EvaluationsLG = new int[9]; private int[] texelKingSafetyR2EvaluationsLG = new int[17]; private int[] texelKingSafetySREvaluationsPT1EG = new int[12]; private int[] texelKingSafetySREvaluationsPT2EG = new int[12]; private int[] texelKingSafetySREvaluationsPT3EG = new int[12]; private int[] texelKingSafetySREvaluationsPT4EG = new int[12]; private int[] texelKingSafetySREvaluationsPT5EG = new int[12]; private int[] texelKingSafetySREvaluationsPT6EG = new int[12]; private int[] texelKingSafetySREvaluationsPT1LG = new int[12]; private int[] texelKingSafetySREvaluationsPT2LG = new int[12]; private int[] texelKingSafetySREvaluationsPT3LG = new int[12]; private int[] texelKingSafetySREvaluationsPT4LG = new int[12]; private int[] texelKingSafetySREvaluationsPT5LG = new int[12]; private int[] texelKingSafetySREvaluationsPT6LG = new int[12]; private int[,] texelMobilityStraightEG = new int[14, 15], texelMobilityStraightLG = new int[14, 15]; private int[,] texelMobilityDiagonalEG = new int[14, 14], texelMobilityDiagonalLG = new int[14, 14]; private int[] texelPieceEvaluations = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[] blackSidedSquares = new int[64] { 56, 57, 58, 59, 60, 61, 62, 63, 48, 49, 50, 51, 52, 53, 54, 55, 40, 41, 42, 43, 44, 45, 46, 47, 32, 33, 34, 35, 36, 37, 38, 39, 24, 25, 26, 27, 28, 29, 30, 31, 16, 17, 18, 19, 20, 21, 22, 23, 08, 09, 10, 11, 12, 13, 14, 15, 00, 01, 02, 03, 04, 05, 06, 07 }; private int[,] T_Pawns = new int[3, 64] { { 0, 0, 0, 0, 0, 0, 0, 0, 98, 134, 61, 95, 68, 126, 34, -11, -6, 7, 26, 31, 65, 56, 25, -20, -14, 13, 6, 21, 23, 12, 17, -23, -27, -2, -5, 12, 17, 6, 10, -25, -26, -4, -4, -10, 3, 3, 33, -12, -35, -1, -20, -23, -15, 24, 38, -22, 0, 0, 0, 0, 0, 0, 0, 0, } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { 0, 0, 0, 0, 0, 0, 0, 0, 178, 173, 158, 134, 147, 132, 165, 187, 94, 100, 85, 67, 56, 53, 82, 84, 32, 24, 13, 5, -2, 4, 17, 17, 13, 9, -3, -7, -7, -8, 3, -1, 4, 7, -6, 1, 0, -5, -1, -8, 13, 8, 8, 10, 13, 0, 2, -7, 0, 0, 0, 0, 0, 0, 0, 0, } }; private int[,] T_Knights = new int[3, 64] { { -167, -89, -34, -49, 61, -97, -15, -107, -73, -41, 72, 36, 23, 62, 7, -17, -47, 60, 37, 65, 84, 129, 73, 44, -9, 17, 19, 53, 37, 69, 18, 22, -13, 4, 16, 13, 28, 19, 21, -8, -23, -9, 12, 10, 19, 17, 25, -16, -29, -53, -12, -3, -1, 18, -14, -19, -105, -21, -58, -33, -17, -28, -19, -23 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -58, -38, -13, -28, -31, -27, -63, -99, -25, -8, -25, -2, -9, -25, -24, -52, -24, -20, 10, 9, -1, -9, -19, -41, -17, 3, 22, 22, 22, 11, 8, -18, -18, -6, 16, 25, 16, 17, 4, -18, -23, -3, -1, 15, 10, -3, -20, -22, -42, -20, -10, -5, -2, -20, -23, -44, -29, -51, -23, -15, -22, -18, -50, -64 } }; private int[,] T_Bishops = new int[3, 64] { { -29, 4, -82, -37, -25, -42, 7, -8, -26, 16, -18, -13, 30, 59, 18, -47, -16, 37, 43, 40, 35, 50, 37, -2, -4, 5, 19, 50, 37, 37, 7, -2, -6, 13, 13, 26, 34, 12, 10, 4, 0, 15, 15, 15, 14, 27, 18, 10, 4, 15, 16, 0, 7, 21, 33, 1, -33, -3, -14, -21, -13, -12, -39, -21 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -14, -21, -11, -8, -7, -9, -17, -24, -8, -4, 7, -12, -3, -13, -4, -14, 2, -8, 0, -1, -2, 6, 0, 4, -3, 9, 12, 9, 14, 10, 3, 2, -6, 3, 13, 19, 7, 10, -3, -9, -12, -3, 8, 10, 13, 3, -7, -15, -14, -18, -7, -1, 4, -9, -15, -27, -23, -9, -23, -5, -9, -16, -5, -17 } }; private int[,] T_Rooks = new int[3, 64] { { 32, 42, 32, 51, 63, 9, 31, 43, 27, 32, 58, 62, 80, 67, 26, 44, -5, 19, 26, 36, 17, 45, 61, 16, -24, -11, 7, 26, 24, 35, -8, -20, -36, -26, -12, -1, 9, -7, 6, -23, -45, -25, -16, -17, 3, 0, -5, -33, -44, -16, -20, -9, -1, 11, -6, -71, -19, -13, 1, 17, 16, 7, -37, -26 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { 13, 10, 18, 15, 12, 12, 8, 5, 11, 13, 13, 11, -3, 3, 8, 3, 7, 7, 7, 5, 4, -3, -5, -3, 4, 3, 13, 1, 2, 1, -1, 2, 3, 5, 8, 4, -5, -6, -8, -11, -4, 0, -5, -1, -7, -12, -8, -16, -6, -6, 0, 2, -9, -9, -11, -3, -9, 2, 3, -1, -5, -13, 4, -20 } }; private int[,] T_Queens = new int[3, 64] { { -28, 0, 29, 12, 59, 44, 43, 45, -24, -39, -5, 1, -16, 57, 28, 54, -13, -17, 7, 8, 29, 56, 47, 57, -27, -27, -16, -16, -1, 17, -2, 1, -9, -26, -9, -10, -2, -4, 3, -3, -14, 2, -11, -2, -5, 2, 14, 5, -35, -8, 11, 2, 8, 15, -3, 1, -1, -18, -9, 10, -15, -25, -31, -50 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -9, 22, 22, 27, 27, 19, 10, 20, -17, 20, 32, 41, 58, 25, 30, 0, -20, 6, 9, 49, 47, 35, 19, 9, 3, 22, 24, 45, 57, 40, 57, 36, -18, 28, 19, 47, 31, 34, 39, 23, -16, -27, 15, 6, 9, 17, 10, 5, -22, -23, -30, -16, -16, -23, -36, -32, -33, -28, -22, -43, -5, -32, -20, -41 } }; private int[,] T_Kings = new int[3, 64] { { -65, 23, 16, -15, -56, -34, 2, 13, 29, -1, -20, -7, -8, -4, -38, -29, -9, 24, 2, -16, -20, 6, 22, -22, -17, -20, -12, -27, -30, -25, -14, -36, -49, -1, -27, -39, -46, -44, -33, -51, -14, -14, -22, -46, -44, -30, -15, -27, 1, 7, -8, -64, -43, -16, 9, 8, -15, 36, 12, -54, 8, -28, 24, 14 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -74, -35, -18, -18, -11, 15, 4, -17, -12, 17, 14, 17, 17, 38, 23, 11, 10, 17, 23, 15, 20, 45, 44, 13, -8, 22, 24, 27, 26, 33, 26, 3, -18, -4, 21, 24, 27, 23, 9, -11, -19, -3, 11, 21, 23, 16, 7, -9, -27, -11, 4, 13, 14, 4, -5, -17, -53, -34, -21, -11, -28, -14, -24, -43 } }; private int[] paramsLowerLimits = new int[5] { -10000, -10000, -10000, -10000, -10000 }; private int[] paramsUpperLimits = new int[5] { 10000, 10000, 10000, 10000, 10000 }; private List<TLM_ChessGame> threadDataset; private int threadFrom, threadTo; private int[] threadParams; private int customThreadID = 0; private ulong ulAllThreadIDsUnfinished = 0; private double lastCostVal = 0d; private double sumCostVals = 0d; private int costCalculations = 0; private readonly string[] TEXELPRINT_GAMEPARTS = new string[3] { "Early Game: ", "Mid Game: ", "Late Game: "}; private readonly string[] TEXELPRINT_PIECES = new string[6] { "Bauer: ", "Springer: ", "Lufer: ", "Turm: ", "Dame: ", "Knig: "}; private double[] earlyGameMultipliers = new double[33]; private double[] middleGameMultipliers = new double[33]; private double[] lateGameMultipliers = new double[33]; private int[] pieceTypeGameProgressImpact = new int[14] { 0, 0, 1, 1, 2, 4, 0, 0, 0, 1, 1, 2, 4, 0 }; private void PrecalculateMultipliers() { if (BOARD_MANAGER_ID == ENGINE_VALS.PARALLEL_BOARDS - 1) SNAPSHOT_WRITLINE_REPLACEMENT(); for (int i = 0; i < 25; i++) { earlyGameMultipliers[i] = EGMultiplierFunction(i); lateGameMultipliers[i] = LGMultiplierFunction(i); if (BOARD_MANAGER_ID == ENGINE_VALS.PARALLEL_BOARDS - 1) SNAPSHOT_WRITLINE_REPLACEMENT("[" + i + "] "+ earlyGameMultipliers[i] + " | "+ middleGameMultipliers[i] + " | "+ lateGameMultipliers[i]); } } private double MultiplierFunction(double pVal, double pXShift) { double d = Math.Exp(1d /6d * (pVal - pXShift)); return 5 * (d /Math.Pow(d + 1, 2d)); } private double EGMultiplierFunction(double pVal) { return Math.Clamp(1 /16d * (pVal - 4d), 0d, 1d); } private double LGMultiplierFunction(double pVal) { return Math.Clamp(1 /-16d * (pVal - 4d) + 1d, 0d, 1d); } private double EGMultiplierFunction2(double pVal) { return Math.Clamp(1 /32d * pVal, 0d, 1d); } private double LGMultiplierFunction2(double pVal) { return Math.Clamp(1 /-32d * pVal + 1d, 0d, 1d); } private void TuneWithTxtFile(string pTXTName) { List<TLM_ChessGame> gameDataset = new List<TLM_ChessGame>(); string tPath = PathManager.GetTXTPath(pTXTName); string[] tStrs = File.ReadAllLines(tPath); List<string> tGames = new List<string>(); foreach (string s in tStrs) if (s.Contains(';') && s.Replace(" ", "") != "") tGames.Add(s); foreach (string s in tGames) { TLM_ChessGame tGame = CGFF.GetGame(s); LoadFenString(tGame.startFen); foreach (int hMove in tGame.hashedMoves) { List<Move> moveOptionList = new List<Move>(); GetLegalMoves(ref moveOptionList); int tL = moveOptionList.Count; for (int j = 0; j < tL; j++) { Move tMove = moveOptionList[j]; if (tMove.moveHash == hMove) { tGame.actualMoves.Add(tMove); PlainMakeMove(tMove); tL = -1; break; } } if (tL != -1) break; } gameDataset.Add(tGame); } SNAPSHOT_WRITLINE_REPLACEMENT("[TLM TEXEL TUNER] " + tGames.Count + " Games Loaded In!"); BOT_MAIN.curTEXELPARAMS = new int[TEXEL_PARAMS]; BOT_MAIN.ParallelTexelTuning(gameDataset); } private void LoadBestTexelParamsIn() { int[] ttt = new int[778]; ttt[0] = 82; ttt[1] = 341; ttt[2] = 416; ttt[3] = 470; ttt[4] = 1106; ttt[5] = 102; ttt[6] = 302; ttt[7] = 304; ttt[8] = 518; ttt[9] = 960; SetupTexelEvaluationParams(ttt); } private void SetupTexelEvaluationParams(int[] pParams) { texelPieceEvaluationsV2EG[8] = -(texelPieceEvaluationsV2EG[1] = pParams[0]); texelPieceEvaluationsV2EG[9] = -(texelPieceEvaluationsV2EG[2] = pParams[1]); texelPieceEvaluationsV2EG[10] = -(texelPieceEvaluationsV2EG[3] = pParams[2]); texelPieceEvaluationsV2EG[11] = -(texelPieceEvaluationsV2EG[4] = pParams[3]); texelPieceEvaluationsV2EG[12] = -(texelPieceEvaluationsV2EG[5] = pParams[4]); texelPieceEvaluationsV2LG[8] = -(texelPieceEvaluationsV2LG[1] = pParams[5]); texelPieceEvaluationsV2LG[9] = -(texelPieceEvaluationsV2LG[2] = pParams[6]); texelPieceEvaluationsV2LG[10] = -(texelPieceEvaluationsV2LG[3] = pParams[7]); texelPieceEvaluationsV2LG[11] = -(texelPieceEvaluationsV2LG[4] = pParams[8]); texelPieceEvaluationsV2LG[12] = -(texelPieceEvaluationsV2LG[5] = pParams[9]); int c = 10; for (int p = 1; p < 7; p++) { for (int s = 0; s < 64; s++) { texelTuningRuntimePositionalValsV2EG[p + 7][blackSidedSquares[s]] = -(texelTuningRuntimePositionalValsV2EG[p][s] = pParams[c++]); texelTuningRuntimePositionalValsV2LG[p + 7][blackSidedSquares[s]] = -(texelTuningRuntimePositionalValsV2LG[p][s] = pParams[c++]); } } return; for (int p = 2; p < 7; p++) { for (int a = 0; a < 15; a++) { if (a != 14) { texelMobilityDiagonalEG[p + 7, a] = -(texelMobilityDiagonalEG[p, a] = pParams[c++]); texelMobilityDiagonalLG[p + 7, a] = -(texelMobilityDiagonalLG[p, a] = pParams[c++]); } texelMobilityStraightEG[p + 7, a] = -(texelMobilityStraightEG[p, a] = pParams[c++]); texelMobilityStraightLG[p + 7, a] = -(texelMobilityStraightLG[p, a] = pParams[c++]); } } for (int i = 0; i < 12; i++) { texelKingSafetySREvaluationsPT1EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT2EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT3EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT4EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT5EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT6EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT1LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT2LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT3LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT4LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT5LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT6LG[i] = pParams[c++]; } } private void PrintDefinedTexelParams(int[] pParams) { int c = 0; for (int t = 0; t < 3; t++) { SNAPSHOT_WRITLINE_REPLACEMENT(TEXELPRINT_GAMEPARTS[t]); for (int p = 0; p < 6; p++) { SNAPSHOT_WRITLINE_REPLACEMENT(TEXELPRINT_PIECES[p]); texelTuningVals[t, p] = new int[64]; for (int s = 0; s < 64; s++) { if (s % 8 == 0 && s != 0) SNAPSHOT_WRITLINE_REPLACEMENT(); SNAPSHOT_WRITLINE_REPLACEMENT((texelTuningVals[t, p][s] = pParams[c++]) + ", "); } SNAPSHOT_WRITLINE_REPLACEMENT(); } } piecePositionEvals = GetInterpolatedProcessedValues(texelTuningVals); } public void TLMTuning(List<TLM_ChessGame> pDataset) { int tGameDataSetLen = pDataset.Count; int[,][] tRatio = new int[33, 6][]; int[,][] tTotalMoves = new int[33, 6][]; double[,][] tSummedRatios = new double[33, 6][]; double[,][] tSummedDataAmount = new double[33, 6][]; double[,][] tTuningResults = new double[33, 6][]; for (int t = 1; t < 33; t++) { for (int p = 0; p < 6; p++) { tRatio[t, p] = new int[64]; tTotalMoves[t, p] = new int[64]; tSummedRatios[t, p] = new double[64]; tSummedDataAmount[t, p] = new double[64]; tTuningResults[t, p] = new double[64]; } } for (int j = 0; j < tGameDataSetLen; j++) { TLM_ChessGame tGame = pDataset[j]; int tGR = tGame.gameResult - 1; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count - 5; for (int i = 0; i < tL; i++) { if (tGame.isMoveNonTactical[i]) { int tPieceAmount = ULONG_OPERATIONS.CountBits(allPieceBitboard); for (int s = 0; s < 64; s++) { int tPT = pieceTypeArray[s] - 1; if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, s)) { tTotalMoves[tPieceAmount, tPT][s]++; tRatio[tPieceAmount, tPT][s] += tGR; } else if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, s)) { int b = blackSidedSquares[s]; tTotalMoves[tPieceAmount, tPT][b]++; tRatio[tPieceAmount, tPT][b] += tGR; } } } PlainMakeMove(tGame.actualMoves[i]); } } double[,] allMultipliers = new double[33, 33]; for (int sh = 0; sh < 33; sh++) { for (int i = 0; i < 33; i++) { allMultipliers[sh, i] = MultiplierFunction(i, sh); } } for (int t = 1; t < 33; t++) { for (int p = 0; p < 6; p++) { for (int s = 0; s < 64; s++) { for (int t2 = 1; t2 < 33; t2++) { double cmult = allMultipliers[t, t2]; tSummedRatios[t, p][s] += tRatio[t2, p][s] * cmult; tSummedDataAmount[t, p][s] += tTotalMoves[t2, p][s] * cmult; } tTuningResults[t, p][s] = TTT(tSummedRatios[t, p][s], tSummedDataAmount[t, p][s]); } } } int c = 0; int[] tparams = new int[1152]; for (int t = 1; t < 33; t += 15) { if (t == 31) t = 32; SNAPSHOT_WRITLINE_REPLACEMENT("PieceCount = " + t + ": "); for (int p = 0; p < 6; p++) { SNAPSHOT_WRITLINE_REPLACEMENT(TEXELPRINT_PIECES[p]); for (int s = 0; s < 64; s++) { if (s % 8 == 0 && s != 0) SNAPSHOT_WRITLINE_REPLACEMENT(); SNAPSHOT_WRITLINE_REPLACEMENT((tparams[c++] = (int)(tTuningResults[t, p][s] * 100)).ToString().Replace(",", ".") + "("+ (int)tSummedDataAmount[t, p][s] + ")"+ ", "); } SNAPSHOT_WRITLINE_REPLACEMENT(); } } string tS = "PARAMS: {"; for (int i = 0; i < tparams.Length; i++) tS += tparams[i] + ","; tS = tS.Substring(0, tS.Length - 1) + "}\n"; SNAPSHOT_WRITLINE_REPLACEMENT(tS); TexelTuning(pDataset, tparams); } private double TTT(double d1, double d2) { if (d2 == 0) return 0; return d1 /d2; } public void TexelTuning(List<TLM_ChessGame> pDataset, int[] pCurBestParams) { Stopwatch sw = Stopwatch.StartNew(); string tPath = PathManager.GetTXTPath("OTHER/TEXEL_TUNING"); int paramCount = pCurBestParams.Length; double bestAvrgCost = CalculateAverageTexelCost(pDataset, pCurBestParams); SNAPSHOT_WRITLINE_REPLACEMENT("CUR PARAMS COST: " + bestAvrgCost); int packetSize = Math.Clamp(paramCount /ENGINE_VALS.CPU_CORES, 1, 100000); paramsLowerLimits = new int[paramCount]; paramsUpperLimits = new int[paramCount]; for (int i = 0; i < paramCount; i++) { int lim = i < 10 ? 100000 : 200; paramsLowerLimits[i] = -lim; paramsUpperLimits[i] = lim; } SNAPSHOT_WRITLINE_REPLACEMENT("PARAM-COUNT: " + paramCount); SNAPSHOT_WRITLINE_REPLACEMENT("PACKET-SIZE: " + packetSize); while (packetSize <= paramCount) { BOT_MAIN.TEXELfinished = 0; int lM = 0, tC = 0; ulong tUL = 0ul; for (int m = packetSize; lM < paramCount; m += packetSize) { if (m > paramCount) m = paramCount; tUL = ULONG_OPERATIONS.SetBitToOne(tUL, ++tC); lM = m; } tC = lM = 0; for (int m = packetSize; lM < paramCount; m += packetSize) { if (m > paramCount) m = paramCount; tC++; BOT_MAIN.boardManagers[tC].SetPlayTexelVals(pDataset, lM, m, pCurBestParams, paramsLowerLimits, paramsUpperLimits, tC, tUL); ThreadPool.QueueUserWorkItem(new WaitCallback(BOT_MAIN.boardManagers[tC].TexelTuningThreadedPackage)); lM = m; } packetSize = paramCount + 1; int tmod = 0; while (tC != BOT_MAIN.TEXELfinished) { if (++tmod % 20 == 0) { WriteTexelParamsToTXT(tPath, BOT_MAIN.curTEXELPARAMS); SNAPSHOT_WRITLINE_REPLACEMENT(CalculateAverageTexelCost(pDataset, BOT_MAIN.curTEXELPARAMS) + " | "+ BOT_MAIN.TEXELadjustmentsmade); SNAPSHOT_WRITLINE_REPLACEMENT(ULONG_OPERATIONS.GetBitVisualization(BOT_MAIN.TEXELfinishedwithoutimpovement)); } Thread.Sleep(100); } SNAPSHOT_WRITLINE_REPLACEMENT("One Thread Generation FINISHED! :) :) :)"); pCurBestParams = BOT_MAIN.curTEXELPARAMS; } sw.Stop(); WriteTexelParamsToTXT(tPath, BOT_MAIN.curTEXELPARAMS); SNAPSHOT_WRITLINE_REPLACEMENT("END COST: " + CalculateAverageTexelCost(pDataset, BOT_MAIN.curTEXELPARAMS)); SNAPSHOT_WRITLINE_REPLACEMENT(BOT_MAIN.TEXELadjustmentsmade); SNAPSHOT_WRITLINE_REPLACEMENT(sw.ElapsedMilliseconds); } public void TexelTuningThreadedPackage(object obj) { SNAPSHOT_WRITLINE_REPLACEMENT("Started CThreadID [" + customThreadID + "] which is handling Params ["+ threadFrom + "] - ["+ threadTo + "]"); bool firstIter = true; do { double bestAvrgCost = CalculateAverageTexelCost(threadDataset, threadParams); int adjust_val = firstIter ? 512 : 8; do { adjust_val /= 2; bool improvedAvrgCost = true; while (improvedAvrgCost) { improvedAvrgCost = false; for (int i = threadFrom; i < threadTo; i++) { bool improvedWithThisParam = true; int tadjustval = adjust_val; bool lastTimeMaximized = false, lastTimeMinimized = false; while (improvedWithThisParam) { improvedWithThisParam = false; int[] curParams = (int[])threadParams.Clone(); int paramBefore = curParams[i]; curParams[i] = Math.Clamp(paramBefore + adjust_val, paramsLowerLimits[i], paramsUpperLimits[i]); double curAvrgCost = CalculateAverageTexelCost(threadDataset, curParams); if (curAvrgCost < bestAvrgCost) { improvedAvrgCost = true; improvedWithThisParam = true; SNAPSHOT_WRITLINE_REPLACEMENT("Improved Param [" + i + "] at CThreadID ["+ customThreadID + "]: +"+ adjust_val + " ("+ GetDoublePrecentageString(bestAvrgCost - curAvrgCost) + ")"); bestAvrgCost = curAvrgCost; threadParams = curParams; BOT_MAIN.TEXELadjustmentsmade++; BOT_MAIN.TEXELfinishedwithoutimpovement = ulAllThreadIDsUnfinished; if (lastTimeMaximized) { adjust_val *= 4; lastTimeMaximized = false; } else lastTimeMaximized = true; lastTimeMinimized = false; } else { curParams[i] = Math.Clamp(paramBefore - adjust_val, paramsLowerLimits[i], paramsUpperLimits[i]); curAvrgCost = CalculateAverageTexelCost(threadDataset, curParams); if (curAvrgCost < bestAvrgCost) { improvedAvrgCost = true; improvedWithThisParam = true; SNAPSHOT_WRITLINE_REPLACEMENT("Improved Param [" + i + "] at CThreadID ["+ customThreadID + "]: -"+ adjust_val + " ("+ GetDoublePrecentageString(bestAvrgCost - curAvrgCost) + ")"); bestAvrgCost = curAvrgCost; threadParams = curParams; BOT_MAIN.TEXELadjustmentsmade++; BOT_MAIN.TEXELfinishedwithoutimpovement = ulAllThreadIDsUnfinished; if (lastTimeMinimized) { adjust_val *= 4; lastTimeMinimized = false; } else lastTimeMinimized = true; lastTimeMaximized = false; } } if (adjust_val != 1) adjust_val /= 2; for (int j = threadFrom; j < threadTo; j++) { BOT_MAIN.curTEXELPARAMS[j] = threadParams[j]; } threadParams = (int[])BOT_MAIN.curTEXELPARAMS.Clone(); bestAvrgCost = CalculateAverageTexelCost(threadDataset, threadParams); } adjust_val = tadjustval; } } } while (adjust_val != 1); BOT_MAIN.TEXELfinishedwithoutimpovement = ULONG_OPERATIONS.SetBitToZero(BOT_MAIN.TEXELfinishedwithoutimpovement, customThreadID); SNAPSHOT_WRITLINE_REPLACEMENT("FULLY FINISHED " + customThreadID + ". IMPROVEMENT THREAD PACKAGE CYCLE"); firstIter = false; } while (BOT_MAIN.TEXELfinishedwithoutimpovement != 0); BOT_MAIN.TEXELfinished++; } private void WriteTexelParamsToTXT(string pPath, int[] pParams) { try { string tS = "PARAMS: {"; for (int i = 0; i < pParams.Length; i++) tS += pParams[i] + ","; tS = tS.Substring(0, tS.Length - 1) + "}\n"; File.AppendAllText(pPath, tS); } catch { SNAPSHOT_WRITLINE_REPLACEMENT("Mal wieder TXT zu lange gebraucht um zu aktualisieren."); } } private double costSum = 0d; private int texelCostMovesEvaluated = 0; private double CalculateAverageTexelCost(List<TLM_ChessGame> tDataset, int[] pParams, bool pFullCost = true) { costSum = 0d; texelCostMovesEvaluated = 0; SetupTexelEvaluationParams(pParams); int tGameDataSetLen = tDataset.Count; int start = 0, end = tGameDataSetLen; if (!pFullCost) { end = (start = globalRandom.Next(0, end - 256)) + 256; } for (int j = start; j < end; j++) { TLM_ChessGame tGame = tDataset[j]; double tGR = tGame.gameResult; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count - 5; texelCostMovesEvaluated += tL; for (int i = 0; i < tL; i++) { costSum += TexelCost(tGR - TexelTuningSigmoid(TexelEvaluate())); PlainMakeMove(tGame.actualMoves[i]); } } return costSum /texelCostMovesEvaluated; } private double CalculateAverageTexelCostThreadedVersionLEGACYDOESNTWORK(List<TLM_ChessGame> tDataset, int[] pParams) { Stopwatch sw = Stopwatch.StartNew(); BOT_MAIN.TEXELcostSum = 0d; BOT_MAIN.TEXELfinished = 0; BOT_MAIN.TEXELcostMovesEvaluated = 0; int tGameDataSetLen = tDataset.Count; int gamesPerThread = tGameDataSetLen /ENGINE_VALS.CPU_CORES; for (int i = 0; i < ENGINE_VALS.CPU_CORES - 1; i++) { } for (int i = 0; i < ENGINE_VALS.CPU_CORES - 1; i++) { } while (BOT_MAIN.TEXELfinished != ENGINE_VALS.CPU_CORES) Thread.Sleep(1); sw.Stop(); return BOT_MAIN.TEXELcostSum /BOT_MAIN.TEXELcostMovesEvaluated; } public void SetPlayThroughVals(List<TLM_ChessGame> pDataset, int pFrom, int pTo) { threadDataset = pDataset; threadFrom = pFrom; threadTo = pTo; } public void SetPlayTexelVals(List<TLM_ChessGame> pDataset, int pFrom, int pTo, int[] pTexelParams, int[] pLowerLimits, int[] pUpperLimits, int pThreadID, ulong pUL) { threadDataset = pDataset; threadFrom = pFrom; threadTo = pTo; threadParams = pTexelParams; paramsLowerLimits = pLowerLimits; paramsUpperLimits = pUpperLimits; customThreadID = pThreadID; ulAllThreadIDsUnfinished = pUL; } public void PlayThroughSetOfGames(object obj) { SNAPSHOT_WRITLINE_REPLACEMENT(threadFrom + "->"+ threadTo); int sortedOut = 0; for (int j = threadFrom; j < threadTo; j++) { TLM_ChessGame tGame = threadDataset[j]; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count; for (int i = 0; i < tL; i++) { int tQuietEval = isWhiteToMove ? QuiescenceWhite(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, 0, PreMinimaxCheckCheckWhite(), NULL_MOVE) : QuiescenceBlack(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, 0, PreMinimaxCheckCheckBlack(), NULL_MOVE); bool tB; tGame.isMoveNonTactical.Add(tB = (Evaluate() == tQuietEval && i > 4)); if (!tB) sortedOut++; PlainMakeMove(tGame.actualMoves[i]); } } BOT_MAIN.TEXELsortedout += sortedOut; BOT_MAIN.TEXELfinished++; } public void CalculateAverageTexelCostThreadFunction(object obj) { SetupTexelEvaluationParams(threadParams); double d = 0d; for (int j = threadFrom; j < threadTo; j++) { TLM_ChessGame tGame = threadDataset[j]; double tGR = tGame.gameResult; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count - 5; BOT_MAIN.TEXELcostMovesEvaluated += tL; for (int i = 0; i < tL; i++) { d += TexelCost(tGR - TexelTuningSigmoid(TexelEvaluate())); PlainMakeMove(tGame.actualMoves[i]); } } BOT_MAIN.TEXELcostSum += d; BOT_MAIN.TEXELfinished++; } private void ConsoleWriteLineTuneArray<T>(T[,][] pArr) { for (int j = 0; j < 3; j++) { SNAPSHOT_WRITLINE_REPLACEMENT("{"); for (int k = 0; k < 6; k++) { SNAPSHOT_WRITLINE_REPLACEMENT("{"); for (int s = 0; s < 64; s++) SNAPSHOT_WRITLINE_REPLACEMENT(pArr[j, k][s] + ", "); SNAPSHOT_WRITLINE_REPLACEMENT("\n}"); } SNAPSHOT_WRITLINE_REPLACEMENT("}"); } } private void Tune(string pGameCGFF, double pLearningRate) { TLM_ChessGame tGame = CGFF.GetGame(pGameCGFF); LoadFenString(tGame.startFen); double tDGameResult = tGame.gameResult; foreach (int hMove in tGame.hashedMoves) { Tune(tDGameResult, pLearningRate); List<Move> moveOptionList = new List<Move>(); GetLegalMoves(ref moveOptionList); int tL = moveOptionList.Count; for (int i = 0; i < tL; i++) { Move tMove = moveOptionList[i]; if (tMove.moveHash == hMove) { PlainMakeMove(tMove); tL = -1; break; } } if (tL != -1) break; } } private void Tune(double pGameResult, double pLearningRate) { int tPC = ULONG_OPERATIONS.CountBits(allPieceBitboard); double oneThroughPieceCount = 1d /tPC; double egMult = earlyGameMultipliers[tPC], mgMult = middleGameMultipliers[tPC], lgMult = lateGameMultipliers[tPC]; double tTexelResult = TexelEvaluateF(); double tSigmoidedTexelResult = TexelSigmoid(tTexelResult); double tDif = tSigmoidedTexelResult - pGameResult; double tM = oneThroughPieceCount * TexelCostDerivative(tDif) * TexelSigmoidDerivative(tTexelResult) * pLearningRate; sumCostVals += lastCostVal = TexelCost(tDif); costCalculations++; for (int i = 0; i < 64; i++) { if (ULONG_OPERATIONS.IsBitZero(allPieceBitboard, i)) continue; int tPT = pieceTypeArray[i] - 1, tI = i; if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, i)) tI = blackSidedSquares[i]; texelTuningAdjustIterations[tPT, tI]++; } } private double TexelEvaluateF() { texelTuningRuntimeVals = GetInterpolatedProcessedValues(texelTuningVals); return TexelEvaluate(); } private int TexelEvaluate() { int tEvalEG = 0, tEvalLG = 0, tProgress = 0; ulong[] attkULs = new ulong[14]; for (int p = 0; p < 64; p++) { if (((int)(allPieceBitboard >> p) & 1) == 0) continue; int aPT = pieceTypeArray[p], tPT = aPT + 7 * ((int)(blackPieceBitboard >> p) & 1); tEvalEG += texelTuningRuntimePositionalValsV2EG[tPT][p] + texelPieceEvaluationsV2EG[tPT]; tEvalLG += texelTuningRuntimePositionalValsV2LG[tPT][p] + texelPieceEvaluationsV2LG[tPT]; tProgress += pieceTypeGameProgressImpact[tPT]; } if (tProgress > 24) tProgress = 24; return (int)(earlyGameMultipliers[tProgress] * tEvalEG + lateGameMultipliers[tProgress] * tEvalLG); } private const double TexelK = 0.2; private double TexelTuningSigmoid(double pVal) { return 2d /(1 + Math.Pow(10, -TexelK * pVal /400)); } private double TexelSigmoid(double pVal) { return 2d /(Math.Exp(-0.04d * pVal) + 1d); } private double TexelSigmoidDerivative(double pVal) { double d = Math.Exp(-0.04d * pVal); return 2d * d /(25d * (d + 1d) * (d + 1d)); } private double TexelCost(double pVal) { return pVal * pVal; } private double TexelCostDerivative(double pVal) { return 2 * pVal; } private char[] fenPieces = new char[7] { 'z', 'p', 'n', 'b', 'r', 'q', 'k' }; private string[] squareNames = new string[64] { "a1", "b1", "c1", "d1", "e1", "f1", "g1", "h1", "a2", "b2", "c2", "d2", "e2", "f2", "g2", "h2", "a3", "b3", "c3", "d3", "e3", "f3", "g3", "h3", "a4", "b4", "c4", "d4", "e4", "f4", "g4", "h4", "a5", "b5", "c5", "d5", "e5", "f5", "g5", "h5", "a6", "b6", "c6", "d6", "e6", "f6", "g6", "h6", "a7", "b7", "c7", "d7", "e7", "f7", "g7", "h7", "a8", "b8", "c8", "d8", "e8", "f8", "g8", "h8"}; public string CreateFenString() { string rFEN = ""; for (int i = 7; i >= 0; i--) { int t = 0; for (int j = 0; j < 8; j++) { int sq = i * 8 + j; if (pieceTypeArray[sq] != 0) { if (t != 0) rFEN += t; t = 0; } if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, sq)) { switch (pieceTypeArray[sq]) { case 0: t++; SNAPSHOT_WRITLINE_REPLACEMENT("???"); break; case 1: rFEN += 'P'; break; case 2: rFEN += 'N'; break; case 3: rFEN += 'B'; break; case 4: rFEN += 'R'; break; case 5: rFEN += 'Q'; break; case 6: rFEN += 'K'; break; } } else { switch (pieceTypeArray[sq]) { case 0: t++; break; case 1: rFEN += 'p'; break; case 2: rFEN += 'n'; break; case 3: rFEN += 'b'; break; case 4: rFEN += 'r'; break; case 5: rFEN += 'q'; break; case 6: rFEN += 'k'; break; } } } if (t != 0) rFEN += t; if (i != 0) rFEN += "/"; } rFEN += (isWhiteToMove ? " w": " b"); rFEN += (whiteCastleRightKingSide ? " K": " "); rFEN += (whiteCastleRightQueenSide ? "Q": ""); rFEN += (blackCastleRightKingSide ? "k": ""); rFEN += (blackCastleRightQueenSide ? "q": ""); if (!whiteCastleRightKingSide && !whiteCastleRightQueenSide && !blackCastleRightKingSide && !blackCastleRightQueenSide) rFEN += "-"; if (enPassantSquare < 64) rFEN += " "+ squareNames[enPassantSquare] + " "; else rFEN += " - "; return rFEN + fiftyMoveRuleCounter + " "+ ((happenedHalfMoves - happenedHalfMoves % 2) /2); } public void LoadFenString(string fenStr) { debugFEN = fenStr; lastMadeMove = NULL_MOVE; zobristKey = 0ul; whitePieceBitboard = blackPieceBitboard = allPieceBitboard = 0ul; for (int i = 0; i < 64; i++) pieceTypeArray[i] = 0; string[] spaceSpl = fenStr.Split(' '); string[] rowSpl = spaceSpl[0].Split('/'); string epstr = spaceSpl[3]; if (epstr == "-") enPassantSquare = 65; else enPassantSquare = (epstr[0] - 'a') + 8 * (epstr[1] - '1'); isWhiteToMove = true; if (spaceSpl[1] == "b") isWhiteToMove = false; if (!isWhiteToMove) zobristKey ^= blackTurnHash; string crstr = spaceSpl[2]; whiteCastleRightKingSide = whiteCastleRightQueenSide = blackCastleRightKingSide = blackCastleRightQueenSide = false; int crStrL = crstr.Length; for (int i = 0; i < crStrL; i++) { switch (crstr[i]) { case 'K': whiteCastleRightKingSide = true; break; case 'Q': whiteCastleRightQueenSide = true; break; case 'k': blackCastleRightKingSide = true; break; case 'q': blackCastleRightQueenSide = true; break; } } fiftyMoveRuleCounter = Convert.ToInt32(spaceSpl[4]); happenedHalfMoves = Convert.ToInt32(spaceSpl[5]) * 2; if (!isWhiteToMove) happenedHalfMoves++; int tSq = 0; for (int i = rowSpl.Length; i-- > 0;) { string tStr = rowSpl[i]; int tStrLen = tStr.Length; for (int c = 0; c < tStrLen; c++) { char tChar = tStr[c]; if (Char.IsDigit(tChar)) tSq += tChar - '0'; else { bool tCol = Char.IsLower(tChar); if (tCol) blackPieceBitboard = ULONG_OPERATIONS.SetBitToOne(blackPieceBitboard, tSq); else whitePieceBitboard = ULONG_OPERATIONS.SetBitToOne(whitePieceBitboard, tSq); if (tChar == 'k') blackKingSquare = tSq; else if (tChar == 'K') whiteKingSquare = tSq; pieceTypeArray[tSq] = Array.IndexOf(fenPieces, Char.ToLower(tChar)); if (tCol) zobristKey ^= pieceHashesBlack[tSq, pieceTypeArray[tSq]]; else zobristKey ^= pieceHashesWhite[tSq, pieceTypeArray[tSq]]; tSq++; } } } if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; zobristKey ^= enPassantSquareHashes[enPassantSquare]; allPieceBitboard = whitePieceBitboard | blackPieceBitboard; if (zobristKey == 16260251586586513106) moveHashList.Clear(); else { moveHashList.Clear(); moveHashList.Add(1); moveHashList.Add(2); moveHashList.Add(3); } } private ulong[,] pieceHashesWhite = new ulong[64, 7], pieceHashesBlack = new ulong[64, 7]; private ulong blackTurnHash, whiteKingSideRochadeRightHash, whiteQueenSideRochadeRightHash, blackKingSideRochadeRightHash, blackQueenSideRochadeRightHash; private ulong[] enPassantSquareHashes = new ulong[66]; private Dictionary<ulong, int> singleCheckCaseBackup = new Dictionary<ulong, int>(); private void InitZobrist() { Random rng = new Random(31415926); for (int sq = 0; sq < 64; sq++) { enPassantSquareHashes[sq] = ULONG_OPERATIONS.GetRandomULONG(rng); for (int it = 1; it < 7; it++) { pieceHashesWhite[sq, it] = ULONG_OPERATIONS.GetRandomULONG(rng); pieceHashesBlack[sq, it] = ULONG_OPERATIONS.GetRandomULONG(rng); } } blackTurnHash = ULONG_OPERATIONS.GetRandomULONG(rng); whiteKingSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); whiteQueenSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); blackKingSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); blackQueenSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); } public void SetKnightMasks(ulong[] uls) { knightSquareBitboards = uls; } public void SetKingMasks(ulong[] uls) { kingSquareBitboards = uls; } private Move[,] whiteEnPassantMoves = new Move[64, 64]; private Move[,] blackEnPassantMoves = new Move[64, 64]; private bool[] epValidationArray = new bool[64] { false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true , true , true , true , true , true , true , true, true , true , true , true , true , true , true , true, true , true , true , true , true , true , true , true, true , true , true , true , true , true , true , true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false }; private ulong[] kingSafetyRing1 = new ulong[64], kingSafetyRing2 = new ulong[64]; private ulong[] kingSafetySpecialRingW = new ulong[64], kingSafetySpecialRingB = new ulong[64]; private ulong[] rowPrecalcs = new ulong[8], columnPrecalcs = new ulong[8]; const ulong columnUL = 0x101010101010101, rowUL = 0b11111111; private void PrecalculateKingSafetyBitboards() { for (int i = 0; i < 8; i++) { rowPrecalcs[i] = rowUL << (8 * i); columnPrecalcs[i] = columnUL << i; } for (int i = 0; i < 64; i++) { int tMod = i % 8; int tRow = (i - tMod) /8; ulong tULC = columnPrecalcs[tMod], tULR = rowPrecalcs[tRow]; ulong tULC2 = columnPrecalcs[tMod], tULR2 = rowPrecalcs[tRow]; if (tMod < 7) tULC |= columnPrecalcs[tMod + 1]; if (tMod > 0) tULC |= columnPrecalcs[tMod - 1]; if (tRow < 7) tULR |= rowPrecalcs[tRow + 1]; if (tRow > 0) tULR |= rowPrecalcs[tRow - 1]; if (tMod < 6) tULC2 |= columnPrecalcs[tMod + 2]; if (tMod > 1) tULC2 |= columnPrecalcs[tMod - 2]; if (tRow < 6) tULR2 |= rowPrecalcs[tRow + 2]; if (tRow > 1) tULR2 |= rowPrecalcs[tRow - 2]; tULR2 |= tULR; tULC2 |= tULC; kingSafetyRing1[i] = ULONG_OPERATIONS.SetBitToZero(tULR & tULC, i); kingSafetyRing2[i] = ULONG_OPERATIONS.SetBitsToZero(tULR2 & tULC2, i, i + 1, i - 1, i + 7, i + 8, i + 9, i - 7, i - 8, i - 9); } for (int i = 0; i < 64; i++) { if (i < 56) kingSafetySpecialRingW[i] = ULONG_OPERATIONS.SetBitToZero(kingSafetyRing1[i] | kingSafetyRing1[i + 8], i); else kingSafetySpecialRingW[i] = kingSafetyRing1[i]; if (i > 7) kingSafetySpecialRingB[i] = ULONG_OPERATIONS.SetBitToZero(kingSafetyRing1[i] | kingSafetyRing1[i - 8], i); else kingSafetySpecialRingB[i] = kingSafetyRing1[i]; } } private void PrecalculateEnPassantMoves() { for (int i = 0; i < 64; i++) { if (!epValidationArray[i]) continue; for (int j = 0; j < 64; j++) { if (i == j) continue; if (Math.Abs(i - j) > 9) continue; if (!epValidationArray[j]) continue; whiteEnPassantMoves[i, j] = new Move(false, i, j, j - 8); blackEnPassantMoves[i, j] = new Move(false, i, j, j + 8); } } } private void PawnAttackBitboards() { for (int sq = 0; sq < 64; sq++) { ulong u = 0ul; if (sq % 8 != 0) u = ULONG_OPERATIONS.SetBitToOne(u, sq + 7); if (sq % 8 != 7) u = ULONG_OPERATIONS.SetBitToOne(u, sq + 9); whitePawnAttackSquareBitboards[sq] = u; u = 0ul; if (sq % 8 != 0 && sq - 9 > -1) u = ULONG_OPERATIONS.SetBitToOne(u, sq - 9); if (sq % 8 != 7 && sq - 7 > -1) u = ULONG_OPERATIONS.SetBitToOne(u, sq - 7); blackPawnAttackSquareBitboards[sq] = u; } } private int[] squareConnectivesPrecalculationArray = new int[4096]; public int[] squareConnectivesCrossDirsPrecalculationArray { get; set; } = new int[4096]; private ulong[] squareConnectivesPrecalculationRayArray = new ulong[4096]; private ulong[] squareConnectivesPrecalculationLineArray = new ulong[4096]; private List<Dictionary<ulong, int>> rayCollidingSquareCalculations = new List<Dictionary<ulong, int>>(); private readonly int[] maxIntWithSpecifiedBitcount = new int[8] { 0, 0b1, 0b11, 0b111, 0b1111, 0b11111, 0b111111, 0b1111111 }; private List<ulong> differentRays = new List<ulong>(); private void SquareConnectivesPrecalculations() { for (int square = 0; square < 64; square++) { rayCollidingSquareCalculations.Add(new Dictionary<ulong, int>()); rayCollidingSquareCalculations[square].Add(0ul, square); for (int square2 = 0; square2 < 64; square2++) { if (square == square2) continue; int t = 0, t2 = 0, difSign = Math.Sign(square2 - square), itSq = square, g = 0; ulong tRay = 0ul, tExclRay = 0ul; List<int> tRayInts = new List<int>(); if (difSign == -1) g = 7; if (square % 8 == square2 % 8) { t2 = t = 1; while ((itSq += difSign * 8) < 64 && itSq > -1) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } } else if ((square - square % 8) == (square2 - square2 % 8)) { t = 1; t2 = -1; while ((itSq += difSign) % 8 != g && itSq > -1 && itSq < 64) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } } else { int dif = Math.Abs(square2 - square); if (dif % 7 == 0) { t = 2; t2 = 2; g = (difSign == 1) ? 7 : 0; while ((itSq += difSign * 7) % 8 != g && itSq < 64 && itSq > -1) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } if (ULONG_OPERATIONS.IsBitZero(tRay, square2)) { t2 = t = 0; tRay = 0ul; } } else if (dif % 9 == 0) { t = 2; t2 = -2; if (square == 0 && square2 == 63 || square == 63 && square2 == 0) SNAPSHOT_WRITLINE_REPLACEMENT("!"); while ((itSq += difSign * 9) % 8 != g && itSq < 64 && itSq > -1) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } if (ULONG_OPERATIONS.IsBitZero(tRay, square2)) { t2 = t = 0; tRay = 0ul; } } } if (square == 0 && square2 == 63) { t2 = t = 2; tRayInts.Clear(); tExclRay = tRay = ULONG_OPERATIONS.SetBitsToOne(0ul, 9, 18, 27, 36, 45, 54, 63); tRayInts = new List<int>() { 9, 18, 27, 36, 45, 54, 63 }; } else if (square2 == 0 && square == 63) { t = 2; tRayInts.Clear(); t2 = -2; tExclRay = tRay = ULONG_OPERATIONS.SetBitsToOne(0ul, 0, 9, 18, 27, 36, 45, 54); tRayInts = new List<int>() { 54, 45, 36, 27, 18, 9, 0 }; } if (tRay != 0ul && !differentRays.Contains(tRay)) { differentRays.Add(tRay); int ccount, combI = maxIntWithSpecifiedBitcount[ccount = ULONG_OPERATIONS.CountBits(tRay)]; do { ulong curAllPieceBitboard = 0ul; int solution = square; for (int j = 0; j < ccount; j++) { if (((combI >> j) & 1) == 1) { curAllPieceBitboard = ULONG_OPERATIONS.SetBitToOne(curAllPieceBitboard, tRayInts[j]); if (solution == square) solution = tRayInts[j]; } } rayCollidingSquareCalculations[square].Add(curAllPieceBitboard, solution); } while (--combI != 0); } squareConnectivesPrecalculationArray[square << 6 | square2] = t; squareConnectivesPrecalculationRayArray[square << 6 | square2] = tRay; squareConnectivesCrossDirsPrecalculationArray[square << 6 | square2] = t2; if (t != 0) squareConnectivesPrecalculationLineArray[square << 6 | square2] = (square == 0 && square2 == 63 || square2 == 0 && square == 63) ? tExclRay : ULONG_OPERATIONS.SetBitToOne(tExclRay, square2); if (squareConnectivesPrecalculationLineArray[square << 6 | square2] == 0ul && ULONG_OPERATIONS.IsBitOne(knightSquareBitboards[square], square2)) squareConnectivesPrecalculationLineArray[square << 6 | square2] = 1ul << square2; } differentRays.Clear(); } } public void SNAPSHOT_WRITLINE_REPLACEMENT() { } public void SNAPSHOT_WRITLINE_REPLACEMENT(object pStr) { } private string GetDoublePrecentageString(double pVal) { return ((int)(pVal * 1_000_000) /10_000d) + "%"; } private string ReplaceAllULONGIsBitOne(string pCode) { const string METHOD_NAME = "ULONG_OPERATIONS.IsBitOne"; int METHOD_NAME_LEN = METHOD_NAME.Length, iterations = 0; int pIndex = pCode.IndexOf(METHOD_NAME); while (pIndex != -1 && ++iterations < 10_000) { List<int> paramIndexes = new List<int>(); int openedBracketCount = 1, closedBracketCount = 0, a = METHOD_NAME_LEN + pIndex; string tpCode = pCode.Substring(0, pIndex); paramIndexes.Add(a + 1); while (++a < pCode.Length) { switch (pCode[a]) { case '(': openedBracketCount++; break; case ')': if (++closedBracketCount == openedBracketCount) { pIndex = a; a = int.MaxValue - 5; } break; case ',': if (openedBracketCount - closedBracketCount == 1) paramIndexes.Add(a + 1); break; } } if (openedBracketCount == closedBracketCount && paramIndexes.Count == 2) { tpCode += "((int)("+ pCode.Substring(paramIndexes[0], paramIndexes[1] - paramIndexes[0] - 1) + (pCode[paramIndexes[1]] == ' ' ? " >> (": " >> (") + pCode.Substring(paramIndexes[1], pIndex - paramIndexes[1]) + ")) & 1) == 1"+ pCode.Substring(pIndex + 1, pCode.Length - pIndex - 1); } pIndex = (pCode = tpCode).IndexOf(METHOD_NAME); } SNAPSHOT_WRITLINE_REPLACEMENT(iterations + " ITERATIONS"); return pCode; } private string ReplaceAllULONGIsBitZero(string pCode) { const string METHOD_NAME = "ULONG_OPERATIONS.IsBitZero"; int METHOD_NAME_LEN = METHOD_NAME.Length, iterations = 0; int pIndex = pCode.IndexOf(METHOD_NAME); while (pIndex != -1 && ++iterations < 10_000) { List<int> paramIndexes = new List<int>(); int openedBracketCount = 1, closedBracketCount = 0, a = METHOD_NAME_LEN + pIndex; string tpCode = pCode.Substring(0, pIndex); paramIndexes.Add(a + 1); while (++a < pCode.Length) { switch (pCode[a]) { case '(': openedBracketCount++; break; case ')': if (++closedBracketCount == openedBracketCount) { pIndex = a; a = int.MaxValue - 5; } break; case ',': if (openedBracketCount - closedBracketCount == 1) paramIndexes.Add(a + 1); break; } } if (openedBracketCount == closedBracketCount && paramIndexes.Count == 2) { tpCode += "((int)("+ pCode.Substring(paramIndexes[0], paramIndexes[1] - paramIndexes[0] - 1) + (pCode[paramIndexes[1]] == ' ' ? " >>": " >> ") + pCode.Substring(paramIndexes[1], pIndex - paramIndexes[1]) + ") & 1) == 0"+ pCode.Substring(pIndex + 1, pCode.Length - pIndex - 1); } pIndex = (pCode = tpCode).IndexOf(METHOD_NAME); } SNAPSHOT_WRITLINE_REPLACEMENT(iterations + " ITERATIONS"); return pCode; } private string GetThreeDigitSeperatedInteger(int pInt) { string s = pInt.ToString(), r = s[0].ToString(); int t = s.Length % 3; for (int i = 1; i < s.Length; i++) { if (i % 3 == t) r += "."; r += s[i]; } s = ""; for (int i = 0; i < r.Length; i++) s += r[i]; return s; } public double GetAverageDepth() { return (double)depths /(double)searches; } }
public class SNAPSHOT_V01_00_015 : IBoardManager  { public int TEXEL_PARAMS { get; } = 778; private const int BESTMOVE_SORT_VAL = -2_000_000_000; private const int CAPTURE_SORT_VAL = -1_000_000_000; private const int KILLERMOVE_SORT_VAL = -1000; private readonly int[,] MVVLVA_TABLE = new int[7, 7] { { 0, 0, 0, 0, 0, 0, 0 }, { 0, 1500, 1400, 1300, 1200, 1100, 1000 }, { 0, 3500, 3400, 3300, 3200, 3100, 3000 }, { 0, 4500, 4400, 4300, 4200, 4100, 4000 }, { 0, 5500, 5400, 5300, 5200, 5100, 5000 }, { 0, 9500, 9400, 9300, 9200, 9100, 9000 }, { 0, 0, 0, 0, 0, 0, 0 }}; private int BOARD_MANAGER_ID = -1; private bool debugSearchDepthResults = false; private bool debugSortResults = false; private RookMovement rookMovement; private BishopMovement bishopMovement; private QueenMovement queenMovement; private KnightMovement knightMovement; private KingMovement kingMovement; private WhitePawnMovement whitePawnMovement; private BlackPawnMovement blackPawnMovement; private Rays rays; public List<Move> moveOptionList { get; set; } private int[] pieceTypeArray = new int[64]; public ulong whitePieceBitboard, blackPieceBitboard, allPieceBitboard; private ulong zobristKey; private int whiteKingSquare, blackKingSquare, enPassantSquare = 65, happenedHalfMoves = 0, fiftyMoveRuleCounter = 0; private bool whiteCastleRightKingSide, whiteCastleRightQueenSide, blackCastleRightKingSide, blackCastleRightQueenSide; private bool isWhiteToMove; private const ulong WHITE_KING_ROCHADE = 96, WHITE_QUEEN_ROCHADE = 14, BLACK_KING_ROCHADE = 6917529027641081856, BLACK_QUEEN_ROCHADE = 1008806316530991104, WHITE_QUEEN_ATTK_ROCHADE = 12, BLACK_QUEEN_ATTK_ROCHADE = 864691128455135232; private readonly Move mWHITE_KING_ROCHADE = new Move(4, 6, 7, 5), mWHITE_QUEEN_ROCHADE = new Move(4, 2, 0, 3), mBLACK_KING_ROCHADE = new Move(60, 62, 63, 61), mBLACK_QUEEN_ROCHADE = new Move(60, 58, 56, 59); private ulong[] knightSquareBitboards = new ulong[64]; private ulong[] whitePawnAttackSquareBitboards = new ulong[64]; private ulong[] blackPawnAttackSquareBitboards = new ulong[64]; private ulong[] kingSquareBitboards = new ulong[64]; private bool[,] pieceTypeAbilities = new bool[7, 3] { { false, false, false }, { false, false, false }, { false, false, false }, { false, false, true }, { false, true, false }, { false, true, true }, { false, false, false } }; private List<int> moveHashList = new List<int>(); private ulong[] curSearchZobristKeyLine = Array.Empty<ulong>(); private Move[] debugMoveList = new Move[128]; private string debugFEN = ""; private Stopwatch globalTimer = Stopwatch.StartNew(); private Move lastMadeMove; private int depths, searches; private Random globalRandom = new Random(); public SNAPSHOT_V01_00_015(string fen) { Setup(fen); } public void Setup(string pFen) { Stopwatch setupStopwatch = Stopwatch.StartNew(); BOARD_MANAGER_ID = BOT_MAIN.curBoardManagerID; for (int i = 0; i < 33; i++) for (int j = 0; j < 14; j++) piecePositionEvals[i, j] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; for (int i = 0; i < 33; i++) for (int j = 0; j < 14; j++) texelTuningRuntimeVals[i, j] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; for (int i = 0; i < 3; i++) for (int j = 0; j < 6; j++) texelTuningVals[i, j] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; for (int i = 0; i < 14; i++) { texelTuningRuntimePositionalValsV2EG[i] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; texelTuningRuntimePositionalValsV2LG[i] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; } PrecalculateKingSafetyBitboards(); PrecalculateMultipliers(); GetLowNoisePositionalEvaluation(globalRandom); MinimaxRoot(1L); SetupConsoleWrite("[PRECALCS] Zobrist Hashing"); InitZobrist(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Knight Movement"); knightMovement = new KnightMovement(this); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Square Connectives"); SquareConnectivesPrecalculations(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Pawn Attack Bitboards"); PawnAttackBitboards(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Rays"); rays = new Rays(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); queenMovement = new QueenMovement(this); SetupConsoleWrite("[PRECALCS] Rook Movement"); rookMovement = new RookMovement(this, queenMovement); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Bishop Movement"); bishopMovement = new BishopMovement(this, queenMovement); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] King Movement"); kingMovement = new KingMovement(this); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Pawn Movement"); whitePawnMovement = new WhitePawnMovement(this); blackPawnMovement = new BlackPawnMovement(this); PrecalculateEnPassantMoves(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWriteLine("[DONE]\n\n"); LoadFenString(pFen); LoadBestTexelParamsIn(); setupStopwatch.Stop(); } private void SetupConsoleWriteLine(string pStr) { if (BOT_MAIN.isFirstBoardManagerInitialized) return; SNAPSHOT_WRITLINE_REPLACEMENT(pStr); } private void SetupConsoleWrite(string pStr) { if (BOT_MAIN.isFirstBoardManagerInitialized) return; SNAPSHOT_WRITLINE_REPLACEMENT(pStr); } public void GetLowNoisePositionalEvaluation(System.Random rng) { int[,][] digitArray = new int[3, 6][]; for (int i = 0; i < 3; i++) for (int j = 0; j < 6; j++) digitArray[i, j] = GetRand64IntArray(rng, -5, 6); lowNoisePositionEvals1 = GetInterpolatedProcessedValues(digitArray); int[,][] digitArray2 = new int[3, 6][]; for (int i = 0; i < 3; i++) for (int j = 0; j < 6; j++) digitArray2[i, j] = GetRand64IntArray(rng, -5, 6); lowNoisePositionEvals2 = GetInterpolatedProcessedValues(digitArray2); } private int[] GetRand64IntArray(System.Random rng, int pMin, int pMax) { return new int[64] { rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax) }; } private string GetAIArrayValuesStringRepresentation(int[,][] pArr) { string r = "int[,][] ReLe_AI_RESULT_VALS = new int[3, 6][] {"; for (int i = 0; i < 3; i++) { r += "{"; for (int j = 0; j < 5; j++) { r += GetIntArray64LStringRepresentation(pArr[i, j]) + ","; } r += GetIntArray64LStringRepresentation(pArr[i, 5]) + "},"; } return r.Substring(0, r.Length - 1) + "};"; } private string GetIntArray64LStringRepresentation(int[] p64LArr) { if (p64LArr == null) return ""; string r = "new int[64]{"; for (int i = 0; i < 63; i++) { r += p64LArr[i] + ","; } return r + p64LArr[63] + "}"; } public void TempStuff() { } private string[] gameResultStrings = new string[5] { "Black Has Won!", "Draw!", "White Has Won!", "Non Existant Result!", "Game is Ongoing!"}; private int[,][] lowNoisePositionEvals1, lowNoisePositionEvals2; public void ThreadSelfPlay(object obj) { PlayGameAgainstItself(obj); } public void PlayGameAgainstItself(object obj, string pStartFEN = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1", long tickLimitForEngine = ENGINE_VALS.SELF_PLAY_THINK_TIME) { int ttGState; while (BOT_MAIN.goalGameCount > BOT_MAIN.gamesPlayed) { try { string tGameStr; GetLowNoisePositionalEvaluation(globalRandom); LoadFenString(tGameStr = pStartFEN); tGameStr += ";"; int tGState = 3, tmc = 0; bool lowNoiceDecider = globalRandom.NextDouble() < 0.5d; while (tGState == 3) { piecePositionEvals = lowNoiceDecider ? lowNoisePositionEvals1 : lowNoisePositionEvals2; MinimaxRoot(tickLimitForEngine); Move tM = transpositionTable[zobristKey].bestMove; PlainMakeMove(tM); tGameStr += NuCRe.GetNuCRe(tM.moveHash) + ","; BOT_MAIN.movesPlayed++; tGState = GameState(isWhiteToMove); lowNoiceDecider = !lowNoiceDecider; tmc++; } ttGState = tGState; tGameStr += ttGState + 1; SNAPSHOT_WRITLINE_REPLACEMENT(tGameStr); BOT_MAIN.gamesPlayedResultArray[ttGState + 1]++; BOT_MAIN.gamesPlayed++; BOT_MAIN.selfPlayGameStrings.Add(tGameStr); } catch (Exception tE) { SNAPSHOT_WRITLINE_REPLACEMENT(tE.ToString()); } } } public void PlayGameOnConsoleAgainstHuman(string pStartFEN = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1", bool pHumanPlaysWhite = true, long tickLimitForEngine = 10_000_000L) { debugSearchDepthResults = true; LoadFenString(pStartFEN); if (!(pHumanPlaysWhite ^ isWhiteToMove)) { var pVS = Console.ReadLine(); if (pVS == null) return; Move tm = GetMoveOfString(pVS.ToString()); SNAPSHOT_WRITLINE_REPLACEMENT(tm); PlainMakeMove(tm); } int tGState = 3; while (tGState == 3) { MinimaxRoot(tickLimitForEngine); PlayThroughZobristTree(); Move tM = transpositionTable[zobristKey].bestMove; SNAPSHOT_WRITLINE_REPLACEMENT(tM); SNAPSHOT_WRITLINE_REPLACEMENT(CreateFenString()); PlainMakeMove(tM); tGState = GameState(isWhiteToMove); if (tGState != 3 || tM == NULL_MOVE) break; var pV = ""; tM = NULL_MOVE; do { pV = Console.ReadLine(); if (pV == null) continue; tM = GetMoveOfString(pV.ToString()); SNAPSHOT_WRITLINE_REPLACEMENT(tM); } while (tM == NULL_MOVE); PlainMakeMove(tM); tGState = GameState(isWhiteToMove); } } private void PlayThroughZobristTree() { SetJumpState(); SNAPSHOT_WRITLINE_REPLACEMENT("\n- - - - - - - - - - - - -"); int tC = 1; Dictionary<ulong, bool> usedULs = new Dictionary<ulong, bool>(); while (transpositionTable.TryGetValue(zobristKey, out TranspositionEntry tM)) { if (usedULs.ContainsKey(zobristKey)) { SNAPSHOT_WRITLINE_REPLACEMENT(tC + ": AT LEAST ONE REPETION; REST NOT VISIBLE"); break; } SNAPSHOT_WRITLINE_REPLACEMENT(tC + ": "+ tM.bestMove + " > "); usedULs.Add(zobristKey, true); PlainMakeMove(tM.bestMove); tC++; } SNAPSHOT_WRITLINE_REPLACEMENT("- - - - - - - - - - - - -\n"); LoadJumpState(); } public Move? ReturnNextMove(Move? lastMove, long pThinkingTime) { if (lastMove != null) PlainMakeMove(lastMove); if (GameState(isWhiteToMove) != 3) return null; MinimaxRoot(pThinkingTime); if (!transpositionTable.ContainsKey(zobristKey)) return null; Move tm = transpositionTable[zobristKey].bestMove; PlainMakeMove(tm); return tm; } private int[] jmpSt_pieceTypeArray; private ulong jmpSt_whitePieceBitboard, jmpSt_blackPieceBitboard; private ulong jmpSt_zobristKey; private int jmpSt_whiteKingSquare, jmpSt_blackKingSquare, jmpSt_enPassantSquare, jmpSt_happenedHalfMoves, jmpSt_fiftyMoveRuleCounter; private bool jmpSt_whiteCastleRightKingSide, jmpSt_whiteCastleRightQueenSide, jmpSt_blackCastleRightKingSide, jmpSt_blackCastleRightQueenSide; private bool jmpSt_isWhiteToMove; private ulong[] jmpSt_curSearchZobristKeyLine; private int[] jmpSt_moveHashList; public void LoadJumpState() { pieceTypeArray = (int[])jmpSt_pieceTypeArray.Clone(); whitePieceBitboard = jmpSt_whitePieceBitboard; blackPieceBitboard = jmpSt_blackPieceBitboard; zobristKey = jmpSt_zobristKey; whiteKingSquare = jmpSt_whiteKingSquare; blackKingSquare = jmpSt_blackKingSquare; enPassantSquare = jmpSt_enPassantSquare; happenedHalfMoves = jmpSt_happenedHalfMoves; fiftyMoveRuleCounter = jmpSt_fiftyMoveRuleCounter; whiteCastleRightKingSide = jmpSt_whiteCastleRightKingSide; whiteCastleRightQueenSide = jmpSt_whiteCastleRightQueenSide; blackCastleRightKingSide = jmpSt_blackCastleRightKingSide; blackCastleRightQueenSide = jmpSt_blackCastleRightQueenSide; isWhiteToMove = jmpSt_isWhiteToMove; curSearchZobristKeyLine = (ulong[])jmpSt_curSearchZobristKeyLine.Clone(); allPieceBitboard = blackPieceBitboard | whitePieceBitboard; moveHashList = jmpSt_moveHashList.ToList(); } public void SetJumpState() { jmpSt_pieceTypeArray = (int[])pieceTypeArray.Clone(); jmpSt_whitePieceBitboard = whitePieceBitboard; jmpSt_blackPieceBitboard = blackPieceBitboard; jmpSt_zobristKey = zobristKey; jmpSt_whiteKingSquare = whiteKingSquare; jmpSt_blackKingSquare = blackKingSquare; jmpSt_enPassantSquare = enPassantSquare; jmpSt_happenedHalfMoves = happenedHalfMoves; jmpSt_fiftyMoveRuleCounter = fiftyMoveRuleCounter; jmpSt_whiteCastleRightKingSide = whiteCastleRightKingSide; jmpSt_whiteCastleRightQueenSide = whiteCastleRightQueenSide; jmpSt_blackCastleRightKingSide = blackCastleRightKingSide; jmpSt_blackCastleRightQueenSide = blackCastleRightQueenSide; jmpSt_isWhiteToMove = isWhiteToMove; jmpSt_curSearchZobristKeyLine = (ulong[])curSearchZobristKeyLine.Clone(); jmpSt_moveHashList = moveHashList.ToArray(); } private int PreMinimaxCheckCheckWhite() { ulong bitShiftedKingPos = 1ul << whiteKingSquare; int curR = -1; for (int p = 0; p < 64; p++) { if (ULONG_OPERATIONS.IsBitZero(blackPieceBitboard, p)) continue; int tPT; switch (tPT = pieceTypeArray[p]) { case 1: if ((bitShiftedKingPos & blackPawnAttackSquareBitboards[p]) != 0ul) return p; break; case 2: if ((bitShiftedKingPos & knightSquareBitboards[p]) != 0ul) return p; break; case 6: break; default: if ((squareConnectivesPrecalculationLineArray[whiteKingSquare << 6 | p] & allPieceBitboard) == (1ul << p) && pieceTypeAbilities[tPT, squareConnectivesPrecalculationArray[whiteKingSquare << 6 | p]]) { if (curR != -1) return -779; curR = p; } break; } } return curR; } private int PreMinimaxCheckCheckBlack() { ulong bitShiftedKingPos = 1ul << blackKingSquare; int curR = -1; for (int p = 0; p < 64; p++) { if (ULONG_OPERATIONS.IsBitZero(whitePieceBitboard, p)) continue; int tPT; switch (tPT = pieceTypeArray[p]) { case 1: if ((bitShiftedKingPos & whitePawnAttackSquareBitboards[p]) != 0ul) return p; break; case 2: if ((bitShiftedKingPos & knightSquareBitboards[p]) != 0ul) return p; break; case 6: break; default: if ((squareConnectivesPrecalculationLineArray[blackKingSquare << 6 | p] & allPieceBitboard) == (1ul << p) && pieceTypeAbilities[tPT, squareConnectivesPrecalculationArray[blackKingSquare << 6 | p]]) { if (curR != -1) return -779; curR = p; } break; } } return curR; } private int LecacyLeafCheckingPieceCheckWhite(int pStartPos, int pEndPos, int pPieceType) { int tI, tPossibleAttackPiece; if (pPieceType == 1) { if (ULONG_OPERATIONS.IsBitOne(blackPawnAttackSquareBitboards[pEndPos], whiteKingSquare)) return pEndPos; } else if (pPieceType == 2) { if (ULONG_OPERATIONS.IsBitOne(knightSquareBitboards[pEndPos], whiteKingSquare)) return pEndPos; } else if (pPieceType != 6) { tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | pEndPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; } tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | pStartPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; return -1; } private int LecacyLeafCheckingPieceCheckBlack(int pStartPos, int pEndPos, int pPieceType) { int tI, tPossibleAttackPiece; if (pPieceType == 1) { if (ULONG_OPERATIONS.IsBitOne(whitePawnAttackSquareBitboards[pEndPos], blackKingSquare)) return pEndPos; } else if (pPieceType == 2) { if (ULONG_OPERATIONS.IsBitOne(knightSquareBitboards[pEndPos], blackKingSquare)) return pEndPos; } else if (pPieceType != 6) { tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | pEndPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; } tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | pStartPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; return -1; } public void GetLegalMoves(ref List<Move> pMoveList) { int attk; if (isWhiteToMove) { attk = PreMinimaxCheckCheckWhite(); if (attk == -779) GetLegalWhiteMovesSpecialDoubleCheckCase(ref pMoveList); else GetLegalWhiteMoves(attk, ref pMoveList); } else { attk = PreMinimaxCheckCheckBlack(); if (attk == -779) GetLegalBlackMovesSpecialDoubleCheckCase(ref pMoveList); else GetLegalBlackMoves(attk, ref pMoveList); } } private void GetLegalWhiteMoves(int pCheckingPieceSquare, ref List<Move> pMoveList) { if (pCheckingPieceSquare == -779) { GetLegalWhiteMovesSpecialDoubleCheckCase(ref pMoveList); return; } moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= blackPawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, whiteKingSquare); if (curCheckCount == 0) { if (whiteCastleRightKingSide && ((allPieceBitboard | oppAttkBitboard) & WHITE_KING_ROCHADE) == 0ul) pMoveList.Add(mWHITE_KING_ROCHADE); if (whiteCastleRightQueenSide && (allPieceBitboard & WHITE_QUEEN_ROCHADE | oppAttkBitboard & WHITE_QUEEN_ATTK_ROCHADE) == 0ul) pMoveList.Add(mWHITE_QUEEN_ROCHADE); if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, whitePieceBitboard, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[whiteKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare + 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, whitePieceBitboard, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveList(whiteKingSquare, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalWhiteCaptures(int pCheckingPieceSquare, ref List<Move> pMoveList) { if (pCheckingPieceSquare == -779) { GetLegalWhiteCapturesSpecialDoubleCheckCase(ref pMoveList); return; } moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= blackPawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, whiteKingSquare); if (curCheckCount == 0) { if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & blackPieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[whiteKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare + 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & blackPieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveListOnlyCaptures(whiteKingSquare, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalWhiteMovesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= blackPawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveList(whiteKingSquare, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalWhiteCapturesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= blackPawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveListOnlyCaptures(whiteKingSquare, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalBlackMoves(int pCheckingPieceSquare, ref List<Move> pMoveList) { if (pCheckingPieceSquare == -779) { GetLegalBlackMovesSpecialDoubleCheckCase(ref pMoveList); return; } moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= whitePawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, blackKingSquare); if (curCheckCount == 0) { if (blackCastleRightKingSide && ((allPieceBitboard | oppAttkBitboard) & BLACK_KING_ROCHADE) == 0ul) pMoveList.Add(mBLACK_KING_ROCHADE); if (blackCastleRightQueenSide && (allPieceBitboard & BLACK_QUEEN_ROCHADE | oppAttkBitboard & BLACK_QUEEN_ATTK_ROCHADE) == 0ul) pMoveList.Add(mBLACK_QUEEN_ROCHADE); if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveList(p, blackKingSquare, blackPieceBitboard, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[blackKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare - 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveList(p, blackKingSquare, blackPieceBitboard, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveList(blackKingSquare, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); } private void GetLegalBlackCaptures(int pCheckingPieceSquare, ref List<Move> pMoveList) { if (pCheckingPieceSquare == -779) { GetLegalBlackCapturesSpecialDoubleCheckCase(ref pMoveList); return; } moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= whitePawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, blackKingSquare); if (curCheckCount == 0) { if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & whitePieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[blackKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare - 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & whitePieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveListOnlyCaptures(blackKingSquare, ~oppAttkBitboard & whitePieceBitboard); } private void GetLegalBlackMovesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= whitePawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveList(blackKingSquare, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); } private void GetLegalBlackCapturesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= whitePawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveListOnlyCaptures(blackKingSquare, ~oppAttkBitboard & whitePieceBitboard); } public Move GetMoveOfString(string pMove) { int tSP, tEP; string[] tSpl = pMove.Split(','); if (Char.IsNumber(pMove[0])) { tSP = Convert.ToInt32(tSpl[0]); tEP = Convert.ToInt32(tSpl[1]); } else { tSP = SQUARES.NumberNotation(tSpl[0]); tEP = SQUARES.NumberNotation(tSpl[1]); } int tPT = pieceTypeArray[tSP]; bool tIC = ULONG_OPERATIONS.IsBitOne(allPieceBitboard, tEP), tIEP = enPassantSquare == tEP && tPT == 1; if (tSpl.Length == 3) return new Move(tSP, tEP, tPT, Convert.ToInt32(tSpl[2]), tIC); if (tIEP) return new Move(true, tSP, tEP, isWhiteToMove ? tEP - 8 : tEP + 8); if (tPT == 1 && Math.Abs(tSP - tEP) > 11) return new Move(tSP, tEP, 1, false, isWhiteToMove ? tSP + 8 : tSP - 8); if (tPT == 6 && (Math.Abs(tSP - tEP) == 2 || Math.Abs(tSP - tEP) == 3)) { if (isWhiteToMove) return tEP == 6 ? mWHITE_KING_ROCHADE : mWHITE_QUEEN_ROCHADE; return tEP == 62 ? mBLACK_KING_ROCHADE : mBLACK_QUEEN_ROCHADE; } return new Move(tSP, tEP, tPT, tIC); } public void PlainMakeMove(string pMoveName) { PlainMakeMove(GetMoveOfString(pMoveName)); } public void PlainMakeMove(Move pMove) { lastMadeMove = pMove; if (isWhiteToMove) WhiteMakeMove(pMove); else BlackMakeMove(pMove); debugFEN = CreateFenString(); } public void WhiteMakeMove(Move pMove) { int tEndPos = pMove.endPos, tStartPos = pMove.startPos, tPieceType = pMove.pieceType, tPTI = pieceTypeArray[tEndPos]; fiftyMoveRuleCounter++; whitePieceBitboard ^= pMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey ^= blackTurnHash ^ enPassantSquareHashes[enPassantSquare] ^ pieceHashesWhite[tStartPos, tPieceType] ^ pieceHashesWhite[tEndPos, tPieceType]; enPassantSquare = 65; isWhiteToMove = false; switch (pMove.moveTypeID) { case 0: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 1: fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 2: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 3: whiteKingSquare = tEndPos; if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 4: if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 5: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 6: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 7: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[whiteKingSquare = tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 8: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 9: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = pMove.enPassantOption]; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 11: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; whiteKingSquare = tEndPos; pieceTypeArray[pMove.rochadeEndPos] = 4; pieceTypeArray[pMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesWhite[pMove.rochadeStartPos, 4] ^ pieceHashesWhite[pMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 12: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[pMove.enPassantOption] = 0; zobristKey ^= pieceHashesBlack[pMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 13: fiftyMoveRuleCounter = 0; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; zobristKey ^= pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, pMove.promotionType]; break; case 14: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, tPTI] ^ pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, pMove.promotionType]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; } moveHashList.Add(pMove.moveHash); if (pMove.isCapture || tPieceType == 1) { curSearchZobristKeyLine = Array.Empty<ulong>(); return; } ulong[] u = new ulong[(tPTI = curSearchZobristKeyLine.Length) + 1]; for (int i = tPTI; i-- > 0;) u[i] = curSearchZobristKeyLine[i]; u[tPTI] = zobristKey; curSearchZobristKeyLine = u; } public void BlackMakeMove(Move pMove) { int tEndPos = pMove.endPos, tStartPos = pMove.startPos, tPieceType = pMove.pieceType, tPTI = pieceTypeArray[tEndPos]; fiftyMoveRuleCounter++; blackPieceBitboard ^= pMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey ^= blackTurnHash ^ enPassantSquareHashes[enPassantSquare] ^ pieceHashesBlack[tStartPos, tPieceType] ^ pieceHashesBlack[tEndPos, tPieceType]; enPassantSquare = 65; isWhiteToMove = true; switch (pMove.moveTypeID) { case 0: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 1: fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 2: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 3: blackKingSquare = tEndPos; if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 4: if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 5: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 6: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 7: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[blackKingSquare = tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 8: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 9: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = pMove.enPassantOption]; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 11: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; blackKingSquare = tEndPos; pieceTypeArray[pMove.rochadeEndPos] = 4; pieceTypeArray[pMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesBlack[pMove.rochadeStartPos, 4] ^ pieceHashesBlack[pMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 12: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[pMove.enPassantOption] = 0; zobristKey ^= pieceHashesWhite[pMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 13: fiftyMoveRuleCounter = 0; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, pMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 14: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } zobristKey ^= pieceHashesWhite[tEndPos, tPTI] ^ pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, pMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; } moveHashList.Add(pMove.moveHash); if (pMove.isCapture || tPieceType == 1) { curSearchZobristKeyLine = Array.Empty<ulong>(); return; } ulong[] u = new ulong[(tPTI = curSearchZobristKeyLine.Length) + 1]; for (int i = tPTI; i-- > 0;) u[i] = curSearchZobristKeyLine[i]; u[tPTI] = zobristKey; curSearchZobristKeyLine = u; } public void WhiteUndoMove(Move pMove) { } private const int WHITE_CHECKMATE_VAL = 100000, BLACK_CHECKMATE_VAL = -100000, CHECK_EXTENSION_LENGTH = -12, MAX_QUIESCENCE_TOTAL_LENGTH = -32; private readonly Move NULL_MOVE = new Move(0, 0, 0); private int curSearchDepth = 0, curSubSearchDepth = -1; public int MinimaxRoot(long pTime) { evalCount = 0; searches++; int baseLineLen = 0; long tTimestamp = globalTimer.ElapsedTicks + pTime; ClearHeuristics(); transpositionTable.Clear(); ulong[] tZobristKeyLine = Array.Empty<ulong>(); if (curSearchZobristKeyLine != null) { baseLineLen = curSearchZobristKeyLine.Length; tZobristKeyLine = new ulong[baseLineLen]; Array.Copy(curSearchZobristKeyLine, tZobristKeyLine, baseLineLen); } int perftScore, tattk = isWhiteToMove ? PreMinimaxCheckCheckWhite() : PreMinimaxCheckCheckBlack(), pDepth = 1; (string, int) bookMoveTuple = TLMDatabase.SearchForNextBookMove(moveHashList); if (bookMoveTuple.Item2 != 0) { int actualMoveHash = NuCRe.GetNumber(bookMoveTuple.Item1); List<Move> tMoves = new List<Move>(); GetLegalMoves(ref tMoves); int tL = tMoves.Count; for (int i = 0; i < tL; i++) { if (tMoves[i].moveHash == actualMoveHash) { if (debugSearchDepthResults) { SNAPSHOT_WRITLINE_REPLACEMENT("TLM_DB_Count: " + bookMoveTuple.Item2); SNAPSHOT_WRITLINE_REPLACEMENT(">> " + tMoves[i]); } transpositionTable.Add(zobristKey, new TranspositionEntry(tMoves[i], Array.Empty<int>())); return 0; } } } do { curSearchDepth = pDepth; curSubSearchDepth = pDepth - 1; ulong[] completeZobristHistory = new ulong[baseLineLen + pDepth - CHECK_EXTENSION_LENGTH + 1]; for (int i = 0; i < baseLineLen; i++) completeZobristHistory[i] = curSearchZobristKeyLine[i]; curSearchZobristKeyLine = completeZobristHistory; if (isWhiteToMove) { if (tattk == -1) perftScore = MinimaxWhite(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); else perftScore = MinimaxWhite(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); } else { if (tattk == -1) perftScore = MinimaxBlack(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); else perftScore = MinimaxBlack(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); } if (debugSearchDepthResults && pTime != 1L) { int tNpS = Convert.ToInt32((double)evalCount * 10_000_000d /(double)(pTime - tTimestamp + globalTimer.ElapsedTicks)); int tSearchEval = perftScore; int timeForSearchSoFar = (int)((pTime - tTimestamp + globalTimer.ElapsedTicks) /10000d); Move tBestMove = transpositionTable[zobristKey].bestMove; SNAPSHOT_WRITLINE_REPLACEMENT((tSearchEval >= 0 ? "+": "") + tSearchEval); SNAPSHOT_WRITLINE_REPLACEMENT(" " + tBestMove + "  ["); SNAPSHOT_WRITLINE_REPLACEMENT("Depth = " + pDepth + ", "); SNAPSHOT_WRITLINE_REPLACEMENT("Evals = " + GetThreeDigitSeperatedInteger(evalCount) + ", "); SNAPSHOT_WRITLINE_REPLACEMENT("Time = " + GetThreeDigitSeperatedInteger(timeForSearchSoFar) + "ms, "); SNAPSHOT_WRITLINE_REPLACEMENT("NpS = " + GetThreeDigitSeperatedInteger(tNpS) + "]"); } pDepth++; } while (globalTimer.ElapsedTicks < tTimestamp && pDepth < 179); depths += pDepth - 1; BOT_MAIN.depthsSearched += pDepth - 1; BOT_MAIN.searchesFinished++; BOT_MAIN.evaluationsMade += evalCount; curSearchZobristKeyLine = tZobristKeyLine; return perftScore; } private int[] squareToRankArray = new int[64] { 0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1, 2,2,2,2,2,2,2,2, 3,3,3,3,3,3,3,3, 4,4,4,4,4,4,4,4, 5,5,5,5,5,5,5,5, 6,6,6,6,6,6,6,6, 7,7,7,7,7,7,7,7 }; private bool WhiteIsPositionTheSpecialCase(Move pLastMove, int pCheckingSquare) { if (pLastMove.isPromotion && pLastMove.isCapture && (pLastMove.promotionType == 4 || pLastMove.promotionType == 5)) { if(pLastMove.startPos % 8 == pCheckingSquare % 8 && pLastMove.startPos == whiteKingSquare + 8) return true; if (pCheckingSquare > -1 && squareToRankArray[pLastMove.startPos] == squareToRankArray[pCheckingSquare] && pLastMove.endPos == whiteKingSquare - 8) return true; } return false; } private bool BlackIsPositionTheSpecialCase(Move pLastMove, int pCheckingSquare) { if (pLastMove.isPromotion && pLastMove.isCapture && (pLastMove.promotionType == 4 || pLastMove.promotionType == 5)) { if (pLastMove.startPos % 8 == pCheckingSquare % 8 && pLastMove.startPos == blackKingSquare - 8) return true; if (pCheckingSquare > -1 && squareToRankArray[pLastMove.startPos] == squareToRankArray[pCheckingSquare] && pLastMove.endPos == blackKingSquare + 8) return true; } return false; } private int MinimaxWhite(int pPly, int pAlpha, int pBeta, int pDepth, int pRepetitionHistoryPly, int pCheckingSquare, Move pLastMove) { if (IsDrawByRepetition(pRepetitionHistoryPly - 4)) return 0; if ((pDepth <= 0 && pCheckingSquare == -1) || pDepth < CHECK_EXTENSION_LENGTH) return QuiescenceWhite(pPly, pAlpha, pBeta, pDepth - 1, pCheckingSquare, pLastMove); List<Move> moveOptionList = new List<Move>(); Move bestMove = NULL_MOVE; if (WhiteIsPositionTheSpecialCase(pLastMove, pCheckingSquare)) GetLegalWhiteMovesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalWhiteMoves(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tWhiteKingSquare = whiteKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1, curEval = BLACK_CHECKMATE_VAL - pDepth; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = true; double[] moveSortingArray = new double[molc]; int[] moveSortingArrayIndexes = new int[molc], thisSearchMoveSortingArrayForTransposEntry = new int[molc]; transpositionTable.TryGetValue(zobristKey, out TranspositionEntry transposEntry); if (transposEntry == null) { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; } } else { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove == transposEntry.bestMove) moveSortingArray[m] = BESTMOVE_SORT_VAL; else if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; if (transposEntry.moveGenOrderedEvalLength > m) moveSortingArray[m] -= transposEntry.moveGenOrderedEvals[m]; } } Array.Sort(moveSortingArray, moveSortingArrayIndexes); for (int m = 0; m < molc; m++) { int tActualIndex = moveSortingArrayIndexes[m]; Move curMove = moveOptionList[tActualIndex]; if (debugSortResults && pDepth == curSubSearchDepth) { SNAPSHOT_WRITLINE_REPLACEMENT(moveSortingArray[m] + " | "+ curMove); } int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; whitePieceBitboard = tWPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesWhite[tStartPos, tPieceType] ^ pieceHashesWhite[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 0: blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 1: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 2: blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 3: whiteKingSquare = tEndPos; if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 4: blackPieceBitboard = tBPB; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 5: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[whiteKingSquare = tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = curMove.enPassantOption]; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 11: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; whiteKingSquare = tEndPos; blackPieceBitboard = tBPB; pieceTypeArray[curMove.rochadeEndPos] = 4; pieceTypeArray[curMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesWhite[curMove.rochadeStartPos, 4] ^ pieceHashesWhite[curMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | curMove.rochadeEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << curMove.rochadeEndPos)) tCheckPos = curMove.rochadeEndPos; break; case 12: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesBlack[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 13: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; zobristKey ^= pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, curMove.promotionType]; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; case 14: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, tPTI] ^ pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, curMove.promotionType]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } curSearchZobristKeyLine[pRepetitionHistoryPly] = zobristKey; debugMoveList[pPly] = curMove; int tEval = MinimaxBlack(pPly + 1, pAlpha, pBeta, pDepth - 1, pRepetitionHistoryPly + 1, tCheckPos, curMove); thisSearchMoveSortingArrayForTransposEntry[tActualIndex] = tEval; pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 3: whiteKingSquare = tWhiteKingSquare; break; case 7: whiteKingSquare = tWhiteKingSquare; break; case 10: enPassantSquare = 65; break; case 11: whiteKingSquare = tWhiteKingSquare; pieceTypeArray[curMove.rochadeStartPos] = 4; pieceTypeArray[curMove.rochadeEndPos] = 0; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 13: pieceTypeArray[tStartPos] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval > curEval) { bestMove = curMove; curEval = tEval; } if (pAlpha < curEval) pAlpha = curEval; if (curEval >= pBeta) { if (!curMove.isCapture) { killerMoveHeuristic[curMove.moveHash] = true; if (pDepth > 0) historyHeuristic[curMove.moveHash] += pDepth * pDepth; } break; } } isWhiteToMove = true; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; if (molc == 0 && pCheckingSquare == -1) curEval = 0; if (!transpositionTable.ContainsKey(zobristKey)) transpositionTable.Add(zobristKey, new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry)); else transpositionTable[zobristKey] = new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry); return curEval; } private int QuiescenceWhite(int pPly, int pAlpha, int pBeta, int pDepth, int pCheckingSquare, Move pLastMove) { int standPat = TexelEvaluate(); if (standPat >= pBeta || pDepth < MAX_QUIESCENCE_TOTAL_LENGTH) return pBeta; if (standPat > pAlpha) pAlpha = standPat; List<Move> moveOptionList = new List<Move>(); if (WhiteIsPositionTheSpecialCase(pLastMove, pCheckingSquare)) GetLegalWhiteCapturesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalWhiteCaptures(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tWhiteKingSquare = whiteKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = true; for (int m = 0; m < molc; m++) { Move curMove = moveOptionList[m]; int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; whitePieceBitboard = tWPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesWhite[tStartPos, tPieceType] ^ pieceHashesWhite[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 5: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[whiteKingSquare = tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 12: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesBlack[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 14: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, tPTI] ^ pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, curMove.promotionType]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } debugMoveList[pPly] = curMove; int tEval = QuiescenceBlack(pPly + 1, pAlpha, pBeta, pDepth - 1, tCheckPos, curMove); pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 7: whiteKingSquare = tWhiteKingSquare; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval >= pBeta) return pBeta; if (pAlpha < tEval) pAlpha = tEval; } isWhiteToMove = true; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; return pAlpha; } private int MinimaxBlack(int pPly, int pAlpha, int pBeta, int pDepth, int pRepetitionHistoryPly, int pCheckingSquare, Move pLastMove) { if (IsDrawByRepetition(pRepetitionHistoryPly - 4)) return 0; if ((pDepth <= 0 && pCheckingSquare == -1) || pDepth < CHECK_EXTENSION_LENGTH) return QuiescenceBlack(pPly, pAlpha, pBeta, pDepth - 1, pCheckingSquare, pLastMove); List<Move> moveOptionList = new List<Move>(); Move bestMove = NULL_MOVE; if (BlackIsPositionTheSpecialCase(pLastMove, pCheckingSquare)) GetLegalBlackMovesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalBlackMoves(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tBlackKingSquare = blackKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1, curEval = WHITE_CHECKMATE_VAL + pDepth; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = false; double[] moveSortingArray = new double[molc]; int[] moveSortingArrayIndexes = new int[molc], thisSearchMoveSortingArrayForTransposEntry = new int[molc]; transpositionTable.TryGetValue(zobristKey, out TranspositionEntry transposEntry); if (transposEntry == null) { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; } } else { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove == transposEntry.bestMove) moveSortingArray[m] = BESTMOVE_SORT_VAL; else if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; if (transposEntry.moveGenOrderedEvalLength > m) moveSortingArray[m] -= transposEntry.moveGenOrderedEvals[m]; } } Array.Sort(moveSortingArray, moveSortingArrayIndexes); for (int m = 0; m < molc; m++) { int tActualIndex = moveSortingArrayIndexes[m]; Move curMove = moveOptionList[tActualIndex]; if (debugSortResults && pDepth == curSearchDepth) { SNAPSHOT_WRITLINE_REPLACEMENT("=== " + moveSortingArray[m] + " | "+ curMove); } int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; blackPieceBitboard = tBPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesBlack[tStartPos, tPieceType] ^ pieceHashesBlack[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 0: whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 1: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 2: whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 3: blackKingSquare = tEndPos; if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 4: whitePieceBitboard = tWPB; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 5: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[blackKingSquare = tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = curMove.enPassantOption]; whitePieceBitboard = tWPB; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 11: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; blackKingSquare = tEndPos; whitePieceBitboard = tWPB; pieceTypeArray[curMove.rochadeEndPos] = 4; pieceTypeArray[curMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesBlack[curMove.rochadeStartPos, 4] ^ pieceHashesBlack[curMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | curMove.rochadeEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << curMove.rochadeEndPos)) tCheckPos = curMove.rochadeEndPos; break; case 12: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesWhite[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 13: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, curMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; case 14: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } zobristKey ^= pieceHashesWhite[tEndPos, tPTI] ^ pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, curMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } curSearchZobristKeyLine[pRepetitionHistoryPly] = zobristKey; debugMoveList[pPly] = curMove; int tEval = MinimaxWhite(pPly + 1, pAlpha, pBeta, pDepth - 1, pRepetitionHistoryPly + 1, tCheckPos, curMove); thisSearchMoveSortingArrayForTransposEntry[tActualIndex] = tEval; pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 3: blackKingSquare = tBlackKingSquare; break; case 7: blackKingSquare = tBlackKingSquare; break; case 10: enPassantSquare = 65; break; case 11: blackKingSquare = tBlackKingSquare; pieceTypeArray[curMove.rochadeStartPos] = 4; pieceTypeArray[curMove.rochadeEndPos] = 0; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 13: pieceTypeArray[tStartPos] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval < curEval) { bestMove = curMove; curEval = tEval; } if (pBeta > curEval) pBeta = curEval; if (curEval <= pAlpha) { if (!curMove.isCapture) { killerMoveHeuristic[curMove.moveHash] = true; if (pDepth > 0) historyHeuristic[curMove.moveHash] += pDepth * pDepth; } break; } } isWhiteToMove = false; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; if (molc == 0 && pCheckingSquare == -1) curEval = 0; if (!transpositionTable.ContainsKey(zobristKey)) transpositionTable.Add(zobristKey, new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry)); else transpositionTable[zobristKey] = new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry); return curEval; } private int QuiescenceBlack(int pPly, int pAlpha, int pBeta, int pDepth, int pCheckingSquare, Move pLastMove) { int standPat = TexelEvaluate(); if (standPat <= pAlpha || pDepth < MAX_QUIESCENCE_TOTAL_LENGTH) return pAlpha; if (standPat < pBeta) pBeta = standPat; List<Move> moveOptionList = new List<Move>(); if (BlackIsPositionTheSpecialCase(pLastMove, pCheckingSquare)) GetLegalBlackCapturesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalBlackCaptures(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tBlackKingSquare = blackKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = false; for (int m = 0; m < molc; m++) { Move curMove = moveOptionList[m]; int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; blackPieceBitboard = tBPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesBlack[tStartPos, tPieceType] ^ pieceHashesBlack[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 5: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[blackKingSquare = tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 12: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesWhite[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 14: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } zobristKey ^= pieceHashesWhite[tEndPos, tPTI] ^ pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, curMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } debugMoveList[pPly] = curMove; int tEval = QuiescenceWhite(pPly + 1, pAlpha, pBeta, pDepth - 1, tCheckPos, curMove); pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 7: blackKingSquare = tBlackKingSquare; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval <= pAlpha) return pAlpha; if (pBeta > tEval) pBeta = tEval; } isWhiteToMove = false; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; return pBeta; } private bool[] killerMoveHeuristic = new bool[262_144]; private int[] historyHeuristic = new int[262_144]; public void ClearHeuristics() { for (int i = 0; i < 262_144; i++) { killerMoveHeuristic[i] = false; historyHeuristic[i] = 0; } } private Dictionary<ulong, TranspositionEntry> transpositionTable = new Dictionary<ulong, TranspositionEntry>(); private int[] pieceEvals = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[,][] piecePositionEvals = new int[33, 14][]; private int evalCount = 0; private int Evaluate() { evalCount++; if (fiftyMoveRuleCounter > 99) return 0; int tEval = 0, tPT, pieceCount = ULONG_OPERATIONS.CountBits(allPieceBitboard); for (int p = 0; p < 64; p++) tEval += pieceEvals[tPT = pieceTypeArray[p] + 7 * ((int)(blackPieceBitboard >> p) & 1)] + piecePositionEvals[pieceCount, tPT][p]; return tEval; } public int GameState(bool pWhiteKingCouldBeAttacked) { if (IsDrawByRepetition(curSearchZobristKeyLine.Length - 5) || fiftyMoveRuleCounter > 99) return 0; int t; List<Move> tMoves = new List<Move>(); GetLegalMoves(ref tMoves); if (pWhiteKingCouldBeAttacked) { t = PreMinimaxCheckCheckWhite(); if (t == -1) return tMoves.Count == 0 ? 0 : 3; else if (tMoves.Count == 0) return -1; } else { t = PreMinimaxCheckCheckBlack(); if (t == -1) return tMoves.Count == 0 ? 0 : 3; else if (tMoves.Count == 0) return 1; } return 3; } private bool IsDrawByRepetition(int pPlyOfFirstPossibleRepeatedPosition) { int tC = 0; for (int i = pPlyOfFirstPossibleRepeatedPosition; i >= 0; i -= 2) { if (curSearchZobristKeyLine[i] == zobristKey) if (++tC == 2) return true; } return false; } private const int RELE_MAX_MOVE_COUNT_PER_GAME = 500; public double ReLePlayGame(int[,][] pEvalPositionValuesWhite, int[,][] pEvalPositionValuesBlack, long thinkingTimePerMove) { int[,][] processedValuesWhite = InitReLeAgent(pEvalPositionValuesWhite), processedValuesBlack = InitReLeAgent(pEvalPositionValuesBlack); int tGS, mc = 0; do { if (IsDrawByRepetition(curSearchZobristKeyLine.Length - 5)) return 0d; piecePositionEvals = isWhiteToMove ? processedValuesWhite : processedValuesBlack; MinimaxRoot(thinkingTimePerMove); if (transpositionTable.Count == 0) { SNAPSHOT_WRITLINE_REPLACEMENT("?!"); return 0d; } PlainMakeMove(transpositionTable[zobristKey].bestMove); tGS = GameState(isWhiteToMove); transpositionTable.Clear(); if (tGS != 3) break; } while (mc++ < RELE_MAX_MOVE_COUNT_PER_GAME); if (tGS == 3 || tGS == 0) return 0d; else if (tGS == 1) return 0.1d * (double)(RELE_MAX_MOVE_COUNT_PER_GAME - mc); return 0.1d * (double)(-RELE_MAX_MOVE_COUNT_PER_GAME + mc); } public int[,][] InitReLeAgent(int[,][] pEvalPositionValues) { return GetInterpolatedProcessedValues(pEvalPositionValues); } private int[,][] GetInterpolatedProcessedValues(int[,][] pEvalPositionValues) { int[,][] processedValues = new int[33, 14][]; for (int i = 0; i < 32; i++) { int ip1 = i + 1; processedValues[ip1, 7] = processedValues[ip1, 0] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; processedValues[ip1, 8] = SwapArrayViewingSide(processedValues[ip1, 1] = MultiplyArraysWithVal(pEvalPositionValues[0, 0], pEvalPositionValues[1, 0], pEvalPositionValues[2, 0], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 9] = SwapArrayViewingSide(processedValues[ip1, 2] = MultiplyArraysWithVal(pEvalPositionValues[0, 1], pEvalPositionValues[1, 1], pEvalPositionValues[2, 1], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 10] = SwapArrayViewingSide(processedValues[ip1, 3] = MultiplyArraysWithVal(pEvalPositionValues[0, 2], pEvalPositionValues[1, 2], pEvalPositionValues[2, 2], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 11] = SwapArrayViewingSide(processedValues[ip1, 4] = MultiplyArraysWithVal(pEvalPositionValues[0, 3], pEvalPositionValues[1, 3], pEvalPositionValues[2, 3], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 12] = SwapArrayViewingSide(processedValues[ip1, 5] = MultiplyArraysWithVal(pEvalPositionValues[0, 4], pEvalPositionValues[1, 4], pEvalPositionValues[2, 4], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 13] = SwapArrayViewingSide(processedValues[ip1, 6] = MultiplyArraysWithVal(pEvalPositionValues[0, 5], pEvalPositionValues[1, 5], pEvalPositionValues[2, 5], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); } return processedValues; } private double[,][] GetInterpolatedProcessedValues(double[,][] pEvalPositionValues) { double[,][] processedValues = new double[33, 14][]; for (int i = 0; i < 32; i++) { int ip1 = i + 1; processedValues[ip1, 7] = processedValues[ip1, 0] = new double[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; processedValues[ip1, 8] = SwapArrayViewingSide(processedValues[ip1, 1] = MultiplyArraysWithVal(pEvalPositionValues[0, 0], pEvalPositionValues[1, 0], pEvalPositionValues[2, 0], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 9] = SwapArrayViewingSide(processedValues[ip1, 2] = MultiplyArraysWithVal(pEvalPositionValues[0, 1], pEvalPositionValues[1, 1], pEvalPositionValues[2, 1], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 10] = SwapArrayViewingSide(processedValues[ip1, 3] = MultiplyArraysWithVal(pEvalPositionValues[0, 2], pEvalPositionValues[1, 2], pEvalPositionValues[2, 2], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 11] = SwapArrayViewingSide(processedValues[ip1, 4] = MultiplyArraysWithVal(pEvalPositionValues[0, 3], pEvalPositionValues[1, 3], pEvalPositionValues[2, 3], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 12] = SwapArrayViewingSide(processedValues[ip1, 5] = MultiplyArraysWithVal(pEvalPositionValues[0, 4], pEvalPositionValues[1, 4], pEvalPositionValues[2, 4], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 13] = SwapArrayViewingSide(processedValues[ip1, 6] = MultiplyArraysWithVal(pEvalPositionValues[0, 5], pEvalPositionValues[1, 5], pEvalPositionValues[2, 5], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); } return processedValues; } private double[] MultiplyArraysWithVal(double[] pArr1, double[] pArr2, double[] pArr3, double pVal1, double pVal2, double pVal3) { int tL = pArr1.Length; double[] rArr = new double[tL]; for (int i = 0; i < tL; i++) { rArr[i] = pArr1[i] * pVal1 + pArr2[i] * pVal2 + pArr3[i] * pVal3; } return rArr; } private int[] MultiplyArraysWithVal(int[] pArr1, int[] pArr2, int[] pArr3, double pVal1, double pVal2, double pVal3) { int tL = pArr1.Length; int[] rArr = new int[tL]; for (int i = 0; i < tL; i++) { rArr[i] = (int)(pArr1[i] * pVal1 + pArr2[i] * pVal2 + pArr3[i] * pVal3); } return rArr; } private int[] SwapArrayViewingSideAndNegate(int[] pArr) { return new int[64] { -pArr[56], -pArr[57], -pArr[58], -pArr[59], -pArr[60], -pArr[61], -pArr[62], -pArr[63], -pArr[48], -pArr[49], -pArr[50], -pArr[51], -pArr[52], -pArr[53], -pArr[54], -pArr[55], -pArr[40], -pArr[41], -pArr[42], -pArr[43], -pArr[44], -pArr[45], -pArr[46], -pArr[47], -pArr[32], -pArr[33], -pArr[34], -pArr[35], -pArr[36], -pArr[37], -pArr[38], -pArr[39], -pArr[24], -pArr[25], -pArr[26], -pArr[27], -pArr[28], -pArr[29], -pArr[30], -pArr[31], -pArr[16], -pArr[17], -pArr[18], -pArr[19], -pArr[20], -pArr[21], -pArr[22], -pArr[23], -pArr[8], -pArr[9], -pArr[10], -pArr[11], -pArr[12], -pArr[13], -pArr[14], -pArr[15], -pArr[0], -pArr[1], -pArr[2], -pArr[3], -pArr[4], -pArr[5], -pArr[6], -pArr[7] }; } private int[] SwapArrayViewingSide(int[] pArr) { return new int[64] { pArr[56], pArr[57], pArr[58], pArr[59], pArr[60], pArr[61], pArr[62], pArr[63], pArr[48], pArr[49], pArr[50], pArr[51], pArr[52], pArr[53], pArr[54], pArr[55], pArr[40], pArr[41], pArr[42], pArr[43], pArr[44], pArr[45], pArr[46], pArr[47], pArr[32], pArr[33], pArr[34], pArr[35], pArr[36], pArr[37], pArr[38], pArr[39], pArr[24], pArr[25], pArr[26], pArr[27], pArr[28], pArr[29], pArr[30], pArr[31], pArr[16], pArr[17], pArr[18], pArr[19], pArr[20], pArr[21], pArr[22], pArr[23], pArr[8], pArr[9], pArr[10], pArr[11], pArr[12], pArr[13], pArr[14], pArr[15], pArr[0], pArr[1], pArr[2], pArr[3], pArr[4], pArr[5], pArr[6], pArr[7] }; } private double[] SwapArrayViewingSide(double[] pArr) { return new double[64] { pArr[56], pArr[57], pArr[58], pArr[59], pArr[60], pArr[61], pArr[62], pArr[63], pArr[48], pArr[49], pArr[50], pArr[51], pArr[52], pArr[53], pArr[54], pArr[55], pArr[40], pArr[41], pArr[42], pArr[43], pArr[44], pArr[45], pArr[46], pArr[47], pArr[32], pArr[33], pArr[34], pArr[35], pArr[36], pArr[37], pArr[38], pArr[39], pArr[24], pArr[25], pArr[26], pArr[27], pArr[28], pArr[29], pArr[30], pArr[31], pArr[16], pArr[17], pArr[18], pArr[19], pArr[20], pArr[21], pArr[22], pArr[23], pArr[8], pArr[9], pArr[10], pArr[11], pArr[12], pArr[13], pArr[14], pArr[15], pArr[0], pArr[1], pArr[2], pArr[3], pArr[4], pArr[5], pArr[6], pArr[7] }; } private int[,][] texelTuningRuntimeVals = new int[33, 14][]; private int[,][] texelTuningVals = new int[3, 6][]; private int[,] texelTuningAdjustIterations = new int[6, 64]; private int[][] texelTuningRuntimePositionalValsV2EG = new int[14][]; private int[][] texelTuningRuntimePositionalValsV2LG = new int[14][]; private int[] texelPieceEvaluationsV2EG = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[] texelPieceEvaluationsV2LG = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[] texelKingSafetyR1EvaluationsEG = new int[9]; private int[] texelKingSafetyR2EvaluationsEG = new int[17]; private int[] texelKingSafetyR1EvaluationsLG = new int[9]; private int[] texelKingSafetyR2EvaluationsLG = new int[17]; private int[] texelKingSafetySREvaluationsPT1EG = new int[12]; private int[] texelKingSafetySREvaluationsPT2EG = new int[12]; private int[] texelKingSafetySREvaluationsPT3EG = new int[12]; private int[] texelKingSafetySREvaluationsPT4EG = new int[12]; private int[] texelKingSafetySREvaluationsPT5EG = new int[12]; private int[] texelKingSafetySREvaluationsPT6EG = new int[12]; private int[] texelKingSafetySREvaluationsPT1LG = new int[12]; private int[] texelKingSafetySREvaluationsPT2LG = new int[12]; private int[] texelKingSafetySREvaluationsPT3LG = new int[12]; private int[] texelKingSafetySREvaluationsPT4LG = new int[12]; private int[] texelKingSafetySREvaluationsPT5LG = new int[12]; private int[] texelKingSafetySREvaluationsPT6LG = new int[12]; private int[,] texelMobilityStraightEG = new int[14, 15], texelMobilityStraightLG = new int[14, 15]; private int[,] texelMobilityDiagonalEG = new int[14, 14], texelMobilityDiagonalLG = new int[14, 14]; private int[] texelPieceEvaluations = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[] blackSidedSquares = new int[64] { 56, 57, 58, 59, 60, 61, 62, 63, 48, 49, 50, 51, 52, 53, 54, 55, 40, 41, 42, 43, 44, 45, 46, 47, 32, 33, 34, 35, 36, 37, 38, 39, 24, 25, 26, 27, 28, 29, 30, 31, 16, 17, 18, 19, 20, 21, 22, 23, 08, 09, 10, 11, 12, 13, 14, 15, 00, 01, 02, 03, 04, 05, 06, 07 }; private int[,] T_Pawns = new int[3, 64] { { 0, 0, 0, 0, 0, 0, 0, 0, 98, 134, 61, 95, 68, 126, 34, -11, -6, 7, 26, 31, 65, 56, 25, -20, -14, 13, 6, 21, 23, 12, 17, -23, -27, -2, -5, 12, 17, 6, 10, -25, -26, -4, -4, -10, 3, 3, 33, -12, -35, -1, -20, -23, -15, 24, 38, -22, 0, 0, 0, 0, 0, 0, 0, 0, } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { 0, 0, 0, 0, 0, 0, 0, 0, 178, 173, 158, 134, 147, 132, 165, 187, 94, 100, 85, 67, 56, 53, 82, 84, 32, 24, 13, 5, -2, 4, 17, 17, 13, 9, -3, -7, -7, -8, 3, -1, 4, 7, -6, 1, 0, -5, -1, -8, 13, 8, 8, 10, 13, 0, 2, -7, 0, 0, 0, 0, 0, 0, 0, 0, } }; private int[,] T_Knights = new int[3, 64] { { -167, -89, -34, -49, 61, -97, -15, -107, -73, -41, 72, 36, 23, 62, 7, -17, -47, 60, 37, 65, 84, 129, 73, 44, -9, 17, 19, 53, 37, 69, 18, 22, -13, 4, 16, 13, 28, 19, 21, -8, -23, -9, 12, 10, 19, 17, 25, -16, -29, -53, -12, -3, -1, 18, -14, -19, -105, -21, -58, -33, -17, -28, -19, -23 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -58, -38, -13, -28, -31, -27, -63, -99, -25, -8, -25, -2, -9, -25, -24, -52, -24, -20, 10, 9, -1, -9, -19, -41, -17, 3, 22, 22, 22, 11, 8, -18, -18, -6, 16, 25, 16, 17, 4, -18, -23, -3, -1, 15, 10, -3, -20, -22, -42, -20, -10, -5, -2, -20, -23, -44, -29, -51, -23, -15, -22, -18, -50, -64 } }; private int[,] T_Bishops = new int[3, 64] { { -29, 4, -82, -37, -25, -42, 7, -8, -26, 16, -18, -13, 30, 59, 18, -47, -16, 37, 43, 40, 35, 50, 37, -2, -4, 5, 19, 50, 37, 37, 7, -2, -6, 13, 13, 26, 34, 12, 10, 4, 0, 15, 15, 15, 14, 27, 18, 10, 4, 15, 16, 0, 7, 21, 33, 1, -33, -3, -14, -21, -13, -12, -39, -21 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -14, -21, -11, -8, -7, -9, -17, -24, -8, -4, 7, -12, -3, -13, -4, -14, 2, -8, 0, -1, -2, 6, 0, 4, -3, 9, 12, 9, 14, 10, 3, 2, -6, 3, 13, 19, 7, 10, -3, -9, -12, -3, 8, 10, 13, 3, -7, -15, -14, -18, -7, -1, 4, -9, -15, -27, -23, -9, -23, -5, -9, -16, -5, -17 } }; private int[,] T_Rooks = new int[3, 64] { { 32, 42, 32, 51, 63, 9, 31, 43, 27, 32, 58, 62, 80, 67, 26, 44, -5, 19, 26, 36, 17, 45, 61, 16, -24, -11, 7, 26, 24, 35, -8, -20, -36, -26, -12, -1, 9, -7, 6, -23, -45, -25, -16, -17, 3, 0, -5, -33, -44, -16, -20, -9, -1, 11, -6, -71, -19, -13, 1, 17, 16, 7, -37, -26 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { 13, 10, 18, 15, 12, 12, 8, 5, 11, 13, 13, 11, -3, 3, 8, 3, 7, 7, 7, 5, 4, -3, -5, -3, 4, 3, 13, 1, 2, 1, -1, 2, 3, 5, 8, 4, -5, -6, -8, -11, -4, 0, -5, -1, -7, -12, -8, -16, -6, -6, 0, 2, -9, -9, -11, -3, -9, 2, 3, -1, -5, -13, 4, -20 } }; private int[,] T_Queens = new int[3, 64] { { -28, 0, 29, 12, 59, 44, 43, 45, -24, -39, -5, 1, -16, 57, 28, 54, -13, -17, 7, 8, 29, 56, 47, 57, -27, -27, -16, -16, -1, 17, -2, 1, -9, -26, -9, -10, -2, -4, 3, -3, -14, 2, -11, -2, -5, 2, 14, 5, -35, -8, 11, 2, 8, 15, -3, 1, -1, -18, -9, 10, -15, -25, -31, -50 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -9, 22, 22, 27, 27, 19, 10, 20, -17, 20, 32, 41, 58, 25, 30, 0, -20, 6, 9, 49, 47, 35, 19, 9, 3, 22, 24, 45, 57, 40, 57, 36, -18, 28, 19, 47, 31, 34, 39, 23, -16, -27, 15, 6, 9, 17, 10, 5, -22, -23, -30, -16, -16, -23, -36, -32, -33, -28, -22, -43, -5, -32, -20, -41 } }; private int[,] T_Kings = new int[3, 64] { { -65, 23, 16, -15, -56, -34, 2, 13, 29, -1, -20, -7, -8, -4, -38, -29, -9, 24, 2, -16, -20, 6, 22, -22, -17, -20, -12, -27, -30, -25, -14, -36, -49, -1, -27, -39, -46, -44, -33, -51, -14, -14, -22, -46, -44, -30, -15, -27, 1, 7, -8, -64, -43, -16, 9, 8, -15, 36, 12, -54, 8, -28, 24, 14 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -74, -35, -18, -18, -11, 15, 4, -17, -12, 17, 14, 17, 17, 38, 23, 11, 10, 17, 23, 15, 20, 45, 44, 13, -8, 22, 24, 27, 26, 33, 26, 3, -18, -4, 21, 24, 27, 23, 9, -11, -19, -3, 11, 21, 23, 16, 7, -9, -27, -11, 4, 13, 14, 4, -5, -17, -53, -34, -21, -11, -28, -14, -24, -43 } }; private int[] paramsLowerLimits = new int[5] { -10000, -10000, -10000, -10000, -10000 }; private int[] paramsUpperLimits = new int[5] { 10000, 10000, 10000, 10000, 10000 }; private List<TLM_ChessGame> threadDataset; private int threadFrom, threadTo; private int[] threadParams; private int customThreadID = 0; private ulong ulAllThreadIDsUnfinished = 0; private double lastCostVal = 0d; private double sumCostVals = 0d; private int costCalculations = 0; private readonly string[] TEXELPRINT_GAMEPARTS = new string[3] { "Early Game: ", "Mid Game: ", "Late Game: "}; private readonly string[] TEXELPRINT_PIECES = new string[6] { "Bauer: ", "Springer: ", "Lufer: ", "Turm: ", "Dame: ", "Knig: "}; private double[] earlyGameMultipliers = new double[33]; private double[] middleGameMultipliers = new double[33]; private double[] lateGameMultipliers = new double[33]; private int[] pieceTypeGameProgressImpact = new int[14] { 0, 0, 1, 1, 2, 4, 0, 0, 0, 1, 1, 2, 4, 0 }; private void PrecalculateMultipliers() { if (BOARD_MANAGER_ID == ENGINE_VALS.PARALLEL_BOARDS - 1) SNAPSHOT_WRITLINE_REPLACEMENT(); for (int i = 0; i < 25; i++) { earlyGameMultipliers[i] = EGMultiplierFunction(i); lateGameMultipliers[i] = LGMultiplierFunction(i); if (BOARD_MANAGER_ID == ENGINE_VALS.PARALLEL_BOARDS - 1) SNAPSHOT_WRITLINE_REPLACEMENT("[" + i + "] "+ earlyGameMultipliers[i] + " | "+ middleGameMultipliers[i] + " | "+ lateGameMultipliers[i]); } } private double MultiplierFunction(double pVal, double pXShift) { double d = Math.Exp(1d /6d * (pVal - pXShift)); return 5 * (d /Math.Pow(d + 1, 2d)); } private double EGMultiplierFunction(double pVal) { return Math.Clamp(1 /16d * (pVal - 4d), 0d, 1d); } private double LGMultiplierFunction(double pVal) { return Math.Clamp(1 /-16d * (pVal - 4d) + 1d, 0d, 1d); } private double EGMultiplierFunction2(double pVal) { return Math.Clamp(1 /32d * pVal, 0d, 1d); } private double LGMultiplierFunction2(double pVal) { return Math.Clamp(1 /-32d * pVal + 1d, 0d, 1d); } private void TuneWithTxtFile(string pTXTName) { List<TLM_ChessGame> gameDataset = new List<TLM_ChessGame>(); string tPath = PathManager.GetTXTPath(pTXTName); string[] tStrs = File.ReadAllLines(tPath); List<string> tGames = new List<string>(); foreach (string s in tStrs) if (s.Contains(';') && s.Replace(" ", "") != "") tGames.Add(s); foreach (string s in tGames) { TLM_ChessGame tGame = CGFF.GetGame(s); LoadFenString(tGame.startFen); foreach (int hMove in tGame.hashedMoves) { List<Move> moveOptionList = new List<Move>(); GetLegalMoves(ref moveOptionList); int tL = moveOptionList.Count; for (int j = 0; j < tL; j++) { Move tMove = moveOptionList[j]; if (tMove.moveHash == hMove) { tGame.actualMoves.Add(tMove); PlainMakeMove(tMove); tL = -1; break; } } if (tL != -1) break; } gameDataset.Add(tGame); } SNAPSHOT_WRITLINE_REPLACEMENT("[TLM TEXEL TUNER] " + tGames.Count + " Games Loaded In!"); BOT_MAIN.curTEXELPARAMS = new int[TEXEL_PARAMS]; BOT_MAIN.ParallelTexelTuning(gameDataset); } private void LoadBestTexelParamsIn() { int[] ttt = new int[778]; ttt[0] = 82; ttt[1] = 341; ttt[2] = 416; ttt[3] = 470; ttt[4] = 1106; ttt[5] = 102; ttt[6] = 302; ttt[7] = 304; ttt[8] = 518; ttt[9] = 960; SetupTexelEvaluationParams(ttt); } private void SetupTexelEvaluationParams(int[] pParams) { texelPieceEvaluationsV2EG[8] = -(texelPieceEvaluationsV2EG[1] = pParams[0]); texelPieceEvaluationsV2EG[9] = -(texelPieceEvaluationsV2EG[2] = pParams[1]); texelPieceEvaluationsV2EG[10] = -(texelPieceEvaluationsV2EG[3] = pParams[2]); texelPieceEvaluationsV2EG[11] = -(texelPieceEvaluationsV2EG[4] = pParams[3]); texelPieceEvaluationsV2EG[12] = -(texelPieceEvaluationsV2EG[5] = pParams[4]); texelPieceEvaluationsV2LG[8] = -(texelPieceEvaluationsV2LG[1] = pParams[5]); texelPieceEvaluationsV2LG[9] = -(texelPieceEvaluationsV2LG[2] = pParams[6]); texelPieceEvaluationsV2LG[10] = -(texelPieceEvaluationsV2LG[3] = pParams[7]); texelPieceEvaluationsV2LG[11] = -(texelPieceEvaluationsV2LG[4] = pParams[8]); texelPieceEvaluationsV2LG[12] = -(texelPieceEvaluationsV2LG[5] = pParams[9]); int c = 10; for (int p = 1; p < 7; p++) { for (int s = 0; s < 64; s++) { texelTuningRuntimePositionalValsV2EG[p + 7][blackSidedSquares[s]] = -(texelTuningRuntimePositionalValsV2EG[p][s] = pParams[c++]); texelTuningRuntimePositionalValsV2LG[p + 7][blackSidedSquares[s]] = -(texelTuningRuntimePositionalValsV2LG[p][s] = pParams[c++]); } } return; for (int p = 2; p < 7; p++) { for (int a = 0; a < 15; a++) { if (a != 14) { texelMobilityDiagonalEG[p + 7, a] = -(texelMobilityDiagonalEG[p, a] = pParams[c++]); texelMobilityDiagonalLG[p + 7, a] = -(texelMobilityDiagonalLG[p, a] = pParams[c++]); } texelMobilityStraightEG[p + 7, a] = -(texelMobilityStraightEG[p, a] = pParams[c++]); texelMobilityStraightLG[p + 7, a] = -(texelMobilityStraightLG[p, a] = pParams[c++]); } } for (int i = 0; i < 12; i++) { texelKingSafetySREvaluationsPT1EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT2EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT3EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT4EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT5EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT6EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT1LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT2LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT3LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT4LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT5LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT6LG[i] = pParams[c++]; } } private void PrintDefinedTexelParams(int[] pParams) { int c = 0; for (int t = 0; t < 3; t++) { SNAPSHOT_WRITLINE_REPLACEMENT(TEXELPRINT_GAMEPARTS[t]); for (int p = 0; p < 6; p++) { SNAPSHOT_WRITLINE_REPLACEMENT(TEXELPRINT_PIECES[p]); texelTuningVals[t, p] = new int[64]; for (int s = 0; s < 64; s++) { if (s % 8 == 0 && s != 0) SNAPSHOT_WRITLINE_REPLACEMENT(); SNAPSHOT_WRITLINE_REPLACEMENT((texelTuningVals[t, p][s] = pParams[c++]) + ", "); } SNAPSHOT_WRITLINE_REPLACEMENT(); } } piecePositionEvals = GetInterpolatedProcessedValues(texelTuningVals); } public void TLMTuning(List<TLM_ChessGame> pDataset) { int tGameDataSetLen = pDataset.Count; int[,][] tRatio = new int[33, 6][]; int[,][] tTotalMoves = new int[33, 6][]; double[,][] tSummedRatios = new double[33, 6][]; double[,][] tSummedDataAmount = new double[33, 6][]; double[,][] tTuningResults = new double[33, 6][]; for (int t = 1; t < 33; t++) { for (int p = 0; p < 6; p++) { tRatio[t, p] = new int[64]; tTotalMoves[t, p] = new int[64]; tSummedRatios[t, p] = new double[64]; tSummedDataAmount[t, p] = new double[64]; tTuningResults[t, p] = new double[64]; } } for (int j = 0; j < tGameDataSetLen; j++) { TLM_ChessGame tGame = pDataset[j]; int tGR = tGame.gameResult - 1; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count - 5; for (int i = 0; i < tL; i++) { if (tGame.isMoveNonTactical[i]) { int tPieceAmount = ULONG_OPERATIONS.CountBits(allPieceBitboard); for (int s = 0; s < 64; s++) { int tPT = pieceTypeArray[s] - 1; if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, s)) { tTotalMoves[tPieceAmount, tPT][s]++; tRatio[tPieceAmount, tPT][s] += tGR; } else if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, s)) { int b = blackSidedSquares[s]; tTotalMoves[tPieceAmount, tPT][b]++; tRatio[tPieceAmount, tPT][b] += tGR; } } } PlainMakeMove(tGame.actualMoves[i]); } } double[,] allMultipliers = new double[33, 33]; for (int sh = 0; sh < 33; sh++) { for (int i = 0; i < 33; i++) { allMultipliers[sh, i] = MultiplierFunction(i, sh); } } for (int t = 1; t < 33; t++) { for (int p = 0; p < 6; p++) { for (int s = 0; s < 64; s++) { for (int t2 = 1; t2 < 33; t2++) { double cmult = allMultipliers[t, t2]; tSummedRatios[t, p][s] += tRatio[t2, p][s] * cmult; tSummedDataAmount[t, p][s] += tTotalMoves[t2, p][s] * cmult; } tTuningResults[t, p][s] = TTT(tSummedRatios[t, p][s], tSummedDataAmount[t, p][s]); } } } int c = 0; int[] tparams = new int[1152]; for (int t = 1; t < 33; t += 15) { if (t == 31) t = 32; SNAPSHOT_WRITLINE_REPLACEMENT("PieceCount = " + t + ": "); for (int p = 0; p < 6; p++) { SNAPSHOT_WRITLINE_REPLACEMENT(TEXELPRINT_PIECES[p]); for (int s = 0; s < 64; s++) { if (s % 8 == 0 && s != 0) SNAPSHOT_WRITLINE_REPLACEMENT(); SNAPSHOT_WRITLINE_REPLACEMENT((tparams[c++] = (int)(tTuningResults[t, p][s] * 100)).ToString().Replace(",", ".") + "("+ (int)tSummedDataAmount[t, p][s] + ")"+ ", "); } SNAPSHOT_WRITLINE_REPLACEMENT(); } } string tS = "PARAMS: {"; for (int i = 0; i < tparams.Length; i++) tS += tparams[i] + ","; tS = tS.Substring(0, tS.Length - 1) + "}\n"; SNAPSHOT_WRITLINE_REPLACEMENT(tS); TexelTuning(pDataset, tparams); } private double TTT(double d1, double d2) { if (d2 == 0) return 0; return d1 /d2; } public void TexelTuning(List<TLM_ChessGame> pDataset, int[] pCurBestParams) { Stopwatch sw = Stopwatch.StartNew(); string tPath = PathManager.GetTXTPath("OTHER/TEXEL_TUNING"); int paramCount = pCurBestParams.Length; double bestAvrgCost = CalculateAverageTexelCost(pDataset, pCurBestParams); SNAPSHOT_WRITLINE_REPLACEMENT("CUR PARAMS COST: " + bestAvrgCost); int packetSize = Math.Clamp(paramCount /ENGINE_VALS.CPU_CORES, 1, 100000); paramsLowerLimits = new int[paramCount]; paramsUpperLimits = new int[paramCount]; for (int i = 0; i < paramCount; i++) { int lim = i < 10 ? 100000 : 200; paramsLowerLimits[i] = -lim; paramsUpperLimits[i] = lim; } SNAPSHOT_WRITLINE_REPLACEMENT("PARAM-COUNT: " + paramCount); SNAPSHOT_WRITLINE_REPLACEMENT("PACKET-SIZE: " + packetSize); while (packetSize <= paramCount) { BOT_MAIN.TEXELfinished = 0; int lM = 0, tC = 0; ulong tUL = 0ul; for (int m = packetSize; lM < paramCount; m += packetSize) { if (m > paramCount) m = paramCount; tUL = ULONG_OPERATIONS.SetBitToOne(tUL, ++tC); lM = m; } tC = lM = 0; for (int m = packetSize; lM < paramCount; m += packetSize) { if (m > paramCount) m = paramCount; tC++; BOT_MAIN.boardManagers[tC].SetPlayTexelVals(pDataset, lM, m, pCurBestParams, paramsLowerLimits, paramsUpperLimits, tC, tUL); ThreadPool.QueueUserWorkItem(new WaitCallback(BOT_MAIN.boardManagers[tC].TexelTuningThreadedPackage)); lM = m; } packetSize = paramCount + 1; int tmod = 0; while (tC != BOT_MAIN.TEXELfinished) { if (++tmod % 20 == 0) { WriteTexelParamsToTXT(tPath, BOT_MAIN.curTEXELPARAMS); SNAPSHOT_WRITLINE_REPLACEMENT(CalculateAverageTexelCost(pDataset, BOT_MAIN.curTEXELPARAMS) + " | "+ BOT_MAIN.TEXELadjustmentsmade); SNAPSHOT_WRITLINE_REPLACEMENT(ULONG_OPERATIONS.GetBitVisualization(BOT_MAIN.TEXELfinishedwithoutimpovement)); } Thread.Sleep(100); } SNAPSHOT_WRITLINE_REPLACEMENT("One Thread Generation FINISHED! :) :) :)"); pCurBestParams = BOT_MAIN.curTEXELPARAMS; } sw.Stop(); WriteTexelParamsToTXT(tPath, BOT_MAIN.curTEXELPARAMS); SNAPSHOT_WRITLINE_REPLACEMENT("END COST: " + CalculateAverageTexelCost(pDataset, BOT_MAIN.curTEXELPARAMS)); SNAPSHOT_WRITLINE_REPLACEMENT(BOT_MAIN.TEXELadjustmentsmade); SNAPSHOT_WRITLINE_REPLACEMENT(sw.ElapsedMilliseconds); } public void TexelTuningThreadedPackage(object obj) { SNAPSHOT_WRITLINE_REPLACEMENT("Started CThreadID [" + customThreadID + "] which is handling Params ["+ threadFrom + "] - ["+ threadTo + "]"); bool firstIter = true; do { double bestAvrgCost = CalculateAverageTexelCost(threadDataset, threadParams); int adjust_val = firstIter ? 512 : 8; do { adjust_val /= 2; bool improvedAvrgCost = true; while (improvedAvrgCost) { improvedAvrgCost = false; for (int i = threadFrom; i < threadTo; i++) { bool improvedWithThisParam = true; int tadjustval = adjust_val; bool lastTimeMaximized = false, lastTimeMinimized = false; while (improvedWithThisParam) { improvedWithThisParam = false; int[] curParams = (int[])threadParams.Clone(); int paramBefore = curParams[i]; curParams[i] = Math.Clamp(paramBefore + adjust_val, paramsLowerLimits[i], paramsUpperLimits[i]); double curAvrgCost = CalculateAverageTexelCost(threadDataset, curParams); if (curAvrgCost < bestAvrgCost) { improvedAvrgCost = true; improvedWithThisParam = true; SNAPSHOT_WRITLINE_REPLACEMENT("Improved Param [" + i + "] at CThreadID ["+ customThreadID + "]: +"+ adjust_val + " ("+ GetDoublePrecentageString(bestAvrgCost - curAvrgCost) + ")"); bestAvrgCost = curAvrgCost; threadParams = curParams; BOT_MAIN.TEXELadjustmentsmade++; BOT_MAIN.TEXELfinishedwithoutimpovement = ulAllThreadIDsUnfinished; if (lastTimeMaximized) { adjust_val *= 4; lastTimeMaximized = false; } else lastTimeMaximized = true; lastTimeMinimized = false; } else { curParams[i] = Math.Clamp(paramBefore - adjust_val, paramsLowerLimits[i], paramsUpperLimits[i]); curAvrgCost = CalculateAverageTexelCost(threadDataset, curParams); if (curAvrgCost < bestAvrgCost) { improvedAvrgCost = true; improvedWithThisParam = true; SNAPSHOT_WRITLINE_REPLACEMENT("Improved Param [" + i + "] at CThreadID ["+ customThreadID + "]: -"+ adjust_val + " ("+ GetDoublePrecentageString(bestAvrgCost - curAvrgCost) + ")"); bestAvrgCost = curAvrgCost; threadParams = curParams; BOT_MAIN.TEXELadjustmentsmade++; BOT_MAIN.TEXELfinishedwithoutimpovement = ulAllThreadIDsUnfinished; if (lastTimeMinimized) { adjust_val *= 4; lastTimeMinimized = false; } else lastTimeMinimized = true; lastTimeMaximized = false; } } if (adjust_val != 1) adjust_val /= 2; for (int j = threadFrom; j < threadTo; j++) { BOT_MAIN.curTEXELPARAMS[j] = threadParams[j]; } threadParams = (int[])BOT_MAIN.curTEXELPARAMS.Clone(); bestAvrgCost = CalculateAverageTexelCost(threadDataset, threadParams); } adjust_val = tadjustval; } } } while (adjust_val != 1); BOT_MAIN.TEXELfinishedwithoutimpovement = ULONG_OPERATIONS.SetBitToZero(BOT_MAIN.TEXELfinishedwithoutimpovement, customThreadID); SNAPSHOT_WRITLINE_REPLACEMENT("FULLY FINISHED " + customThreadID + ". IMPROVEMENT THREAD PACKAGE CYCLE"); firstIter = false; } while (BOT_MAIN.TEXELfinishedwithoutimpovement != 0); BOT_MAIN.TEXELfinished++; } private void WriteTexelParamsToTXT(string pPath, int[] pParams) { try { string tS = "PARAMS: {"; for (int i = 0; i < pParams.Length; i++) tS += pParams[i] + ","; tS = tS.Substring(0, tS.Length - 1) + "}\n"; File.AppendAllText(pPath, tS); } catch { SNAPSHOT_WRITLINE_REPLACEMENT("Mal wieder TXT zu lange gebraucht um zu aktualisieren."); } } private double costSum = 0d; private int texelCostMovesEvaluated = 0; private double CalculateAverageTexelCost(List<TLM_ChessGame> tDataset, int[] pParams, bool pFullCost = true) { costSum = 0d; texelCostMovesEvaluated = 0; SetupTexelEvaluationParams(pParams); int tGameDataSetLen = tDataset.Count; int start = 0, end = tGameDataSetLen; if (!pFullCost) { end = (start = globalRandom.Next(0, end - 256)) + 256; } for (int j = start; j < end; j++) { TLM_ChessGame tGame = tDataset[j]; double tGR = tGame.gameResult; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count - 5; texelCostMovesEvaluated += tL; for (int i = 0; i < tL; i++) { costSum += TexelCost(tGR - TexelTuningSigmoid(TexelEvaluate())); PlainMakeMove(tGame.actualMoves[i]); } } return costSum /texelCostMovesEvaluated; } private double CalculateAverageTexelCostThreadedVersionLEGACYDOESNTWORK(List<TLM_ChessGame> tDataset, int[] pParams) { Stopwatch sw = Stopwatch.StartNew(); BOT_MAIN.TEXELcostSum = 0d; BOT_MAIN.TEXELfinished = 0; BOT_MAIN.TEXELcostMovesEvaluated = 0; int tGameDataSetLen = tDataset.Count; int gamesPerThread = tGameDataSetLen /ENGINE_VALS.CPU_CORES; for (int i = 0; i < ENGINE_VALS.CPU_CORES - 1; i++) { } for (int i = 0; i < ENGINE_VALS.CPU_CORES - 1; i++) { } while (BOT_MAIN.TEXELfinished != ENGINE_VALS.CPU_CORES) Thread.Sleep(1); sw.Stop(); return BOT_MAIN.TEXELcostSum /BOT_MAIN.TEXELcostMovesEvaluated; } public void SetPlayThroughVals(List<TLM_ChessGame> pDataset, int pFrom, int pTo) { threadDataset = pDataset; threadFrom = pFrom; threadTo = pTo; } public void SetPlayTexelVals(List<TLM_ChessGame> pDataset, int pFrom, int pTo, int[] pTexelParams, int[] pLowerLimits, int[] pUpperLimits, int pThreadID, ulong pUL) { threadDataset = pDataset; threadFrom = pFrom; threadTo = pTo; threadParams = pTexelParams; paramsLowerLimits = pLowerLimits; paramsUpperLimits = pUpperLimits; customThreadID = pThreadID; ulAllThreadIDsUnfinished = pUL; } public void PlayThroughSetOfGames(object obj) { SNAPSHOT_WRITLINE_REPLACEMENT(threadFrom + "->"+ threadTo); int sortedOut = 0; for (int j = threadFrom; j < threadTo; j++) { TLM_ChessGame tGame = threadDataset[j]; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count; for (int i = 0; i < tL; i++) { int tQuietEval = isWhiteToMove ? QuiescenceWhite(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, 0, PreMinimaxCheckCheckWhite(), NULL_MOVE) : QuiescenceBlack(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, 0, PreMinimaxCheckCheckBlack(), NULL_MOVE); bool tB; tGame.isMoveNonTactical.Add(tB = (Evaluate() == tQuietEval && i > 4)); if (!tB) sortedOut++; PlainMakeMove(tGame.actualMoves[i]); } } BOT_MAIN.TEXELsortedout += sortedOut; BOT_MAIN.TEXELfinished++; } public void CalculateAverageTexelCostThreadFunction(object obj) { SetupTexelEvaluationParams(threadParams); double d = 0d; for (int j = threadFrom; j < threadTo; j++) { TLM_ChessGame tGame = threadDataset[j]; double tGR = tGame.gameResult; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count - 5; BOT_MAIN.TEXELcostMovesEvaluated += tL; for (int i = 0; i < tL; i++) { d += TexelCost(tGR - TexelTuningSigmoid(TexelEvaluate())); PlainMakeMove(tGame.actualMoves[i]); } } BOT_MAIN.TEXELcostSum += d; BOT_MAIN.TEXELfinished++; } private void ConsoleWriteLineTuneArray<T>(T[,][] pArr) { for (int j = 0; j < 3; j++) { SNAPSHOT_WRITLINE_REPLACEMENT("{"); for (int k = 0; k < 6; k++) { SNAPSHOT_WRITLINE_REPLACEMENT("{"); for (int s = 0; s < 64; s++) SNAPSHOT_WRITLINE_REPLACEMENT(pArr[j, k][s] + ", "); SNAPSHOT_WRITLINE_REPLACEMENT("\n}"); } SNAPSHOT_WRITLINE_REPLACEMENT("}"); } } private void Tune(string pGameCGFF, double pLearningRate) { TLM_ChessGame tGame = CGFF.GetGame(pGameCGFF); LoadFenString(tGame.startFen); double tDGameResult = tGame.gameResult; foreach (int hMove in tGame.hashedMoves) { Tune(tDGameResult, pLearningRate); List<Move> moveOptionList = new List<Move>(); GetLegalMoves(ref moveOptionList); int tL = moveOptionList.Count; for (int i = 0; i < tL; i++) { Move tMove = moveOptionList[i]; if (tMove.moveHash == hMove) { PlainMakeMove(tMove); tL = -1; break; } } if (tL != -1) break; } } private void Tune(double pGameResult, double pLearningRate) { int tPC = ULONG_OPERATIONS.CountBits(allPieceBitboard); double oneThroughPieceCount = 1d /tPC; double egMult = earlyGameMultipliers[tPC], mgMult = middleGameMultipliers[tPC], lgMult = lateGameMultipliers[tPC]; double tTexelResult = TexelEvaluateF(); double tSigmoidedTexelResult = TexelSigmoid(tTexelResult); double tDif = tSigmoidedTexelResult - pGameResult; double tM = oneThroughPieceCount * TexelCostDerivative(tDif) * TexelSigmoidDerivative(tTexelResult) * pLearningRate; sumCostVals += lastCostVal = TexelCost(tDif); costCalculations++; for (int i = 0; i < 64; i++) { if (ULONG_OPERATIONS.IsBitZero(allPieceBitboard, i)) continue; int tPT = pieceTypeArray[i] - 1, tI = i; if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, i)) tI = blackSidedSquares[i]; texelTuningAdjustIterations[tPT, tI]++; } } private double TexelEvaluateF() { texelTuningRuntimeVals = GetInterpolatedProcessedValues(texelTuningVals); return TexelEvaluate(); } private int TexelEvaluate() { int tEvalEG = 0, tEvalLG = 0, tProgress = 0; ulong[] attkULs = new ulong[14]; for (int p = 0; p < 64; p++) { if (((int)(allPieceBitboard >> p) & 1) == 0) continue; int aPT = pieceTypeArray[p], tPT = aPT + 7 * ((int)(blackPieceBitboard >> p) & 1); tEvalEG += texelTuningRuntimePositionalValsV2EG[tPT][p] + texelPieceEvaluationsV2EG[tPT]; tEvalLG += texelTuningRuntimePositionalValsV2LG[tPT][p] + texelPieceEvaluationsV2LG[tPT]; tProgress += pieceTypeGameProgressImpact[tPT]; } if (tProgress > 24) tProgress = 24; return (int)(earlyGameMultipliers[tProgress] * tEvalEG + lateGameMultipliers[tProgress] * tEvalLG); } private const double TexelK = 0.2; private double TexelTuningSigmoid(double pVal) { return 2d /(1 + Math.Pow(10, -TexelK * pVal /400)); } private double TexelSigmoid(double pVal) { return 2d /(Math.Exp(-0.04d * pVal) + 1d); } private double TexelSigmoidDerivative(double pVal) { double d = Math.Exp(-0.04d * pVal); return 2d * d /(25d * (d + 1d) * (d + 1d)); } private double TexelCost(double pVal) { return pVal * pVal; } private double TexelCostDerivative(double pVal) { return 2 * pVal; } private char[] fenPieces = new char[7] { 'z', 'p', 'n', 'b', 'r', 'q', 'k' }; private string[] squareNames = new string[64] { "a1", "b1", "c1", "d1", "e1", "f1", "g1", "h1", "a2", "b2", "c2", "d2", "e2", "f2", "g2", "h2", "a3", "b3", "c3", "d3", "e3", "f3", "g3", "h3", "a4", "b4", "c4", "d4", "e4", "f4", "g4", "h4", "a5", "b5", "c5", "d5", "e5", "f5", "g5", "h5", "a6", "b6", "c6", "d6", "e6", "f6", "g6", "h6", "a7", "b7", "c7", "d7", "e7", "f7", "g7", "h7", "a8", "b8", "c8", "d8", "e8", "f8", "g8", "h8"}; public string CreateFenString() { string rFEN = ""; for (int i = 7; i >= 0; i--) { int t = 0; for (int j = 0; j < 8; j++) { int sq = i * 8 + j; if (pieceTypeArray[sq] != 0) { if (t != 0) rFEN += t; t = 0; } if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, sq)) { switch (pieceTypeArray[sq]) { case 0: t++; SNAPSHOT_WRITLINE_REPLACEMENT("???"); break; case 1: rFEN += 'P'; break; case 2: rFEN += 'N'; break; case 3: rFEN += 'B'; break; case 4: rFEN += 'R'; break; case 5: rFEN += 'Q'; break; case 6: rFEN += 'K'; break; } } else { switch (pieceTypeArray[sq]) { case 0: t++; break; case 1: rFEN += 'p'; break; case 2: rFEN += 'n'; break; case 3: rFEN += 'b'; break; case 4: rFEN += 'r'; break; case 5: rFEN += 'q'; break; case 6: rFEN += 'k'; break; } } } if (t != 0) rFEN += t; if (i != 0) rFEN += "/"; } rFEN += (isWhiteToMove ? " w": " b"); rFEN += (whiteCastleRightKingSide ? " K": " "); rFEN += (whiteCastleRightQueenSide ? "Q": ""); rFEN += (blackCastleRightKingSide ? "k": ""); rFEN += (blackCastleRightQueenSide ? "q": ""); if (!whiteCastleRightKingSide && !whiteCastleRightQueenSide && !blackCastleRightKingSide && !blackCastleRightQueenSide) rFEN += "-"; if (enPassantSquare < 64) rFEN += " "+ squareNames[enPassantSquare] + " "; else rFEN += " - "; return rFEN + fiftyMoveRuleCounter + " "+ ((happenedHalfMoves - happenedHalfMoves % 2) /2); } public void LoadFenString(string fenStr) { debugFEN = fenStr; lastMadeMove = NULL_MOVE; zobristKey = 0ul; whitePieceBitboard = blackPieceBitboard = allPieceBitboard = 0ul; for (int i = 0; i < 64; i++) pieceTypeArray[i] = 0; string[] spaceSpl = fenStr.Split(' '); string[] rowSpl = spaceSpl[0].Split('/'); string epstr = spaceSpl[3]; if (epstr == "-") enPassantSquare = 65; else enPassantSquare = (epstr[0] - 'a') + 8 * (epstr[1] - '1'); isWhiteToMove = true; if (spaceSpl[1] == "b") isWhiteToMove = false; if (!isWhiteToMove) zobristKey ^= blackTurnHash; string crstr = spaceSpl[2]; whiteCastleRightKingSide = whiteCastleRightQueenSide = blackCastleRightKingSide = blackCastleRightQueenSide = false; int crStrL = crstr.Length; for (int i = 0; i < crStrL; i++) { switch (crstr[i]) { case 'K': whiteCastleRightKingSide = true; break; case 'Q': whiteCastleRightQueenSide = true; break; case 'k': blackCastleRightKingSide = true; break; case 'q': blackCastleRightQueenSide = true; break; } } fiftyMoveRuleCounter = Convert.ToInt32(spaceSpl[4]); happenedHalfMoves = Convert.ToInt32(spaceSpl[5]) * 2; if (!isWhiteToMove) happenedHalfMoves++; int tSq = 0; for (int i = rowSpl.Length; i-- > 0;) { string tStr = rowSpl[i]; int tStrLen = tStr.Length; for (int c = 0; c < tStrLen; c++) { char tChar = tStr[c]; if (Char.IsDigit(tChar)) tSq += tChar - '0'; else { bool tCol = Char.IsLower(tChar); if (tCol) blackPieceBitboard = ULONG_OPERATIONS.SetBitToOne(blackPieceBitboard, tSq); else whitePieceBitboard = ULONG_OPERATIONS.SetBitToOne(whitePieceBitboard, tSq); if (tChar == 'k') blackKingSquare = tSq; else if (tChar == 'K') whiteKingSquare = tSq; pieceTypeArray[tSq] = Array.IndexOf(fenPieces, Char.ToLower(tChar)); if (tCol) zobristKey ^= pieceHashesBlack[tSq, pieceTypeArray[tSq]]; else zobristKey ^= pieceHashesWhite[tSq, pieceTypeArray[tSq]]; tSq++; } } } if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; zobristKey ^= enPassantSquareHashes[enPassantSquare]; allPieceBitboard = whitePieceBitboard | blackPieceBitboard; if (zobristKey == 16260251586586513106) moveHashList.Clear(); else { moveHashList.Clear(); moveHashList.Add(1); moveHashList.Add(2); moveHashList.Add(3); } } private ulong[,] pieceHashesWhite = new ulong[64, 7], pieceHashesBlack = new ulong[64, 7]; private ulong blackTurnHash, whiteKingSideRochadeRightHash, whiteQueenSideRochadeRightHash, blackKingSideRochadeRightHash, blackQueenSideRochadeRightHash; private ulong[] enPassantSquareHashes = new ulong[66]; private Dictionary<ulong, int> singleCheckCaseBackup = new Dictionary<ulong, int>(); private void InitZobrist() { Random rng = new Random(31415926); for (int sq = 0; sq < 64; sq++) { enPassantSquareHashes[sq] = ULONG_OPERATIONS.GetRandomULONG(rng); for (int it = 1; it < 7; it++) { pieceHashesWhite[sq, it] = ULONG_OPERATIONS.GetRandomULONG(rng); pieceHashesBlack[sq, it] = ULONG_OPERATIONS.GetRandomULONG(rng); } } blackTurnHash = ULONG_OPERATIONS.GetRandomULONG(rng); whiteKingSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); whiteQueenSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); blackKingSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); blackQueenSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); } public void SetKnightMasks(ulong[] uls) { knightSquareBitboards = uls; } public void SetKingMasks(ulong[] uls) { kingSquareBitboards = uls; } private Move[,] whiteEnPassantMoves = new Move[64, 64]; private Move[,] blackEnPassantMoves = new Move[64, 64]; private bool[] epValidationArray = new bool[64] { false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true , true , true , true , true , true , true , true, true , true , true , true , true , true , true , true, true , true , true , true , true , true , true , true, true , true , true , true , true , true , true , true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false }; private ulong[] kingSafetyRing1 = new ulong[64], kingSafetyRing2 = new ulong[64]; private ulong[] kingSafetySpecialRingW = new ulong[64], kingSafetySpecialRingB = new ulong[64]; private ulong[] rowPrecalcs = new ulong[8], columnPrecalcs = new ulong[8]; const ulong columnUL = 0x101010101010101, rowUL = 0b11111111; private void PrecalculateKingSafetyBitboards() { for (int i = 0; i < 8; i++) { rowPrecalcs[i] = rowUL << (8 * i); columnPrecalcs[i] = columnUL << i; } for (int i = 0; i < 64; i++) { int tMod = i % 8; int tRow = (i - tMod) /8; ulong tULC = columnPrecalcs[tMod], tULR = rowPrecalcs[tRow]; ulong tULC2 = columnPrecalcs[tMod], tULR2 = rowPrecalcs[tRow]; if (tMod < 7) tULC |= columnPrecalcs[tMod + 1]; if (tMod > 0) tULC |= columnPrecalcs[tMod - 1]; if (tRow < 7) tULR |= rowPrecalcs[tRow + 1]; if (tRow > 0) tULR |= rowPrecalcs[tRow - 1]; if (tMod < 6) tULC2 |= columnPrecalcs[tMod + 2]; if (tMod > 1) tULC2 |= columnPrecalcs[tMod - 2]; if (tRow < 6) tULR2 |= rowPrecalcs[tRow + 2]; if (tRow > 1) tULR2 |= rowPrecalcs[tRow - 2]; tULR2 |= tULR; tULC2 |= tULC; kingSafetyRing1[i] = ULONG_OPERATIONS.SetBitToZero(tULR & tULC, i); kingSafetyRing2[i] = ULONG_OPERATIONS.SetBitsToZero(tULR2 & tULC2, i, i + 1, i - 1, i + 7, i + 8, i + 9, i - 7, i - 8, i - 9); } for (int i = 0; i < 64; i++) { if (i < 56) kingSafetySpecialRingW[i] = ULONG_OPERATIONS.SetBitToZero(kingSafetyRing1[i] | kingSafetyRing1[i + 8], i); else kingSafetySpecialRingW[i] = kingSafetyRing1[i]; if (i > 7) kingSafetySpecialRingB[i] = ULONG_OPERATIONS.SetBitToZero(kingSafetyRing1[i] | kingSafetyRing1[i - 8], i); else kingSafetySpecialRingB[i] = kingSafetyRing1[i]; } } private void PrecalculateEnPassantMoves() { for (int i = 0; i < 64; i++) { if (!epValidationArray[i]) continue; for (int j = 0; j < 64; j++) { if (i == j) continue; if (Math.Abs(i - j) > 9) continue; if (!epValidationArray[j]) continue; whiteEnPassantMoves[i, j] = new Move(false, i, j, j - 8); blackEnPassantMoves[i, j] = new Move(false, i, j, j + 8); } } } private void PawnAttackBitboards() { for (int sq = 0; sq < 64; sq++) { ulong u = 0ul; if (sq % 8 != 0) u = ULONG_OPERATIONS.SetBitToOne(u, sq + 7); if (sq % 8 != 7) u = ULONG_OPERATIONS.SetBitToOne(u, sq + 9); whitePawnAttackSquareBitboards[sq] = u; u = 0ul; if (sq % 8 != 0 && sq - 9 > -1) u = ULONG_OPERATIONS.SetBitToOne(u, sq - 9); if (sq % 8 != 7 && sq - 7 > -1) u = ULONG_OPERATIONS.SetBitToOne(u, sq - 7); blackPawnAttackSquareBitboards[sq] = u; } } private int[] squareConnectivesPrecalculationArray = new int[4096]; public int[] squareConnectivesCrossDirsPrecalculationArray { get; set; } = new int[4096]; private ulong[] squareConnectivesPrecalculationRayArray = new ulong[4096]; private ulong[] squareConnectivesPrecalculationLineArray = new ulong[4096]; private List<Dictionary<ulong, int>> rayCollidingSquareCalculations = new List<Dictionary<ulong, int>>(); private readonly int[] maxIntWithSpecifiedBitcount = new int[8] { 0, 0b1, 0b11, 0b111, 0b1111, 0b11111, 0b111111, 0b1111111 }; private List<ulong> differentRays = new List<ulong>(); private void SquareConnectivesPrecalculations() { for (int square = 0; square < 64; square++) { rayCollidingSquareCalculations.Add(new Dictionary<ulong, int>()); rayCollidingSquareCalculations[square].Add(0ul, square); for (int square2 = 0; square2 < 64; square2++) { if (square == square2) continue; int t = 0, t2 = 0, difSign = Math.Sign(square2 - square), itSq = square, g = 0; ulong tRay = 0ul, tExclRay = 0ul; List<int> tRayInts = new List<int>(); if (difSign == -1) g = 7; if (square % 8 == square2 % 8) { t2 = t = 1; while ((itSq += difSign * 8) < 64 && itSq > -1) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } } else if ((square - square % 8) == (square2 - square2 % 8)) { t = 1; t2 = -1; while ((itSq += difSign) % 8 != g && itSq > -1 && itSq < 64) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } } else { int dif = Math.Abs(square2 - square); if (dif % 7 == 0) { t = 2; t2 = 2; g = (difSign == 1) ? 7 : 0; while ((itSq += difSign * 7) % 8 != g && itSq < 64 && itSq > -1) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } if (ULONG_OPERATIONS.IsBitZero(tRay, square2)) { t2 = t = 0; tRay = 0ul; } } else if (dif % 9 == 0) { t = 2; t2 = -2; if (square == 0 && square2 == 63 || square == 63 && square2 == 0) SNAPSHOT_WRITLINE_REPLACEMENT("!"); while ((itSq += difSign * 9) % 8 != g && itSq < 64 && itSq > -1) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } if (ULONG_OPERATIONS.IsBitZero(tRay, square2)) { t2 = t = 0; tRay = 0ul; } } } if (square == 0 && square2 == 63) { t2 = t = 2; tRayInts.Clear(); tExclRay = tRay = ULONG_OPERATIONS.SetBitsToOne(0ul, 9, 18, 27, 36, 45, 54, 63); tRayInts = new List<int>() { 9, 18, 27, 36, 45, 54, 63 }; } else if (square2 == 0 && square == 63) { t = 2; tRayInts.Clear(); t2 = -2; tExclRay = tRay = ULONG_OPERATIONS.SetBitsToOne(0ul, 0, 9, 18, 27, 36, 45, 54); tRayInts = new List<int>() { 54, 45, 36, 27, 18, 9, 0 }; } if (tRay != 0ul && !differentRays.Contains(tRay)) { differentRays.Add(tRay); int ccount, combI = maxIntWithSpecifiedBitcount[ccount = ULONG_OPERATIONS.CountBits(tRay)]; do { ulong curAllPieceBitboard = 0ul; int solution = square; for (int j = 0; j < ccount; j++) { if (((combI >> j) & 1) == 1) { curAllPieceBitboard = ULONG_OPERATIONS.SetBitToOne(curAllPieceBitboard, tRayInts[j]); if (solution == square) solution = tRayInts[j]; } } rayCollidingSquareCalculations[square].Add(curAllPieceBitboard, solution); } while (--combI != 0); } squareConnectivesPrecalculationArray[square << 6 | square2] = t; squareConnectivesPrecalculationRayArray[square << 6 | square2] = tRay; squareConnectivesCrossDirsPrecalculationArray[square << 6 | square2] = t2; if (t != 0) squareConnectivesPrecalculationLineArray[square << 6 | square2] = (square == 0 && square2 == 63 || square2 == 0 && square == 63) ? tExclRay : ULONG_OPERATIONS.SetBitToOne(tExclRay, square2); if (squareConnectivesPrecalculationLineArray[square << 6 | square2] == 0ul && ULONG_OPERATIONS.IsBitOne(knightSquareBitboards[square], square2)) squareConnectivesPrecalculationLineArray[square << 6 | square2] = 1ul << square2; } differentRays.Clear(); } } public void SNAPSHOT_WRITLINE_REPLACEMENT() { } public void SNAPSHOT_WRITLINE_REPLACEMENT(object pStr) { } private string GetDoublePrecentageString(double pVal) { return ((int)(pVal * 1_000_000) /10_000d) + "%"; } private string ReplaceAllULONGIsBitOne(string pCode) { const string METHOD_NAME = "ULONG_OPERATIONS.IsBitOne"; int METHOD_NAME_LEN = METHOD_NAME.Length, iterations = 0; int pIndex = pCode.IndexOf(METHOD_NAME); while (pIndex != -1 && ++iterations < 10_000) { List<int> paramIndexes = new List<int>(); int openedBracketCount = 1, closedBracketCount = 0, a = METHOD_NAME_LEN + pIndex; string tpCode = pCode.Substring(0, pIndex); paramIndexes.Add(a + 1); while (++a < pCode.Length) { switch (pCode[a]) { case '(': openedBracketCount++; break; case ')': if (++closedBracketCount == openedBracketCount) { pIndex = a; a = int.MaxValue - 5; } break; case ',': if (openedBracketCount - closedBracketCount == 1) paramIndexes.Add(a + 1); break; } } if (openedBracketCount == closedBracketCount && paramIndexes.Count == 2) { tpCode += "((int)("+ pCode.Substring(paramIndexes[0], paramIndexes[1] - paramIndexes[0] - 1) + (pCode[paramIndexes[1]] == ' ' ? " >> (": " >> (") + pCode.Substring(paramIndexes[1], pIndex - paramIndexes[1]) + ")) & 1) == 1"+ pCode.Substring(pIndex + 1, pCode.Length - pIndex - 1); } pIndex = (pCode = tpCode).IndexOf(METHOD_NAME); } SNAPSHOT_WRITLINE_REPLACEMENT(iterations + " ITERATIONS"); return pCode; } private string ReplaceAllULONGIsBitZero(string pCode) { const string METHOD_NAME = "ULONG_OPERATIONS.IsBitZero"; int METHOD_NAME_LEN = METHOD_NAME.Length, iterations = 0; int pIndex = pCode.IndexOf(METHOD_NAME); while (pIndex != -1 && ++iterations < 10_000) { List<int> paramIndexes = new List<int>(); int openedBracketCount = 1, closedBracketCount = 0, a = METHOD_NAME_LEN + pIndex; string tpCode = pCode.Substring(0, pIndex); paramIndexes.Add(a + 1); while (++a < pCode.Length) { switch (pCode[a]) { case '(': openedBracketCount++; break; case ')': if (++closedBracketCount == openedBracketCount) { pIndex = a; a = int.MaxValue - 5; } break; case ',': if (openedBracketCount - closedBracketCount == 1) paramIndexes.Add(a + 1); break; } } if (openedBracketCount == closedBracketCount && paramIndexes.Count == 2) { tpCode += "((int)("+ pCode.Substring(paramIndexes[0], paramIndexes[1] - paramIndexes[0] - 1) + (pCode[paramIndexes[1]] == ' ' ? " >>": " >> ") + pCode.Substring(paramIndexes[1], pIndex - paramIndexes[1]) + ") & 1) == 0"+ pCode.Substring(pIndex + 1, pCode.Length - pIndex - 1); } pIndex = (pCode = tpCode).IndexOf(METHOD_NAME); } SNAPSHOT_WRITLINE_REPLACEMENT(iterations + " ITERATIONS"); return pCode; } private string GetThreeDigitSeperatedInteger(int pInt) { string s = pInt.ToString(), r = s[0].ToString(); int t = s.Length % 3; for (int i = 1; i < s.Length; i++) { if (i % 3 == t) r += "."; r += s[i]; } s = ""; for (int i = 0; i < r.Length; i++) s += r[i]; return s; } public double GetAverageDepth() { return (double)depths /(double)searches; } }
public class SNAPSHOT_V01_00_016 : IBoardManager  { public int TEXEL_PARAMS { get; } = 778; private const int BESTMOVE_SORT_VAL = -2_000_000_000; private const int CAPTURE_SORT_VAL = -1_000_000_000; private const int KILLERMOVE_SORT_VAL = -1000; private readonly int[,] MVVLVA_TABLE = new int[7, 7] { { 0, 0, 0, 0, 0, 0, 0 }, { 0, 1500, 1400, 1300, 1200, 1100, 1000 }, { 0, 3500, 3400, 3300, 3200, 3100, 3000 }, { 0, 4500, 4400, 4300, 4200, 4100, 4000 }, { 0, 5500, 5400, 5300, 5200, 5100, 5000 }, { 0, 9500, 9400, 9300, 9200, 9100, 9000 }, { 0, 0, 0, 0, 0, 0, 0 }}; private int BOARD_MANAGER_ID = -1; private bool debugSearchDepthResults = false; private bool debugSortResults = false; private RookMovement rookMovement; private BishopMovement bishopMovement; private QueenMovement queenMovement; private KnightMovement knightMovement; private KingMovement kingMovement; private WhitePawnMovement whitePawnMovement; private BlackPawnMovement blackPawnMovement; private Rays rays; public List<Move> moveOptionList { get; set; } private int[] pieceTypeArray = new int[64]; public ulong whitePieceBitboard, blackPieceBitboard, allPieceBitboard; private ulong zobristKey; private int whiteKingSquare, blackKingSquare, enPassantSquare = 65, happenedHalfMoves = 0, fiftyMoveRuleCounter = 0; private bool whiteCastleRightKingSide, whiteCastleRightQueenSide, blackCastleRightKingSide, blackCastleRightQueenSide; private bool isWhiteToMove; private const ulong WHITE_KING_ROCHADE = 96, WHITE_QUEEN_ROCHADE = 14, BLACK_KING_ROCHADE = 6917529027641081856, BLACK_QUEEN_ROCHADE = 1008806316530991104, WHITE_QUEEN_ATTK_ROCHADE = 12, BLACK_QUEEN_ATTK_ROCHADE = 864691128455135232; private readonly Move mWHITE_KING_ROCHADE = new Move(4, 6, 7, 5), mWHITE_QUEEN_ROCHADE = new Move(4, 2, 0, 3), mBLACK_KING_ROCHADE = new Move(60, 62, 63, 61), mBLACK_QUEEN_ROCHADE = new Move(60, 58, 56, 59); private ulong[] knightSquareBitboards = new ulong[64]; private ulong[] whitePawnAttackSquareBitboards = new ulong[64]; private ulong[] blackPawnAttackSquareBitboards = new ulong[64]; private ulong[] kingSquareBitboards = new ulong[64]; private bool[,] pieceTypeAbilities = new bool[7, 3] { { false, false, false }, { false, false, false }, { false, false, false }, { false, false, true }, { false, true, false }, { false, true, true }, { false, false, false } }; private List<int> moveHashList = new List<int>(); private ulong[] curSearchZobristKeyLine = Array.Empty<ulong>(); private Move[] debugMoveList = new Move[128]; private string debugFEN = ""; private Stopwatch globalTimer = Stopwatch.StartNew(); private Move lastMadeMove; private int depths, searches; private Random globalRandom = new Random(); public SNAPSHOT_V01_00_016(string fen) { Setup(fen); } public void Setup(string pFen) { Stopwatch setupStopwatch = Stopwatch.StartNew(); BOARD_MANAGER_ID = BOT_MAIN.curBoardManagerID; for (int i = 0; i < 33; i++) for (int j = 0; j < 14; j++) piecePositionEvals[i, j] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; for (int i = 0; i < 33; i++) for (int j = 0; j < 14; j++) texelTuningRuntimeVals[i, j] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; for (int i = 0; i < 3; i++) for (int j = 0; j < 6; j++) texelTuningVals[i, j] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; for (int i = 0; i < 14; i++) { texelTuningRuntimePositionalValsV2EG[i] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; texelTuningRuntimePositionalValsV2LG[i] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; } PrecalculateKingSafetyBitboards(); PrecalculateMultipliers(); GetLowNoisePositionalEvaluation(globalRandom); MinimaxRoot(1L); SetupConsoleWrite("[PRECALCS] Zobrist Hashing"); InitZobrist(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Knight Movement"); knightMovement = new KnightMovement(this); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Square Connectives"); SquareConnectivesPrecalculations(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Pawn Attack Bitboards"); PawnAttackBitboards(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Rays"); rays = new Rays(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); queenMovement = new QueenMovement(this); SetupConsoleWrite("[PRECALCS] Rook Movement"); rookMovement = new RookMovement(this, queenMovement); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Bishop Movement"); bishopMovement = new BishopMovement(this, queenMovement); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] King Movement"); kingMovement = new KingMovement(this); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Pawn Movement"); whitePawnMovement = new WhitePawnMovement(this); blackPawnMovement = new BlackPawnMovement(this); PrecalculateEnPassantMoves(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWriteLine("[DONE]\n\n"); LoadFenString(pFen); LoadBestTexelParamsIn(); setupStopwatch.Stop(); } private void SetupConsoleWriteLine(string pStr) { if (BOT_MAIN.isFirstBoardManagerInitialized) return; SNAPSHOT_WRITLINE_REPLACEMENT(pStr); } private void SetupConsoleWrite(string pStr) { if (BOT_MAIN.isFirstBoardManagerInitialized) return; SNAPSHOT_WRITLINE_REPLACEMENT(pStr); } public void GetLowNoisePositionalEvaluation(System.Random rng) { int[,][] digitArray = new int[3, 6][]; for (int i = 0; i < 3; i++) for (int j = 0; j < 6; j++) digitArray[i, j] = GetRand64IntArray(rng, -5, 6); lowNoisePositionEvals1 = GetInterpolatedProcessedValues(digitArray); int[,][] digitArray2 = new int[3, 6][]; for (int i = 0; i < 3; i++) for (int j = 0; j < 6; j++) digitArray2[i, j] = GetRand64IntArray(rng, -5, 6); lowNoisePositionEvals2 = GetInterpolatedProcessedValues(digitArray2); } private int[] GetRand64IntArray(System.Random rng, int pMin, int pMax) { return new int[64] { rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax) }; } private string GetAIArrayValuesStringRepresentation(int[,][] pArr) { string r = "int[,][] ReLe_AI_RESULT_VALS = new int[3, 6][] {"; for (int i = 0; i < 3; i++) { r += "{"; for (int j = 0; j < 5; j++) { r += GetIntArray64LStringRepresentation(pArr[i, j]) + ","; } r += GetIntArray64LStringRepresentation(pArr[i, 5]) + "},"; } return r.Substring(0, r.Length - 1) + "};"; } private string GetIntArray64LStringRepresentation(int[] p64LArr) { if (p64LArr == null) return ""; string r = "new int[64]{"; for (int i = 0; i < 63; i++) { r += p64LArr[i] + ","; } return r + p64LArr[63] + "}"; } public void TempStuff() { } private string[] gameResultStrings = new string[5] { "Black Has Won!", "Draw!", "White Has Won!", "Non Existant Result!", "Game is Ongoing!"}; private int[,][] lowNoisePositionEvals1, lowNoisePositionEvals2; public void ThreadSelfPlay(object obj) { PlayGameAgainstItself(obj); } public void PlayGameAgainstItself(object obj, string pStartFEN = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1", long tickLimitForEngine = ENGINE_VALS.SELF_PLAY_THINK_TIME) { int ttGState; while (BOT_MAIN.goalGameCount > BOT_MAIN.gamesPlayed) { try { string tGameStr; GetLowNoisePositionalEvaluation(globalRandom); LoadFenString(tGameStr = pStartFEN); tGameStr += ";"; int tGState = 3, tmc = 0; bool lowNoiceDecider = globalRandom.NextDouble() < 0.5d; while (tGState == 3) { piecePositionEvals = lowNoiceDecider ? lowNoisePositionEvals1 : lowNoisePositionEvals2; MinimaxRoot(tickLimitForEngine); Move tM = transpositionTable[zobristKey].bestMove; PlainMakeMove(tM); tGameStr += NuCRe.GetNuCRe(tM.moveHash) + ","; BOT_MAIN.movesPlayed++; tGState = GameState(isWhiteToMove); lowNoiceDecider = !lowNoiceDecider; tmc++; } ttGState = tGState; tGameStr += ttGState + 1; SNAPSHOT_WRITLINE_REPLACEMENT(tGameStr); BOT_MAIN.gamesPlayedResultArray[ttGState + 1]++; BOT_MAIN.gamesPlayed++; BOT_MAIN.selfPlayGameStrings.Add(tGameStr); } catch (Exception tE) { SNAPSHOT_WRITLINE_REPLACEMENT(tE.ToString()); } } } public void PlayGameOnConsoleAgainstHuman(string pStartFEN = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1", bool pHumanPlaysWhite = true, long tickLimitForEngine = 10_000_000L) { debugSearchDepthResults = true; LoadFenString(pStartFEN); if (!(pHumanPlaysWhite ^ isWhiteToMove)) { var pVS = Console.ReadLine(); if (pVS == null) return; Move tm = GetMoveOfString(pVS.ToString()); SNAPSHOT_WRITLINE_REPLACEMENT(tm); PlainMakeMove(tm); } int tGState = 3; while (tGState == 3) { MinimaxRoot(tickLimitForEngine); PlayThroughZobristTree(); Move tM = transpositionTable[zobristKey].bestMove; SNAPSHOT_WRITLINE_REPLACEMENT(tM); SNAPSHOT_WRITLINE_REPLACEMENT(CreateFenString()); PlainMakeMove(tM); tGState = GameState(isWhiteToMove); if (tGState != 3 || tM == NULL_MOVE) break; var pV = ""; tM = NULL_MOVE; do { pV = Console.ReadLine(); if (pV == null) continue; tM = GetMoveOfString(pV.ToString()); SNAPSHOT_WRITLINE_REPLACEMENT(tM); } while (tM == NULL_MOVE); PlainMakeMove(tM); tGState = GameState(isWhiteToMove); } } private void PlayThroughZobristTree() { SetJumpState(); SNAPSHOT_WRITLINE_REPLACEMENT("\n- - - - - - - - - - - - -"); int tC = 1; Dictionary<ulong, bool> usedULs = new Dictionary<ulong, bool>(); while (transpositionTable.TryGetValue(zobristKey, out TranspositionEntry tM)) { if (usedULs.ContainsKey(zobristKey)) { SNAPSHOT_WRITLINE_REPLACEMENT(tC + ": AT LEAST ONE REPETION; REST NOT VISIBLE"); break; } SNAPSHOT_WRITLINE_REPLACEMENT(tC + ": "+ tM.bestMove + " > "); usedULs.Add(zobristKey, true); PlainMakeMove(tM.bestMove); tC++; } SNAPSHOT_WRITLINE_REPLACEMENT("- - - - - - - - - - - - -\n"); LoadJumpState(); } public Move? ReturnNextMove(Move? lastMove, long pThinkingTime) { if (lastMove != null) PlainMakeMove(lastMove); if (GameState(isWhiteToMove) != 3) return null; MinimaxRoot(pThinkingTime); if (!transpositionTable.ContainsKey(zobristKey)) return null; Move tm = transpositionTable[zobristKey].bestMove; PlainMakeMove(tm); return tm; } private int[] jmpSt_pieceTypeArray; private ulong jmpSt_whitePieceBitboard, jmpSt_blackPieceBitboard; private ulong jmpSt_zobristKey; private int jmpSt_whiteKingSquare, jmpSt_blackKingSquare, jmpSt_enPassantSquare, jmpSt_happenedHalfMoves, jmpSt_fiftyMoveRuleCounter; private bool jmpSt_whiteCastleRightKingSide, jmpSt_whiteCastleRightQueenSide, jmpSt_blackCastleRightKingSide, jmpSt_blackCastleRightQueenSide; private bool jmpSt_isWhiteToMove; private ulong[] jmpSt_curSearchZobristKeyLine; private int[] jmpSt_moveHashList; public void LoadJumpState() { pieceTypeArray = (int[])jmpSt_pieceTypeArray.Clone(); whitePieceBitboard = jmpSt_whitePieceBitboard; blackPieceBitboard = jmpSt_blackPieceBitboard; zobristKey = jmpSt_zobristKey; whiteKingSquare = jmpSt_whiteKingSquare; blackKingSquare = jmpSt_blackKingSquare; enPassantSquare = jmpSt_enPassantSquare; happenedHalfMoves = jmpSt_happenedHalfMoves; fiftyMoveRuleCounter = jmpSt_fiftyMoveRuleCounter; whiteCastleRightKingSide = jmpSt_whiteCastleRightKingSide; whiteCastleRightQueenSide = jmpSt_whiteCastleRightQueenSide; blackCastleRightKingSide = jmpSt_blackCastleRightKingSide; blackCastleRightQueenSide = jmpSt_blackCastleRightQueenSide; isWhiteToMove = jmpSt_isWhiteToMove; curSearchZobristKeyLine = (ulong[])jmpSt_curSearchZobristKeyLine.Clone(); allPieceBitboard = blackPieceBitboard | whitePieceBitboard; moveHashList = jmpSt_moveHashList.ToList(); } public void SetJumpState() { jmpSt_pieceTypeArray = (int[])pieceTypeArray.Clone(); jmpSt_whitePieceBitboard = whitePieceBitboard; jmpSt_blackPieceBitboard = blackPieceBitboard; jmpSt_zobristKey = zobristKey; jmpSt_whiteKingSquare = whiteKingSquare; jmpSt_blackKingSquare = blackKingSquare; jmpSt_enPassantSquare = enPassantSquare; jmpSt_happenedHalfMoves = happenedHalfMoves; jmpSt_fiftyMoveRuleCounter = fiftyMoveRuleCounter; jmpSt_whiteCastleRightKingSide = whiteCastleRightKingSide; jmpSt_whiteCastleRightQueenSide = whiteCastleRightQueenSide; jmpSt_blackCastleRightKingSide = blackCastleRightKingSide; jmpSt_blackCastleRightQueenSide = blackCastleRightQueenSide; jmpSt_isWhiteToMove = isWhiteToMove; jmpSt_curSearchZobristKeyLine = (ulong[])curSearchZobristKeyLine.Clone(); jmpSt_moveHashList = moveHashList.ToArray(); } private int PreMinimaxCheckCheckWhite() { ulong bitShiftedKingPos = 1ul << whiteKingSquare; int curR = -1; for (int p = 0; p < 64; p++) { if (ULONG_OPERATIONS.IsBitZero(blackPieceBitboard, p)) continue; int tPT; switch (tPT = pieceTypeArray[p]) { case 1: if ((bitShiftedKingPos & blackPawnAttackSquareBitboards[p]) != 0ul) return p; break; case 2: if ((bitShiftedKingPos & knightSquareBitboards[p]) != 0ul) return p; break; case 6: break; default: if ((squareConnectivesPrecalculationLineArray[whiteKingSquare << 6 | p] & allPieceBitboard) == (1ul << p) && pieceTypeAbilities[tPT, squareConnectivesPrecalculationArray[whiteKingSquare << 6 | p]]) { if (curR != -1) return -779; curR = p; } break; } } return curR; } private int PreMinimaxCheckCheckBlack() { ulong bitShiftedKingPos = 1ul << blackKingSquare; int curR = -1; for (int p = 0; p < 64; p++) { if (ULONG_OPERATIONS.IsBitZero(whitePieceBitboard, p)) continue; int tPT; switch (tPT = pieceTypeArray[p]) { case 1: if ((bitShiftedKingPos & whitePawnAttackSquareBitboards[p]) != 0ul) return p; break; case 2: if ((bitShiftedKingPos & knightSquareBitboards[p]) != 0ul) return p; break; case 6: break; default: if ((squareConnectivesPrecalculationLineArray[blackKingSquare << 6 | p] & allPieceBitboard) == (1ul << p) && pieceTypeAbilities[tPT, squareConnectivesPrecalculationArray[blackKingSquare << 6 | p]]) { if (curR != -1) return -779; curR = p; } break; } } return curR; } private int LecacyLeafCheckingPieceCheckWhite(int pStartPos, int pEndPos, int pPieceType) { int tI, tPossibleAttackPiece; if (pPieceType == 1) { if (ULONG_OPERATIONS.IsBitOne(blackPawnAttackSquareBitboards[pEndPos], whiteKingSquare)) return pEndPos; } else if (pPieceType == 2) { if (ULONG_OPERATIONS.IsBitOne(knightSquareBitboards[pEndPos], whiteKingSquare)) return pEndPos; } else if (pPieceType != 6) { tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | pEndPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; } tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | pStartPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; return -1; } private int LecacyLeafCheckingPieceCheckBlack(int pStartPos, int pEndPos, int pPieceType) { int tI, tPossibleAttackPiece; if (pPieceType == 1) { if (ULONG_OPERATIONS.IsBitOne(whitePawnAttackSquareBitboards[pEndPos], blackKingSquare)) return pEndPos; } else if (pPieceType == 2) { if (ULONG_OPERATIONS.IsBitOne(knightSquareBitboards[pEndPos], blackKingSquare)) return pEndPos; } else if (pPieceType != 6) { tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | pEndPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; } tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | pStartPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; return -1; } public void GetLegalMoves(ref List<Move> pMoveList) { int attk; if (isWhiteToMove) { attk = PreMinimaxCheckCheckWhite(); if (attk == -779) GetLegalWhiteMovesSpecialDoubleCheckCase(ref pMoveList); else GetLegalWhiteMoves(attk, ref pMoveList); } else { attk = PreMinimaxCheckCheckBlack(); if (attk == -779) GetLegalBlackMovesSpecialDoubleCheckCase(ref pMoveList); else GetLegalBlackMoves(attk, ref pMoveList); } } private void GetLegalWhiteMoves(int pCheckingPieceSquare, ref List<Move> pMoveList) { if (pCheckingPieceSquare == -779) { GetLegalWhiteMovesSpecialDoubleCheckCase(ref pMoveList); return; } moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= blackPawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, whiteKingSquare); if (curCheckCount == 0) { if (whiteCastleRightKingSide && ((allPieceBitboard | oppAttkBitboard) & WHITE_KING_ROCHADE) == 0ul) pMoveList.Add(mWHITE_KING_ROCHADE); if (whiteCastleRightQueenSide && (allPieceBitboard & WHITE_QUEEN_ROCHADE | oppAttkBitboard & WHITE_QUEEN_ATTK_ROCHADE) == 0ul) pMoveList.Add(mWHITE_QUEEN_ROCHADE); if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, whitePieceBitboard, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[whiteKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare + 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, whitePieceBitboard, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveList(whiteKingSquare, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalWhiteCaptures(int pCheckingPieceSquare, ref List<Move> pMoveList) { if (pCheckingPieceSquare == -779) { GetLegalWhiteCapturesSpecialDoubleCheckCase(ref pMoveList); return; } moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= blackPawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, whiteKingSquare); if (curCheckCount == 0) { if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & blackPieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[whiteKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare + 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & blackPieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveListOnlyCaptures(whiteKingSquare, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalWhiteMovesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= blackPawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveList(whiteKingSquare, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalWhiteCapturesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= blackPawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveListOnlyCaptures(whiteKingSquare, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalBlackMoves(int pCheckingPieceSquare, ref List<Move> pMoveList) { if (pCheckingPieceSquare == -779) { GetLegalBlackMovesSpecialDoubleCheckCase(ref pMoveList); return; } moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= whitePawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, blackKingSquare); if (curCheckCount == 0) { if (blackCastleRightKingSide && ((allPieceBitboard | oppAttkBitboard) & BLACK_KING_ROCHADE) == 0ul) pMoveList.Add(mBLACK_KING_ROCHADE); if (blackCastleRightQueenSide && (allPieceBitboard & BLACK_QUEEN_ROCHADE | oppAttkBitboard & BLACK_QUEEN_ATTK_ROCHADE) == 0ul) pMoveList.Add(mBLACK_QUEEN_ROCHADE); if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveList(p, blackKingSquare, blackPieceBitboard, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[blackKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare - 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveList(p, blackKingSquare, blackPieceBitboard, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveList(blackKingSquare, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); } private void GetLegalBlackCaptures(int pCheckingPieceSquare, ref List<Move> pMoveList) { if (pCheckingPieceSquare == -779) { GetLegalBlackCapturesSpecialDoubleCheckCase(ref pMoveList); return; } moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= whitePawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, blackKingSquare); if (curCheckCount == 0) { if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & whitePieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[blackKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare - 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & whitePieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveListOnlyCaptures(blackKingSquare, ~oppAttkBitboard & whitePieceBitboard); } private void GetLegalBlackMovesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= whitePawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveList(blackKingSquare, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); } private void GetLegalBlackCapturesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= whitePawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveListOnlyCaptures(blackKingSquare, ~oppAttkBitboard & whitePieceBitboard); } public Move GetMoveOfString(string pMove) { int tSP, tEP; string[] tSpl = pMove.Split(','); if (Char.IsNumber(pMove[0])) { tSP = Convert.ToInt32(tSpl[0]); tEP = Convert.ToInt32(tSpl[1]); } else { tSP = SQUARES.NumberNotation(tSpl[0]); tEP = SQUARES.NumberNotation(tSpl[1]); } int tPT = pieceTypeArray[tSP]; bool tIC = ULONG_OPERATIONS.IsBitOne(allPieceBitboard, tEP), tIEP = enPassantSquare == tEP && tPT == 1; if (tSpl.Length == 3) return new Move(tSP, tEP, tPT, Convert.ToInt32(tSpl[2]), tIC); if (tIEP) return new Move(true, tSP, tEP, isWhiteToMove ? tEP - 8 : tEP + 8); if (tPT == 1 && Math.Abs(tSP - tEP) > 11) return new Move(tSP, tEP, 1, false, isWhiteToMove ? tSP + 8 : tSP - 8); if (tPT == 6 && (Math.Abs(tSP - tEP) == 2 || Math.Abs(tSP - tEP) == 3)) { if (isWhiteToMove) return tEP == 6 ? mWHITE_KING_ROCHADE : mWHITE_QUEEN_ROCHADE; return tEP == 62 ? mBLACK_KING_ROCHADE : mBLACK_QUEEN_ROCHADE; } return new Move(tSP, tEP, tPT, tIC); } public void PlainMakeMove(string pMoveName) { PlainMakeMove(GetMoveOfString(pMoveName)); } public void PlainMakeMove(Move pMove) { lastMadeMove = pMove; if (isWhiteToMove) WhiteMakeMove(pMove); else BlackMakeMove(pMove); debugFEN = CreateFenString(); } public void WhiteMakeMove(Move pMove) { int tEndPos = pMove.endPos, tStartPos = pMove.startPos, tPieceType = pMove.pieceType, tPTI = pieceTypeArray[tEndPos]; fiftyMoveRuleCounter++; whitePieceBitboard ^= pMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey ^= blackTurnHash ^ enPassantSquareHashes[enPassantSquare] ^ pieceHashesWhite[tStartPos, tPieceType] ^ pieceHashesWhite[tEndPos, tPieceType]; enPassantSquare = 65; isWhiteToMove = false; switch (pMove.moveTypeID) { case 0: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 1: fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 2: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 3: whiteKingSquare = tEndPos; if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 4: if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 5: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 6: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 7: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[whiteKingSquare = tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 8: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 9: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = pMove.enPassantOption]; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 11: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; whiteKingSquare = tEndPos; pieceTypeArray[pMove.rochadeEndPos] = 4; pieceTypeArray[pMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesWhite[pMove.rochadeStartPos, 4] ^ pieceHashesWhite[pMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 12: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[pMove.enPassantOption] = 0; zobristKey ^= pieceHashesBlack[pMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 13: fiftyMoveRuleCounter = 0; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; zobristKey ^= pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, pMove.promotionType]; break; case 14: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, tPTI] ^ pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, pMove.promotionType]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; } moveHashList.Add(pMove.moveHash); if (pMove.isCapture || tPieceType == 1) { curSearchZobristKeyLine = Array.Empty<ulong>(); return; } ulong[] u = new ulong[(tPTI = curSearchZobristKeyLine.Length) + 1]; for (int i = tPTI; i-- > 0;) u[i] = curSearchZobristKeyLine[i]; u[tPTI] = zobristKey; curSearchZobristKeyLine = u; } public void BlackMakeMove(Move pMove) { int tEndPos = pMove.endPos, tStartPos = pMove.startPos, tPieceType = pMove.pieceType, tPTI = pieceTypeArray[tEndPos]; fiftyMoveRuleCounter++; blackPieceBitboard ^= pMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey ^= blackTurnHash ^ enPassantSquareHashes[enPassantSquare] ^ pieceHashesBlack[tStartPos, tPieceType] ^ pieceHashesBlack[tEndPos, tPieceType]; enPassantSquare = 65; isWhiteToMove = true; switch (pMove.moveTypeID) { case 0: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 1: fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 2: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 3: blackKingSquare = tEndPos; if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 4: if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 5: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 6: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 7: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[blackKingSquare = tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 8: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 9: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = pMove.enPassantOption]; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 11: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; blackKingSquare = tEndPos; pieceTypeArray[pMove.rochadeEndPos] = 4; pieceTypeArray[pMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesBlack[pMove.rochadeStartPos, 4] ^ pieceHashesBlack[pMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 12: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[pMove.enPassantOption] = 0; zobristKey ^= pieceHashesWhite[pMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 13: fiftyMoveRuleCounter = 0; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, pMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 14: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } zobristKey ^= pieceHashesWhite[tEndPos, tPTI] ^ pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, pMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; } moveHashList.Add(pMove.moveHash); if (pMove.isCapture || tPieceType == 1) { curSearchZobristKeyLine = Array.Empty<ulong>(); return; } ulong[] u = new ulong[(tPTI = curSearchZobristKeyLine.Length) + 1]; for (int i = tPTI; i-- > 0;) u[i] = curSearchZobristKeyLine[i]; u[tPTI] = zobristKey; curSearchZobristKeyLine = u; } public void WhiteUndoMove(Move pMove) { } private const int WHITE_CHECKMATE_VAL = 100000, BLACK_CHECKMATE_VAL = -100000, CHECK_EXTENSION_LENGTH = -12, MAX_QUIESCENCE_TOTAL_LENGTH = -32; private readonly Move NULL_MOVE = new Move(0, 0, 0); private int curSearchDepth = 0, curSubSearchDepth = -1; public int MinimaxRoot(long pTime) { evalCount = 0; searches++; int baseLineLen = 0; long tTimestamp = globalTimer.ElapsedTicks + pTime; ClearHeuristics(); transpositionTable.Clear(); ulong[] tZobristKeyLine = Array.Empty<ulong>(); if (curSearchZobristKeyLine != null) { baseLineLen = curSearchZobristKeyLine.Length; tZobristKeyLine = new ulong[baseLineLen]; Array.Copy(curSearchZobristKeyLine, tZobristKeyLine, baseLineLen); } int perftScore, tattk = isWhiteToMove ? PreMinimaxCheckCheckWhite() : PreMinimaxCheckCheckBlack(), pDepth = 1; (string, int) bookMoveTuple = TLMDatabase.SearchForNextBookMove(moveHashList); if (bookMoveTuple.Item2 != 0) { int actualMoveHash = NuCRe.GetNumber(bookMoveTuple.Item1); List<Move> tMoves = new List<Move>(); GetLegalMoves(ref tMoves); int tL = tMoves.Count; for (int i = 0; i < tL; i++) { if (tMoves[i].moveHash == actualMoveHash) { if (debugSearchDepthResults) { SNAPSHOT_WRITLINE_REPLACEMENT("TLM_DB_Count: " + bookMoveTuple.Item2); SNAPSHOT_WRITLINE_REPLACEMENT(">> " + tMoves[i]); } transpositionTable.Add(zobristKey, new TranspositionEntry(tMoves[i], Array.Empty<int>())); return 0; } } } do { curSearchDepth = pDepth; curSubSearchDepth = pDepth - 1; ulong[] completeZobristHistory = new ulong[baseLineLen + pDepth - CHECK_EXTENSION_LENGTH + 1]; for (int i = 0; i < baseLineLen; i++) completeZobristHistory[i] = curSearchZobristKeyLine[i]; curSearchZobristKeyLine = completeZobristHistory; if (isWhiteToMove) { if (tattk == -1) perftScore = MinimaxWhite(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); else perftScore = MinimaxWhite(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); } else { if (tattk == -1) perftScore = MinimaxBlack(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); else perftScore = MinimaxBlack(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); } if (debugSearchDepthResults && pTime != 1L) { int tNpS = Convert.ToInt32((double)evalCount * 10_000_000d /(double)(pTime - tTimestamp + globalTimer.ElapsedTicks)); int tSearchEval = perftScore; int timeForSearchSoFar = (int)((pTime - tTimestamp + globalTimer.ElapsedTicks) /10000d); Move tBestMove = transpositionTable[zobristKey].bestMove; SNAPSHOT_WRITLINE_REPLACEMENT((tSearchEval >= 0 ? "+": "") + tSearchEval); SNAPSHOT_WRITLINE_REPLACEMENT(" " + tBestMove + "  ["); SNAPSHOT_WRITLINE_REPLACEMENT("Depth = " + pDepth + ", "); SNAPSHOT_WRITLINE_REPLACEMENT("Evals = " + GetThreeDigitSeperatedInteger(evalCount) + ", "); SNAPSHOT_WRITLINE_REPLACEMENT("Time = " + GetThreeDigitSeperatedInteger(timeForSearchSoFar) + "ms, "); SNAPSHOT_WRITLINE_REPLACEMENT("NpS = " + GetThreeDigitSeperatedInteger(tNpS) + "]"); } pDepth++; } while (globalTimer.ElapsedTicks < tTimestamp && pDepth < 179); depths += pDepth - 1; BOT_MAIN.depthsSearched += pDepth - 1; BOT_MAIN.searchesFinished++; BOT_MAIN.evaluationsMade += evalCount; curSearchZobristKeyLine = tZobristKeyLine; return perftScore; } private int[] squareToRankArray = new int[64] { 0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1, 2,2,2,2,2,2,2,2, 3,3,3,3,3,3,3,3, 4,4,4,4,4,4,4,4, 5,5,5,5,5,5,5,5, 6,6,6,6,6,6,6,6, 7,7,7,7,7,7,7,7 }; private bool WhiteIsPositionTheSpecialCase(Move pLastMove, int pCheckingSquare) { if (pLastMove.isPromotion && pLastMove.isCapture && (pLastMove.promotionType == 4 || pLastMove.promotionType == 5)) { if(pLastMove.startPos % 8 == pCheckingSquare % 8 && pLastMove.startPos == whiteKingSquare + 8) return true; if (pCheckingSquare > -1 && squareToRankArray[pLastMove.startPos] == squareToRankArray[pCheckingSquare] && pLastMove.endPos == whiteKingSquare - 8) return true; } return false; } private bool BlackIsPositionTheSpecialCase(Move pLastMove, int pCheckingSquare) { if (pLastMove.isPromotion && pLastMove.isCapture && (pLastMove.promotionType == 4 || pLastMove.promotionType == 5)) { if (pLastMove.startPos % 8 == pCheckingSquare % 8 && pLastMove.startPos == blackKingSquare - 8) return true; if (pCheckingSquare > -1 && squareToRankArray[pLastMove.startPos] == squareToRankArray[pCheckingSquare] && pLastMove.endPos == blackKingSquare + 8) return true; } return false; } private int MinimaxWhite(int pPly, int pAlpha, int pBeta, int pDepth, int pRepetitionHistoryPly, int pCheckingSquare, Move pLastMove) { if (IsDrawByRepetition(pRepetitionHistoryPly - 4)) return 0; if ((pDepth <= 0 && pCheckingSquare == -1) || pDepth < CHECK_EXTENSION_LENGTH) return QuiescenceWhite(pPly, pAlpha, pBeta, pDepth - 1, pCheckingSquare, pLastMove); List<Move> moveOptionList = new List<Move>(); Move bestMove = NULL_MOVE; if (WhiteIsPositionTheSpecialCase(pLastMove, pCheckingSquare)) GetLegalWhiteMovesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalWhiteMoves(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tWhiteKingSquare = whiteKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1, curEval = BLACK_CHECKMATE_VAL - pDepth; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = true; double[] moveSortingArray = new double[molc]; int[] moveSortingArrayIndexes = new int[molc], thisSearchMoveSortingArrayForTransposEntry = new int[molc]; transpositionTable.TryGetValue(zobristKey, out TranspositionEntry transposEntry); if (transposEntry == null) { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; } } else { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove == transposEntry.bestMove) moveSortingArray[m] = BESTMOVE_SORT_VAL; else if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; if (transposEntry.moveGenOrderedEvalLength > m) moveSortingArray[m] -= transposEntry.moveGenOrderedEvals[m]; } } Array.Sort(moveSortingArray, moveSortingArrayIndexes); for (int m = 0; m < molc; m++) { int tActualIndex = moveSortingArrayIndexes[m]; Move curMove = moveOptionList[tActualIndex]; if (debugSortResults && pDepth == curSubSearchDepth) { SNAPSHOT_WRITLINE_REPLACEMENT(moveSortingArray[m] + " | "+ curMove); } int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; whitePieceBitboard = tWPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesWhite[tStartPos, tPieceType] ^ pieceHashesWhite[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 0: blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 1: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 2: blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 3: whiteKingSquare = tEndPos; if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 4: blackPieceBitboard = tBPB; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 5: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[whiteKingSquare = tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = curMove.enPassantOption]; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 11: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; whiteKingSquare = tEndPos; blackPieceBitboard = tBPB; pieceTypeArray[curMove.rochadeEndPos] = 4; pieceTypeArray[curMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesWhite[curMove.rochadeStartPos, 4] ^ pieceHashesWhite[curMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | curMove.rochadeEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << curMove.rochadeEndPos)) tCheckPos = curMove.rochadeEndPos; break; case 12: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesBlack[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 13: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; zobristKey ^= pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, curMove.promotionType]; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; case 14: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, tPTI] ^ pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, curMove.promotionType]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } curSearchZobristKeyLine[pRepetitionHistoryPly] = zobristKey; debugMoveList[pPly] = curMove; int tEval = MinimaxBlack(pPly + 1, pAlpha, pBeta, pDepth - 1, pRepetitionHistoryPly + 1, tCheckPos, curMove); thisSearchMoveSortingArrayForTransposEntry[tActualIndex] = tEval; pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 3: whiteKingSquare = tWhiteKingSquare; break; case 7: whiteKingSquare = tWhiteKingSquare; break; case 10: enPassantSquare = 65; break; case 11: whiteKingSquare = tWhiteKingSquare; pieceTypeArray[curMove.rochadeStartPos] = 4; pieceTypeArray[curMove.rochadeEndPos] = 0; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 13: pieceTypeArray[tStartPos] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval > curEval) { bestMove = curMove; curEval = tEval; } if (pAlpha < curEval) pAlpha = curEval; if (curEval >= pBeta) { if (!curMove.isCapture) { killerMoveHeuristic[curMove.moveHash] = true; if (pDepth > 0) historyHeuristic[curMove.moveHash] += pDepth * pDepth; } break; } } isWhiteToMove = true; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; if (molc == 0 && pCheckingSquare == -1) curEval = 0; if (!transpositionTable.ContainsKey(zobristKey)) transpositionTable.Add(zobristKey, new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry)); else transpositionTable[zobristKey] = new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry); return curEval; } private int QuiescenceWhite(int pPly, int pAlpha, int pBeta, int pDepth, int pCheckingSquare, Move pLastMove) { int standPat = TexelEvaluate(); if (standPat >= pBeta || pDepth < MAX_QUIESCENCE_TOTAL_LENGTH) return pBeta; if (standPat > pAlpha) pAlpha = standPat; List<Move> moveOptionList = new List<Move>(); if (WhiteIsPositionTheSpecialCase(pLastMove, pCheckingSquare)) GetLegalWhiteCapturesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalWhiteCaptures(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tWhiteKingSquare = whiteKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = true; for (int m = 0; m < molc; m++) { Move curMove = moveOptionList[m]; int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; whitePieceBitboard = tWPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesWhite[tStartPos, tPieceType] ^ pieceHashesWhite[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 5: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[whiteKingSquare = tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 12: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesBlack[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 14: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, tPTI] ^ pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, curMove.promotionType]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } debugMoveList[pPly] = curMove; int tEval = QuiescenceBlack(pPly + 1, pAlpha, pBeta, pDepth - 1, tCheckPos, curMove); pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 7: whiteKingSquare = tWhiteKingSquare; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval >= pBeta) return pBeta; if (pAlpha < tEval) pAlpha = tEval; } isWhiteToMove = true; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; return pAlpha; } private int MinimaxBlack(int pPly, int pAlpha, int pBeta, int pDepth, int pRepetitionHistoryPly, int pCheckingSquare, Move pLastMove) { if (IsDrawByRepetition(pRepetitionHistoryPly - 4)) return 0; if ((pDepth <= 0 && pCheckingSquare == -1) || pDepth < CHECK_EXTENSION_LENGTH) return QuiescenceBlack(pPly, pAlpha, pBeta, pDepth - 1, pCheckingSquare, pLastMove); List<Move> moveOptionList = new List<Move>(); Move bestMove = NULL_MOVE; if (BlackIsPositionTheSpecialCase(pLastMove, pCheckingSquare)) GetLegalBlackMovesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalBlackMoves(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tBlackKingSquare = blackKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1, curEval = WHITE_CHECKMATE_VAL + pDepth; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = false; double[] moveSortingArray = new double[molc]; int[] moveSortingArrayIndexes = new int[molc], thisSearchMoveSortingArrayForTransposEntry = new int[molc]; transpositionTable.TryGetValue(zobristKey, out TranspositionEntry transposEntry); if (transposEntry == null) { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; } } else { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove == transposEntry.bestMove) moveSortingArray[m] = BESTMOVE_SORT_VAL; else if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; if (transposEntry.moveGenOrderedEvalLength > m) moveSortingArray[m] -= transposEntry.moveGenOrderedEvals[m]; } } Array.Sort(moveSortingArray, moveSortingArrayIndexes); for (int m = 0; m < molc; m++) { int tActualIndex = moveSortingArrayIndexes[m]; Move curMove = moveOptionList[tActualIndex]; if (debugSortResults && pDepth == curSearchDepth) { SNAPSHOT_WRITLINE_REPLACEMENT("=== " + moveSortingArray[m] + " | "+ curMove); } int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; blackPieceBitboard = tBPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesBlack[tStartPos, tPieceType] ^ pieceHashesBlack[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 0: whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 1: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 2: whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 3: blackKingSquare = tEndPos; if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 4: whitePieceBitboard = tWPB; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 5: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[blackKingSquare = tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = curMove.enPassantOption]; whitePieceBitboard = tWPB; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 11: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; blackKingSquare = tEndPos; whitePieceBitboard = tWPB; pieceTypeArray[curMove.rochadeEndPos] = 4; pieceTypeArray[curMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesBlack[curMove.rochadeStartPos, 4] ^ pieceHashesBlack[curMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | curMove.rochadeEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << curMove.rochadeEndPos)) tCheckPos = curMove.rochadeEndPos; break; case 12: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesWhite[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 13: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, curMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; case 14: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } zobristKey ^= pieceHashesWhite[tEndPos, tPTI] ^ pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, curMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } curSearchZobristKeyLine[pRepetitionHistoryPly] = zobristKey; debugMoveList[pPly] = curMove; int tEval = MinimaxWhite(pPly + 1, pAlpha, pBeta, pDepth - 1, pRepetitionHistoryPly + 1, tCheckPos, curMove); thisSearchMoveSortingArrayForTransposEntry[tActualIndex] = tEval; pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 3: blackKingSquare = tBlackKingSquare; break; case 7: blackKingSquare = tBlackKingSquare; break; case 10: enPassantSquare = 65; break; case 11: blackKingSquare = tBlackKingSquare; pieceTypeArray[curMove.rochadeStartPos] = 4; pieceTypeArray[curMove.rochadeEndPos] = 0; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 13: pieceTypeArray[tStartPos] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval < curEval) { bestMove = curMove; curEval = tEval; } if (pBeta > curEval) pBeta = curEval; if (curEval <= pAlpha) { if (!curMove.isCapture) { killerMoveHeuristic[curMove.moveHash] = true; if (pDepth > 0) historyHeuristic[curMove.moveHash] += pDepth * pDepth; } break; } } isWhiteToMove = false; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; if (molc == 0 && pCheckingSquare == -1) curEval = 0; if (!transpositionTable.ContainsKey(zobristKey)) transpositionTable.Add(zobristKey, new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry)); else transpositionTable[zobristKey] = new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry); return curEval; } private int QuiescenceBlack(int pPly, int pAlpha, int pBeta, int pDepth, int pCheckingSquare, Move pLastMove) { int standPat = TexelEvaluate(); if (standPat <= pAlpha || pDepth < MAX_QUIESCENCE_TOTAL_LENGTH) return pAlpha; if (standPat < pBeta) pBeta = standPat; List<Move> moveOptionList = new List<Move>(); if (BlackIsPositionTheSpecialCase(pLastMove, pCheckingSquare)) GetLegalBlackCapturesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalBlackCaptures(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tBlackKingSquare = blackKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = false; for (int m = 0; m < molc; m++) { Move curMove = moveOptionList[m]; int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; blackPieceBitboard = tBPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesBlack[tStartPos, tPieceType] ^ pieceHashesBlack[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 5: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[blackKingSquare = tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 12: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesWhite[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 14: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } zobristKey ^= pieceHashesWhite[tEndPos, tPTI] ^ pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, curMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } debugMoveList[pPly] = curMove; int tEval = QuiescenceWhite(pPly + 1, pAlpha, pBeta, pDepth - 1, tCheckPos, curMove); pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 7: blackKingSquare = tBlackKingSquare; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval <= pAlpha) return pAlpha; if (pBeta > tEval) pBeta = tEval; } isWhiteToMove = false; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; return pBeta; } private bool[] killerMoveHeuristic = new bool[262_144]; private int[] historyHeuristic = new int[262_144]; public void ClearHeuristics() { for (int i = 0; i < 262_144; i++) { killerMoveHeuristic[i] = false; historyHeuristic[i] = 0; } } private Dictionary<ulong, TranspositionEntry> transpositionTable = new Dictionary<ulong, TranspositionEntry>(); private int[] pieceEvals = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[,][] piecePositionEvals = new int[33, 14][]; private int evalCount = 0; private int Evaluate() { evalCount++; if (fiftyMoveRuleCounter > 99) return 0; int tEval = 0, tPT, pieceCount = ULONG_OPERATIONS.CountBits(allPieceBitboard); for (int p = 0; p < 64; p++) tEval += pieceEvals[tPT = pieceTypeArray[p] + 7 * ((int)(blackPieceBitboard >> p) & 1)] + piecePositionEvals[pieceCount, tPT][p]; return tEval; } public int GameState(bool pWhiteKingCouldBeAttacked) { if (IsDrawByRepetition(curSearchZobristKeyLine.Length - 5) || fiftyMoveRuleCounter > 99) return 0; int t; List<Move> tMoves = new List<Move>(); GetLegalMoves(ref tMoves); if (pWhiteKingCouldBeAttacked) { t = PreMinimaxCheckCheckWhite(); if (t == -1) return tMoves.Count == 0 ? 0 : 3; else if (tMoves.Count == 0) return -1; } else { t = PreMinimaxCheckCheckBlack(); if (t == -1) return tMoves.Count == 0 ? 0 : 3; else if (tMoves.Count == 0) return 1; } return 3; } private bool IsDrawByRepetition(int pPlyOfFirstPossibleRepeatedPosition) { int tC = 0; for (int i = pPlyOfFirstPossibleRepeatedPosition; i >= 0; i -= 2) { if (curSearchZobristKeyLine[i] == zobristKey) if (++tC == 2) return true; } return false; } private const int RELE_MAX_MOVE_COUNT_PER_GAME = 500; public double ReLePlayGame(int[,][] pEvalPositionValuesWhite, int[,][] pEvalPositionValuesBlack, long thinkingTimePerMove) { int[,][] processedValuesWhite = InitReLeAgent(pEvalPositionValuesWhite), processedValuesBlack = InitReLeAgent(pEvalPositionValuesBlack); int tGS, mc = 0; do { if (IsDrawByRepetition(curSearchZobristKeyLine.Length - 5)) return 0d; piecePositionEvals = isWhiteToMove ? processedValuesWhite : processedValuesBlack; MinimaxRoot(thinkingTimePerMove); if (transpositionTable.Count == 0) { SNAPSHOT_WRITLINE_REPLACEMENT("?!"); return 0d; } PlainMakeMove(transpositionTable[zobristKey].bestMove); tGS = GameState(isWhiteToMove); transpositionTable.Clear(); if (tGS != 3) break; } while (mc++ < RELE_MAX_MOVE_COUNT_PER_GAME); if (tGS == 3 || tGS == 0) return 0d; else if (tGS == 1) return 0.1d * (double)(RELE_MAX_MOVE_COUNT_PER_GAME - mc); return 0.1d * (double)(-RELE_MAX_MOVE_COUNT_PER_GAME + mc); } public int[,][] InitReLeAgent(int[,][] pEvalPositionValues) { return GetInterpolatedProcessedValues(pEvalPositionValues); } private int[,][] GetInterpolatedProcessedValues(int[,][] pEvalPositionValues) { int[,][] processedValues = new int[33, 14][]; for (int i = 0; i < 32; i++) { int ip1 = i + 1; processedValues[ip1, 7] = processedValues[ip1, 0] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; processedValues[ip1, 8] = SwapArrayViewingSide(processedValues[ip1, 1] = MultiplyArraysWithVal(pEvalPositionValues[0, 0], pEvalPositionValues[1, 0], pEvalPositionValues[2, 0], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 9] = SwapArrayViewingSide(processedValues[ip1, 2] = MultiplyArraysWithVal(pEvalPositionValues[0, 1], pEvalPositionValues[1, 1], pEvalPositionValues[2, 1], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 10] = SwapArrayViewingSide(processedValues[ip1, 3] = MultiplyArraysWithVal(pEvalPositionValues[0, 2], pEvalPositionValues[1, 2], pEvalPositionValues[2, 2], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 11] = SwapArrayViewingSide(processedValues[ip1, 4] = MultiplyArraysWithVal(pEvalPositionValues[0, 3], pEvalPositionValues[1, 3], pEvalPositionValues[2, 3], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 12] = SwapArrayViewingSide(processedValues[ip1, 5] = MultiplyArraysWithVal(pEvalPositionValues[0, 4], pEvalPositionValues[1, 4], pEvalPositionValues[2, 4], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 13] = SwapArrayViewingSide(processedValues[ip1, 6] = MultiplyArraysWithVal(pEvalPositionValues[0, 5], pEvalPositionValues[1, 5], pEvalPositionValues[2, 5], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); } return processedValues; } private double[,][] GetInterpolatedProcessedValues(double[,][] pEvalPositionValues) { double[,][] processedValues = new double[33, 14][]; for (int i = 0; i < 32; i++) { int ip1 = i + 1; processedValues[ip1, 7] = processedValues[ip1, 0] = new double[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; processedValues[ip1, 8] = SwapArrayViewingSide(processedValues[ip1, 1] = MultiplyArraysWithVal(pEvalPositionValues[0, 0], pEvalPositionValues[1, 0], pEvalPositionValues[2, 0], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 9] = SwapArrayViewingSide(processedValues[ip1, 2] = MultiplyArraysWithVal(pEvalPositionValues[0, 1], pEvalPositionValues[1, 1], pEvalPositionValues[2, 1], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 10] = SwapArrayViewingSide(processedValues[ip1, 3] = MultiplyArraysWithVal(pEvalPositionValues[0, 2], pEvalPositionValues[1, 2], pEvalPositionValues[2, 2], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 11] = SwapArrayViewingSide(processedValues[ip1, 4] = MultiplyArraysWithVal(pEvalPositionValues[0, 3], pEvalPositionValues[1, 3], pEvalPositionValues[2, 3], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 12] = SwapArrayViewingSide(processedValues[ip1, 5] = MultiplyArraysWithVal(pEvalPositionValues[0, 4], pEvalPositionValues[1, 4], pEvalPositionValues[2, 4], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 13] = SwapArrayViewingSide(processedValues[ip1, 6] = MultiplyArraysWithVal(pEvalPositionValues[0, 5], pEvalPositionValues[1, 5], pEvalPositionValues[2, 5], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); } return processedValues; } private double[] MultiplyArraysWithVal(double[] pArr1, double[] pArr2, double[] pArr3, double pVal1, double pVal2, double pVal3) { int tL = pArr1.Length; double[] rArr = new double[tL]; for (int i = 0; i < tL; i++) { rArr[i] = pArr1[i] * pVal1 + pArr2[i] * pVal2 + pArr3[i] * pVal3; } return rArr; } private int[] MultiplyArraysWithVal(int[] pArr1, int[] pArr2, int[] pArr3, double pVal1, double pVal2, double pVal3) { int tL = pArr1.Length; int[] rArr = new int[tL]; for (int i = 0; i < tL; i++) { rArr[i] = (int)(pArr1[i] * pVal1 + pArr2[i] * pVal2 + pArr3[i] * pVal3); } return rArr; } private int[] SwapArrayViewingSideAndNegate(int[] pArr) { return new int[64] { -pArr[56], -pArr[57], -pArr[58], -pArr[59], -pArr[60], -pArr[61], -pArr[62], -pArr[63], -pArr[48], -pArr[49], -pArr[50], -pArr[51], -pArr[52], -pArr[53], -pArr[54], -pArr[55], -pArr[40], -pArr[41], -pArr[42], -pArr[43], -pArr[44], -pArr[45], -pArr[46], -pArr[47], -pArr[32], -pArr[33], -pArr[34], -pArr[35], -pArr[36], -pArr[37], -pArr[38], -pArr[39], -pArr[24], -pArr[25], -pArr[26], -pArr[27], -pArr[28], -pArr[29], -pArr[30], -pArr[31], -pArr[16], -pArr[17], -pArr[18], -pArr[19], -pArr[20], -pArr[21], -pArr[22], -pArr[23], -pArr[8], -pArr[9], -pArr[10], -pArr[11], -pArr[12], -pArr[13], -pArr[14], -pArr[15], -pArr[0], -pArr[1], -pArr[2], -pArr[3], -pArr[4], -pArr[5], -pArr[6], -pArr[7] }; } private int[] SwapArrayViewingSide(int[] pArr) { return new int[64] { pArr[56], pArr[57], pArr[58], pArr[59], pArr[60], pArr[61], pArr[62], pArr[63], pArr[48], pArr[49], pArr[50], pArr[51], pArr[52], pArr[53], pArr[54], pArr[55], pArr[40], pArr[41], pArr[42], pArr[43], pArr[44], pArr[45], pArr[46], pArr[47], pArr[32], pArr[33], pArr[34], pArr[35], pArr[36], pArr[37], pArr[38], pArr[39], pArr[24], pArr[25], pArr[26], pArr[27], pArr[28], pArr[29], pArr[30], pArr[31], pArr[16], pArr[17], pArr[18], pArr[19], pArr[20], pArr[21], pArr[22], pArr[23], pArr[8], pArr[9], pArr[10], pArr[11], pArr[12], pArr[13], pArr[14], pArr[15], pArr[0], pArr[1], pArr[2], pArr[3], pArr[4], pArr[5], pArr[6], pArr[7] }; } private double[] SwapArrayViewingSide(double[] pArr) { return new double[64] { pArr[56], pArr[57], pArr[58], pArr[59], pArr[60], pArr[61], pArr[62], pArr[63], pArr[48], pArr[49], pArr[50], pArr[51], pArr[52], pArr[53], pArr[54], pArr[55], pArr[40], pArr[41], pArr[42], pArr[43], pArr[44], pArr[45], pArr[46], pArr[47], pArr[32], pArr[33], pArr[34], pArr[35], pArr[36], pArr[37], pArr[38], pArr[39], pArr[24], pArr[25], pArr[26], pArr[27], pArr[28], pArr[29], pArr[30], pArr[31], pArr[16], pArr[17], pArr[18], pArr[19], pArr[20], pArr[21], pArr[22], pArr[23], pArr[8], pArr[9], pArr[10], pArr[11], pArr[12], pArr[13], pArr[14], pArr[15], pArr[0], pArr[1], pArr[2], pArr[3], pArr[4], pArr[5], pArr[6], pArr[7] }; } private int[,][] texelTuningRuntimeVals = new int[33, 14][]; private int[,][] texelTuningVals = new int[3, 6][]; private int[,] texelTuningAdjustIterations = new int[6, 64]; private int[][] texelTuningRuntimePositionalValsV2EG = new int[14][]; private int[][] texelTuningRuntimePositionalValsV2LG = new int[14][]; private int[] texelPieceEvaluationsV2EG = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[] texelPieceEvaluationsV2LG = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[] texelKingSafetyR1EvaluationsEG = new int[9]; private int[] texelKingSafetyR2EvaluationsEG = new int[17]; private int[] texelKingSafetyR1EvaluationsLG = new int[9]; private int[] texelKingSafetyR2EvaluationsLG = new int[17]; private int[] texelKingSafetySREvaluationsPT1EG = new int[12]; private int[] texelKingSafetySREvaluationsPT2EG = new int[12]; private int[] texelKingSafetySREvaluationsPT3EG = new int[12]; private int[] texelKingSafetySREvaluationsPT4EG = new int[12]; private int[] texelKingSafetySREvaluationsPT5EG = new int[12]; private int[] texelKingSafetySREvaluationsPT6EG = new int[12]; private int[] texelKingSafetySREvaluationsPT1LG = new int[12]; private int[] texelKingSafetySREvaluationsPT2LG = new int[12]; private int[] texelKingSafetySREvaluationsPT3LG = new int[12]; private int[] texelKingSafetySREvaluationsPT4LG = new int[12]; private int[] texelKingSafetySREvaluationsPT5LG = new int[12]; private int[] texelKingSafetySREvaluationsPT6LG = new int[12]; private int[,] texelMobilityStraightEG = new int[14, 15], texelMobilityStraightLG = new int[14, 15]; private int[,] texelMobilityDiagonalEG = new int[14, 14], texelMobilityDiagonalLG = new int[14, 14]; private int[] texelPieceEvaluations = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[] blackSidedSquares = new int[64] { 56, 57, 58, 59, 60, 61, 62, 63, 48, 49, 50, 51, 52, 53, 54, 55, 40, 41, 42, 43, 44, 45, 46, 47, 32, 33, 34, 35, 36, 37, 38, 39, 24, 25, 26, 27, 28, 29, 30, 31, 16, 17, 18, 19, 20, 21, 22, 23, 08, 09, 10, 11, 12, 13, 14, 15, 00, 01, 02, 03, 04, 05, 06, 07 }; private int[,] T_Pawns = new int[3, 64] { { 0, 0, 0, 0, 0, 0, 0, 0, 98, 134, 61, 95, 68, 126, 34, -11, -6, 7, 26, 31, 65, 56, 25, -20, -14, 13, 6, 21, 23, 12, 17, -23, -27, -2, -5, 12, 17, 6, 10, -25, -26, -4, -4, -10, 3, 3, 33, -12, -35, -1, -20, -23, -15, 24, 38, -22, 0, 0, 0, 0, 0, 0, 0, 0, } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { 0, 0, 0, 0, 0, 0, 0, 0, 178, 173, 158, 134, 147, 132, 165, 187, 94, 100, 85, 67, 56, 53, 82, 84, 32, 24, 13, 5, -2, 4, 17, 17, 13, 9, -3, -7, -7, -8, 3, -1, 4, 7, -6, 1, 0, -5, -1, -8, 13, 8, 8, 10, 13, 0, 2, -7, 0, 0, 0, 0, 0, 0, 0, 0, } }; private int[,] T_Knights = new int[3, 64] { { -167, -89, -34, -49, 61, -97, -15, -107, -73, -41, 72, 36, 23, 62, 7, -17, -47, 60, 37, 65, 84, 129, 73, 44, -9, 17, 19, 53, 37, 69, 18, 22, -13, 4, 16, 13, 28, 19, 21, -8, -23, -9, 12, 10, 19, 17, 25, -16, -29, -53, -12, -3, -1, 18, -14, -19, -105, -21, -58, -33, -17, -28, -19, -23 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -58, -38, -13, -28, -31, -27, -63, -99, -25, -8, -25, -2, -9, -25, -24, -52, -24, -20, 10, 9, -1, -9, -19, -41, -17, 3, 22, 22, 22, 11, 8, -18, -18, -6, 16, 25, 16, 17, 4, -18, -23, -3, -1, 15, 10, -3, -20, -22, -42, -20, -10, -5, -2, -20, -23, -44, -29, -51, -23, -15, -22, -18, -50, -64 } }; private int[,] T_Bishops = new int[3, 64] { { -29, 4, -82, -37, -25, -42, 7, -8, -26, 16, -18, -13, 30, 59, 18, -47, -16, 37, 43, 40, 35, 50, 37, -2, -4, 5, 19, 50, 37, 37, 7, -2, -6, 13, 13, 26, 34, 12, 10, 4, 0, 15, 15, 15, 14, 27, 18, 10, 4, 15, 16, 0, 7, 21, 33, 1, -33, -3, -14, -21, -13, -12, -39, -21 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -14, -21, -11, -8, -7, -9, -17, -24, -8, -4, 7, -12, -3, -13, -4, -14, 2, -8, 0, -1, -2, 6, 0, 4, -3, 9, 12, 9, 14, 10, 3, 2, -6, 3, 13, 19, 7, 10, -3, -9, -12, -3, 8, 10, 13, 3, -7, -15, -14, -18, -7, -1, 4, -9, -15, -27, -23, -9, -23, -5, -9, -16, -5, -17 } }; private int[,] T_Rooks = new int[3, 64] { { 32, 42, 32, 51, 63, 9, 31, 43, 27, 32, 58, 62, 80, 67, 26, 44, -5, 19, 26, 36, 17, 45, 61, 16, -24, -11, 7, 26, 24, 35, -8, -20, -36, -26, -12, -1, 9, -7, 6, -23, -45, -25, -16, -17, 3, 0, -5, -33, -44, -16, -20, -9, -1, 11, -6, -71, -19, -13, 1, 17, 16, 7, -37, -26 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { 13, 10, 18, 15, 12, 12, 8, 5, 11, 13, 13, 11, -3, 3, 8, 3, 7, 7, 7, 5, 4, -3, -5, -3, 4, 3, 13, 1, 2, 1, -1, 2, 3, 5, 8, 4, -5, -6, -8, -11, -4, 0, -5, -1, -7, -12, -8, -16, -6, -6, 0, 2, -9, -9, -11, -3, -9, 2, 3, -1, -5, -13, 4, -20 } }; private int[,] T_Queens = new int[3, 64] { { -28, 0, 29, 12, 59, 44, 43, 45, -24, -39, -5, 1, -16, 57, 28, 54, -13, -17, 7, 8, 29, 56, 47, 57, -27, -27, -16, -16, -1, 17, -2, 1, -9, -26, -9, -10, -2, -4, 3, -3, -14, 2, -11, -2, -5, 2, 14, 5, -35, -8, 11, 2, 8, 15, -3, 1, -1, -18, -9, 10, -15, -25, -31, -50 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -9, 22, 22, 27, 27, 19, 10, 20, -17, 20, 32, 41, 58, 25, 30, 0, -20, 6, 9, 49, 47, 35, 19, 9, 3, 22, 24, 45, 57, 40, 57, 36, -18, 28, 19, 47, 31, 34, 39, 23, -16, -27, 15, 6, 9, 17, 10, 5, -22, -23, -30, -16, -16, -23, -36, -32, -33, -28, -22, -43, -5, -32, -20, -41 } }; private int[,] T_Kings = new int[3, 64] { { -65, 23, 16, -15, -56, -34, 2, 13, 29, -1, -20, -7, -8, -4, -38, -29, -9, 24, 2, -16, -20, 6, 22, -22, -17, -20, -12, -27, -30, -25, -14, -36, -49, -1, -27, -39, -46, -44, -33, -51, -14, -14, -22, -46, -44, -30, -15, -27, 1, 7, -8, -64, -43, -16, 9, 8, -15, 36, 12, -54, 8, -28, 24, 14 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -74, -35, -18, -18, -11, 15, 4, -17, -12, 17, 14, 17, 17, 38, 23, 11, 10, 17, 23, 15, 20, 45, 44, 13, -8, 22, 24, 27, 26, 33, 26, 3, -18, -4, 21, 24, 27, 23, 9, -11, -19, -3, 11, 21, 23, 16, 7, -9, -27, -11, 4, 13, 14, 4, -5, -17, -53, -34, -21, -11, -28, -14, -24, -43 } }; private int[] paramsLowerLimits = new int[5] { -10000, -10000, -10000, -10000, -10000 }; private int[] paramsUpperLimits = new int[5] { 10000, 10000, 10000, 10000, 10000 }; private List<TLM_ChessGame> threadDataset; private int threadFrom, threadTo; private int[] threadParams; private int customThreadID = 0; private ulong ulAllThreadIDsUnfinished = 0; private double lastCostVal = 0d; private double sumCostVals = 0d; private int costCalculations = 0; private readonly string[] TEXELPRINT_GAMEPARTS = new string[3] { "Early Game: ", "Mid Game: ", "Late Game: "}; private readonly string[] TEXELPRINT_PIECES = new string[6] { "Bauer: ", "Springer: ", "Lufer: ", "Turm: ", "Dame: ", "Knig: "}; private double[] earlyGameMultipliers = new double[33]; private double[] middleGameMultipliers = new double[33]; private double[] lateGameMultipliers = new double[33]; private int[] pieceTypeGameProgressImpact = new int[14] { 0, 0, 1, 1, 2, 4, 0, 0, 0, 1, 1, 2, 4, 0 }; private void PrecalculateMultipliers() { if (BOARD_MANAGER_ID == ENGINE_VALS.PARALLEL_BOARDS - 1) SNAPSHOT_WRITLINE_REPLACEMENT(); for (int i = 0; i < 25; i++) { earlyGameMultipliers[i] = EGMultiplierFunction(i); lateGameMultipliers[i] = LGMultiplierFunction(i); if (BOARD_MANAGER_ID == ENGINE_VALS.PARALLEL_BOARDS - 1) SNAPSHOT_WRITLINE_REPLACEMENT("[" + i + "] "+ earlyGameMultipliers[i] + " | "+ middleGameMultipliers[i] + " | "+ lateGameMultipliers[i]); } } private double MultiplierFunction(double pVal, double pXShift) { double d = Math.Exp(1d /6d * (pVal - pXShift)); return 5 * (d /Math.Pow(d + 1, 2d)); } private double EGMultiplierFunction(double pVal) { return Math.Clamp(1 /16d * (pVal - 4d), 0d, 1d); } private double LGMultiplierFunction(double pVal) { return Math.Clamp(1 /-16d * (pVal - 4d) + 1d, 0d, 1d); } private double EGMultiplierFunction2(double pVal) { return Math.Clamp(1 /32d * pVal, 0d, 1d); } private double LGMultiplierFunction2(double pVal) { return Math.Clamp(1 /-32d * pVal + 1d, 0d, 1d); } private void TuneWithTxtFile(string pTXTName) { List<TLM_ChessGame> gameDataset = new List<TLM_ChessGame>(); string tPath = PathManager.GetTXTPath(pTXTName); string[] tStrs = File.ReadAllLines(tPath); List<string> tGames = new List<string>(); foreach (string s in tStrs) if (s.Contains(';') && s.Replace(" ", "") != "") tGames.Add(s); foreach (string s in tGames) { TLM_ChessGame tGame = CGFF.GetGame(s); LoadFenString(tGame.startFen); foreach (int hMove in tGame.hashedMoves) { List<Move> moveOptionList = new List<Move>(); GetLegalMoves(ref moveOptionList); int tL = moveOptionList.Count; for (int j = 0; j < tL; j++) { Move tMove = moveOptionList[j]; if (tMove.moveHash == hMove) { tGame.actualMoves.Add(tMove); PlainMakeMove(tMove); tL = -1; break; } } if (tL != -1) break; } gameDataset.Add(tGame); } SNAPSHOT_WRITLINE_REPLACEMENT("[TLM TEXEL TUNER] " + tGames.Count + " Games Loaded In!"); BOT_MAIN.curTEXELPARAMS = new int[TEXEL_PARAMS]; BOT_MAIN.ParallelTexelTuning(gameDataset); } private void LoadBestTexelParamsIn() { int[] ttt = new int[778] { 82, 341, 416, 470, 1106, 102, 302, 304, 518, 960, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, -46, 0, -20, 0, 64, -21, -71, 37, 29, 6, 98, 13, 44, 0, -26, -14, -36, -20, 94, 16, 60, 10, -62, -19, -38, -8, -28, 14, -26, -4, -32, -28, -52, 30, 56, -40, -72, -22, 100, 4, -98, -34, 6, -49, 32, -10, 72, 20, 84, -56, -60, -112, 128, -28, 152, 34, 26, -52, 200, -56, 76, 44, -56, -113, -156, 188, -39, 28, 200, -90, -60, -86, 100, -178, -119, -200, 200, 200, -20, -22, -78, -158, -200, 196, 200, -200, -200, -200, 104, 200, 138, -122, 200, 200, 124, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 200, 156, -37, -68, -148, -200, 200, -70, 72, 76, -31, -200, -21, 178, -200, 200, 200, -200, 123, -188, -6, 164, -74, 24, -28, -8, 71, -50, -112, -200, -8, -44, 27, -23, -50, 19, 19, 41, 150, 152, 4, -98, -36, -34, 174, -106, -16, 17, 141, -48, -108, 162, 6, -112, -52, 76, 68, 8, -86, 68, -176, 189, 81, 162, -200, 152, -41, 128, 172, -173, -144, 56, 22, 94, -28, 32, 16, -63, 36, -200, -200, -200, -22, 56, -116, 76, -36, -30, 100, 52, -166, -114, 142, -52, -44, -200, -18, -72, 60, 200, -160, 96, 46, -200, -28, -32, -44, 132, 60, -200, -137, -200, -176, 200, -200, -200, 4, 200, -200, 72, 200, -78, 200, 160, -105, 200, 96, -114, 200, 200, -88, -24, 11, -34, 184, 26, 83, -140, 10, -16, -72, -200, 12, -200, 46, -200, 11, 82, 66, -102, 22, -184, 32, 114, 140, -26, -18, -36, 66, 100, 25, -24, 133, -96, 50, 2, 80, 184, 43, -136, 44, 124, -148, 180, 69, -126, -200, 6, 78, -96, 89, -68, 200, -116, 114, 158, 5, -154, 115, 200, -152, -171, 41, -80, -23, 137, 98, -80, 40, -42, 200, 52, 146, 200, 6, -112, 32, 200, 132, 4, 90, -200, -200, 104, 67, -56, 186, 124, 140, 97, -144, 200, -4, -160, -117, -200, 24, -80, 200, 28, -46, -24, -52, -200, -200, 72, 20, 34, 200, -16, 88, 56, 200, -146, 120, 174, 200, -200, -86, 125, 172, -70, 4, 124, -72, 0, -2, 70, -14, 48, -32, 200, 80, 24, -132, 74, -44, 184, -4, -136, 0, -16, 20, -18, -32, 96, 92, 56, 2, 174, 196, -200, -56, -116, 88, 200, -8, 168, -13, 74, -106, 200, -182, 80, 82, -128, -16, 90, -200, 66, -88, 58, -16, 80, -34, 96, -95, -96, -200, 76, 26, -72, 32, -27, -108, 164, 200, -36, -93, -10, -56, 22, 36, 74, -200, -96, 200, 88, -88, 156, -92, 96, -200, 200, 191, -8, 62, -8, -100, 136, -72, -36, 200, -64, -114, 153, -110, 174, 46, 108, 142, 121, -200, 108, -200, 74, -4, 104, -200, 116, 82, 200, -76, 176, -200, 76, -8, 200, 46, 29, -86, 12, -24, -80, -12, 200, 124, -16, 54, 104, 200, -94, 140, 36, 32, -64, 24, -178, 15, -200, 0, -200, 4, -32, -124, 148, 176, 192, 90, 164, -91, 200, 172, -200, 64, 34, 40, -200, 0, -200, 12, -124, 48, -200, -56, 184, -8, -184, 0, 200, -16, 200, -8, 180, -18, -20, 24, -200, -58, 174, -200, 40, -4, -200, -24, 200, 54, 200, -24, -32, 37, 192, 48, 44, 26, 200, -22, 200, -145, -200, 30, 86, 54, 200, -102, -34, 94, -98, 92, -200, -76, 196, -18, -200, -180, 16, 186, -92, -200, -200, 164, -200, 62, 192, 159, -112, -12, -70, 184, 104, 200, -200, -148, -4, 86, -144, 200, -100, 200, 200, -104, 114, 132, -168, 12, 56, -10, 82, 200, -200, -200, -196, -6, 52, -200, 84, 200, -192, 128, 200, -200, -200, 200, 88, 168, -32, -84, 172, 52, -172, 0, -40, 68, -186, 42, 96, -200, -198, 200, -56, -176, 88, 0, 86, 16, -124, -46, 40, -16, -4, 54, -184, 200, 58, -200, 77, -200, -44, 102, 0, -50, -10, -92, 100, -86, 8, 20, -20, -200, 38, -200, -49, -4, 2, -200, 78, 0, -40, -92, 32, 0, -164, -88, -38, -138, -118, 29, -34, -200, -200, -200, -71, -200, 200, -200, -108, -200, 0, 192, -24, 104, -200, 200, 190, -28, -200, -200, -200, 128, -96, 200, 200, 200, 200, -200, -200, 177, -24, 200, 132, 200, -190, 200, -130, 200, 148, 200, 200, -200, -100, 200, -196, -200, 90, 200, -200, 200, 200, -200, -200, -200, -200, -200, 118, -200, 85, -200, 166, 199, -200 }; SetupTexelEvaluationParams(ttt); } private void SetupTexelEvaluationParams(int[] pParams) { texelPieceEvaluationsV2EG[8] = -(texelPieceEvaluationsV2EG[1] = pParams[0]); texelPieceEvaluationsV2EG[9] = -(texelPieceEvaluationsV2EG[2] = pParams[1]); texelPieceEvaluationsV2EG[10] = -(texelPieceEvaluationsV2EG[3] = pParams[2]); texelPieceEvaluationsV2EG[11] = -(texelPieceEvaluationsV2EG[4] = pParams[3]); texelPieceEvaluationsV2EG[12] = -(texelPieceEvaluationsV2EG[5] = pParams[4]); texelPieceEvaluationsV2LG[8] = -(texelPieceEvaluationsV2LG[1] = pParams[5]); texelPieceEvaluationsV2LG[9] = -(texelPieceEvaluationsV2LG[2] = pParams[6]); texelPieceEvaluationsV2LG[10] = -(texelPieceEvaluationsV2LG[3] = pParams[7]); texelPieceEvaluationsV2LG[11] = -(texelPieceEvaluationsV2LG[4] = pParams[8]); texelPieceEvaluationsV2LG[12] = -(texelPieceEvaluationsV2LG[5] = pParams[9]); int c = 10; for (int p = 1; p < 7; p++) { for (int s = 0; s < 64; s++) { texelTuningRuntimePositionalValsV2EG[p + 7][blackSidedSquares[s]] = -(texelTuningRuntimePositionalValsV2EG[p][s] = pParams[c++]); texelTuningRuntimePositionalValsV2LG[p + 7][blackSidedSquares[s]] = -(texelTuningRuntimePositionalValsV2LG[p][s] = pParams[c++]); } } return; for (int p = 2; p < 7; p++) { for (int a = 0; a < 15; a++) { if (a != 14) { texelMobilityDiagonalEG[p + 7, a] = -(texelMobilityDiagonalEG[p, a] = pParams[c++]); texelMobilityDiagonalLG[p + 7, a] = -(texelMobilityDiagonalLG[p, a] = pParams[c++]); } texelMobilityStraightEG[p + 7, a] = -(texelMobilityStraightEG[p, a] = pParams[c++]); texelMobilityStraightLG[p + 7, a] = -(texelMobilityStraightLG[p, a] = pParams[c++]); } } for (int i = 0; i < 12; i++) { texelKingSafetySREvaluationsPT1EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT2EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT3EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT4EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT5EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT6EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT1LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT2LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT3LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT4LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT5LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT6LG[i] = pParams[c++]; } } private void PrintDefinedTexelParams(int[] pParams) { int c = 0; for (int t = 0; t < 3; t++) { SNAPSHOT_WRITLINE_REPLACEMENT(TEXELPRINT_GAMEPARTS[t]); for (int p = 0; p < 6; p++) { SNAPSHOT_WRITLINE_REPLACEMENT(TEXELPRINT_PIECES[p]); texelTuningVals[t, p] = new int[64]; for (int s = 0; s < 64; s++) { if (s % 8 == 0 && s != 0) SNAPSHOT_WRITLINE_REPLACEMENT(); SNAPSHOT_WRITLINE_REPLACEMENT((texelTuningVals[t, p][s] = pParams[c++]) + ", "); } SNAPSHOT_WRITLINE_REPLACEMENT(); } } piecePositionEvals = GetInterpolatedProcessedValues(texelTuningVals); } public void TLMTuning(List<TLM_ChessGame> pDataset) { int tGameDataSetLen = pDataset.Count; int[,][] tRatio = new int[33, 6][]; int[,][] tTotalMoves = new int[33, 6][]; double[,][] tSummedRatios = new double[33, 6][]; double[,][] tSummedDataAmount = new double[33, 6][]; double[,][] tTuningResults = new double[33, 6][]; for (int t = 1; t < 33; t++) { for (int p = 0; p < 6; p++) { tRatio[t, p] = new int[64]; tTotalMoves[t, p] = new int[64]; tSummedRatios[t, p] = new double[64]; tSummedDataAmount[t, p] = new double[64]; tTuningResults[t, p] = new double[64]; } } for (int j = 0; j < tGameDataSetLen; j++) { TLM_ChessGame tGame = pDataset[j]; int tGR = tGame.gameResult - 1; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count - 5; for (int i = 0; i < tL; i++) { if (tGame.isMoveNonTactical[i]) { int tPieceAmount = ULONG_OPERATIONS.CountBits(allPieceBitboard); for (int s = 0; s < 64; s++) { int tPT = pieceTypeArray[s] - 1; if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, s)) { tTotalMoves[tPieceAmount, tPT][s]++; tRatio[tPieceAmount, tPT][s] += tGR; } else if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, s)) { int b = blackSidedSquares[s]; tTotalMoves[tPieceAmount, tPT][b]++; tRatio[tPieceAmount, tPT][b] += tGR; } } } PlainMakeMove(tGame.actualMoves[i]); } } double[,] allMultipliers = new double[33, 33]; for (int sh = 0; sh < 33; sh++) { for (int i = 0; i < 33; i++) { allMultipliers[sh, i] = MultiplierFunction(i, sh); } } for (int t = 1; t < 33; t++) { for (int p = 0; p < 6; p++) { for (int s = 0; s < 64; s++) { for (int t2 = 1; t2 < 33; t2++) { double cmult = allMultipliers[t, t2]; tSummedRatios[t, p][s] += tRatio[t2, p][s] * cmult; tSummedDataAmount[t, p][s] += tTotalMoves[t2, p][s] * cmult; } tTuningResults[t, p][s] = TTT(tSummedRatios[t, p][s], tSummedDataAmount[t, p][s]); } } } int c = 0; int[] tparams = new int[1152]; for (int t = 1; t < 33; t += 15) { if (t == 31) t = 32; SNAPSHOT_WRITLINE_REPLACEMENT("PieceCount = " + t + ": "); for (int p = 0; p < 6; p++) { SNAPSHOT_WRITLINE_REPLACEMENT(TEXELPRINT_PIECES[p]); for (int s = 0; s < 64; s++) { if (s % 8 == 0 && s != 0) SNAPSHOT_WRITLINE_REPLACEMENT(); SNAPSHOT_WRITLINE_REPLACEMENT((tparams[c++] = (int)(tTuningResults[t, p][s] * 100)).ToString().Replace(",", ".") + "("+ (int)tSummedDataAmount[t, p][s] + ")"+ ", "); } SNAPSHOT_WRITLINE_REPLACEMENT(); } } string tS = "PARAMS: {"; for (int i = 0; i < tparams.Length; i++) tS += tparams[i] + ","; tS = tS.Substring(0, tS.Length - 1) + "}\n"; SNAPSHOT_WRITLINE_REPLACEMENT(tS); TexelTuning(pDataset, tparams); } private double TTT(double d1, double d2) { if (d2 == 0) return 0; return d1 /d2; } public void TexelTuning(List<TLM_ChessGame> pDataset, int[] pCurBestParams) { Stopwatch sw = Stopwatch.StartNew(); string tPath = PathManager.GetTXTPath("OTHER/TEXEL_TUNING"); int paramCount = pCurBestParams.Length; double bestAvrgCost = CalculateAverageTexelCost(pDataset, pCurBestParams); SNAPSHOT_WRITLINE_REPLACEMENT("CUR PARAMS COST: " + bestAvrgCost); int packetSize = Math.Clamp(paramCount /ENGINE_VALS.CPU_CORES, 1, 100000); paramsLowerLimits = new int[paramCount]; paramsUpperLimits = new int[paramCount]; for (int i = 0; i < paramCount; i++) { int lim = i < 10 ? 100000 : 200; paramsLowerLimits[i] = -lim; paramsUpperLimits[i] = lim; } SNAPSHOT_WRITLINE_REPLACEMENT("PARAM-COUNT: " + paramCount); SNAPSHOT_WRITLINE_REPLACEMENT("PACKET-SIZE: " + packetSize); while (packetSize <= paramCount) { BOT_MAIN.TEXELfinished = 0; int lM = 0, tC = 0; ulong tUL = 0ul; for (int m = packetSize; lM < paramCount; m += packetSize) { if (m > paramCount) m = paramCount; tUL = ULONG_OPERATIONS.SetBitToOne(tUL, ++tC); lM = m; } tC = lM = 0; for (int m = packetSize; lM < paramCount; m += packetSize) { if (m > paramCount) m = paramCount; tC++; BOT_MAIN.boardManagers[tC].SetPlayTexelVals(pDataset, lM, m, pCurBestParams, paramsLowerLimits, paramsUpperLimits, tC, tUL); ThreadPool.QueueUserWorkItem(new WaitCallback(BOT_MAIN.boardManagers[tC].TexelTuningThreadedPackage)); lM = m; } packetSize = paramCount + 1; int tmod = 0; while (tC != BOT_MAIN.TEXELfinished) { if (++tmod % 20 == 0) { WriteTexelParamsToTXT(tPath, BOT_MAIN.curTEXELPARAMS); SNAPSHOT_WRITLINE_REPLACEMENT(CalculateAverageTexelCost(pDataset, BOT_MAIN.curTEXELPARAMS) + " | "+ BOT_MAIN.TEXELadjustmentsmade); SNAPSHOT_WRITLINE_REPLACEMENT(ULONG_OPERATIONS.GetBitVisualization(BOT_MAIN.TEXELfinishedwithoutimpovement)); } Thread.Sleep(100); } SNAPSHOT_WRITLINE_REPLACEMENT("One Thread Generation FINISHED! :) :) :)"); pCurBestParams = BOT_MAIN.curTEXELPARAMS; } sw.Stop(); WriteTexelParamsToTXT(tPath, BOT_MAIN.curTEXELPARAMS); SNAPSHOT_WRITLINE_REPLACEMENT("END COST: " + CalculateAverageTexelCost(pDataset, BOT_MAIN.curTEXELPARAMS)); SNAPSHOT_WRITLINE_REPLACEMENT(BOT_MAIN.TEXELadjustmentsmade); SNAPSHOT_WRITLINE_REPLACEMENT(sw.ElapsedMilliseconds); } public void TexelTuningThreadedPackage(object obj) { SNAPSHOT_WRITLINE_REPLACEMENT("Started CThreadID [" + customThreadID + "] which is handling Params ["+ threadFrom + "] - ["+ threadTo + "]"); bool firstIter = true; do { double bestAvrgCost = CalculateAverageTexelCost(threadDataset, threadParams); int adjust_val = firstIter ? 512 : 8; do { adjust_val /= 2; bool improvedAvrgCost = true; while (improvedAvrgCost) { improvedAvrgCost = false; for (int i = threadFrom; i < threadTo; i++) { bool improvedWithThisParam = true; int tadjustval = adjust_val; bool lastTimeMaximized = false, lastTimeMinimized = false; while (improvedWithThisParam) { improvedWithThisParam = false; int[] curParams = (int[])threadParams.Clone(); int paramBefore = curParams[i]; curParams[i] = Math.Clamp(paramBefore + adjust_val, paramsLowerLimits[i], paramsUpperLimits[i]); double curAvrgCost = CalculateAverageTexelCost(threadDataset, curParams); if (curAvrgCost < bestAvrgCost) { improvedAvrgCost = true; improvedWithThisParam = true; SNAPSHOT_WRITLINE_REPLACEMENT("Improved Param [" + i + "] at CThreadID ["+ customThreadID + "]: +"+ adjust_val + " ("+ GetDoublePrecentageString(bestAvrgCost - curAvrgCost) + ")"); bestAvrgCost = curAvrgCost; threadParams = curParams; BOT_MAIN.TEXELadjustmentsmade++; BOT_MAIN.TEXELfinishedwithoutimpovement = ulAllThreadIDsUnfinished; if (lastTimeMaximized) { adjust_val *= 4; lastTimeMaximized = false; } else lastTimeMaximized = true; lastTimeMinimized = false; } else { curParams[i] = Math.Clamp(paramBefore - adjust_val, paramsLowerLimits[i], paramsUpperLimits[i]); curAvrgCost = CalculateAverageTexelCost(threadDataset, curParams); if (curAvrgCost < bestAvrgCost) { improvedAvrgCost = true; improvedWithThisParam = true; SNAPSHOT_WRITLINE_REPLACEMENT("Improved Param [" + i + "] at CThreadID ["+ customThreadID + "]: -"+ adjust_val + " ("+ GetDoublePrecentageString(bestAvrgCost - curAvrgCost) + ")"); bestAvrgCost = curAvrgCost; threadParams = curParams; BOT_MAIN.TEXELadjustmentsmade++; BOT_MAIN.TEXELfinishedwithoutimpovement = ulAllThreadIDsUnfinished; if (lastTimeMinimized) { adjust_val *= 4; lastTimeMinimized = false; } else lastTimeMinimized = true; lastTimeMaximized = false; } } if (adjust_val != 1) adjust_val /= 2; for (int j = threadFrom; j < threadTo; j++) { BOT_MAIN.curTEXELPARAMS[j] = threadParams[j]; } threadParams = (int[])BOT_MAIN.curTEXELPARAMS.Clone(); bestAvrgCost = CalculateAverageTexelCost(threadDataset, threadParams); } adjust_val = tadjustval; } } } while (adjust_val != 1); BOT_MAIN.TEXELfinishedwithoutimpovement = ULONG_OPERATIONS.SetBitToZero(BOT_MAIN.TEXELfinishedwithoutimpovement, customThreadID); SNAPSHOT_WRITLINE_REPLACEMENT("FULLY FINISHED " + customThreadID + ". IMPROVEMENT THREAD PACKAGE CYCLE"); firstIter = false; } while (BOT_MAIN.TEXELfinishedwithoutimpovement != 0); BOT_MAIN.TEXELfinished++; } private void WriteTexelParamsToTXT(string pPath, int[] pParams) { try { string tS = "PARAMS: {"; for (int i = 0; i < pParams.Length; i++) tS += pParams[i] + ","; tS = tS.Substring(0, tS.Length - 1) + "}\n"; File.AppendAllText(pPath, tS); } catch { SNAPSHOT_WRITLINE_REPLACEMENT("Mal wieder TXT zu lange gebraucht um zu aktualisieren."); } } private double costSum = 0d; private int texelCostMovesEvaluated = 0; private double CalculateAverageTexelCost(List<TLM_ChessGame> tDataset, int[] pParams, bool pFullCost = true) { costSum = 0d; texelCostMovesEvaluated = 0; SetupTexelEvaluationParams(pParams); int tGameDataSetLen = tDataset.Count; int start = 0, end = tGameDataSetLen; if (!pFullCost) { end = (start = globalRandom.Next(0, end - 256)) + 256; } for (int j = start; j < end; j++) { TLM_ChessGame tGame = tDataset[j]; double tGR = tGame.gameResult; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count - 5; texelCostMovesEvaluated += tL; for (int i = 0; i < tL; i++) { costSum += TexelCost(tGR - TexelTuningSigmoid(TexelEvaluate())); PlainMakeMove(tGame.actualMoves[i]); } } return costSum /texelCostMovesEvaluated; } private double CalculateAverageTexelCostThreadedVersionLEGACYDOESNTWORK(List<TLM_ChessGame> tDataset, int[] pParams) { Stopwatch sw = Stopwatch.StartNew(); BOT_MAIN.TEXELcostSum = 0d; BOT_MAIN.TEXELfinished = 0; BOT_MAIN.TEXELcostMovesEvaluated = 0; int tGameDataSetLen = tDataset.Count; int gamesPerThread = tGameDataSetLen /ENGINE_VALS.CPU_CORES; for (int i = 0; i < ENGINE_VALS.CPU_CORES - 1; i++) { } for (int i = 0; i < ENGINE_VALS.CPU_CORES - 1; i++) { } while (BOT_MAIN.TEXELfinished != ENGINE_VALS.CPU_CORES) Thread.Sleep(1); sw.Stop(); return BOT_MAIN.TEXELcostSum /BOT_MAIN.TEXELcostMovesEvaluated; } public void SetPlayThroughVals(List<TLM_ChessGame> pDataset, int pFrom, int pTo) { threadDataset = pDataset; threadFrom = pFrom; threadTo = pTo; } public void SetPlayTexelVals(List<TLM_ChessGame> pDataset, int pFrom, int pTo, int[] pTexelParams, int[] pLowerLimits, int[] pUpperLimits, int pThreadID, ulong pUL) { threadDataset = pDataset; threadFrom = pFrom; threadTo = pTo; threadParams = pTexelParams; paramsLowerLimits = pLowerLimits; paramsUpperLimits = pUpperLimits; customThreadID = pThreadID; ulAllThreadIDsUnfinished = pUL; } public void PlayThroughSetOfGames(object obj) { SNAPSHOT_WRITLINE_REPLACEMENT(threadFrom + "->"+ threadTo); int sortedOut = 0; for (int j = threadFrom; j < threadTo; j++) { TLM_ChessGame tGame = threadDataset[j]; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count; for (int i = 0; i < tL; i++) { int tQuietEval = isWhiteToMove ? QuiescenceWhite(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, 0, PreMinimaxCheckCheckWhite(), NULL_MOVE) : QuiescenceBlack(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, 0, PreMinimaxCheckCheckBlack(), NULL_MOVE); bool tB; tGame.isMoveNonTactical.Add(tB = (Evaluate() == tQuietEval && i > 4)); if (!tB) sortedOut++; PlainMakeMove(tGame.actualMoves[i]); } } BOT_MAIN.TEXELsortedout += sortedOut; BOT_MAIN.TEXELfinished++; } public void CalculateAverageTexelCostThreadFunction(object obj) { SetupTexelEvaluationParams(threadParams); double d = 0d; for (int j = threadFrom; j < threadTo; j++) { TLM_ChessGame tGame = threadDataset[j]; double tGR = tGame.gameResult; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count - 5; BOT_MAIN.TEXELcostMovesEvaluated += tL; for (int i = 0; i < tL; i++) { d += TexelCost(tGR - TexelTuningSigmoid(TexelEvaluate())); PlainMakeMove(tGame.actualMoves[i]); } } BOT_MAIN.TEXELcostSum += d; BOT_MAIN.TEXELfinished++; } private void ConsoleWriteLineTuneArray<T>(T[,][] pArr) { for (int j = 0; j < 3; j++) { SNAPSHOT_WRITLINE_REPLACEMENT("{"); for (int k = 0; k < 6; k++) { SNAPSHOT_WRITLINE_REPLACEMENT("{"); for (int s = 0; s < 64; s++) SNAPSHOT_WRITLINE_REPLACEMENT(pArr[j, k][s] + ", "); SNAPSHOT_WRITLINE_REPLACEMENT("\n}"); } SNAPSHOT_WRITLINE_REPLACEMENT("}"); } } private void Tune(string pGameCGFF, double pLearningRate) { TLM_ChessGame tGame = CGFF.GetGame(pGameCGFF); LoadFenString(tGame.startFen); double tDGameResult = tGame.gameResult; foreach (int hMove in tGame.hashedMoves) { Tune(tDGameResult, pLearningRate); List<Move> moveOptionList = new List<Move>(); GetLegalMoves(ref moveOptionList); int tL = moveOptionList.Count; for (int i = 0; i < tL; i++) { Move tMove = moveOptionList[i]; if (tMove.moveHash == hMove) { PlainMakeMove(tMove); tL = -1; break; } } if (tL != -1) break; } } private void Tune(double pGameResult, double pLearningRate) { int tPC = ULONG_OPERATIONS.CountBits(allPieceBitboard); double oneThroughPieceCount = 1d /tPC; double egMult = earlyGameMultipliers[tPC], mgMult = middleGameMultipliers[tPC], lgMult = lateGameMultipliers[tPC]; double tTexelResult = TexelEvaluateF(); double tSigmoidedTexelResult = TexelSigmoid(tTexelResult); double tDif = tSigmoidedTexelResult - pGameResult; double tM = oneThroughPieceCount * TexelCostDerivative(tDif) * TexelSigmoidDerivative(tTexelResult) * pLearningRate; sumCostVals += lastCostVal = TexelCost(tDif); costCalculations++; for (int i = 0; i < 64; i++) { if (ULONG_OPERATIONS.IsBitZero(allPieceBitboard, i)) continue; int tPT = pieceTypeArray[i] - 1, tI = i; if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, i)) tI = blackSidedSquares[i]; texelTuningAdjustIterations[tPT, tI]++; } } private double TexelEvaluateF() { texelTuningRuntimeVals = GetInterpolatedProcessedValues(texelTuningVals); return TexelEvaluate(); } private int TexelEvaluate() { int tEvalEG = 0, tEvalLG = 0, tProgress = 0; ulong[] attkULs = new ulong[14]; for (int p = 0; p < 64; p++) { if (((int)(allPieceBitboard >> p) & 1) == 0) continue; int aPT = pieceTypeArray[p], tPT = aPT + 7 * ((int)(blackPieceBitboard >> p) & 1); tEvalEG += texelTuningRuntimePositionalValsV2EG[tPT][p] + texelPieceEvaluationsV2EG[tPT]; tEvalLG += texelTuningRuntimePositionalValsV2LG[tPT][p] + texelPieceEvaluationsV2LG[tPT]; tProgress += pieceTypeGameProgressImpact[tPT]; } if (tProgress > 24) tProgress = 24; return (int)(earlyGameMultipliers[tProgress] * tEvalEG + lateGameMultipliers[tProgress] * tEvalLG); } private const double TexelK = 0.2; private double TexelTuningSigmoid(double pVal) { return 2d /(1 + Math.Pow(10, -TexelK * pVal /400)); } private double TexelSigmoid(double pVal) { return 2d /(Math.Exp(-0.04d * pVal) + 1d); } private double TexelSigmoidDerivative(double pVal) { double d = Math.Exp(-0.04d * pVal); return 2d * d /(25d * (d + 1d) * (d + 1d)); } private double TexelCost(double pVal) { return pVal * pVal; } private double TexelCostDerivative(double pVal) { return 2 * pVal; } private char[] fenPieces = new char[7] { 'z', 'p', 'n', 'b', 'r', 'q', 'k' }; private string[] squareNames = new string[64] { "a1", "b1", "c1", "d1", "e1", "f1", "g1", "h1", "a2", "b2", "c2", "d2", "e2", "f2", "g2", "h2", "a3", "b3", "c3", "d3", "e3", "f3", "g3", "h3", "a4", "b4", "c4", "d4", "e4", "f4", "g4", "h4", "a5", "b5", "c5", "d5", "e5", "f5", "g5", "h5", "a6", "b6", "c6", "d6", "e6", "f6", "g6", "h6", "a7", "b7", "c7", "d7", "e7", "f7", "g7", "h7", "a8", "b8", "c8", "d8", "e8", "f8", "g8", "h8"}; public string CreateFenString() { string rFEN = ""; for (int i = 7; i >= 0; i--) { int t = 0; for (int j = 0; j < 8; j++) { int sq = i * 8 + j; if (pieceTypeArray[sq] != 0) { if (t != 0) rFEN += t; t = 0; } if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, sq)) { switch (pieceTypeArray[sq]) { case 0: t++; SNAPSHOT_WRITLINE_REPLACEMENT("???"); break; case 1: rFEN += 'P'; break; case 2: rFEN += 'N'; break; case 3: rFEN += 'B'; break; case 4: rFEN += 'R'; break; case 5: rFEN += 'Q'; break; case 6: rFEN += 'K'; break; } } else { switch (pieceTypeArray[sq]) { case 0: t++; break; case 1: rFEN += 'p'; break; case 2: rFEN += 'n'; break; case 3: rFEN += 'b'; break; case 4: rFEN += 'r'; break; case 5: rFEN += 'q'; break; case 6: rFEN += 'k'; break; } } } if (t != 0) rFEN += t; if (i != 0) rFEN += "/"; } rFEN += (isWhiteToMove ? " w": " b"); rFEN += (whiteCastleRightKingSide ? " K": " "); rFEN += (whiteCastleRightQueenSide ? "Q": ""); rFEN += (blackCastleRightKingSide ? "k": ""); rFEN += (blackCastleRightQueenSide ? "q": ""); if (!whiteCastleRightKingSide && !whiteCastleRightQueenSide && !blackCastleRightKingSide && !blackCastleRightQueenSide) rFEN += "-"; if (enPassantSquare < 64) rFEN += " "+ squareNames[enPassantSquare] + " "; else rFEN += " - "; return rFEN + fiftyMoveRuleCounter + " "+ ((happenedHalfMoves - happenedHalfMoves % 2) /2); } public void LoadFenString(string fenStr) { debugFEN = fenStr; lastMadeMove = NULL_MOVE; zobristKey = 0ul; whitePieceBitboard = blackPieceBitboard = allPieceBitboard = 0ul; for (int i = 0; i < 64; i++) pieceTypeArray[i] = 0; string[] spaceSpl = fenStr.Split(' '); string[] rowSpl = spaceSpl[0].Split('/'); string epstr = spaceSpl[3]; if (epstr == "-") enPassantSquare = 65; else enPassantSquare = (epstr[0] - 'a') + 8 * (epstr[1] - '1'); isWhiteToMove = true; if (spaceSpl[1] == "b") isWhiteToMove = false; if (!isWhiteToMove) zobristKey ^= blackTurnHash; string crstr = spaceSpl[2]; whiteCastleRightKingSide = whiteCastleRightQueenSide = blackCastleRightKingSide = blackCastleRightQueenSide = false; int crStrL = crstr.Length; for (int i = 0; i < crStrL; i++) { switch (crstr[i]) { case 'K': whiteCastleRightKingSide = true; break; case 'Q': whiteCastleRightQueenSide = true; break; case 'k': blackCastleRightKingSide = true; break; case 'q': blackCastleRightQueenSide = true; break; } } fiftyMoveRuleCounter = Convert.ToInt32(spaceSpl[4]); happenedHalfMoves = Convert.ToInt32(spaceSpl[5]) * 2; if (!isWhiteToMove) happenedHalfMoves++; int tSq = 0; for (int i = rowSpl.Length; i-- > 0;) { string tStr = rowSpl[i]; int tStrLen = tStr.Length; for (int c = 0; c < tStrLen; c++) { char tChar = tStr[c]; if (Char.IsDigit(tChar)) tSq += tChar - '0'; else { bool tCol = Char.IsLower(tChar); if (tCol) blackPieceBitboard = ULONG_OPERATIONS.SetBitToOne(blackPieceBitboard, tSq); else whitePieceBitboard = ULONG_OPERATIONS.SetBitToOne(whitePieceBitboard, tSq); if (tChar == 'k') blackKingSquare = tSq; else if (tChar == 'K') whiteKingSquare = tSq; pieceTypeArray[tSq] = Array.IndexOf(fenPieces, Char.ToLower(tChar)); if (tCol) zobristKey ^= pieceHashesBlack[tSq, pieceTypeArray[tSq]]; else zobristKey ^= pieceHashesWhite[tSq, pieceTypeArray[tSq]]; tSq++; } } } if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; zobristKey ^= enPassantSquareHashes[enPassantSquare]; allPieceBitboard = whitePieceBitboard | blackPieceBitboard; if (zobristKey == 16260251586586513106) moveHashList.Clear(); else { moveHashList.Clear(); moveHashList.Add(1); moveHashList.Add(2); moveHashList.Add(3); } } private ulong[,] pieceHashesWhite = new ulong[64, 7], pieceHashesBlack = new ulong[64, 7]; private ulong blackTurnHash, whiteKingSideRochadeRightHash, whiteQueenSideRochadeRightHash, blackKingSideRochadeRightHash, blackQueenSideRochadeRightHash; private ulong[] enPassantSquareHashes = new ulong[66]; private Dictionary<ulong, int> singleCheckCaseBackup = new Dictionary<ulong, int>(); private void InitZobrist() { Random rng = new Random(31415926); for (int sq = 0; sq < 64; sq++) { enPassantSquareHashes[sq] = ULONG_OPERATIONS.GetRandomULONG(rng); for (int it = 1; it < 7; it++) { pieceHashesWhite[sq, it] = ULONG_OPERATIONS.GetRandomULONG(rng); pieceHashesBlack[sq, it] = ULONG_OPERATIONS.GetRandomULONG(rng); } } blackTurnHash = ULONG_OPERATIONS.GetRandomULONG(rng); whiteKingSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); whiteQueenSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); blackKingSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); blackQueenSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); } public void SetKnightMasks(ulong[] uls) { knightSquareBitboards = uls; } public void SetKingMasks(ulong[] uls) { kingSquareBitboards = uls; } private Move[,] whiteEnPassantMoves = new Move[64, 64]; private Move[,] blackEnPassantMoves = new Move[64, 64]; private bool[] epValidationArray = new bool[64] { false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true , true , true , true , true , true , true , true, true , true , true , true , true , true , true , true, true , true , true , true , true , true , true , true, true , true , true , true , true , true , true , true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false }; private ulong[] kingSafetyRing1 = new ulong[64], kingSafetyRing2 = new ulong[64]; private ulong[] kingSafetySpecialRingW = new ulong[64], kingSafetySpecialRingB = new ulong[64]; private ulong[] rowPrecalcs = new ulong[8], columnPrecalcs = new ulong[8]; const ulong columnUL = 0x101010101010101, rowUL = 0b11111111; private void PrecalculateKingSafetyBitboards() { for (int i = 0; i < 8; i++) { rowPrecalcs[i] = rowUL << (8 * i); columnPrecalcs[i] = columnUL << i; } for (int i = 0; i < 64; i++) { int tMod = i % 8; int tRow = (i - tMod) /8; ulong tULC = columnPrecalcs[tMod], tULR = rowPrecalcs[tRow]; ulong tULC2 = columnPrecalcs[tMod], tULR2 = rowPrecalcs[tRow]; if (tMod < 7) tULC |= columnPrecalcs[tMod + 1]; if (tMod > 0) tULC |= columnPrecalcs[tMod - 1]; if (tRow < 7) tULR |= rowPrecalcs[tRow + 1]; if (tRow > 0) tULR |= rowPrecalcs[tRow - 1]; if (tMod < 6) tULC2 |= columnPrecalcs[tMod + 2]; if (tMod > 1) tULC2 |= columnPrecalcs[tMod - 2]; if (tRow < 6) tULR2 |= rowPrecalcs[tRow + 2]; if (tRow > 1) tULR2 |= rowPrecalcs[tRow - 2]; tULR2 |= tULR; tULC2 |= tULC; kingSafetyRing1[i] = ULONG_OPERATIONS.SetBitToZero(tULR & tULC, i); kingSafetyRing2[i] = ULONG_OPERATIONS.SetBitsToZero(tULR2 & tULC2, i, i + 1, i - 1, i + 7, i + 8, i + 9, i - 7, i - 8, i - 9); } for (int i = 0; i < 64; i++) { if (i < 56) kingSafetySpecialRingW[i] = ULONG_OPERATIONS.SetBitToZero(kingSafetyRing1[i] | kingSafetyRing1[i + 8], i); else kingSafetySpecialRingW[i] = kingSafetyRing1[i]; if (i > 7) kingSafetySpecialRingB[i] = ULONG_OPERATIONS.SetBitToZero(kingSafetyRing1[i] | kingSafetyRing1[i - 8], i); else kingSafetySpecialRingB[i] = kingSafetyRing1[i]; } } private void PrecalculateEnPassantMoves() { for (int i = 0; i < 64; i++) { if (!epValidationArray[i]) continue; for (int j = 0; j < 64; j++) { if (i == j) continue; if (Math.Abs(i - j) > 9) continue; if (!epValidationArray[j]) continue; whiteEnPassantMoves[i, j] = new Move(false, i, j, j - 8); blackEnPassantMoves[i, j] = new Move(false, i, j, j + 8); } } } private void PawnAttackBitboards() { for (int sq = 0; sq < 64; sq++) { ulong u = 0ul; if (sq % 8 != 0) u = ULONG_OPERATIONS.SetBitToOne(u, sq + 7); if (sq % 8 != 7) u = ULONG_OPERATIONS.SetBitToOne(u, sq + 9); whitePawnAttackSquareBitboards[sq] = u; u = 0ul; if (sq % 8 != 0 && sq - 9 > -1) u = ULONG_OPERATIONS.SetBitToOne(u, sq - 9); if (sq % 8 != 7 && sq - 7 > -1) u = ULONG_OPERATIONS.SetBitToOne(u, sq - 7); blackPawnAttackSquareBitboards[sq] = u; } } private int[] squareConnectivesPrecalculationArray = new int[4096]; public int[] squareConnectivesCrossDirsPrecalculationArray { get; set; } = new int[4096]; private ulong[] squareConnectivesPrecalculationRayArray = new ulong[4096]; private ulong[] squareConnectivesPrecalculationLineArray = new ulong[4096]; private List<Dictionary<ulong, int>> rayCollidingSquareCalculations = new List<Dictionary<ulong, int>>(); private readonly int[] maxIntWithSpecifiedBitcount = new int[8] { 0, 0b1, 0b11, 0b111, 0b1111, 0b11111, 0b111111, 0b1111111 }; private List<ulong> differentRays = new List<ulong>(); private void SquareConnectivesPrecalculations() { for (int square = 0; square < 64; square++) { rayCollidingSquareCalculations.Add(new Dictionary<ulong, int>()); rayCollidingSquareCalculations[square].Add(0ul, square); for (int square2 = 0; square2 < 64; square2++) { if (square == square2) continue; int t = 0, t2 = 0, difSign = Math.Sign(square2 - square), itSq = square, g = 0; ulong tRay = 0ul, tExclRay = 0ul; List<int> tRayInts = new List<int>(); if (difSign == -1) g = 7; if (square % 8 == square2 % 8) { t2 = t = 1; while ((itSq += difSign * 8) < 64 && itSq > -1) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } } else if ((square - square % 8) == (square2 - square2 % 8)) { t = 1; t2 = -1; while ((itSq += difSign) % 8 != g && itSq > -1 && itSq < 64) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } } else { int dif = Math.Abs(square2 - square); if (dif % 7 == 0) { t = 2; t2 = 2; g = (difSign == 1) ? 7 : 0; while ((itSq += difSign * 7) % 8 != g && itSq < 64 && itSq > -1) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } if (ULONG_OPERATIONS.IsBitZero(tRay, square2)) { t2 = t = 0; tRay = 0ul; } } else if (dif % 9 == 0) { t = 2; t2 = -2; if (square == 0 && square2 == 63 || square == 63 && square2 == 0) SNAPSHOT_WRITLINE_REPLACEMENT("!"); while ((itSq += difSign * 9) % 8 != g && itSq < 64 && itSq > -1) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } if (ULONG_OPERATIONS.IsBitZero(tRay, square2)) { t2 = t = 0; tRay = 0ul; } } } if (square == 0 && square2 == 63) { t2 = t = 2; tRayInts.Clear(); tExclRay = tRay = ULONG_OPERATIONS.SetBitsToOne(0ul, 9, 18, 27, 36, 45, 54, 63); tRayInts = new List<int>() { 9, 18, 27, 36, 45, 54, 63 }; } else if (square2 == 0 && square == 63) { t = 2; tRayInts.Clear(); t2 = -2; tExclRay = tRay = ULONG_OPERATIONS.SetBitsToOne(0ul, 0, 9, 18, 27, 36, 45, 54); tRayInts = new List<int>() { 54, 45, 36, 27, 18, 9, 0 }; } if (tRay != 0ul && !differentRays.Contains(tRay)) { differentRays.Add(tRay); int ccount, combI = maxIntWithSpecifiedBitcount[ccount = ULONG_OPERATIONS.CountBits(tRay)]; do { ulong curAllPieceBitboard = 0ul; int solution = square; for (int j = 0; j < ccount; j++) { if (((combI >> j) & 1) == 1) { curAllPieceBitboard = ULONG_OPERATIONS.SetBitToOne(curAllPieceBitboard, tRayInts[j]); if (solution == square) solution = tRayInts[j]; } } rayCollidingSquareCalculations[square].Add(curAllPieceBitboard, solution); } while (--combI != 0); } squareConnectivesPrecalculationArray[square << 6 | square2] = t; squareConnectivesPrecalculationRayArray[square << 6 | square2] = tRay; squareConnectivesCrossDirsPrecalculationArray[square << 6 | square2] = t2; if (t != 0) squareConnectivesPrecalculationLineArray[square << 6 | square2] = (square == 0 && square2 == 63 || square2 == 0 && square == 63) ? tExclRay : ULONG_OPERATIONS.SetBitToOne(tExclRay, square2); if (squareConnectivesPrecalculationLineArray[square << 6 | square2] == 0ul && ULONG_OPERATIONS.IsBitOne(knightSquareBitboards[square], square2)) squareConnectivesPrecalculationLineArray[square << 6 | square2] = 1ul << square2; } differentRays.Clear(); } } public void SNAPSHOT_WRITLINE_REPLACEMENT() { } public void SNAPSHOT_WRITLINE_REPLACEMENT(object pStr) { } private string GetDoublePrecentageString(double pVal) { return ((int)(pVal * 1_000_000) /10_000d) + "%"; } private string ReplaceAllULONGIsBitOne(string pCode) { const string METHOD_NAME = "ULONG_OPERATIONS.IsBitOne"; int METHOD_NAME_LEN = METHOD_NAME.Length, iterations = 0; int pIndex = pCode.IndexOf(METHOD_NAME); while (pIndex != -1 && ++iterations < 10_000) { List<int> paramIndexes = new List<int>(); int openedBracketCount = 1, closedBracketCount = 0, a = METHOD_NAME_LEN + pIndex; string tpCode = pCode.Substring(0, pIndex); paramIndexes.Add(a + 1); while (++a < pCode.Length) { switch (pCode[a]) { case '(': openedBracketCount++; break; case ')': if (++closedBracketCount == openedBracketCount) { pIndex = a; a = int.MaxValue - 5; } break; case ',': if (openedBracketCount - closedBracketCount == 1) paramIndexes.Add(a + 1); break; } } if (openedBracketCount == closedBracketCount && paramIndexes.Count == 2) { tpCode += "((int)("+ pCode.Substring(paramIndexes[0], paramIndexes[1] - paramIndexes[0] - 1) + (pCode[paramIndexes[1]] == ' ' ? " >> (": " >> (") + pCode.Substring(paramIndexes[1], pIndex - paramIndexes[1]) + ")) & 1) == 1"+ pCode.Substring(pIndex + 1, pCode.Length - pIndex - 1); } pIndex = (pCode = tpCode).IndexOf(METHOD_NAME); } SNAPSHOT_WRITLINE_REPLACEMENT(iterations + " ITERATIONS"); return pCode; } private string ReplaceAllULONGIsBitZero(string pCode) { const string METHOD_NAME = "ULONG_OPERATIONS.IsBitZero"; int METHOD_NAME_LEN = METHOD_NAME.Length, iterations = 0; int pIndex = pCode.IndexOf(METHOD_NAME); while (pIndex != -1 && ++iterations < 10_000) { List<int> paramIndexes = new List<int>(); int openedBracketCount = 1, closedBracketCount = 0, a = METHOD_NAME_LEN + pIndex; string tpCode = pCode.Substring(0, pIndex); paramIndexes.Add(a + 1); while (++a < pCode.Length) { switch (pCode[a]) { case '(': openedBracketCount++; break; case ')': if (++closedBracketCount == openedBracketCount) { pIndex = a; a = int.MaxValue - 5; } break; case ',': if (openedBracketCount - closedBracketCount == 1) paramIndexes.Add(a + 1); break; } } if (openedBracketCount == closedBracketCount && paramIndexes.Count == 2) { tpCode += "((int)("+ pCode.Substring(paramIndexes[0], paramIndexes[1] - paramIndexes[0] - 1) + (pCode[paramIndexes[1]] == ' ' ? " >>": " >> ") + pCode.Substring(paramIndexes[1], pIndex - paramIndexes[1]) + ") & 1) == 0"+ pCode.Substring(pIndex + 1, pCode.Length - pIndex - 1); } pIndex = (pCode = tpCode).IndexOf(METHOD_NAME); } SNAPSHOT_WRITLINE_REPLACEMENT(iterations + " ITERATIONS"); return pCode; } private string GetThreeDigitSeperatedInteger(int pInt) { string s = pInt.ToString(), r = s[0].ToString(); int t = s.Length % 3; for (int i = 1; i < s.Length; i++) { if (i % 3 == t) r += "."; r += s[i]; } s = ""; for (int i = 0; i < r.Length; i++) s += r[i]; return s; } public double GetAverageDepth() { return (double)depths /(double)searches; } }
public class SNAPSHOT_V01_00_017 : IBoardManager  { public int TEXEL_PARAMS { get; } = 778; private const int BESTMOVE_SORT_VAL = -2_000_000_000; private const int CAPTURE_SORT_VAL = -1_000_000_000; private const int KILLERMOVE_SORT_VAL = -1000; private readonly int[,] MVVLVA_TABLE = new int[7, 7] { { 0, 0, 0, 0, 0, 0, 0 }, { 0, 1500, 1400, 1300, 1200, 1100, 1000 }, { 0, 3500, 3400, 3300, 3200, 3100, 3000 }, { 0, 4500, 4400, 4300, 4200, 4100, 4000 }, { 0, 5500, 5400, 5300, 5200, 5100, 5000 }, { 0, 9500, 9400, 9300, 9200, 9100, 9000 }, { 0, 0, 0, 0, 0, 0, 0 }}; private int BOARD_MANAGER_ID = -1; private bool debugSearchDepthResults = false; private bool debugSortResults = false; private RookMovement rookMovement; private BishopMovement bishopMovement; private QueenMovement queenMovement; private KnightMovement knightMovement; private KingMovement kingMovement; private WhitePawnMovement whitePawnMovement; private BlackPawnMovement blackPawnMovement; private Rays rays; public List<Move> moveOptionList { get; set; } private int[] pieceTypeArray = new int[64]; public ulong whitePieceBitboard, blackPieceBitboard, allPieceBitboard; private ulong zobristKey; private int whiteKingSquare, blackKingSquare, enPassantSquare = 65, happenedHalfMoves = 0, fiftyMoveRuleCounter = 0; private bool whiteCastleRightKingSide, whiteCastleRightQueenSide, blackCastleRightKingSide, blackCastleRightQueenSide; private bool isWhiteToMove; private const ulong WHITE_KING_ROCHADE = 96, WHITE_QUEEN_ROCHADE = 14, BLACK_KING_ROCHADE = 6917529027641081856, BLACK_QUEEN_ROCHADE = 1008806316530991104, WHITE_QUEEN_ATTK_ROCHADE = 12, BLACK_QUEEN_ATTK_ROCHADE = 864691128455135232; private readonly Move mWHITE_KING_ROCHADE = new Move(4, 6, 7, 5), mWHITE_QUEEN_ROCHADE = new Move(4, 2, 0, 3), mBLACK_KING_ROCHADE = new Move(60, 62, 63, 61), mBLACK_QUEEN_ROCHADE = new Move(60, 58, 56, 59); private ulong[] knightSquareBitboards = new ulong[64]; private ulong[] whitePawnAttackSquareBitboards = new ulong[64]; private ulong[] blackPawnAttackSquareBitboards = new ulong[64]; private ulong[] kingSquareBitboards = new ulong[64]; private bool[,] pieceTypeAbilities = new bool[7, 3] { { false, false, false }, { false, false, false }, { false, false, false }, { false, false, true }, { false, true, false }, { false, true, true }, { false, false, false } }; private List<int> moveHashList = new List<int>(); private ulong[] curSearchZobristKeyLine = Array.Empty<ulong>(); private Move[] debugMoveList = new Move[128]; private string debugFEN = ""; private Stopwatch globalTimer = Stopwatch.StartNew(); private Move lastMadeMove; private int depths, searches; private Random globalRandom = new Random(); public SNAPSHOT_V01_00_017(string fen) { Setup(fen); } public void Setup(string pFen) { Stopwatch setupStopwatch = Stopwatch.StartNew(); BOARD_MANAGER_ID = BOT_MAIN.curBoardManagerID; for (int i = 0; i < 33; i++) for (int j = 0; j < 14; j++) piecePositionEvals[i, j] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; for (int i = 0; i < 33; i++) for (int j = 0; j < 14; j++) texelTuningRuntimeVals[i, j] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; for (int i = 0; i < 3; i++) for (int j = 0; j < 6; j++) texelTuningVals[i, j] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; for (int i = 0; i < 14; i++) { texelTuningRuntimePositionalValsV2EG[i] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; texelTuningRuntimePositionalValsV2LG[i] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; } PrecalculateKingSafetyBitboards(); PrecalculateMultipliers(); GetLowNoisePositionalEvaluation(globalRandom); MinimaxRoot(1L); SetupConsoleWrite("[PRECALCS] Zobrist Hashing"); InitZobrist(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Knight Movement"); knightMovement = new KnightMovement(this); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Square Connectives"); SquareConnectivesPrecalculations(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Pawn Attack Bitboards"); PawnAttackBitboards(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Rays"); rays = new Rays(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); queenMovement = new QueenMovement(this); SetupConsoleWrite("[PRECALCS] Rook Movement"); rookMovement = new RookMovement(this, queenMovement); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Bishop Movement"); bishopMovement = new BishopMovement(this, queenMovement); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] King Movement"); kingMovement = new KingMovement(this); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Pawn Movement"); whitePawnMovement = new WhitePawnMovement(this); blackPawnMovement = new BlackPawnMovement(this); PrecalculateEnPassantMoves(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWriteLine("[DONE]\n\n"); LoadFenString(pFen); LoadBestTexelParamsIn(); setupStopwatch.Stop(); } private void SetupConsoleWriteLine(string pStr) { if (BOT_MAIN.isFirstBoardManagerInitialized) return; SNAPSHOT_WRITLINE_REPLACEMENT(pStr); } private void SetupConsoleWrite(string pStr) { if (BOT_MAIN.isFirstBoardManagerInitialized) return; SNAPSHOT_WRITLINE_REPLACEMENT(pStr); } public void GetLowNoisePositionalEvaluation(System.Random rng) { int[,][] digitArray = new int[3, 6][]; for (int i = 0; i < 3; i++) for (int j = 0; j < 6; j++) digitArray[i, j] = GetRand64IntArray(rng, -5, 6); lowNoisePositionEvals1 = GetInterpolatedProcessedValues(digitArray); int[,][] digitArray2 = new int[3, 6][]; for (int i = 0; i < 3; i++) for (int j = 0; j < 6; j++) digitArray2[i, j] = GetRand64IntArray(rng, -5, 6); lowNoisePositionEvals2 = GetInterpolatedProcessedValues(digitArray2); } private int[] GetRand64IntArray(System.Random rng, int pMin, int pMax) { return new int[64] { rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax) }; } private string GetAIArrayValuesStringRepresentation(int[,][] pArr) { string r = "int[,][] ReLe_AI_RESULT_VALS = new int[3, 6][] {"; for (int i = 0; i < 3; i++) { r += "{"; for (int j = 0; j < 5; j++) { r += GetIntArray64LStringRepresentation(pArr[i, j]) + ","; } r += GetIntArray64LStringRepresentation(pArr[i, 5]) + "},"; } return r.Substring(0, r.Length - 1) + "};"; } private string GetIntArray64LStringRepresentation(int[] p64LArr) { if (p64LArr == null) return ""; string r = "new int[64]{"; for (int i = 0; i < 63; i++) { r += p64LArr[i] + ","; } return r + p64LArr[63] + "}"; } public void TempStuff() { } private string[] gameResultStrings = new string[5] { "Black Has Won!", "Draw!", "White Has Won!", "Non Existant Result!", "Game is Ongoing!"}; private int[,][] lowNoisePositionEvals1, lowNoisePositionEvals2; public void ThreadSelfPlay(object obj) { PlayGameAgainstItself(obj); } public void PlayGameAgainstItself(object obj, string pStartFEN = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1", long tickLimitForEngine = ENGINE_VALS.SELF_PLAY_THINK_TIME) { int ttGState; while (BOT_MAIN.goalGameCount > BOT_MAIN.gamesPlayed) { try { string tGameStr; GetLowNoisePositionalEvaluation(globalRandom); LoadFenString(tGameStr = pStartFEN); tGameStr += ";"; int tGState = 3, tmc = 0; bool lowNoiceDecider = globalRandom.NextDouble() < 0.5d; while (tGState == 3) { piecePositionEvals = lowNoiceDecider ? lowNoisePositionEvals1 : lowNoisePositionEvals2; MinimaxRoot(tickLimitForEngine); Move tM = transpositionTable[zobristKey].bestMove; PlainMakeMove(tM); tGameStr += NuCRe.GetNuCRe(tM.moveHash) + ","; BOT_MAIN.movesPlayed++; tGState = GameState(isWhiteToMove); lowNoiceDecider = !lowNoiceDecider; tmc++; } ttGState = tGState; tGameStr += ttGState + 1; SNAPSHOT_WRITLINE_REPLACEMENT(tGameStr); BOT_MAIN.gamesPlayedResultArray[ttGState + 1]++; BOT_MAIN.gamesPlayed++; BOT_MAIN.selfPlayGameStrings.Add(tGameStr); } catch (Exception tE) { SNAPSHOT_WRITLINE_REPLACEMENT(tE.ToString()); } } } public void PlayGameOnConsoleAgainstHuman(string pStartFEN = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1", bool pHumanPlaysWhite = true, long tickLimitForEngine = 10_000_000L) { debugSearchDepthResults = true; LoadFenString(pStartFEN); if (!(pHumanPlaysWhite ^ isWhiteToMove)) { var pVS = Console.ReadLine(); if (pVS == null) return; Move tm = GetMoveOfString(pVS.ToString()); SNAPSHOT_WRITLINE_REPLACEMENT(tm); PlainMakeMove(tm); } int tGState = 3; while (tGState == 3) { MinimaxRoot(tickLimitForEngine); PlayThroughZobristTree(); Move tM = transpositionTable[zobristKey].bestMove; SNAPSHOT_WRITLINE_REPLACEMENT(tM); SNAPSHOT_WRITLINE_REPLACEMENT(CreateFenString()); PlainMakeMove(tM); tGState = GameState(isWhiteToMove); if (tGState != 3 || tM == NULL_MOVE) break; var pV = ""; tM = NULL_MOVE; do { pV = Console.ReadLine(); if (pV == null) continue; tM = GetMoveOfString(pV.ToString()); SNAPSHOT_WRITLINE_REPLACEMENT(tM); } while (tM == NULL_MOVE); PlainMakeMove(tM); tGState = GameState(isWhiteToMove); } } private void PlayThroughZobristTree() { SetJumpState(); SNAPSHOT_WRITLINE_REPLACEMENT("\n- - - - - - - - - - - - -"); int tC = 1; Dictionary<ulong, bool> usedULs = new Dictionary<ulong, bool>(); while (transpositionTable.TryGetValue(zobristKey, out TranspositionEntry tM)) { if (usedULs.ContainsKey(zobristKey)) { SNAPSHOT_WRITLINE_REPLACEMENT(tC + ": AT LEAST ONE REPETION; REST NOT VISIBLE"); break; } SNAPSHOT_WRITLINE_REPLACEMENT(tC + ": "+ tM.bestMove + " > "); usedULs.Add(zobristKey, true); PlainMakeMove(tM.bestMove); tC++; } SNAPSHOT_WRITLINE_REPLACEMENT("- - - - - - - - - - - - -\n"); LoadJumpState(); } public Move? ReturnNextMove(Move? lastMove, long pThinkingTime) { if (lastMove != null) PlainMakeMove(lastMove); if (GameState(isWhiteToMove) != 3) return null; MinimaxRoot(pThinkingTime); if (!transpositionTable.ContainsKey(zobristKey)) return null; Move tm = transpositionTable[zobristKey].bestMove; PlainMakeMove(tm); return tm; } private int[] jmpSt_pieceTypeArray; private ulong jmpSt_whitePieceBitboard, jmpSt_blackPieceBitboard; private ulong jmpSt_zobristKey; private int jmpSt_whiteKingSquare, jmpSt_blackKingSquare, jmpSt_enPassantSquare, jmpSt_happenedHalfMoves, jmpSt_fiftyMoveRuleCounter; private bool jmpSt_whiteCastleRightKingSide, jmpSt_whiteCastleRightQueenSide, jmpSt_blackCastleRightKingSide, jmpSt_blackCastleRightQueenSide; private bool jmpSt_isWhiteToMove; private ulong[] jmpSt_curSearchZobristKeyLine; private int[] jmpSt_moveHashList; public void LoadJumpState() { pieceTypeArray = (int[])jmpSt_pieceTypeArray.Clone(); whitePieceBitboard = jmpSt_whitePieceBitboard; blackPieceBitboard = jmpSt_blackPieceBitboard; zobristKey = jmpSt_zobristKey; whiteKingSquare = jmpSt_whiteKingSquare; blackKingSquare = jmpSt_blackKingSquare; enPassantSquare = jmpSt_enPassantSquare; happenedHalfMoves = jmpSt_happenedHalfMoves; fiftyMoveRuleCounter = jmpSt_fiftyMoveRuleCounter; whiteCastleRightKingSide = jmpSt_whiteCastleRightKingSide; whiteCastleRightQueenSide = jmpSt_whiteCastleRightQueenSide; blackCastleRightKingSide = jmpSt_blackCastleRightKingSide; blackCastleRightQueenSide = jmpSt_blackCastleRightQueenSide; isWhiteToMove = jmpSt_isWhiteToMove; curSearchZobristKeyLine = (ulong[])jmpSt_curSearchZobristKeyLine.Clone(); allPieceBitboard = blackPieceBitboard | whitePieceBitboard; moveHashList = jmpSt_moveHashList.ToList(); } public void SetJumpState() { jmpSt_pieceTypeArray = (int[])pieceTypeArray.Clone(); jmpSt_whitePieceBitboard = whitePieceBitboard; jmpSt_blackPieceBitboard = blackPieceBitboard; jmpSt_zobristKey = zobristKey; jmpSt_whiteKingSquare = whiteKingSquare; jmpSt_blackKingSquare = blackKingSquare; jmpSt_enPassantSquare = enPassantSquare; jmpSt_happenedHalfMoves = happenedHalfMoves; jmpSt_fiftyMoveRuleCounter = fiftyMoveRuleCounter; jmpSt_whiteCastleRightKingSide = whiteCastleRightKingSide; jmpSt_whiteCastleRightQueenSide = whiteCastleRightQueenSide; jmpSt_blackCastleRightKingSide = blackCastleRightKingSide; jmpSt_blackCastleRightQueenSide = blackCastleRightQueenSide; jmpSt_isWhiteToMove = isWhiteToMove; jmpSt_curSearchZobristKeyLine = (ulong[])curSearchZobristKeyLine.Clone(); jmpSt_moveHashList = moveHashList.ToArray(); } private int PreMinimaxCheckCheckWhite() { ulong bitShiftedKingPos = 1ul << whiteKingSquare; int curR = -1; for (int p = 0; p < 64; p++) { if (ULONG_OPERATIONS.IsBitZero(blackPieceBitboard, p)) continue; int tPT; switch (tPT = pieceTypeArray[p]) { case 1: if ((bitShiftedKingPos & blackPawnAttackSquareBitboards[p]) != 0ul) return p; break; case 2: if ((bitShiftedKingPos & knightSquareBitboards[p]) != 0ul) return p; break; case 6: break; default: if ((squareConnectivesPrecalculationLineArray[whiteKingSquare << 6 | p] & allPieceBitboard) == (1ul << p) && pieceTypeAbilities[tPT, squareConnectivesPrecalculationArray[whiteKingSquare << 6 | p]]) { if (curR != -1) return -779; curR = p; } break; } } return curR; } private int PreMinimaxCheckCheckBlack() { ulong bitShiftedKingPos = 1ul << blackKingSquare; int curR = -1; for (int p = 0; p < 64; p++) { if (ULONG_OPERATIONS.IsBitZero(whitePieceBitboard, p)) continue; int tPT; switch (tPT = pieceTypeArray[p]) { case 1: if ((bitShiftedKingPos & whitePawnAttackSquareBitboards[p]) != 0ul) return p; break; case 2: if ((bitShiftedKingPos & knightSquareBitboards[p]) != 0ul) return p; break; case 6: break; default: if ((squareConnectivesPrecalculationLineArray[blackKingSquare << 6 | p] & allPieceBitboard) == (1ul << p) && pieceTypeAbilities[tPT, squareConnectivesPrecalculationArray[blackKingSquare << 6 | p]]) { if (curR != -1) return -779; curR = p; } break; } } return curR; } private int LecacyLeafCheckingPieceCheckWhite(int pStartPos, int pEndPos, int pPieceType) { int tI, tPossibleAttackPiece; if (pPieceType == 1) { if (ULONG_OPERATIONS.IsBitOne(blackPawnAttackSquareBitboards[pEndPos], whiteKingSquare)) return pEndPos; } else if (pPieceType == 2) { if (ULONG_OPERATIONS.IsBitOne(knightSquareBitboards[pEndPos], whiteKingSquare)) return pEndPos; } else if (pPieceType != 6) { tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | pEndPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; } tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | pStartPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; return -1; } private int LecacyLeafCheckingPieceCheckBlack(int pStartPos, int pEndPos, int pPieceType) { int tI, tPossibleAttackPiece; if (pPieceType == 1) { if (ULONG_OPERATIONS.IsBitOne(whitePawnAttackSquareBitboards[pEndPos], blackKingSquare)) return pEndPos; } else if (pPieceType == 2) { if (ULONG_OPERATIONS.IsBitOne(knightSquareBitboards[pEndPos], blackKingSquare)) return pEndPos; } else if (pPieceType != 6) { tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | pEndPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; } tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | pStartPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; return -1; } public void GetLegalMoves(ref List<Move> pMoveList) { int attk; if (isWhiteToMove) { attk = PreMinimaxCheckCheckWhite(); if (attk == -779) GetLegalWhiteMovesSpecialDoubleCheckCase(ref pMoveList); else GetLegalWhiteMoves(attk, ref pMoveList); } else { attk = PreMinimaxCheckCheckBlack(); if (attk == -779) GetLegalBlackMovesSpecialDoubleCheckCase(ref pMoveList); else GetLegalBlackMoves(attk, ref pMoveList); } } private void GetLegalWhiteMoves(int pCheckingPieceSquare, ref List<Move> pMoveList) { if (pCheckingPieceSquare == -779) { GetLegalWhiteMovesSpecialDoubleCheckCase(ref pMoveList); return; } moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= blackPawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, whiteKingSquare); if (curCheckCount == 0) { if (whiteCastleRightKingSide && ((allPieceBitboard | oppAttkBitboard) & WHITE_KING_ROCHADE) == 0ul) pMoveList.Add(mWHITE_KING_ROCHADE); if (whiteCastleRightQueenSide && (allPieceBitboard & WHITE_QUEEN_ROCHADE | oppAttkBitboard & WHITE_QUEEN_ATTK_ROCHADE) == 0ul) pMoveList.Add(mWHITE_QUEEN_ROCHADE); if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, whitePieceBitboard, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[whiteKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare + 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, whitePieceBitboard, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveList(whiteKingSquare, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalWhiteCaptures(int pCheckingPieceSquare, ref List<Move> pMoveList) { if (pCheckingPieceSquare == -779) { GetLegalWhiteCapturesSpecialDoubleCheckCase(ref pMoveList); return; } moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= blackPawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, whiteKingSquare); if (curCheckCount == 0) { if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & blackPieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[whiteKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare + 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & blackPieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveListOnlyCaptures(whiteKingSquare, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalWhiteMovesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= blackPawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveList(whiteKingSquare, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalWhiteCapturesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= blackPawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveListOnlyCaptures(whiteKingSquare, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalBlackMoves(int pCheckingPieceSquare, ref List<Move> pMoveList) { if (pCheckingPieceSquare == -779) { GetLegalBlackMovesSpecialDoubleCheckCase(ref pMoveList); return; } moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= whitePawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, blackKingSquare); if (curCheckCount == 0) { if (blackCastleRightKingSide && ((allPieceBitboard | oppAttkBitboard) & BLACK_KING_ROCHADE) == 0ul) pMoveList.Add(mBLACK_KING_ROCHADE); if (blackCastleRightQueenSide && (allPieceBitboard & BLACK_QUEEN_ROCHADE | oppAttkBitboard & BLACK_QUEEN_ATTK_ROCHADE) == 0ul) pMoveList.Add(mBLACK_QUEEN_ROCHADE); if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveList(p, blackKingSquare, blackPieceBitboard, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[blackKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare - 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveList(p, blackKingSquare, blackPieceBitboard, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveList(blackKingSquare, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); } private void GetLegalBlackCaptures(int pCheckingPieceSquare, ref List<Move> pMoveList) { if (pCheckingPieceSquare == -779) { GetLegalBlackCapturesSpecialDoubleCheckCase(ref pMoveList); return; } moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= whitePawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, blackKingSquare); if (curCheckCount == 0) { if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & whitePieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[blackKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare - 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & whitePieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveListOnlyCaptures(blackKingSquare, ~oppAttkBitboard & whitePieceBitboard); } private void GetLegalBlackMovesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= whitePawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveList(blackKingSquare, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); } private void GetLegalBlackCapturesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= whitePawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveListOnlyCaptures(blackKingSquare, ~oppAttkBitboard & whitePieceBitboard); } public Move GetMoveOfString(string pMove) { int tSP, tEP; string[] tSpl = pMove.Split(','); if (Char.IsNumber(pMove[0])) { tSP = Convert.ToInt32(tSpl[0]); tEP = Convert.ToInt32(tSpl[1]); } else { tSP = SQUARES.NumberNotation(tSpl[0]); tEP = SQUARES.NumberNotation(tSpl[1]); } int tPT = pieceTypeArray[tSP]; bool tIC = ULONG_OPERATIONS.IsBitOne(allPieceBitboard, tEP), tIEP = enPassantSquare == tEP && tPT == 1; if (tSpl.Length == 3) return new Move(tSP, tEP, tPT, Convert.ToInt32(tSpl[2]), tIC); if (tIEP) return new Move(true, tSP, tEP, isWhiteToMove ? tEP - 8 : tEP + 8); if (tPT == 1 && Math.Abs(tSP - tEP) > 11) return new Move(tSP, tEP, 1, false, isWhiteToMove ? tSP + 8 : tSP - 8); if (tPT == 6 && (Math.Abs(tSP - tEP) == 2 || Math.Abs(tSP - tEP) == 3)) { if (isWhiteToMove) return tEP == 6 ? mWHITE_KING_ROCHADE : mWHITE_QUEEN_ROCHADE; return tEP == 62 ? mBLACK_KING_ROCHADE : mBLACK_QUEEN_ROCHADE; } return new Move(tSP, tEP, tPT, tIC); } public void PlainMakeMove(string pMoveName) { PlainMakeMove(GetMoveOfString(pMoveName)); } public void PlainMakeMove(Move pMove) { lastMadeMove = pMove; if (isWhiteToMove) WhiteMakeMove(pMove); else BlackMakeMove(pMove); debugFEN = CreateFenString(); } public void WhiteMakeMove(Move pMove) { int tEndPos = pMove.endPos, tStartPos = pMove.startPos, tPieceType = pMove.pieceType, tPTI = pieceTypeArray[tEndPos]; fiftyMoveRuleCounter++; whitePieceBitboard ^= pMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey ^= blackTurnHash ^ enPassantSquareHashes[enPassantSquare] ^ pieceHashesWhite[tStartPos, tPieceType] ^ pieceHashesWhite[tEndPos, tPieceType]; enPassantSquare = 65; isWhiteToMove = false; switch (pMove.moveTypeID) { case 0: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 1: fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 2: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 3: whiteKingSquare = tEndPos; if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 4: if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 5: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 6: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 7: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[whiteKingSquare = tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 8: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 9: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = pMove.enPassantOption]; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 11: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; whiteKingSquare = tEndPos; pieceTypeArray[pMove.rochadeEndPos] = 4; pieceTypeArray[pMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesWhite[pMove.rochadeStartPos, 4] ^ pieceHashesWhite[pMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 12: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[pMove.enPassantOption] = 0; zobristKey ^= pieceHashesBlack[pMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 13: fiftyMoveRuleCounter = 0; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; zobristKey ^= pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, pMove.promotionType]; break; case 14: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, tPTI] ^ pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, pMove.promotionType]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; } moveHashList.Add(pMove.moveHash); if (pMove.isCapture || tPieceType == 1) { curSearchZobristKeyLine = Array.Empty<ulong>(); return; } ulong[] u = new ulong[(tPTI = curSearchZobristKeyLine.Length) + 1]; for (int i = tPTI; i-- > 0;) u[i] = curSearchZobristKeyLine[i]; u[tPTI] = zobristKey; curSearchZobristKeyLine = u; } public void BlackMakeMove(Move pMove) { int tEndPos = pMove.endPos, tStartPos = pMove.startPos, tPieceType = pMove.pieceType, tPTI = pieceTypeArray[tEndPos]; fiftyMoveRuleCounter++; blackPieceBitboard ^= pMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey ^= blackTurnHash ^ enPassantSquareHashes[enPassantSquare] ^ pieceHashesBlack[tStartPos, tPieceType] ^ pieceHashesBlack[tEndPos, tPieceType]; enPassantSquare = 65; isWhiteToMove = true; switch (pMove.moveTypeID) { case 0: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 1: fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 2: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 3: blackKingSquare = tEndPos; if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 4: if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 5: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 6: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 7: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[blackKingSquare = tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 8: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 9: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = pMove.enPassantOption]; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 11: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; blackKingSquare = tEndPos; pieceTypeArray[pMove.rochadeEndPos] = 4; pieceTypeArray[pMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesBlack[pMove.rochadeStartPos, 4] ^ pieceHashesBlack[pMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 12: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[pMove.enPassantOption] = 0; zobristKey ^= pieceHashesWhite[pMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 13: fiftyMoveRuleCounter = 0; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, pMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 14: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } zobristKey ^= pieceHashesWhite[tEndPos, tPTI] ^ pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, pMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; } moveHashList.Add(pMove.moveHash); if (pMove.isCapture || tPieceType == 1) { curSearchZobristKeyLine = Array.Empty<ulong>(); return; } ulong[] u = new ulong[(tPTI = curSearchZobristKeyLine.Length) + 1]; for (int i = tPTI; i-- > 0;) u[i] = curSearchZobristKeyLine[i]; u[tPTI] = zobristKey; curSearchZobristKeyLine = u; } public void WhiteUndoMove(Move pMove) { } private const int WHITE_CHECKMATE_VAL = 100000, BLACK_CHECKMATE_VAL = -100000, CHECK_EXTENSION_LENGTH = -12, MAX_QUIESCENCE_TOTAL_LENGTH = -32; private readonly Move NULL_MOVE = new Move(0, 0, 0); private int curSearchDepth = 0, curSubSearchDepth = -1; public int MinimaxRoot(long pTime) { evalCount = 0; searches++; int baseLineLen = 0; long tTimestamp = globalTimer.ElapsedTicks + pTime; ClearHeuristics(); transpositionTable.Clear(); ulong[] tZobristKeyLine = Array.Empty<ulong>(); if (curSearchZobristKeyLine != null) { baseLineLen = curSearchZobristKeyLine.Length; tZobristKeyLine = new ulong[baseLineLen]; Array.Copy(curSearchZobristKeyLine, tZobristKeyLine, baseLineLen); } int perftScore, tattk = isWhiteToMove ? PreMinimaxCheckCheckWhite() : PreMinimaxCheckCheckBlack(), pDepth = 1; (string, int) bookMoveTuple = TLMDatabase.SearchForNextBookMove(moveHashList); if (bookMoveTuple.Item2 != 0) { int actualMoveHash = NuCRe.GetNumber(bookMoveTuple.Item1); List<Move> tMoves = new List<Move>(); GetLegalMoves(ref tMoves); int tL = tMoves.Count; for (int i = 0; i < tL; i++) { if (tMoves[i].moveHash == actualMoveHash) { if (debugSearchDepthResults) { SNAPSHOT_WRITLINE_REPLACEMENT("TLM_DB_Count: " + bookMoveTuple.Item2); SNAPSHOT_WRITLINE_REPLACEMENT(">> " + tMoves[i]); } transpositionTable.Add(zobristKey, new TranspositionEntry(tMoves[i], Array.Empty<int>())); return 0; } } } do { curSearchDepth = pDepth; curSubSearchDepth = pDepth - 1; ulong[] completeZobristHistory = new ulong[baseLineLen + pDepth - CHECK_EXTENSION_LENGTH + 1]; for (int i = 0; i < baseLineLen; i++) completeZobristHistory[i] = curSearchZobristKeyLine[i]; curSearchZobristKeyLine = completeZobristHistory; if (isWhiteToMove) { if (tattk == -1) perftScore = MinimaxWhite(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); else perftScore = MinimaxWhite(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); } else { if (tattk == -1) perftScore = MinimaxBlack(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); else perftScore = MinimaxBlack(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); } if (debugSearchDepthResults && pTime != 1L) { int tNpS = Convert.ToInt32((double)evalCount * 10_000_000d /(double)(pTime - tTimestamp + globalTimer.ElapsedTicks)); int tSearchEval = perftScore; int timeForSearchSoFar = (int)((pTime - tTimestamp + globalTimer.ElapsedTicks) /10000d); Move tBestMove = transpositionTable[zobristKey].bestMove; SNAPSHOT_WRITLINE_REPLACEMENT((tSearchEval >= 0 ? "+": "") + tSearchEval); SNAPSHOT_WRITLINE_REPLACEMENT(" " + tBestMove + "  ["); SNAPSHOT_WRITLINE_REPLACEMENT("Depth = " + pDepth + ", "); SNAPSHOT_WRITLINE_REPLACEMENT("Evals = " + GetThreeDigitSeperatedInteger(evalCount) + ", "); SNAPSHOT_WRITLINE_REPLACEMENT("Time = " + GetThreeDigitSeperatedInteger(timeForSearchSoFar) + "ms, "); SNAPSHOT_WRITLINE_REPLACEMENT("NpS = " + GetThreeDigitSeperatedInteger(tNpS) + "]"); } pDepth++; } while (globalTimer.ElapsedTicks < tTimestamp && pDepth < 179); depths += pDepth - 1; BOT_MAIN.depthsSearched += pDepth - 1; BOT_MAIN.searchesFinished++; BOT_MAIN.evaluationsMade += evalCount; curSearchZobristKeyLine = tZobristKeyLine; return perftScore; } private int[] squareToRankArray = new int[64] { 0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1, 2,2,2,2,2,2,2,2, 3,3,3,3,3,3,3,3, 4,4,4,4,4,4,4,4, 5,5,5,5,5,5,5,5, 6,6,6,6,6,6,6,6, 7,7,7,7,7,7,7,7 }; private bool WhiteIsPositionTheSpecialCase(Move pLastMove, int pCheckingSquare) { if (pLastMove.isPromotion && pLastMove.isCapture && (pLastMove.promotionType == 4 || pLastMove.promotionType == 5)) { if(pLastMove.startPos % 8 == pCheckingSquare % 8 && pLastMove.startPos == whiteKingSquare + 8) return true; if (pCheckingSquare > -1 && squareToRankArray[pLastMove.startPos] == squareToRankArray[pCheckingSquare] && pLastMove.endPos == whiteKingSquare - 8) return true; } return false; } private bool BlackIsPositionTheSpecialCase(Move pLastMove, int pCheckingSquare) { if (pLastMove.isPromotion && pLastMove.isCapture && (pLastMove.promotionType == 4 || pLastMove.promotionType == 5)) { if (pLastMove.startPos % 8 == pCheckingSquare % 8 && pLastMove.startPos == blackKingSquare - 8) return true; if (pCheckingSquare > -1 && squareToRankArray[pLastMove.startPos] == squareToRankArray[pCheckingSquare] && pLastMove.endPos == blackKingSquare + 8) return true; } return false; } private int MinimaxWhite(int pPly, int pAlpha, int pBeta, int pDepth, int pRepetitionHistoryPly, int pCheckingSquare, Move pLastMove) { if (IsDrawByRepetition(pRepetitionHistoryPly - 4)) return 0; if ((pDepth <= 0 && pCheckingSquare == -1) || pDepth < CHECK_EXTENSION_LENGTH) return QuiescenceWhite(pPly, pAlpha, pBeta, pDepth - 1, pCheckingSquare, pLastMove); List<Move> moveOptionList = new List<Move>(); Move bestMove = NULL_MOVE; if (WhiteIsPositionTheSpecialCase(pLastMove, pCheckingSquare)) GetLegalWhiteMovesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalWhiteMoves(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tWhiteKingSquare = whiteKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1, curEval = BLACK_CHECKMATE_VAL - pDepth; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = true; double[] moveSortingArray = new double[molc]; int[] moveSortingArrayIndexes = new int[molc], thisSearchMoveSortingArrayForTransposEntry = new int[molc]; transpositionTable.TryGetValue(zobristKey, out TranspositionEntry transposEntry); if (transposEntry == null) { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; } } else { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove == transposEntry.bestMove) moveSortingArray[m] = BESTMOVE_SORT_VAL; else if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; if (transposEntry.moveGenOrderedEvalLength > m) moveSortingArray[m] -= transposEntry.moveGenOrderedEvals[m]; } } Array.Sort(moveSortingArray, moveSortingArrayIndexes); for (int m = 0; m < molc; m++) { int tActualIndex = moveSortingArrayIndexes[m]; Move curMove = moveOptionList[tActualIndex]; if (debugSortResults && pDepth == curSubSearchDepth) { SNAPSHOT_WRITLINE_REPLACEMENT(moveSortingArray[m] + " | "+ curMove); } int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; whitePieceBitboard = tWPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesWhite[tStartPos, tPieceType] ^ pieceHashesWhite[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 0: blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 1: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 2: blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 3: whiteKingSquare = tEndPos; if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 4: blackPieceBitboard = tBPB; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 5: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[whiteKingSquare = tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = curMove.enPassantOption]; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 11: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; whiteKingSquare = tEndPos; blackPieceBitboard = tBPB; pieceTypeArray[curMove.rochadeEndPos] = 4; pieceTypeArray[curMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesWhite[curMove.rochadeStartPos, 4] ^ pieceHashesWhite[curMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | curMove.rochadeEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << curMove.rochadeEndPos)) tCheckPos = curMove.rochadeEndPos; break; case 12: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesBlack[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 13: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; zobristKey ^= pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, curMove.promotionType]; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; case 14: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, tPTI] ^ pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, curMove.promotionType]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } curSearchZobristKeyLine[pRepetitionHistoryPly] = zobristKey; debugMoveList[pPly] = curMove; int tEval = MinimaxBlack(pPly + 1, pAlpha, pBeta, pDepth - 1, pRepetitionHistoryPly + 1, tCheckPos, curMove); thisSearchMoveSortingArrayForTransposEntry[tActualIndex] = tEval; pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 3: whiteKingSquare = tWhiteKingSquare; break; case 7: whiteKingSquare = tWhiteKingSquare; break; case 10: enPassantSquare = 65; break; case 11: whiteKingSquare = tWhiteKingSquare; pieceTypeArray[curMove.rochadeStartPos] = 4; pieceTypeArray[curMove.rochadeEndPos] = 0; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 13: pieceTypeArray[tStartPos] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval > curEval) { bestMove = curMove; curEval = tEval; } if (pAlpha < curEval) pAlpha = curEval; if (curEval >= pBeta) { if (!curMove.isCapture) { killerMoveHeuristic[curMove.moveHash] = true; if (pDepth > 0) historyHeuristic[curMove.moveHash] += pDepth * pDepth; } break; } } isWhiteToMove = true; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; if (molc == 0 && pCheckingSquare == -1) curEval = 0; if (!transpositionTable.ContainsKey(zobristKey)) transpositionTable.Add(zobristKey, new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry)); else transpositionTable[zobristKey] = new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry); return curEval; } private int QuiescenceWhite(int pPly, int pAlpha, int pBeta, int pDepth, int pCheckingSquare, Move pLastMove) { int standPat = TexelEvaluate(); if (standPat >= pBeta || pDepth < MAX_QUIESCENCE_TOTAL_LENGTH) return pBeta; if (standPat > pAlpha) pAlpha = standPat; List<Move> moveOptionList = new List<Move>(); if (WhiteIsPositionTheSpecialCase(pLastMove, pCheckingSquare)) GetLegalWhiteCapturesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalWhiteCaptures(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tWhiteKingSquare = whiteKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = true; for (int m = 0; m < molc; m++) { Move curMove = moveOptionList[m]; int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; whitePieceBitboard = tWPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesWhite[tStartPos, tPieceType] ^ pieceHashesWhite[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 5: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[whiteKingSquare = tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 12: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesBlack[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 14: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, tPTI] ^ pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, curMove.promotionType]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } debugMoveList[pPly] = curMove; int tEval = QuiescenceBlack(pPly + 1, pAlpha, pBeta, pDepth - 1, tCheckPos, curMove); pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 7: whiteKingSquare = tWhiteKingSquare; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval >= pBeta) return pBeta; if (pAlpha < tEval) pAlpha = tEval; } isWhiteToMove = true; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; return pAlpha; } private int MinimaxBlack(int pPly, int pAlpha, int pBeta, int pDepth, int pRepetitionHistoryPly, int pCheckingSquare, Move pLastMove) { if (IsDrawByRepetition(pRepetitionHistoryPly - 4)) return 0; if ((pDepth <= 0 && pCheckingSquare == -1) || pDepth < CHECK_EXTENSION_LENGTH) return QuiescenceBlack(pPly, pAlpha, pBeta, pDepth - 1, pCheckingSquare, pLastMove); List<Move> moveOptionList = new List<Move>(); Move bestMove = NULL_MOVE; if (BlackIsPositionTheSpecialCase(pLastMove, pCheckingSquare)) GetLegalBlackMovesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalBlackMoves(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tBlackKingSquare = blackKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1, curEval = WHITE_CHECKMATE_VAL + pDepth; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = false; double[] moveSortingArray = new double[molc]; int[] moveSortingArrayIndexes = new int[molc], thisSearchMoveSortingArrayForTransposEntry = new int[molc]; transpositionTable.TryGetValue(zobristKey, out TranspositionEntry transposEntry); if (transposEntry == null) { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; } } else { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove == transposEntry.bestMove) moveSortingArray[m] = BESTMOVE_SORT_VAL; else if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; if (transposEntry.moveGenOrderedEvalLength > m) moveSortingArray[m] -= transposEntry.moveGenOrderedEvals[m]; } } Array.Sort(moveSortingArray, moveSortingArrayIndexes); for (int m = 0; m < molc; m++) { int tActualIndex = moveSortingArrayIndexes[m]; Move curMove = moveOptionList[tActualIndex]; if (debugSortResults && pDepth == curSearchDepth) { SNAPSHOT_WRITLINE_REPLACEMENT("=== " + moveSortingArray[m] + " | "+ curMove); } int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; blackPieceBitboard = tBPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesBlack[tStartPos, tPieceType] ^ pieceHashesBlack[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 0: whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 1: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 2: whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 3: blackKingSquare = tEndPos; if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 4: whitePieceBitboard = tWPB; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 5: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[blackKingSquare = tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = curMove.enPassantOption]; whitePieceBitboard = tWPB; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 11: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; blackKingSquare = tEndPos; whitePieceBitboard = tWPB; pieceTypeArray[curMove.rochadeEndPos] = 4; pieceTypeArray[curMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesBlack[curMove.rochadeStartPos, 4] ^ pieceHashesBlack[curMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | curMove.rochadeEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << curMove.rochadeEndPos)) tCheckPos = curMove.rochadeEndPos; break; case 12: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesWhite[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 13: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, curMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; case 14: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } zobristKey ^= pieceHashesWhite[tEndPos, tPTI] ^ pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, curMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } curSearchZobristKeyLine[pRepetitionHistoryPly] = zobristKey; debugMoveList[pPly] = curMove; int tEval = MinimaxWhite(pPly + 1, pAlpha, pBeta, pDepth - 1, pRepetitionHistoryPly + 1, tCheckPos, curMove); thisSearchMoveSortingArrayForTransposEntry[tActualIndex] = tEval; pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 3: blackKingSquare = tBlackKingSquare; break; case 7: blackKingSquare = tBlackKingSquare; break; case 10: enPassantSquare = 65; break; case 11: blackKingSquare = tBlackKingSquare; pieceTypeArray[curMove.rochadeStartPos] = 4; pieceTypeArray[curMove.rochadeEndPos] = 0; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 13: pieceTypeArray[tStartPos] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval < curEval) { bestMove = curMove; curEval = tEval; } if (pBeta > curEval) pBeta = curEval; if (curEval <= pAlpha) { if (!curMove.isCapture) { killerMoveHeuristic[curMove.moveHash] = true; if (pDepth > 0) historyHeuristic[curMove.moveHash] += pDepth * pDepth; } break; } } isWhiteToMove = false; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; if (molc == 0 && pCheckingSquare == -1) curEval = 0; if (!transpositionTable.ContainsKey(zobristKey)) transpositionTable.Add(zobristKey, new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry)); else transpositionTable[zobristKey] = new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry); return curEval; } private int QuiescenceBlack(int pPly, int pAlpha, int pBeta, int pDepth, int pCheckingSquare, Move pLastMove) { int standPat = TexelEvaluate(); if (standPat <= pAlpha || pDepth < MAX_QUIESCENCE_TOTAL_LENGTH) return pAlpha; if (standPat < pBeta) pBeta = standPat; List<Move> moveOptionList = new List<Move>(); if (BlackIsPositionTheSpecialCase(pLastMove, pCheckingSquare)) GetLegalBlackCapturesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalBlackCaptures(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tBlackKingSquare = blackKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = false; for (int m = 0; m < molc; m++) { Move curMove = moveOptionList[m]; int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; blackPieceBitboard = tBPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesBlack[tStartPos, tPieceType] ^ pieceHashesBlack[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 5: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[blackKingSquare = tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 12: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesWhite[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 14: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } zobristKey ^= pieceHashesWhite[tEndPos, tPTI] ^ pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, curMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } debugMoveList[pPly] = curMove; int tEval = QuiescenceWhite(pPly + 1, pAlpha, pBeta, pDepth - 1, tCheckPos, curMove); pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 7: blackKingSquare = tBlackKingSquare; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval <= pAlpha) return pAlpha; if (pBeta > tEval) pBeta = tEval; } isWhiteToMove = false; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; return pBeta; } private bool[] killerMoveHeuristic = new bool[262_144]; private int[] historyHeuristic = new int[262_144]; public void ClearHeuristics() { for (int i = 0; i < 262_144; i++) { killerMoveHeuristic[i] = false; historyHeuristic[i] = 0; } } private Dictionary<ulong, TranspositionEntry> transpositionTable = new Dictionary<ulong, TranspositionEntry>(); private int[] pieceEvals = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[,][] piecePositionEvals = new int[33, 14][]; private int evalCount = 0; private int Evaluate() { evalCount++; if (fiftyMoveRuleCounter > 99) return 0; int tEval = 0, tPT, pieceCount = ULONG_OPERATIONS.CountBits(allPieceBitboard); for (int p = 0; p < 64; p++) tEval += pieceEvals[tPT = pieceTypeArray[p] + 7 * ((int)(blackPieceBitboard >> p) & 1)] + piecePositionEvals[pieceCount, tPT][p]; return tEval; } public int GameState(bool pWhiteKingCouldBeAttacked) { if (IsDrawByRepetition(curSearchZobristKeyLine.Length - 5) || fiftyMoveRuleCounter > 99) return 0; int t; List<Move> tMoves = new List<Move>(); GetLegalMoves(ref tMoves); if (pWhiteKingCouldBeAttacked) { t = PreMinimaxCheckCheckWhite(); if (t == -1) return tMoves.Count == 0 ? 0 : 3; else if (tMoves.Count == 0) return -1; } else { t = PreMinimaxCheckCheckBlack(); if (t == -1) return tMoves.Count == 0 ? 0 : 3; else if (tMoves.Count == 0) return 1; } return 3; } private bool IsDrawByRepetition(int pPlyOfFirstPossibleRepeatedPosition) { int tC = 0; for (int i = pPlyOfFirstPossibleRepeatedPosition; i >= 0; i -= 2) { if (curSearchZobristKeyLine[i] == zobristKey) if (++tC == 2) return true; } return false; } private const int RELE_MAX_MOVE_COUNT_PER_GAME = 500; public double ReLePlayGame(int[,][] pEvalPositionValuesWhite, int[,][] pEvalPositionValuesBlack, long thinkingTimePerMove) { int[,][] processedValuesWhite = InitReLeAgent(pEvalPositionValuesWhite), processedValuesBlack = InitReLeAgent(pEvalPositionValuesBlack); int tGS, mc = 0; do { if (IsDrawByRepetition(curSearchZobristKeyLine.Length - 5)) return 0d; piecePositionEvals = isWhiteToMove ? processedValuesWhite : processedValuesBlack; MinimaxRoot(thinkingTimePerMove); if (transpositionTable.Count == 0) { SNAPSHOT_WRITLINE_REPLACEMENT("?!"); return 0d; } PlainMakeMove(transpositionTable[zobristKey].bestMove); tGS = GameState(isWhiteToMove); transpositionTable.Clear(); if (tGS != 3) break; } while (mc++ < RELE_MAX_MOVE_COUNT_PER_GAME); if (tGS == 3 || tGS == 0) return 0d; else if (tGS == 1) return 0.1d * (double)(RELE_MAX_MOVE_COUNT_PER_GAME - mc); return 0.1d * (double)(-RELE_MAX_MOVE_COUNT_PER_GAME + mc); } public int[,][] InitReLeAgent(int[,][] pEvalPositionValues) { return GetInterpolatedProcessedValues(pEvalPositionValues); } private int[,][] GetInterpolatedProcessedValues(int[,][] pEvalPositionValues) { int[,][] processedValues = new int[33, 14][]; for (int i = 0; i < 32; i++) { int ip1 = i + 1; processedValues[ip1, 7] = processedValues[ip1, 0] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; processedValues[ip1, 8] = SwapArrayViewingSide(processedValues[ip1, 1] = MultiplyArraysWithVal(pEvalPositionValues[0, 0], pEvalPositionValues[1, 0], pEvalPositionValues[2, 0], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 9] = SwapArrayViewingSide(processedValues[ip1, 2] = MultiplyArraysWithVal(pEvalPositionValues[0, 1], pEvalPositionValues[1, 1], pEvalPositionValues[2, 1], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 10] = SwapArrayViewingSide(processedValues[ip1, 3] = MultiplyArraysWithVal(pEvalPositionValues[0, 2], pEvalPositionValues[1, 2], pEvalPositionValues[2, 2], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 11] = SwapArrayViewingSide(processedValues[ip1, 4] = MultiplyArraysWithVal(pEvalPositionValues[0, 3], pEvalPositionValues[1, 3], pEvalPositionValues[2, 3], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 12] = SwapArrayViewingSide(processedValues[ip1, 5] = MultiplyArraysWithVal(pEvalPositionValues[0, 4], pEvalPositionValues[1, 4], pEvalPositionValues[2, 4], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 13] = SwapArrayViewingSide(processedValues[ip1, 6] = MultiplyArraysWithVal(pEvalPositionValues[0, 5], pEvalPositionValues[1, 5], pEvalPositionValues[2, 5], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); } return processedValues; } private double[,][] GetInterpolatedProcessedValues(double[,][] pEvalPositionValues) { double[,][] processedValues = new double[33, 14][]; for (int i = 0; i < 32; i++) { int ip1 = i + 1; processedValues[ip1, 7] = processedValues[ip1, 0] = new double[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; processedValues[ip1, 8] = SwapArrayViewingSide(processedValues[ip1, 1] = MultiplyArraysWithVal(pEvalPositionValues[0, 0], pEvalPositionValues[1, 0], pEvalPositionValues[2, 0], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 9] = SwapArrayViewingSide(processedValues[ip1, 2] = MultiplyArraysWithVal(pEvalPositionValues[0, 1], pEvalPositionValues[1, 1], pEvalPositionValues[2, 1], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 10] = SwapArrayViewingSide(processedValues[ip1, 3] = MultiplyArraysWithVal(pEvalPositionValues[0, 2], pEvalPositionValues[1, 2], pEvalPositionValues[2, 2], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 11] = SwapArrayViewingSide(processedValues[ip1, 4] = MultiplyArraysWithVal(pEvalPositionValues[0, 3], pEvalPositionValues[1, 3], pEvalPositionValues[2, 3], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 12] = SwapArrayViewingSide(processedValues[ip1, 5] = MultiplyArraysWithVal(pEvalPositionValues[0, 4], pEvalPositionValues[1, 4], pEvalPositionValues[2, 4], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 13] = SwapArrayViewingSide(processedValues[ip1, 6] = MultiplyArraysWithVal(pEvalPositionValues[0, 5], pEvalPositionValues[1, 5], pEvalPositionValues[2, 5], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); } return processedValues; } private double[] MultiplyArraysWithVal(double[] pArr1, double[] pArr2, double[] pArr3, double pVal1, double pVal2, double pVal3) { int tL = pArr1.Length; double[] rArr = new double[tL]; for (int i = 0; i < tL; i++) { rArr[i] = pArr1[i] * pVal1 + pArr2[i] * pVal2 + pArr3[i] * pVal3; } return rArr; } private int[] MultiplyArraysWithVal(int[] pArr1, int[] pArr2, int[] pArr3, double pVal1, double pVal2, double pVal3) { int tL = pArr1.Length; int[] rArr = new int[tL]; for (int i = 0; i < tL; i++) { rArr[i] = (int)(pArr1[i] * pVal1 + pArr2[i] * pVal2 + pArr3[i] * pVal3); } return rArr; } private int[] SwapArrayViewingSideAndNegate(int[] pArr) { return new int[64] { -pArr[56], -pArr[57], -pArr[58], -pArr[59], -pArr[60], -pArr[61], -pArr[62], -pArr[63], -pArr[48], -pArr[49], -pArr[50], -pArr[51], -pArr[52], -pArr[53], -pArr[54], -pArr[55], -pArr[40], -pArr[41], -pArr[42], -pArr[43], -pArr[44], -pArr[45], -pArr[46], -pArr[47], -pArr[32], -pArr[33], -pArr[34], -pArr[35], -pArr[36], -pArr[37], -pArr[38], -pArr[39], -pArr[24], -pArr[25], -pArr[26], -pArr[27], -pArr[28], -pArr[29], -pArr[30], -pArr[31], -pArr[16], -pArr[17], -pArr[18], -pArr[19], -pArr[20], -pArr[21], -pArr[22], -pArr[23], -pArr[8], -pArr[9], -pArr[10], -pArr[11], -pArr[12], -pArr[13], -pArr[14], -pArr[15], -pArr[0], -pArr[1], -pArr[2], -pArr[3], -pArr[4], -pArr[5], -pArr[6], -pArr[7] }; } private int[] SwapArrayViewingSide(int[] pArr) { return new int[64] { pArr[56], pArr[57], pArr[58], pArr[59], pArr[60], pArr[61], pArr[62], pArr[63], pArr[48], pArr[49], pArr[50], pArr[51], pArr[52], pArr[53], pArr[54], pArr[55], pArr[40], pArr[41], pArr[42], pArr[43], pArr[44], pArr[45], pArr[46], pArr[47], pArr[32], pArr[33], pArr[34], pArr[35], pArr[36], pArr[37], pArr[38], pArr[39], pArr[24], pArr[25], pArr[26], pArr[27], pArr[28], pArr[29], pArr[30], pArr[31], pArr[16], pArr[17], pArr[18], pArr[19], pArr[20], pArr[21], pArr[22], pArr[23], pArr[8], pArr[9], pArr[10], pArr[11], pArr[12], pArr[13], pArr[14], pArr[15], pArr[0], pArr[1], pArr[2], pArr[3], pArr[4], pArr[5], pArr[6], pArr[7] }; } private double[] SwapArrayViewingSide(double[] pArr) { return new double[64] { pArr[56], pArr[57], pArr[58], pArr[59], pArr[60], pArr[61], pArr[62], pArr[63], pArr[48], pArr[49], pArr[50], pArr[51], pArr[52], pArr[53], pArr[54], pArr[55], pArr[40], pArr[41], pArr[42], pArr[43], pArr[44], pArr[45], pArr[46], pArr[47], pArr[32], pArr[33], pArr[34], pArr[35], pArr[36], pArr[37], pArr[38], pArr[39], pArr[24], pArr[25], pArr[26], pArr[27], pArr[28], pArr[29], pArr[30], pArr[31], pArr[16], pArr[17], pArr[18], pArr[19], pArr[20], pArr[21], pArr[22], pArr[23], pArr[8], pArr[9], pArr[10], pArr[11], pArr[12], pArr[13], pArr[14], pArr[15], pArr[0], pArr[1], pArr[2], pArr[3], pArr[4], pArr[5], pArr[6], pArr[7] }; } private int[,][] texelTuningRuntimeVals = new int[33, 14][]; private int[,][] texelTuningVals = new int[3, 6][]; private int[,] texelTuningAdjustIterations = new int[6, 64]; private int[][] texelTuningRuntimePositionalValsV2EG = new int[14][]; private int[][] texelTuningRuntimePositionalValsV2LG = new int[14][]; private int[] texelPieceEvaluationsV2EG = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[] texelPieceEvaluationsV2LG = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[] texelKingSafetyR1EvaluationsEG = new int[9]; private int[] texelKingSafetyR2EvaluationsEG = new int[17]; private int[] texelKingSafetyR1EvaluationsLG = new int[9]; private int[] texelKingSafetyR2EvaluationsLG = new int[17]; private int[] texelKingSafetySREvaluationsPT1EG = new int[12]; private int[] texelKingSafetySREvaluationsPT2EG = new int[12]; private int[] texelKingSafetySREvaluationsPT3EG = new int[12]; private int[] texelKingSafetySREvaluationsPT4EG = new int[12]; private int[] texelKingSafetySREvaluationsPT5EG = new int[12]; private int[] texelKingSafetySREvaluationsPT6EG = new int[12]; private int[] texelKingSafetySREvaluationsPT1LG = new int[12]; private int[] texelKingSafetySREvaluationsPT2LG = new int[12]; private int[] texelKingSafetySREvaluationsPT3LG = new int[12]; private int[] texelKingSafetySREvaluationsPT4LG = new int[12]; private int[] texelKingSafetySREvaluationsPT5LG = new int[12]; private int[] texelKingSafetySREvaluationsPT6LG = new int[12]; private int[,] texelMobilityStraightEG = new int[14, 15], texelMobilityStraightLG = new int[14, 15]; private int[,] texelMobilityDiagonalEG = new int[14, 14], texelMobilityDiagonalLG = new int[14, 14]; private int[] texelPieceEvaluations = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[] blackSidedSquares = new int[64] { 56, 57, 58, 59, 60, 61, 62, 63, 48, 49, 50, 51, 52, 53, 54, 55, 40, 41, 42, 43, 44, 45, 46, 47, 32, 33, 34, 35, 36, 37, 38, 39, 24, 25, 26, 27, 28, 29, 30, 31, 16, 17, 18, 19, 20, 21, 22, 23, 08, 09, 10, 11, 12, 13, 14, 15, 00, 01, 02, 03, 04, 05, 06, 07 }; private int[,] T_Pawns = new int[3, 64] { { 0, 0, 0, 0, 0, 0, 0, 0, 98, 134, 61, 95, 68, 126, 34, -11, -6, 7, 26, 31, 65, 56, 25, -20, -14, 13, 6, 21, 23, 12, 17, -23, -27, -2, -5, 12, 17, 6, 10, -25, -26, -4, -4, -10, 3, 3, 33, -12, -35, -1, -20, -23, -15, 24, 38, -22, 0, 0, 0, 0, 0, 0, 0, 0, } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { 0, 0, 0, 0, 0, 0, 0, 0, 178, 173, 158, 134, 147, 132, 165, 187, 94, 100, 85, 67, 56, 53, 82, 84, 32, 24, 13, 5, -2, 4, 17, 17, 13, 9, -3, -7, -7, -8, 3, -1, 4, 7, -6, 1, 0, -5, -1, -8, 13, 8, 8, 10, 13, 0, 2, -7, 0, 0, 0, 0, 0, 0, 0, 0, } }; private int[,] T_Knights = new int[3, 64] { { -167, -89, -34, -49, 61, -97, -15, -107, -73, -41, 72, 36, 23, 62, 7, -17, -47, 60, 37, 65, 84, 129, 73, 44, -9, 17, 19, 53, 37, 69, 18, 22, -13, 4, 16, 13, 28, 19, 21, -8, -23, -9, 12, 10, 19, 17, 25, -16, -29, -53, -12, -3, -1, 18, -14, -19, -105, -21, -58, -33, -17, -28, -19, -23 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -58, -38, -13, -28, -31, -27, -63, -99, -25, -8, -25, -2, -9, -25, -24, -52, -24, -20, 10, 9, -1, -9, -19, -41, -17, 3, 22, 22, 22, 11, 8, -18, -18, -6, 16, 25, 16, 17, 4, -18, -23, -3, -1, 15, 10, -3, -20, -22, -42, -20, -10, -5, -2, -20, -23, -44, -29, -51, -23, -15, -22, -18, -50, -64 } }; private int[,] T_Bishops = new int[3, 64] { { -29, 4, -82, -37, -25, -42, 7, -8, -26, 16, -18, -13, 30, 59, 18, -47, -16, 37, 43, 40, 35, 50, 37, -2, -4, 5, 19, 50, 37, 37, 7, -2, -6, 13, 13, 26, 34, 12, 10, 4, 0, 15, 15, 15, 14, 27, 18, 10, 4, 15, 16, 0, 7, 21, 33, 1, -33, -3, -14, -21, -13, -12, -39, -21 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -14, -21, -11, -8, -7, -9, -17, -24, -8, -4, 7, -12, -3, -13, -4, -14, 2, -8, 0, -1, -2, 6, 0, 4, -3, 9, 12, 9, 14, 10, 3, 2, -6, 3, 13, 19, 7, 10, -3, -9, -12, -3, 8, 10, 13, 3, -7, -15, -14, -18, -7, -1, 4, -9, -15, -27, -23, -9, -23, -5, -9, -16, -5, -17 } }; private int[,] T_Rooks = new int[3, 64] { { 32, 42, 32, 51, 63, 9, 31, 43, 27, 32, 58, 62, 80, 67, 26, 44, -5, 19, 26, 36, 17, 45, 61, 16, -24, -11, 7, 26, 24, 35, -8, -20, -36, -26, -12, -1, 9, -7, 6, -23, -45, -25, -16, -17, 3, 0, -5, -33, -44, -16, -20, -9, -1, 11, -6, -71, -19, -13, 1, 17, 16, 7, -37, -26 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { 13, 10, 18, 15, 12, 12, 8, 5, 11, 13, 13, 11, -3, 3, 8, 3, 7, 7, 7, 5, 4, -3, -5, -3, 4, 3, 13, 1, 2, 1, -1, 2, 3, 5, 8, 4, -5, -6, -8, -11, -4, 0, -5, -1, -7, -12, -8, -16, -6, -6, 0, 2, -9, -9, -11, -3, -9, 2, 3, -1, -5, -13, 4, -20 } }; private int[,] T_Queens = new int[3, 64] { { -28, 0, 29, 12, 59, 44, 43, 45, -24, -39, -5, 1, -16, 57, 28, 54, -13, -17, 7, 8, 29, 56, 47, 57, -27, -27, -16, -16, -1, 17, -2, 1, -9, -26, -9, -10, -2, -4, 3, -3, -14, 2, -11, -2, -5, 2, 14, 5, -35, -8, 11, 2, 8, 15, -3, 1, -1, -18, -9, 10, -15, -25, -31, -50 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -9, 22, 22, 27, 27, 19, 10, 20, -17, 20, 32, 41, 58, 25, 30, 0, -20, 6, 9, 49, 47, 35, 19, 9, 3, 22, 24, 45, 57, 40, 57, 36, -18, 28, 19, 47, 31, 34, 39, 23, -16, -27, 15, 6, 9, 17, 10, 5, -22, -23, -30, -16, -16, -23, -36, -32, -33, -28, -22, -43, -5, -32, -20, -41 } }; private int[,] T_Kings = new int[3, 64] { { -65, 23, 16, -15, -56, -34, 2, 13, 29, -1, -20, -7, -8, -4, -38, -29, -9, 24, 2, -16, -20, 6, 22, -22, -17, -20, -12, -27, -30, -25, -14, -36, -49, -1, -27, -39, -46, -44, -33, -51, -14, -14, -22, -46, -44, -30, -15, -27, 1, 7, -8, -64, -43, -16, 9, 8, -15, 36, 12, -54, 8, -28, 24, 14 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -74, -35, -18, -18, -11, 15, 4, -17, -12, 17, 14, 17, 17, 38, 23, 11, 10, 17, 23, 15, 20, 45, 44, 13, -8, 22, 24, 27, 26, 33, 26, 3, -18, -4, 21, 24, 27, 23, 9, -11, -19, -3, 11, 21, 23, 16, 7, -9, -27, -11, 4, 13, 14, 4, -5, -17, -53, -34, -21, -11, -28, -14, -24, -43 } }; private int[] paramsLowerLimits = new int[5] { -10000, -10000, -10000, -10000, -10000 }; private int[] paramsUpperLimits = new int[5] { 10000, 10000, 10000, 10000, 10000 }; private List<TLM_ChessGame> threadDataset; private int threadFrom, threadTo; private int[] threadParams; private int customThreadID = 0; private ulong ulAllThreadIDsUnfinished = 0; private double lastCostVal = 0d; private double sumCostVals = 0d; private int costCalculations = 0; private readonly string[] TEXELPRINT_GAMEPARTS = new string[3] { "Early Game: ", "Mid Game: ", "Late Game: "}; private readonly string[] TEXELPRINT_PIECES = new string[6] { "Bauer: ", "Springer: ", "Lufer: ", "Turm: ", "Dame: ", "Knig: "}; private double[] earlyGameMultipliers = new double[33]; private double[] middleGameMultipliers = new double[33]; private double[] lateGameMultipliers = new double[33]; private int[] pieceTypeGameProgressImpact = new int[14] { 0, 0, 1, 1, 2, 4, 0, 0, 0, 1, 1, 2, 4, 0 }; private void PrecalculateMultipliers() { if (BOARD_MANAGER_ID == ENGINE_VALS.PARALLEL_BOARDS - 1) SNAPSHOT_WRITLINE_REPLACEMENT(); for (int i = 0; i < 25; i++) { earlyGameMultipliers[i] = EGMultiplierFunction(i); lateGameMultipliers[i] = LGMultiplierFunction(i); if (BOARD_MANAGER_ID == ENGINE_VALS.PARALLEL_BOARDS - 1) SNAPSHOT_WRITLINE_REPLACEMENT("[" + i + "] "+ earlyGameMultipliers[i] + " | "+ middleGameMultipliers[i] + " | "+ lateGameMultipliers[i]); } } private double MultiplierFunction(double pVal, double pXShift) { double d = Math.Exp(1d /6d * (pVal - pXShift)); return 5 * (d /Math.Pow(d + 1, 2d)); } private double EGMultiplierFunction(double pVal) { return Math.Clamp(1 /16d * (pVal - 4d), 0d, 1d); } private double LGMultiplierFunction(double pVal) { return Math.Clamp(1 /-16d * (pVal - 4d) + 1d, 0d, 1d); } private double EGMultiplierFunction2(double pVal) { return Math.Clamp(1 /32d * pVal, 0d, 1d); } private double LGMultiplierFunction2(double pVal) { return Math.Clamp(1 /-32d * pVal + 1d, 0d, 1d); } private void TuneWithTxtFile(string pTXTName) { List<TLM_ChessGame> gameDataset = new List<TLM_ChessGame>(); string tPath = PathManager.GetTXTPath(pTXTName); string[] tStrs = File.ReadAllLines(tPath); List<string> tGames = new List<string>(); foreach (string s in tStrs) if (s.Contains(';') && s.Replace(" ", "") != "") tGames.Add(s); foreach (string s in tGames) { TLM_ChessGame tGame = CGFF.GetGame(s); LoadFenString(tGame.startFen); foreach (int hMove in tGame.hashedMoves) { List<Move> moveOptionList = new List<Move>(); GetLegalMoves(ref moveOptionList); int tL = moveOptionList.Count; for (int j = 0; j < tL; j++) { Move tMove = moveOptionList[j]; if (tMove.moveHash == hMove) { tGame.actualMoves.Add(tMove); PlainMakeMove(tMove); tL = -1; break; } } if (tL != -1) break; } gameDataset.Add(tGame); } SNAPSHOT_WRITLINE_REPLACEMENT("[TLM TEXEL TUNER] " + tGames.Count + " Games Loaded In!"); BOT_MAIN.curTEXELPARAMS = new int[TEXEL_PARAMS]; BOT_MAIN.ParallelTexelTuning(gameDataset); } private void LoadBestTexelParamsIn() { int[] ttt = new int[778] { 72, 300, 484, 528, 904, 128, 272, 280, 504, 720, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -56, 88, -92, -200, 56, -40, -48, -148, -100, 96, -32, -100, 8, -28, -8, 32, -64, -200, 44, -184, 12, -8, 96, -200, -16, -104, -40, 40, 24, -134, -136, -8, -16, 80, -8, -32, 136, -120, -12, -136, -16, 20, -136, 68, 32, -200, 0, 88, -176, 128, -72, 128, 88, -200, 104, -200, 124, 40, 64, 84, 8, -124, -48, 128, 100, -36, -32, -32, -64, 200, -200, 200, 200, -200, 8, 156, -20, 76, 72, 200, 196, 200, 200, 200, -66, 8, 200, 200, -200, 200, -200, 200, 56, 200, -200, 200, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -200, -200, -28, 200, -200, -22, 200, 192, 172, 200, 12, 120, 12, -200, -200, 200, 18, -194, 200, -200, 46, -168, 52, 200, 176, 56, -56, 200, -40, 32, 8, 200, 70, -176, -112, 200, 168, -48, 192, 76, 192, -72, 136, 46, 64, -200, -24, -200, 172, -200, -200, 88, 24, 200, 112, -68, 200, 200, 168, -120, 200, -88, -12, 200, 76, 40, 56, 200, 200, 200, 64, -200, 138, -56, 200, -16, 96, 136, 200, -112, 200, 200, 200, 200, 101, -200, 176, 200, -200, 200, 120, -200, 54, -128, 200, -24, -200, 200, 200, -72, 200, 200, 200, 200, -200, -200, 176, -200, 80, 176, 200, -24, 112, -200, 200, 200, -200, -200, -200, 128, -200, 112, -200, -200, 200, -200, 16, -200, 16, -80, -200, 184, -8, 200, -32, -200, -176, -200, -56, 200, 56, 200, -104, -152, -200, 200, 32, 200, 112, 8, -24, 160, 92, -76, -120, -200, 64, -200, 200, -200, 32, 136, -140, -144, 24, 8, 16, 200, 132, 24, 40, -24, -62, -200, 200, -15, -8, -116, 148, 200, -76, 200, 200, -200, 96, -200, 8, 200, -148, -200, -200, 188, 200, 86, 64, 80, -180, -200, 64, 200, 200, 200, -200, -132, 184, -184, 200, -156, -136, -200, 200, -104, -184, 60, -200, -184, -32, 0, -169, 96, 200, 200, 200, 200, 200, 200, -200, -200, 200, -200, -200, 68, -200, -200, 200, 200, -200, 176, -200, 200, -56, 200, -200, 152, -200, -168, -46, -200, 200, -200, -200, 192, -200, 68, -200, -200, -16, 16, 4, 200, -168, 112, 176, -200, 92, -128, -200, 16, 34, 144, -68, 24, -40, -200, -64, 40, -128, 152, 48, -24, -200, -35, 200, -56, -88, 4, -96, 128, 200, -200, 200, -100, 200, -80, 32, -172, 200, -200, -40, -200, -78, 200, 96, -24, -26, 200, 80, -32, 200, -76, 200, 48, 200, -200, 16, -148, -200, -64, 32, -72, 120, -180, 200, 84, 200, 136, 200, 200, 200, 200, -52, 200, 72, 200, 200, -200, -64, 200, 200, -144, -136, 40, 200, -104, -8, 200, 88, -200, -173, -112, 200, -88, -40, 200, 32, -200, -200, 72, 200, 68, 200, -156, -200, -40, 128, 4, 144, -88, -200, 200, 174, -136, 200, -200, 184, -176, 200, -56, -200, 200, -200, -152, -200, 160, 200, -171, -96, -200, 88, 200, -62, 72, -200, -200, -200, 200, 194, -200, -200, -200, -140, 200, -32, 56, 88, 200, 200, 200, -53, -200, -38, -200, 84, -200, -200, 200, -8, 100, 3, -140, 38, 172, -48, 200, -20, -160, 80, -200, 200, -200, -200, 200, -200, -200, -56, -52, -72, -124, 80, 80, 88, -8, 104, -88, 104, 200, -24, -200, -8, -200, -80, 22, 164, 200, 152, 80, 104, -200, 88, -104, 200, 200, 25, 200, -112, -200, 56, -200, 200, 200, 100, -80, 176, 200, 200, 104, 200, 200, -200, -200, 24, 200, 200, 200, 200, -200, -200, -30, 200, 200, 200, 48, 200, 200, -76, -200, 200, -184, 200, 200, -200, -200, 174, 200, 108, 192, 128, 200, 80, 200, 200, 40, -200, -200, -48, -84, -88, 64, -24, -200, 8, -16, 160, -200, 176, -100, 200, 200, -200, -174, 48, -112, 72, 44, -136, -84, 44, -104, 64, -16, -96, 200, 64, -200, -200, 200, -200, 80, -200, 144, -200, 144, -192, 152, -104, 24, -200, 200, -200, -136, -8, -112, -200, -200, 200, 112, -200, 200, 48, 0, -200, 144, -200, -136, -48, 200, 200, -134, -200, -56, -200, -28, -192, -200, 200, 92, -200, 200, 134, 200, 200, 144, 200, -94, 200, 120, 200, 200, 200, 200, -200, -200, -200, 200, -200, 200, 200, -200, 200, 200, -197, 200, -200, 200, 197, 200, 200, 200, 0, 0, 200, -200, 200, 200, -200, -200, -200, 200, -200, -200, -200, 128, -200, -200, -200, -200, 0, -200, -200, -200 }; SetupTexelEvaluationParams(ttt); } private void SetupTexelEvaluationParams(int[] pParams) { texelPieceEvaluationsV2EG[8] = -(texelPieceEvaluationsV2EG[1] = pParams[0]); texelPieceEvaluationsV2EG[9] = -(texelPieceEvaluationsV2EG[2] = pParams[1]); texelPieceEvaluationsV2EG[10] = -(texelPieceEvaluationsV2EG[3] = pParams[2]); texelPieceEvaluationsV2EG[11] = -(texelPieceEvaluationsV2EG[4] = pParams[3]); texelPieceEvaluationsV2EG[12] = -(texelPieceEvaluationsV2EG[5] = pParams[4]); texelPieceEvaluationsV2LG[8] = -(texelPieceEvaluationsV2LG[1] = pParams[5]); texelPieceEvaluationsV2LG[9] = -(texelPieceEvaluationsV2LG[2] = pParams[6]); texelPieceEvaluationsV2LG[10] = -(texelPieceEvaluationsV2LG[3] = pParams[7]); texelPieceEvaluationsV2LG[11] = -(texelPieceEvaluationsV2LG[4] = pParams[8]); texelPieceEvaluationsV2LG[12] = -(texelPieceEvaluationsV2LG[5] = pParams[9]); int c = 10; for (int p = 1; p < 7; p++) { for (int s = 0; s < 64; s++) { texelTuningRuntimePositionalValsV2EG[p + 7][blackSidedSquares[s]] = -(texelTuningRuntimePositionalValsV2EG[p][s] = pParams[c++]); texelTuningRuntimePositionalValsV2LG[p + 7][blackSidedSquares[s]] = -(texelTuningRuntimePositionalValsV2LG[p][s] = pParams[c++]); } } return; for (int p = 2; p < 7; p++) { for (int a = 0; a < 15; a++) { if (a != 14) { texelMobilityDiagonalEG[p + 7, a] = -(texelMobilityDiagonalEG[p, a] = pParams[c++]); texelMobilityDiagonalLG[p + 7, a] = -(texelMobilityDiagonalLG[p, a] = pParams[c++]); } texelMobilityStraightEG[p + 7, a] = -(texelMobilityStraightEG[p, a] = pParams[c++]); texelMobilityStraightLG[p + 7, a] = -(texelMobilityStraightLG[p, a] = pParams[c++]); } } for (int i = 0; i < 12; i++) { texelKingSafetySREvaluationsPT1EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT2EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT3EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT4EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT5EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT6EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT1LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT2LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT3LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT4LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT5LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT6LG[i] = pParams[c++]; } } private void PrintDefinedTexelParams(int[] pParams) { int c = 0; for (int t = 0; t < 3; t++) { SNAPSHOT_WRITLINE_REPLACEMENT(TEXELPRINT_GAMEPARTS[t]); for (int p = 0; p < 6; p++) { SNAPSHOT_WRITLINE_REPLACEMENT(TEXELPRINT_PIECES[p]); texelTuningVals[t, p] = new int[64]; for (int s = 0; s < 64; s++) { if (s % 8 == 0 && s != 0) SNAPSHOT_WRITLINE_REPLACEMENT(); SNAPSHOT_WRITLINE_REPLACEMENT((texelTuningVals[t, p][s] = pParams[c++]) + ", "); } SNAPSHOT_WRITLINE_REPLACEMENT(); } } piecePositionEvals = GetInterpolatedProcessedValues(texelTuningVals); } public void TLMTuning(List<TLM_ChessGame> pDataset) { int tGameDataSetLen = pDataset.Count; int[,][] tRatio = new int[33, 6][]; int[,][] tTotalMoves = new int[33, 6][]; double[,][] tSummedRatios = new double[33, 6][]; double[,][] tSummedDataAmount = new double[33, 6][]; double[,][] tTuningResults = new double[33, 6][]; for (int t = 1; t < 33; t++) { for (int p = 0; p < 6; p++) { tRatio[t, p] = new int[64]; tTotalMoves[t, p] = new int[64]; tSummedRatios[t, p] = new double[64]; tSummedDataAmount[t, p] = new double[64]; tTuningResults[t, p] = new double[64]; } } for (int j = 0; j < tGameDataSetLen; j++) { TLM_ChessGame tGame = pDataset[j]; int tGR = tGame.gameResult - 1; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count - 5; for (int i = 0; i < tL; i++) { if (tGame.isMoveNonTactical[i]) { int tPieceAmount = ULONG_OPERATIONS.CountBits(allPieceBitboard); for (int s = 0; s < 64; s++) { int tPT = pieceTypeArray[s] - 1; if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, s)) { tTotalMoves[tPieceAmount, tPT][s]++; tRatio[tPieceAmount, tPT][s] += tGR; } else if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, s)) { int b = blackSidedSquares[s]; tTotalMoves[tPieceAmount, tPT][b]++; tRatio[tPieceAmount, tPT][b] += tGR; } } } PlainMakeMove(tGame.actualMoves[i]); } } double[,] allMultipliers = new double[33, 33]; for (int sh = 0; sh < 33; sh++) { for (int i = 0; i < 33; i++) { allMultipliers[sh, i] = MultiplierFunction(i, sh); } } for (int t = 1; t < 33; t++) { for (int p = 0; p < 6; p++) { for (int s = 0; s < 64; s++) { for (int t2 = 1; t2 < 33; t2++) { double cmult = allMultipliers[t, t2]; tSummedRatios[t, p][s] += tRatio[t2, p][s] * cmult; tSummedDataAmount[t, p][s] += tTotalMoves[t2, p][s] * cmult; } tTuningResults[t, p][s] = TTT(tSummedRatios[t, p][s], tSummedDataAmount[t, p][s]); } } } int c = 0; int[] tparams = new int[1152]; for (int t = 1; t < 33; t += 15) { if (t == 31) t = 32; SNAPSHOT_WRITLINE_REPLACEMENT("PieceCount = " + t + ": "); for (int p = 0; p < 6; p++) { SNAPSHOT_WRITLINE_REPLACEMENT(TEXELPRINT_PIECES[p]); for (int s = 0; s < 64; s++) { if (s % 8 == 0 && s != 0) SNAPSHOT_WRITLINE_REPLACEMENT(); SNAPSHOT_WRITLINE_REPLACEMENT((tparams[c++] = (int)(tTuningResults[t, p][s] * 100)).ToString().Replace(",", ".") + "("+ (int)tSummedDataAmount[t, p][s] + ")"+ ", "); } SNAPSHOT_WRITLINE_REPLACEMENT(); } } string tS = "PARAMS: {"; for (int i = 0; i < tparams.Length; i++) tS += tparams[i] + ","; tS = tS.Substring(0, tS.Length - 1) + "}\n"; SNAPSHOT_WRITLINE_REPLACEMENT(tS); TexelTuning(pDataset, tparams); } private double TTT(double d1, double d2) { if (d2 == 0) return 0; return d1 /d2; } public void TexelTuning(List<TLM_ChessGame> pDataset, int[] pCurBestParams) { Stopwatch sw = Stopwatch.StartNew(); string tPath = PathManager.GetTXTPath("OTHER/TEXEL_TUNING"); int paramCount = pCurBestParams.Length; double bestAvrgCost = CalculateAverageTexelCost(pDataset, pCurBestParams); SNAPSHOT_WRITLINE_REPLACEMENT("CUR PARAMS COST: " + bestAvrgCost); int packetSize = Math.Clamp(paramCount /ENGINE_VALS.CPU_CORES, 1, 100000); paramsLowerLimits = new int[paramCount]; paramsUpperLimits = new int[paramCount]; for (int i = 0; i < paramCount; i++) { int lim = i < 10 ? 100000 : 200; paramsLowerLimits[i] = -lim; paramsUpperLimits[i] = lim; } SNAPSHOT_WRITLINE_REPLACEMENT("PARAM-COUNT: " + paramCount); SNAPSHOT_WRITLINE_REPLACEMENT("PACKET-SIZE: " + packetSize); while (packetSize <= paramCount) { BOT_MAIN.TEXELfinished = 0; int lM = 0, tC = 0; ulong tUL = 0ul; for (int m = packetSize; lM < paramCount; m += packetSize) { if (m > paramCount) m = paramCount; tUL = ULONG_OPERATIONS.SetBitToOne(tUL, ++tC); lM = m; } tC = lM = 0; for (int m = packetSize; lM < paramCount; m += packetSize) { if (m > paramCount) m = paramCount; tC++; BOT_MAIN.boardManagers[tC].SetPlayTexelVals(pDataset, lM, m, pCurBestParams, paramsLowerLimits, paramsUpperLimits, tC, tUL); ThreadPool.QueueUserWorkItem(new WaitCallback(BOT_MAIN.boardManagers[tC].TexelTuningThreadedPackage)); lM = m; } packetSize = paramCount + 1; int tmod = 0; while (tC != BOT_MAIN.TEXELfinished) { if (++tmod % 20 == 0) { WriteTexelParamsToTXT(tPath, BOT_MAIN.curTEXELPARAMS); SNAPSHOT_WRITLINE_REPLACEMENT(CalculateAverageTexelCost(pDataset, BOT_MAIN.curTEXELPARAMS) + " | "+ BOT_MAIN.TEXELadjustmentsmade); SNAPSHOT_WRITLINE_REPLACEMENT(ULONG_OPERATIONS.GetBitVisualization(BOT_MAIN.TEXELfinishedwithoutimpovement)); } Thread.Sleep(100); } SNAPSHOT_WRITLINE_REPLACEMENT("One Thread Generation FINISHED! :) :) :)"); pCurBestParams = BOT_MAIN.curTEXELPARAMS; } sw.Stop(); WriteTexelParamsToTXT(tPath, BOT_MAIN.curTEXELPARAMS); SNAPSHOT_WRITLINE_REPLACEMENT("END COST: " + CalculateAverageTexelCost(pDataset, BOT_MAIN.curTEXELPARAMS)); SNAPSHOT_WRITLINE_REPLACEMENT(BOT_MAIN.TEXELadjustmentsmade); SNAPSHOT_WRITLINE_REPLACEMENT(sw.ElapsedMilliseconds); } public void TexelTuningThreadedPackage(object obj) { SNAPSHOT_WRITLINE_REPLACEMENT("Started CThreadID [" + customThreadID + "] which is handling Params ["+ threadFrom + "] - ["+ threadTo + "]"); bool firstIter = true; do { double bestAvrgCost = CalculateAverageTexelCost(threadDataset, threadParams); int adjust_val = firstIter ? 512 : 8; do { adjust_val /= 2; bool improvedAvrgCost = true; while (improvedAvrgCost) { improvedAvrgCost = false; for (int i = threadFrom; i < threadTo; i++) { bool improvedWithThisParam = true; int tadjustval = adjust_val; bool lastTimeMaximized = false, lastTimeMinimized = false; while (improvedWithThisParam) { improvedWithThisParam = false; int[] curParams = (int[])threadParams.Clone(); int paramBefore = curParams[i]; curParams[i] = Math.Clamp(paramBefore + adjust_val, paramsLowerLimits[i], paramsUpperLimits[i]); double curAvrgCost = CalculateAverageTexelCost(threadDataset, curParams); if (curAvrgCost < bestAvrgCost) { improvedAvrgCost = true; improvedWithThisParam = true; SNAPSHOT_WRITLINE_REPLACEMENT("Improved Param [" + i + "] at CThreadID ["+ customThreadID + "]: +"+ adjust_val + " ("+ GetDoublePrecentageString(bestAvrgCost - curAvrgCost) + ")"); bestAvrgCost = curAvrgCost; threadParams = curParams; BOT_MAIN.TEXELadjustmentsmade++; BOT_MAIN.TEXELfinishedwithoutimpovement = ulAllThreadIDsUnfinished; if (lastTimeMaximized) { adjust_val *= 4; lastTimeMaximized = false; } else lastTimeMaximized = true; lastTimeMinimized = false; } else { curParams[i] = Math.Clamp(paramBefore - adjust_val, paramsLowerLimits[i], paramsUpperLimits[i]); curAvrgCost = CalculateAverageTexelCost(threadDataset, curParams); if (curAvrgCost < bestAvrgCost) { improvedAvrgCost = true; improvedWithThisParam = true; SNAPSHOT_WRITLINE_REPLACEMENT("Improved Param [" + i + "] at CThreadID ["+ customThreadID + "]: -"+ adjust_val + " ("+ GetDoublePrecentageString(bestAvrgCost - curAvrgCost) + ")"); bestAvrgCost = curAvrgCost; threadParams = curParams; BOT_MAIN.TEXELadjustmentsmade++; BOT_MAIN.TEXELfinishedwithoutimpovement = ulAllThreadIDsUnfinished; if (lastTimeMinimized) { adjust_val *= 4; lastTimeMinimized = false; } else lastTimeMinimized = true; lastTimeMaximized = false; } } if (adjust_val != 1) adjust_val /= 2; for (int j = threadFrom; j < threadTo; j++) { BOT_MAIN.curTEXELPARAMS[j] = threadParams[j]; } threadParams = (int[])BOT_MAIN.curTEXELPARAMS.Clone(); bestAvrgCost = CalculateAverageTexelCost(threadDataset, threadParams); } adjust_val = tadjustval; } } } while (adjust_val != 1); BOT_MAIN.TEXELfinishedwithoutimpovement = ULONG_OPERATIONS.SetBitToZero(BOT_MAIN.TEXELfinishedwithoutimpovement, customThreadID); SNAPSHOT_WRITLINE_REPLACEMENT("FULLY FINISHED " + customThreadID + ". IMPROVEMENT THREAD PACKAGE CYCLE"); firstIter = false; } while (BOT_MAIN.TEXELfinishedwithoutimpovement != 0); BOT_MAIN.TEXELfinished++; } private void WriteTexelParamsToTXT(string pPath, int[] pParams) { try { string tS = "PARAMS: {"; for (int i = 0; i < pParams.Length; i++) tS += pParams[i] + ","; tS = tS.Substring(0, tS.Length - 1) + "}\n"; File.AppendAllText(pPath, tS); } catch { SNAPSHOT_WRITLINE_REPLACEMENT("Mal wieder TXT zu lange gebraucht um zu aktualisieren."); } } private double costSum = 0d; private int texelCostMovesEvaluated = 0; private double CalculateAverageTexelCost(List<TLM_ChessGame> tDataset, int[] pParams, bool pFullCost = true) { costSum = 0d; texelCostMovesEvaluated = 0; SetupTexelEvaluationParams(pParams); int tGameDataSetLen = tDataset.Count; int start = 0, end = tGameDataSetLen; if (!pFullCost) { end = (start = globalRandom.Next(0, end - 256)) + 256; } for (int j = start; j < end; j++) { TLM_ChessGame tGame = tDataset[j]; double tGR = tGame.gameResult; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count - 5; texelCostMovesEvaluated += tL; for (int i = 0; i < tL; i++) { costSum += TexelCost(tGR - TexelTuningSigmoid(TexelEvaluate())); PlainMakeMove(tGame.actualMoves[i]); } } return costSum /texelCostMovesEvaluated; } private double CalculateAverageTexelCostThreadedVersionLEGACYDOESNTWORK(List<TLM_ChessGame> tDataset, int[] pParams) { Stopwatch sw = Stopwatch.StartNew(); BOT_MAIN.TEXELcostSum = 0d; BOT_MAIN.TEXELfinished = 0; BOT_MAIN.TEXELcostMovesEvaluated = 0; int tGameDataSetLen = tDataset.Count; int gamesPerThread = tGameDataSetLen /ENGINE_VALS.CPU_CORES; for (int i = 0; i < ENGINE_VALS.CPU_CORES - 1; i++) { } for (int i = 0; i < ENGINE_VALS.CPU_CORES - 1; i++) { } while (BOT_MAIN.TEXELfinished != ENGINE_VALS.CPU_CORES) Thread.Sleep(1); sw.Stop(); return BOT_MAIN.TEXELcostSum /BOT_MAIN.TEXELcostMovesEvaluated; } public void SetPlayThroughVals(List<TLM_ChessGame> pDataset, int pFrom, int pTo) { threadDataset = pDataset; threadFrom = pFrom; threadTo = pTo; } public void SetPlayTexelVals(List<TLM_ChessGame> pDataset, int pFrom, int pTo, int[] pTexelParams, int[] pLowerLimits, int[] pUpperLimits, int pThreadID, ulong pUL) { threadDataset = pDataset; threadFrom = pFrom; threadTo = pTo; threadParams = pTexelParams; paramsLowerLimits = pLowerLimits; paramsUpperLimits = pUpperLimits; customThreadID = pThreadID; ulAllThreadIDsUnfinished = pUL; } public void PlayThroughSetOfGames(object obj) { SNAPSHOT_WRITLINE_REPLACEMENT(threadFrom + "->"+ threadTo); int sortedOut = 0; for (int j = threadFrom; j < threadTo; j++) { TLM_ChessGame tGame = threadDataset[j]; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count; for (int i = 0; i < tL; i++) { int tQuietEval = isWhiteToMove ? QuiescenceWhite(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, 0, PreMinimaxCheckCheckWhite(), NULL_MOVE) : QuiescenceBlack(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, 0, PreMinimaxCheckCheckBlack(), NULL_MOVE); bool tB; tGame.isMoveNonTactical.Add(tB = (Evaluate() == tQuietEval && i > 4)); if (!tB) sortedOut++; PlainMakeMove(tGame.actualMoves[i]); } } BOT_MAIN.TEXELsortedout += sortedOut; BOT_MAIN.TEXELfinished++; } public void CalculateAverageTexelCostThreadFunction(object obj) { SetupTexelEvaluationParams(threadParams); double d = 0d; for (int j = threadFrom; j < threadTo; j++) { TLM_ChessGame tGame = threadDataset[j]; double tGR = tGame.gameResult; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count - 5; BOT_MAIN.TEXELcostMovesEvaluated += tL; for (int i = 0; i < tL; i++) { d += TexelCost(tGR - TexelTuningSigmoid(TexelEvaluate())); PlainMakeMove(tGame.actualMoves[i]); } } BOT_MAIN.TEXELcostSum += d; BOT_MAIN.TEXELfinished++; } private void ConsoleWriteLineTuneArray<T>(T[,][] pArr) { for (int j = 0; j < 3; j++) { SNAPSHOT_WRITLINE_REPLACEMENT("{"); for (int k = 0; k < 6; k++) { SNAPSHOT_WRITLINE_REPLACEMENT("{"); for (int s = 0; s < 64; s++) SNAPSHOT_WRITLINE_REPLACEMENT(pArr[j, k][s] + ", "); SNAPSHOT_WRITLINE_REPLACEMENT("\n}"); } SNAPSHOT_WRITLINE_REPLACEMENT("}"); } } private void Tune(string pGameCGFF, double pLearningRate) { TLM_ChessGame tGame = CGFF.GetGame(pGameCGFF); LoadFenString(tGame.startFen); double tDGameResult = tGame.gameResult; foreach (int hMove in tGame.hashedMoves) { Tune(tDGameResult, pLearningRate); List<Move> moveOptionList = new List<Move>(); GetLegalMoves(ref moveOptionList); int tL = moveOptionList.Count; for (int i = 0; i < tL; i++) { Move tMove = moveOptionList[i]; if (tMove.moveHash == hMove) { PlainMakeMove(tMove); tL = -1; break; } } if (tL != -1) break; } } private void Tune(double pGameResult, double pLearningRate) { int tPC = ULONG_OPERATIONS.CountBits(allPieceBitboard); double oneThroughPieceCount = 1d /tPC; double egMult = earlyGameMultipliers[tPC], mgMult = middleGameMultipliers[tPC], lgMult = lateGameMultipliers[tPC]; double tTexelResult = TexelEvaluateF(); double tSigmoidedTexelResult = TexelSigmoid(tTexelResult); double tDif = tSigmoidedTexelResult - pGameResult; double tM = oneThroughPieceCount * TexelCostDerivative(tDif) * TexelSigmoidDerivative(tTexelResult) * pLearningRate; sumCostVals += lastCostVal = TexelCost(tDif); costCalculations++; for (int i = 0; i < 64; i++) { if (ULONG_OPERATIONS.IsBitZero(allPieceBitboard, i)) continue; int tPT = pieceTypeArray[i] - 1, tI = i; if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, i)) tI = blackSidedSquares[i]; texelTuningAdjustIterations[tPT, tI]++; } } private double TexelEvaluateF() { texelTuningRuntimeVals = GetInterpolatedProcessedValues(texelTuningVals); return TexelEvaluate(); } private int TexelEvaluate() { int tEvalEG = 0, tEvalLG = 0, tProgress = 0; ulong[] attkULs = new ulong[14]; for (int p = 0; p < 64; p++) { if (((int)(allPieceBitboard >> p) & 1) == 0) continue; int aPT = pieceTypeArray[p], tPT = aPT + 7 * ((int)(blackPieceBitboard >> p) & 1); tEvalEG += texelTuningRuntimePositionalValsV2EG[tPT][p] + texelPieceEvaluationsV2EG[tPT]; tEvalLG += texelTuningRuntimePositionalValsV2LG[tPT][p] + texelPieceEvaluationsV2LG[tPT]; tProgress += pieceTypeGameProgressImpact[tPT]; } if (tProgress > 24) tProgress = 24; return (int)(earlyGameMultipliers[tProgress] * tEvalEG + lateGameMultipliers[tProgress] * tEvalLG); } private const double TexelK = 0.2; private double TexelTuningSigmoid(double pVal) { return 2d /(1 + Math.Pow(10, -TexelK * pVal /400)); } private double TexelSigmoid(double pVal) { return 2d /(Math.Exp(-0.04d * pVal) + 1d); } private double TexelSigmoidDerivative(double pVal) { double d = Math.Exp(-0.04d * pVal); return 2d * d /(25d * (d + 1d) * (d + 1d)); } private double TexelCost(double pVal) { return pVal * pVal; } private double TexelCostDerivative(double pVal) { return 2 * pVal; } private char[] fenPieces = new char[7] { 'z', 'p', 'n', 'b', 'r', 'q', 'k' }; private string[] squareNames = new string[64] { "a1", "b1", "c1", "d1", "e1", "f1", "g1", "h1", "a2", "b2", "c2", "d2", "e2", "f2", "g2", "h2", "a3", "b3", "c3", "d3", "e3", "f3", "g3", "h3", "a4", "b4", "c4", "d4", "e4", "f4", "g4", "h4", "a5", "b5", "c5", "d5", "e5", "f5", "g5", "h5", "a6", "b6", "c6", "d6", "e6", "f6", "g6", "h6", "a7", "b7", "c7", "d7", "e7", "f7", "g7", "h7", "a8", "b8", "c8", "d8", "e8", "f8", "g8", "h8"}; public string CreateFenString() { string rFEN = ""; for (int i = 7; i >= 0; i--) { int t = 0; for (int j = 0; j < 8; j++) { int sq = i * 8 + j; if (pieceTypeArray[sq] != 0) { if (t != 0) rFEN += t; t = 0; } if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, sq)) { switch (pieceTypeArray[sq]) { case 0: t++; SNAPSHOT_WRITLINE_REPLACEMENT("???"); break; case 1: rFEN += 'P'; break; case 2: rFEN += 'N'; break; case 3: rFEN += 'B'; break; case 4: rFEN += 'R'; break; case 5: rFEN += 'Q'; break; case 6: rFEN += 'K'; break; } } else { switch (pieceTypeArray[sq]) { case 0: t++; break; case 1: rFEN += 'p'; break; case 2: rFEN += 'n'; break; case 3: rFEN += 'b'; break; case 4: rFEN += 'r'; break; case 5: rFEN += 'q'; break; case 6: rFEN += 'k'; break; } } } if (t != 0) rFEN += t; if (i != 0) rFEN += "/"; } rFEN += (isWhiteToMove ? " w": " b"); rFEN += (whiteCastleRightKingSide ? " K": " "); rFEN += (whiteCastleRightQueenSide ? "Q": ""); rFEN += (blackCastleRightKingSide ? "k": ""); rFEN += (blackCastleRightQueenSide ? "q": ""); if (!whiteCastleRightKingSide && !whiteCastleRightQueenSide && !blackCastleRightKingSide && !blackCastleRightQueenSide) rFEN += "-"; if (enPassantSquare < 64) rFEN += " "+ squareNames[enPassantSquare] + " "; else rFEN += " - "; return rFEN + fiftyMoveRuleCounter + " "+ ((happenedHalfMoves - happenedHalfMoves % 2) /2); } public void LoadFenString(string fenStr) { debugFEN = fenStr; lastMadeMove = NULL_MOVE; zobristKey = 0ul; whitePieceBitboard = blackPieceBitboard = allPieceBitboard = 0ul; for (int i = 0; i < 64; i++) pieceTypeArray[i] = 0; string[] spaceSpl = fenStr.Split(' '); string[] rowSpl = spaceSpl[0].Split('/'); string epstr = spaceSpl[3]; if (epstr == "-") enPassantSquare = 65; else enPassantSquare = (epstr[0] - 'a') + 8 * (epstr[1] - '1'); isWhiteToMove = true; if (spaceSpl[1] == "b") isWhiteToMove = false; if (!isWhiteToMove) zobristKey ^= blackTurnHash; string crstr = spaceSpl[2]; whiteCastleRightKingSide = whiteCastleRightQueenSide = blackCastleRightKingSide = blackCastleRightQueenSide = false; int crStrL = crstr.Length; for (int i = 0; i < crStrL; i++) { switch (crstr[i]) { case 'K': whiteCastleRightKingSide = true; break; case 'Q': whiteCastleRightQueenSide = true; break; case 'k': blackCastleRightKingSide = true; break; case 'q': blackCastleRightQueenSide = true; break; } } fiftyMoveRuleCounter = Convert.ToInt32(spaceSpl[4]); happenedHalfMoves = Convert.ToInt32(spaceSpl[5]) * 2; if (!isWhiteToMove) happenedHalfMoves++; int tSq = 0; for (int i = rowSpl.Length; i-- > 0;) { string tStr = rowSpl[i]; int tStrLen = tStr.Length; for (int c = 0; c < tStrLen; c++) { char tChar = tStr[c]; if (Char.IsDigit(tChar)) tSq += tChar - '0'; else { bool tCol = Char.IsLower(tChar); if (tCol) blackPieceBitboard = ULONG_OPERATIONS.SetBitToOne(blackPieceBitboard, tSq); else whitePieceBitboard = ULONG_OPERATIONS.SetBitToOne(whitePieceBitboard, tSq); if (tChar == 'k') blackKingSquare = tSq; else if (tChar == 'K') whiteKingSquare = tSq; pieceTypeArray[tSq] = Array.IndexOf(fenPieces, Char.ToLower(tChar)); if (tCol) zobristKey ^= pieceHashesBlack[tSq, pieceTypeArray[tSq]]; else zobristKey ^= pieceHashesWhite[tSq, pieceTypeArray[tSq]]; tSq++; } } } if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; zobristKey ^= enPassantSquareHashes[enPassantSquare]; allPieceBitboard = whitePieceBitboard | blackPieceBitboard; if (zobristKey == 16260251586586513106) moveHashList.Clear(); else { moveHashList.Clear(); moveHashList.Add(1); moveHashList.Add(2); moveHashList.Add(3); } } private ulong[,] pieceHashesWhite = new ulong[64, 7], pieceHashesBlack = new ulong[64, 7]; private ulong blackTurnHash, whiteKingSideRochadeRightHash, whiteQueenSideRochadeRightHash, blackKingSideRochadeRightHash, blackQueenSideRochadeRightHash; private ulong[] enPassantSquareHashes = new ulong[66]; private Dictionary<ulong, int> singleCheckCaseBackup = new Dictionary<ulong, int>(); private void InitZobrist() { Random rng = new Random(31415926); for (int sq = 0; sq < 64; sq++) { enPassantSquareHashes[sq] = ULONG_OPERATIONS.GetRandomULONG(rng); for (int it = 1; it < 7; it++) { pieceHashesWhite[sq, it] = ULONG_OPERATIONS.GetRandomULONG(rng); pieceHashesBlack[sq, it] = ULONG_OPERATIONS.GetRandomULONG(rng); } } blackTurnHash = ULONG_OPERATIONS.GetRandomULONG(rng); whiteKingSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); whiteQueenSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); blackKingSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); blackQueenSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); } public void SetKnightMasks(ulong[] uls) { knightSquareBitboards = uls; } public void SetKingMasks(ulong[] uls) { kingSquareBitboards = uls; } private Move[,] whiteEnPassantMoves = new Move[64, 64]; private Move[,] blackEnPassantMoves = new Move[64, 64]; private bool[] epValidationArray = new bool[64] { false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true , true , true , true , true , true , true , true, true , true , true , true , true , true , true , true, true , true , true , true , true , true , true , true, true , true , true , true , true , true , true , true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false }; private ulong[] kingSafetyRing1 = new ulong[64], kingSafetyRing2 = new ulong[64]; private ulong[] kingSafetySpecialRingW = new ulong[64], kingSafetySpecialRingB = new ulong[64]; private ulong[] rowPrecalcs = new ulong[8], columnPrecalcs = new ulong[8]; const ulong columnUL = 0x101010101010101, rowUL = 0b11111111; private void PrecalculateKingSafetyBitboards() { for (int i = 0; i < 8; i++) { rowPrecalcs[i] = rowUL << (8 * i); columnPrecalcs[i] = columnUL << i; } for (int i = 0; i < 64; i++) { int tMod = i % 8; int tRow = (i - tMod) /8; ulong tULC = columnPrecalcs[tMod], tULR = rowPrecalcs[tRow]; ulong tULC2 = columnPrecalcs[tMod], tULR2 = rowPrecalcs[tRow]; if (tMod < 7) tULC |= columnPrecalcs[tMod + 1]; if (tMod > 0) tULC |= columnPrecalcs[tMod - 1]; if (tRow < 7) tULR |= rowPrecalcs[tRow + 1]; if (tRow > 0) tULR |= rowPrecalcs[tRow - 1]; if (tMod < 6) tULC2 |= columnPrecalcs[tMod + 2]; if (tMod > 1) tULC2 |= columnPrecalcs[tMod - 2]; if (tRow < 6) tULR2 |= rowPrecalcs[tRow + 2]; if (tRow > 1) tULR2 |= rowPrecalcs[tRow - 2]; tULR2 |= tULR; tULC2 |= tULC; kingSafetyRing1[i] = ULONG_OPERATIONS.SetBitToZero(tULR & tULC, i); kingSafetyRing2[i] = ULONG_OPERATIONS.SetBitsToZero(tULR2 & tULC2, i, i + 1, i - 1, i + 7, i + 8, i + 9, i - 7, i - 8, i - 9); } for (int i = 0; i < 64; i++) { if (i < 56) kingSafetySpecialRingW[i] = ULONG_OPERATIONS.SetBitToZero(kingSafetyRing1[i] | kingSafetyRing1[i + 8], i); else kingSafetySpecialRingW[i] = kingSafetyRing1[i]; if (i > 7) kingSafetySpecialRingB[i] = ULONG_OPERATIONS.SetBitToZero(kingSafetyRing1[i] | kingSafetyRing1[i - 8], i); else kingSafetySpecialRingB[i] = kingSafetyRing1[i]; } } private void PrecalculateEnPassantMoves() { for (int i = 0; i < 64; i++) { if (!epValidationArray[i]) continue; for (int j = 0; j < 64; j++) { if (i == j) continue; if (Math.Abs(i - j) > 9) continue; if (!epValidationArray[j]) continue; whiteEnPassantMoves[i, j] = new Move(false, i, j, j - 8); blackEnPassantMoves[i, j] = new Move(false, i, j, j + 8); } } } private void PawnAttackBitboards() { for (int sq = 0; sq < 64; sq++) { ulong u = 0ul; if (sq % 8 != 0) u = ULONG_OPERATIONS.SetBitToOne(u, sq + 7); if (sq % 8 != 7) u = ULONG_OPERATIONS.SetBitToOne(u, sq + 9); whitePawnAttackSquareBitboards[sq] = u; u = 0ul; if (sq % 8 != 0 && sq - 9 > -1) u = ULONG_OPERATIONS.SetBitToOne(u, sq - 9); if (sq % 8 != 7 && sq - 7 > -1) u = ULONG_OPERATIONS.SetBitToOne(u, sq - 7); blackPawnAttackSquareBitboards[sq] = u; } } private int[] squareConnectivesPrecalculationArray = new int[4096]; public int[] squareConnectivesCrossDirsPrecalculationArray { get; set; } = new int[4096]; private ulong[] squareConnectivesPrecalculationRayArray = new ulong[4096]; private ulong[] squareConnectivesPrecalculationLineArray = new ulong[4096]; private List<Dictionary<ulong, int>> rayCollidingSquareCalculations = new List<Dictionary<ulong, int>>(); private readonly int[] maxIntWithSpecifiedBitcount = new int[8] { 0, 0b1, 0b11, 0b111, 0b1111, 0b11111, 0b111111, 0b1111111 }; private List<ulong> differentRays = new List<ulong>(); private void SquareConnectivesPrecalculations() { for (int square = 0; square < 64; square++) { rayCollidingSquareCalculations.Add(new Dictionary<ulong, int>()); rayCollidingSquareCalculations[square].Add(0ul, square); for (int square2 = 0; square2 < 64; square2++) { if (square == square2) continue; int t = 0, t2 = 0, difSign = Math.Sign(square2 - square), itSq = square, g = 0; ulong tRay = 0ul, tExclRay = 0ul; List<int> tRayInts = new List<int>(); if (difSign == -1) g = 7; if (square % 8 == square2 % 8) { t2 = t = 1; while ((itSq += difSign * 8) < 64 && itSq > -1) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } } else if ((square - square % 8) == (square2 - square2 % 8)) { t = 1; t2 = -1; while ((itSq += difSign) % 8 != g && itSq > -1 && itSq < 64) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } } else { int dif = Math.Abs(square2 - square); if (dif % 7 == 0) { t = 2; t2 = 2; g = (difSign == 1) ? 7 : 0; while ((itSq += difSign * 7) % 8 != g && itSq < 64 && itSq > -1) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } if (ULONG_OPERATIONS.IsBitZero(tRay, square2)) { t2 = t = 0; tRay = 0ul; } } else if (dif % 9 == 0) { t = 2; t2 = -2; if (square == 0 && square2 == 63 || square == 63 && square2 == 0) SNAPSHOT_WRITLINE_REPLACEMENT("!"); while ((itSq += difSign * 9) % 8 != g && itSq < 64 && itSq > -1) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } if (ULONG_OPERATIONS.IsBitZero(tRay, square2)) { t2 = t = 0; tRay = 0ul; } } } if (square == 0 && square2 == 63) { t2 = t = 2; tRayInts.Clear(); tExclRay = tRay = ULONG_OPERATIONS.SetBitsToOne(0ul, 9, 18, 27, 36, 45, 54, 63); tRayInts = new List<int>() { 9, 18, 27, 36, 45, 54, 63 }; } else if (square2 == 0 && square == 63) { t = 2; tRayInts.Clear(); t2 = -2; tExclRay = tRay = ULONG_OPERATIONS.SetBitsToOne(0ul, 0, 9, 18, 27, 36, 45, 54); tRayInts = new List<int>() { 54, 45, 36, 27, 18, 9, 0 }; } if (tRay != 0ul && !differentRays.Contains(tRay)) { differentRays.Add(tRay); int ccount, combI = maxIntWithSpecifiedBitcount[ccount = ULONG_OPERATIONS.CountBits(tRay)]; do { ulong curAllPieceBitboard = 0ul; int solution = square; for (int j = 0; j < ccount; j++) { if (((combI >> j) & 1) == 1) { curAllPieceBitboard = ULONG_OPERATIONS.SetBitToOne(curAllPieceBitboard, tRayInts[j]); if (solution == square) solution = tRayInts[j]; } } rayCollidingSquareCalculations[square].Add(curAllPieceBitboard, solution); } while (--combI != 0); } squareConnectivesPrecalculationArray[square << 6 | square2] = t; squareConnectivesPrecalculationRayArray[square << 6 | square2] = tRay; squareConnectivesCrossDirsPrecalculationArray[square << 6 | square2] = t2; if (t != 0) squareConnectivesPrecalculationLineArray[square << 6 | square2] = (square == 0 && square2 == 63 || square2 == 0 && square == 63) ? tExclRay : ULONG_OPERATIONS.SetBitToOne(tExclRay, square2); if (squareConnectivesPrecalculationLineArray[square << 6 | square2] == 0ul && ULONG_OPERATIONS.IsBitOne(knightSquareBitboards[square], square2)) squareConnectivesPrecalculationLineArray[square << 6 | square2] = 1ul << square2; } differentRays.Clear(); } } public void SNAPSHOT_WRITLINE_REPLACEMENT() { } public void SNAPSHOT_WRITLINE_REPLACEMENT(object pStr) { } private string GetDoublePrecentageString(double pVal) { return ((int)(pVal * 1_000_000) /10_000d) + "%"; } private string ReplaceAllULONGIsBitOne(string pCode) { const string METHOD_NAME = "ULONG_OPERATIONS.IsBitOne"; int METHOD_NAME_LEN = METHOD_NAME.Length, iterations = 0; int pIndex = pCode.IndexOf(METHOD_NAME); while (pIndex != -1 && ++iterations < 10_000) { List<int> paramIndexes = new List<int>(); int openedBracketCount = 1, closedBracketCount = 0, a = METHOD_NAME_LEN + pIndex; string tpCode = pCode.Substring(0, pIndex); paramIndexes.Add(a + 1); while (++a < pCode.Length) { switch (pCode[a]) { case '(': openedBracketCount++; break; case ')': if (++closedBracketCount == openedBracketCount) { pIndex = a; a = int.MaxValue - 5; } break; case ',': if (openedBracketCount - closedBracketCount == 1) paramIndexes.Add(a + 1); break; } } if (openedBracketCount == closedBracketCount && paramIndexes.Count == 2) { tpCode += "((int)("+ pCode.Substring(paramIndexes[0], paramIndexes[1] - paramIndexes[0] - 1) + (pCode[paramIndexes[1]] == ' ' ? " >> (": " >> (") + pCode.Substring(paramIndexes[1], pIndex - paramIndexes[1]) + ")) & 1) == 1"+ pCode.Substring(pIndex + 1, pCode.Length - pIndex - 1); } pIndex = (pCode = tpCode).IndexOf(METHOD_NAME); } SNAPSHOT_WRITLINE_REPLACEMENT(iterations + " ITERATIONS"); return pCode; } private string ReplaceAllULONGIsBitZero(string pCode) { const string METHOD_NAME = "ULONG_OPERATIONS.IsBitZero"; int METHOD_NAME_LEN = METHOD_NAME.Length, iterations = 0; int pIndex = pCode.IndexOf(METHOD_NAME); while (pIndex != -1 && ++iterations < 10_000) { List<int> paramIndexes = new List<int>(); int openedBracketCount = 1, closedBracketCount = 0, a = METHOD_NAME_LEN + pIndex; string tpCode = pCode.Substring(0, pIndex); paramIndexes.Add(a + 1); while (++a < pCode.Length) { switch (pCode[a]) { case '(': openedBracketCount++; break; case ')': if (++closedBracketCount == openedBracketCount) { pIndex = a; a = int.MaxValue - 5; } break; case ',': if (openedBracketCount - closedBracketCount == 1) paramIndexes.Add(a + 1); break; } } if (openedBracketCount == closedBracketCount && paramIndexes.Count == 2) { tpCode += "((int)("+ pCode.Substring(paramIndexes[0], paramIndexes[1] - paramIndexes[0] - 1) + (pCode[paramIndexes[1]] == ' ' ? " >>": " >> ") + pCode.Substring(paramIndexes[1], pIndex - paramIndexes[1]) + ") & 1) == 0"+ pCode.Substring(pIndex + 1, pCode.Length - pIndex - 1); } pIndex = (pCode = tpCode).IndexOf(METHOD_NAME); } SNAPSHOT_WRITLINE_REPLACEMENT(iterations + " ITERATIONS"); return pCode; } private string GetThreeDigitSeperatedInteger(int pInt) { string s = pInt.ToString(), r = s[0].ToString(); int t = s.Length % 3; for (int i = 1; i < s.Length; i++) { if (i % 3 == t) r += "."; r += s[i]; } s = ""; for (int i = 0; i < r.Length; i++) s += r[i]; return s; } public double GetAverageDepth() { return (double)depths /(double)searches; } }
public class SNAPSHOT_V01_00_018 : IBoardManager  { public int TEXEL_PARAMS { get; } = 778; private const int BESTMOVE_SORT_VAL = -2_000_000_000; private const int CAPTURE_SORT_VAL = -1_000_000_000; private const int KILLERMOVE_SORT_VAL = -1000; private readonly int[,] MVVLVA_TABLE = new int[7, 7] { { 0, 0, 0, 0, 0, 0, 0 }, { 0, 1500, 1400, 1300, 1200, 1100, 1000 }, { 0, 3500, 3400, 3300, 3200, 3100, 3000 }, { 0, 4500, 4400, 4300, 4200, 4100, 4000 }, { 0, 5500, 5400, 5300, 5200, 5100, 5000 }, { 0, 9500, 9400, 9300, 9200, 9100, 9000 }, { 0, 0, 0, 0, 0, 0, 0 }}; private int BOARD_MANAGER_ID = -1; private bool debugSearchDepthResults = false; private bool debugSortResults = false; private RookMovement rookMovement; private BishopMovement bishopMovement; private QueenMovement queenMovement; private KnightMovement knightMovement; private KingMovement kingMovement; private WhitePawnMovement whitePawnMovement; private BlackPawnMovement blackPawnMovement; private Rays rays; public List<Move> moveOptionList { get; set; } private int[] pieceTypeArray = new int[64]; public ulong whitePieceBitboard, blackPieceBitboard, allPieceBitboard; private ulong zobristKey; private int whiteKingSquare, blackKingSquare, enPassantSquare = 65, happenedHalfMoves = 0, fiftyMoveRuleCounter = 0; private bool whiteCastleRightKingSide, whiteCastleRightQueenSide, blackCastleRightKingSide, blackCastleRightQueenSide; private bool isWhiteToMove; private const ulong WHITE_KING_ROCHADE = 96, WHITE_QUEEN_ROCHADE = 14, BLACK_KING_ROCHADE = 6917529027641081856, BLACK_QUEEN_ROCHADE = 1008806316530991104, WHITE_QUEEN_ATTK_ROCHADE = 12, BLACK_QUEEN_ATTK_ROCHADE = 864691128455135232; private readonly Move mWHITE_KING_ROCHADE = new Move(4, 6, 7, 5), mWHITE_QUEEN_ROCHADE = new Move(4, 2, 0, 3), mBLACK_KING_ROCHADE = new Move(60, 62, 63, 61), mBLACK_QUEEN_ROCHADE = new Move(60, 58, 56, 59); private ulong[] knightSquareBitboards = new ulong[64]; private ulong[] whitePawnAttackSquareBitboards = new ulong[64]; private ulong[] blackPawnAttackSquareBitboards = new ulong[64]; private ulong[] kingSquareBitboards = new ulong[64]; private bool[,] pieceTypeAbilities = new bool[7, 3] { { false, false, false }, { false, false, false }, { false, false, false }, { false, false, true }, { false, true, false }, { false, true, true }, { false, false, false } }; private List<int> moveHashList = new List<int>(); private ulong[] curSearchZobristKeyLine = Array.Empty<ulong>(); private Move[] debugMoveList = new Move[128]; private string debugFEN = ""; private Stopwatch globalTimer = Stopwatch.StartNew(); private Move lastMadeMove; private int depths, searches; private Random globalRandom = new Random(); public SNAPSHOT_V01_00_018(string fen) { Setup(fen); } public void Setup(string pFen) { Stopwatch setupStopwatch = Stopwatch.StartNew(); BOARD_MANAGER_ID = BOT_MAIN.curBoardManagerID; for (int i = 0; i < 33; i++) for (int j = 0; j < 14; j++) piecePositionEvals[i, j] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; for (int i = 0; i < 33; i++) for (int j = 0; j < 14; j++) texelTuningRuntimeVals[i, j] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; for (int i = 0; i < 3; i++) for (int j = 0; j < 6; j++) texelTuningVals[i, j] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; for (int i = 0; i < 14; i++) { texelTuningRuntimePositionalValsV2EG[i] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; texelTuningRuntimePositionalValsV2LG[i] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; } PrecalculateKingSafetyBitboards(); PrecalculateMultipliers(); GetLowNoisePositionalEvaluation(globalRandom); MinimaxRoot(1L); SetupConsoleWrite("[PRECALCS] Zobrist Hashing"); InitZobrist(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Knight Movement"); knightMovement = new KnightMovement(this); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Square Connectives"); SquareConnectivesPrecalculations(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Pawn Attack Bitboards"); PawnAttackBitboards(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Rays"); rays = new Rays(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); queenMovement = new QueenMovement(this); SetupConsoleWrite("[PRECALCS] Rook Movement"); rookMovement = new RookMovement(this, queenMovement); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Bishop Movement"); bishopMovement = new BishopMovement(this, queenMovement); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] King Movement"); kingMovement = new KingMovement(this); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWrite("[PRECALCS] Pawn Movement"); whitePawnMovement = new WhitePawnMovement(this); blackPawnMovement = new BlackPawnMovement(this); PrecalculateEnPassantMoves(); SetupConsoleWriteLine(" (" + setupStopwatch.ElapsedTicks /10_000_000d + "s)"); SetupConsoleWriteLine("[DONE]\n\n"); LoadFenString(pFen); LoadBestTexelParamsIn(); setupStopwatch.Stop(); } private void SetupConsoleWriteLine(string pStr) { if (BOT_MAIN.isFirstBoardManagerInitialized) return; SNAPSHOT_WRITLINE_REPLACEMENT(pStr); } private void SetupConsoleWrite(string pStr) { if (BOT_MAIN.isFirstBoardManagerInitialized) return; SNAPSHOT_WRITLINE_REPLACEMENT(pStr); } public void GetLowNoisePositionalEvaluation(System.Random rng) { int[,][] digitArray = new int[3, 6][]; for (int i = 0; i < 3; i++) for (int j = 0; j < 6; j++) digitArray[i, j] = GetRand64IntArray(rng, -5, 6); lowNoisePositionEvals1 = GetInterpolatedProcessedValues(digitArray); int[,][] digitArray2 = new int[3, 6][]; for (int i = 0; i < 3; i++) for (int j = 0; j < 6; j++) digitArray2[i, j] = GetRand64IntArray(rng, -5, 6); lowNoisePositionEvals2 = GetInterpolatedProcessedValues(digitArray2); } private int[] GetRand64IntArray(System.Random rng, int pMin, int pMax) { return new int[64] { rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax), rng.Next(pMin, pMax) }; } private string GetAIArrayValuesStringRepresentation(int[,][] pArr) { string r = "int[,][] ReLe_AI_RESULT_VALS = new int[3, 6][] {"; for (int i = 0; i < 3; i++) { r += "{"; for (int j = 0; j < 5; j++) { r += GetIntArray64LStringRepresentation(pArr[i, j]) + ","; } r += GetIntArray64LStringRepresentation(pArr[i, 5]) + "},"; } return r.Substring(0, r.Length - 1) + "};"; } private string GetIntArray64LStringRepresentation(int[] p64LArr) { if (p64LArr == null) return ""; string r = "new int[64]{"; for (int i = 0; i < 63; i++) { r += p64LArr[i] + ","; } return r + p64LArr[63] + "}"; } public void TempStuff() { PlayGameOnConsoleAgainstHuman(ENGINE_VALS.DEFAULT_FEN, true, 30_000_000L); } private string[] gameResultStrings = new string[5] { "Black Has Won!", "Draw!", "White Has Won!", "Non Existant Result!", "Game is Ongoing!"}; private int[,][] lowNoisePositionEvals1, lowNoisePositionEvals2; public void ThreadSelfPlay(object obj) { PlayGameAgainstItself(obj); } public void PlayGameAgainstItself(object obj, string pStartFEN = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1", long tickLimitForEngine = ENGINE_VALS.SELF_PLAY_THINK_TIME) { int ttGState; while (BOT_MAIN.goalGameCount > BOT_MAIN.gamesPlayed) { try { string tGameStr; GetLowNoisePositionalEvaluation(globalRandom); LoadFenString(tGameStr = pStartFEN); tGameStr += ";"; int tGState = 3, tmc = 0; bool lowNoiceDecider = globalRandom.NextDouble() < 0.5d; while (tGState == 3) { piecePositionEvals = lowNoiceDecider ? lowNoisePositionEvals1 : lowNoisePositionEvals2; MinimaxRoot(tickLimitForEngine); Move tM = transpositionTable[zobristKey].bestMove; PlainMakeMove(tM); tGameStr += NuCRe.GetNuCRe(tM.moveHash) + ","; BOT_MAIN.movesPlayed++; tGState = GameState(isWhiteToMove); lowNoiceDecider = !lowNoiceDecider; tmc++; } ttGState = tGState; tGameStr += ttGState + 1; SNAPSHOT_WRITLINE_REPLACEMENT(tGameStr); BOT_MAIN.gamesPlayedResultArray[ttGState + 1]++; BOT_MAIN.gamesPlayed++; BOT_MAIN.selfPlayGameStrings.Add(tGameStr); } catch (Exception tE) { SNAPSHOT_WRITLINE_REPLACEMENT(tE.ToString()); } } } public void PlayGameOnConsoleAgainstHuman(string pStartFEN = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1", bool pHumanPlaysWhite = true, long tickLimitForEngine = 10_000_000L) { debugSearchDepthResults = true; LoadFenString(pStartFEN); if (!(pHumanPlaysWhite ^ isWhiteToMove)) { var pVS = Console.ReadLine(); if (pVS == null) return; Move tm = GetMoveOfString(pVS.ToString()); SNAPSHOT_WRITLINE_REPLACEMENT(tm); PlainMakeMove(tm); } int tGState = 3; while (tGState == 3) { MinimaxRoot(tickLimitForEngine); PlayThroughZobristTree(); Move tM = transpositionTable[zobristKey].bestMove; SNAPSHOT_WRITLINE_REPLACEMENT(tM); SNAPSHOT_WRITLINE_REPLACEMENT(CreateFenString()); PlainMakeMove(tM); tGState = GameState(isWhiteToMove); if (tGState != 3 || tM == NULL_MOVE) break; var pV = ""; tM = NULL_MOVE; do { pV = Console.ReadLine(); if (pV == null) continue; tM = GetMoveOfString(pV.ToString()); SNAPSHOT_WRITLINE_REPLACEMENT(tM); } while (tM == NULL_MOVE); PlainMakeMove(tM); tGState = GameState(isWhiteToMove); } } private void PlayThroughZobristTree() { SetJumpState(); SNAPSHOT_WRITLINE_REPLACEMENT("\n- - - - - - - - - - - - -"); int tC = 1; Dictionary<ulong, bool> usedULs = new Dictionary<ulong, bool>(); while (transpositionTable.TryGetValue(zobristKey, out TranspositionEntry tM)) { if (usedULs.ContainsKey(zobristKey)) { SNAPSHOT_WRITLINE_REPLACEMENT(tC + ": AT LEAST ONE REPETION; REST NOT VISIBLE"); break; } SNAPSHOT_WRITLINE_REPLACEMENT(tC + ": "+ tM.bestMove + " > "); usedULs.Add(zobristKey, true); PlainMakeMove(tM.bestMove); tC++; } SNAPSHOT_WRITLINE_REPLACEMENT("- - - - - - - - - - - - -\n"); LoadJumpState(); } public Move? ReturnNextMove(Move? lastMove, long pThinkingTime) { if (lastMove != null) PlainMakeMove(lastMove); if (GameState(isWhiteToMove) != 3) return null; MinimaxRoot(pThinkingTime); if (!transpositionTable.ContainsKey(zobristKey)) return null; Move tm = transpositionTable[zobristKey].bestMove; PlainMakeMove(tm); return tm; } private int[] jmpSt_pieceTypeArray; private ulong jmpSt_whitePieceBitboard, jmpSt_blackPieceBitboard; private ulong jmpSt_zobristKey; private int jmpSt_whiteKingSquare, jmpSt_blackKingSquare, jmpSt_enPassantSquare, jmpSt_happenedHalfMoves, jmpSt_fiftyMoveRuleCounter; private bool jmpSt_whiteCastleRightKingSide, jmpSt_whiteCastleRightQueenSide, jmpSt_blackCastleRightKingSide, jmpSt_blackCastleRightQueenSide; private bool jmpSt_isWhiteToMove; private ulong[] jmpSt_curSearchZobristKeyLine; private int[] jmpSt_moveHashList; public void LoadJumpState() { pieceTypeArray = (int[])jmpSt_pieceTypeArray.Clone(); whitePieceBitboard = jmpSt_whitePieceBitboard; blackPieceBitboard = jmpSt_blackPieceBitboard; zobristKey = jmpSt_zobristKey; whiteKingSquare = jmpSt_whiteKingSquare; blackKingSquare = jmpSt_blackKingSquare; enPassantSquare = jmpSt_enPassantSquare; happenedHalfMoves = jmpSt_happenedHalfMoves; fiftyMoveRuleCounter = jmpSt_fiftyMoveRuleCounter; whiteCastleRightKingSide = jmpSt_whiteCastleRightKingSide; whiteCastleRightQueenSide = jmpSt_whiteCastleRightQueenSide; blackCastleRightKingSide = jmpSt_blackCastleRightKingSide; blackCastleRightQueenSide = jmpSt_blackCastleRightQueenSide; isWhiteToMove = jmpSt_isWhiteToMove; curSearchZobristKeyLine = (ulong[])jmpSt_curSearchZobristKeyLine.Clone(); allPieceBitboard = blackPieceBitboard | whitePieceBitboard; moveHashList = jmpSt_moveHashList.ToList(); } public void SetJumpState() { jmpSt_pieceTypeArray = (int[])pieceTypeArray.Clone(); jmpSt_whitePieceBitboard = whitePieceBitboard; jmpSt_blackPieceBitboard = blackPieceBitboard; jmpSt_zobristKey = zobristKey; jmpSt_whiteKingSquare = whiteKingSquare; jmpSt_blackKingSquare = blackKingSquare; jmpSt_enPassantSquare = enPassantSquare; jmpSt_happenedHalfMoves = happenedHalfMoves; jmpSt_fiftyMoveRuleCounter = fiftyMoveRuleCounter; jmpSt_whiteCastleRightKingSide = whiteCastleRightKingSide; jmpSt_whiteCastleRightQueenSide = whiteCastleRightQueenSide; jmpSt_blackCastleRightKingSide = blackCastleRightKingSide; jmpSt_blackCastleRightQueenSide = blackCastleRightQueenSide; jmpSt_isWhiteToMove = isWhiteToMove; jmpSt_curSearchZobristKeyLine = (ulong[])curSearchZobristKeyLine.Clone(); jmpSt_moveHashList = moveHashList.ToArray(); } private int PreMinimaxCheckCheckWhite() { ulong bitShiftedKingPos = 1ul << whiteKingSquare; int curR = -1; for (int p = 0; p < 64; p++) { if (ULONG_OPERATIONS.IsBitZero(blackPieceBitboard, p)) continue; int tPT; switch (tPT = pieceTypeArray[p]) { case 1: if ((bitShiftedKingPos & blackPawnAttackSquareBitboards[p]) != 0ul) return p; break; case 2: if ((bitShiftedKingPos & knightSquareBitboards[p]) != 0ul) return p; break; case 6: break; default: if ((squareConnectivesPrecalculationLineArray[whiteKingSquare << 6 | p] & allPieceBitboard) == (1ul << p) && pieceTypeAbilities[tPT, squareConnectivesPrecalculationArray[whiteKingSquare << 6 | p]]) { if (curR != -1) return -779; curR = p; } break; } } return curR; } private int PreMinimaxCheckCheckBlack() { ulong bitShiftedKingPos = 1ul << blackKingSquare; int curR = -1; for (int p = 0; p < 64; p++) { if (ULONG_OPERATIONS.IsBitZero(whitePieceBitboard, p)) continue; int tPT; switch (tPT = pieceTypeArray[p]) { case 1: if ((bitShiftedKingPos & whitePawnAttackSquareBitboards[p]) != 0ul) return p; break; case 2: if ((bitShiftedKingPos & knightSquareBitboards[p]) != 0ul) return p; break; case 6: break; default: if ((squareConnectivesPrecalculationLineArray[blackKingSquare << 6 | p] & allPieceBitboard) == (1ul << p) && pieceTypeAbilities[tPT, squareConnectivesPrecalculationArray[blackKingSquare << 6 | p]]) { if (curR != -1) return -779; curR = p; } break; } } return curR; } private int LecacyLeafCheckingPieceCheckWhite(int pStartPos, int pEndPos, int pPieceType) { int tI, tPossibleAttackPiece; if (pPieceType == 1) { if (ULONG_OPERATIONS.IsBitOne(blackPawnAttackSquareBitboards[pEndPos], whiteKingSquare)) return pEndPos; } else if (pPieceType == 2) { if (ULONG_OPERATIONS.IsBitOne(knightSquareBitboards[pEndPos], whiteKingSquare)) return pEndPos; } else if (pPieceType != 6) { tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | pEndPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; } tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | pStartPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; return -1; } private int LecacyLeafCheckingPieceCheckBlack(int pStartPos, int pEndPos, int pPieceType) { int tI, tPossibleAttackPiece; if (pPieceType == 1) { if (ULONG_OPERATIONS.IsBitOne(whitePawnAttackSquareBitboards[pEndPos], blackKingSquare)) return pEndPos; } else if (pPieceType == 2) { if (ULONG_OPERATIONS.IsBitOne(knightSquareBitboards[pEndPos], blackKingSquare)) return pEndPos; } else if (pPieceType != 6) { tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | pEndPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; } tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | pStartPos] & allPieceBitboard]; if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, tPossibleAttackPiece) && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) return tPossibleAttackPiece; return -1; } public void GetLegalMoves(ref List<Move> pMoveList) { int attk; if (isWhiteToMove) { attk = PreMinimaxCheckCheckWhite(); if (attk == -779) GetLegalWhiteMovesSpecialDoubleCheckCase(ref pMoveList); else GetLegalWhiteMoves(attk, ref pMoveList); } else { attk = PreMinimaxCheckCheckBlack(); if (attk == -779) GetLegalBlackMovesSpecialDoubleCheckCase(ref pMoveList); else GetLegalBlackMoves(attk, ref pMoveList); } } private void GetLegalWhiteMoves(int pCheckingPieceSquare, ref List<Move> pMoveList) { if (pCheckingPieceSquare == -779) { GetLegalWhiteMovesSpecialDoubleCheckCase(ref pMoveList); return; } moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= blackPawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, whiteKingSquare); if (curCheckCount == 0) { if (whiteCastleRightKingSide && ((allPieceBitboard | oppAttkBitboard) & WHITE_KING_ROCHADE) == 0ul) pMoveList.Add(mWHITE_KING_ROCHADE); if (whiteCastleRightQueenSide && (allPieceBitboard & WHITE_QUEEN_ROCHADE | oppAttkBitboard & WHITE_QUEEN_ATTK_ROCHADE) == 0ul) pMoveList.Add(mWHITE_QUEEN_ROCHADE); if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, whitePieceBitboard, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[whiteKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare + 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, whitePieceBitboard, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveList(whiteKingSquare, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalWhiteCaptures(int pCheckingPieceSquare, ref List<Move> pMoveList) { if (pCheckingPieceSquare == -779) { GetLegalWhiteCapturesSpecialDoubleCheckCase(ref pMoveList); return; } moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= blackPawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, whiteKingSquare); if (curCheckCount == 0) { if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & blackPieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[whiteKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (whitePieceBitboard & blackPawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare + 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = whiteKingSquare << 6, epM9 = enPassantSquare - 9, epM8 = epM9 + 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } epM9 += 2; if (((int)(whitePieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(blackPieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(blackPieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(whiteEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard); else whitePawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, blackPieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackPieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whiteKingSquare, blackPieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & blackPieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveListOnlyCaptures(whiteKingSquare, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalWhiteMovesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= blackPawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveList(whiteKingSquare, oppAttkBitboard | whitePieceBitboard, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalWhiteCapturesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= blackPawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, whiteKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveListOnlyCaptures(whiteKingSquare, ~oppAttkBitboard & blackPieceBitboard); } private void GetLegalBlackMoves(int pCheckingPieceSquare, ref List<Move> pMoveList) { if (pCheckingPieceSquare == -779) { GetLegalBlackMovesSpecialDoubleCheckCase(ref pMoveList); return; } moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= whitePawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, blackKingSquare); if (curCheckCount == 0) { if (blackCastleRightKingSide && ((allPieceBitboard | oppAttkBitboard) & BLACK_KING_ROCHADE) == 0ul) pMoveList.Add(mBLACK_KING_ROCHADE); if (blackCastleRightQueenSide && (allPieceBitboard & BLACK_QUEEN_ROCHADE | oppAttkBitboard & BLACK_QUEEN_ATTK_ROCHADE) == 0ul) pMoveList.Add(mBLACK_QUEEN_ROCHADE); if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveList(p, blackKingSquare, blackPieceBitboard, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[blackKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare - 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveList(p, blackPieceBitboard, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveList(p, blackKingSquare, blackPieceBitboard, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionList(p, allPieceBitboard, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveList(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveList(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveList(p, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveList(blackKingSquare, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); } private void GetLegalBlackCaptures(int pCheckingPieceSquare, ref List<Move> pMoveList) { if (pCheckingPieceSquare == -779) { GetLegalBlackCapturesSpecialDoubleCheckCase(ref pMoveList); return; } moveOptionList = pMoveList; ulong oppDiagonalSliderVision = 0ul, oppStraightSliderVision = 0ul, oppStaticPieceVision = 0ul, oppAttkBitboard, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppStaticPieceVision |= whitePawnAttackSquareBitboards[p]; break; case 2: oppStaticPieceVision |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppDiagonalSliderVision, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppStraightSliderVision, ref pinnedPieces); break; case 6: oppStaticPieceVision |= kingSquareBitboards[p]; break; } } oppAttkBitboard = oppDiagonalSliderVision | oppStraightSliderVision | oppStaticPieceVision; int curCheckCount = ULONG_OPERATIONS.TrippleIsBitOne(oppDiagonalSliderVision, oppStaticPieceVision, oppStraightSliderVision, blackKingSquare); if (curCheckCount == 0) { if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 7) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1 && enPassantSquare % 8 != 0) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & whitePieceBitboard); break; } } } else if (curCheckCount == 1) { ulong tCheckingPieceLine = squareConnectivesPrecalculationLineArray[blackKingSquare << 6 | pCheckingPieceSquare]; if (enPassantSquare != 65 && (blackPieceBitboard & whitePawnAttackSquareBitboards[enPassantSquare]) != 0ul && (((int)(tCheckingPieceLine >> enPassantSquare) & 1) == 1 || (pCheckingPieceSquare - 8 == enPassantSquare && pieceTypeArray[pCheckingPieceSquare] == 1))) { int shiftedKS = blackKingSquare << 6, epM9 = enPassantSquare + 9, epM8 = epM9 - 1; ulong tu = ULONG_OPERATIONS.SetBitToOne(ULONG_OPERATIONS.SetBitToZero(allPieceBitboard, epM8), enPassantSquare); int possibleAttacker2 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM8] & tu]; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } epM9 -= 2; if (((int)(blackPieceBitboard >> epM9) & 1) == 1 && pieceTypeArray[epM9] == 1) { int possibleAttacker1 = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[shiftedKS | epM9] & ULONG_OPERATIONS.SetBitToZero(tu, epM9)]; if (!(((int)(whitePieceBitboard >> possibleAttacker1) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker1], squareConnectivesPrecalculationArray[shiftedKS | epM9]] || ((int)(whitePieceBitboard >> possibleAttacker2) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[possibleAttacker2], squareConnectivesPrecalculationArray[shiftedKS | epM8]])) pMoveList.Add(blackEnPassantMoves[epM9, enPassantSquare]); } } for (int p = 0; p < 64; p++) { if (((int)(blackPieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: if (((int)(pinnedPieces >> p) & 1) == 0) blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard); else blackPawnMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard); break; case 2: if (((int)(pinnedPieces >> p) & 1) == 0) knightMovement.AddMovesToMoveOptionListOnlyCaptures(p, whitePieceBitboard); break; case 3: if (((int)(pinnedPieces >> p) & 1) == 0) bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else bishopMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 4: if (((int)(pinnedPieces >> p) & 1) == 0) rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else rookMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 5: if (((int)(pinnedPieces >> p) & 1) == 0) queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, whitePieceBitboard, allPieceBitboard); else queenMovement.AddMoveOptionsToMoveListOnlyCaptures(p, blackKingSquare, whitePieceBitboard, allPieceBitboard); break; case 6: kingMovement.AddMoveOptionsToMoveListOnlyCaptures(p, ~oppAttkBitboard & whitePieceBitboard); break; } } int s_molc = pMoveList.Count; List<Move> tMoves = new List<Move>(); for (int m = 0; m < s_molc; m++) { Move mm = pMoveList[m]; if (mm.pieceType == 6) tMoves.Add(pMoveList[m]); else if (((int)(tCheckingPieceLine >> pMoveList[m].endPos) & 1) == 1 || mm.isEnPassant) tMoves.Add(pMoveList[m]); } pMoveList = tMoves; } else kingMovement.AddMoveOptionsToMoveListOnlyCaptures(blackKingSquare, ~oppAttkBitboard & whitePieceBitboard); } private void GetLegalBlackMovesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= whitePawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveList(blackKingSquare, oppAttkBitboard | blackPieceBitboard, ~oppAttkBitboard & whitePieceBitboard); } private void GetLegalBlackCapturesSpecialDoubleCheckCase(ref List<Move> pMoveList) { moveOptionList = pMoveList; ulong oppAttkBitboard = 0ul, pinnedPieces = 0ul; for (int p = 0; p < 64; p++) { if (((int)(whitePieceBitboard >> p) & 1) == 0) continue; switch (pieceTypeArray[p]) { case 1: oppAttkBitboard |= whitePawnAttackSquareBitboards[p]; break; case 2: oppAttkBitboard |= knightSquareBitboards[p]; break; case 3: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 4: rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 5: rays.DiagonalRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); rays.StraightRays(allPieceBitboard, p, blackKingSquare, ref oppAttkBitboard, ref pinnedPieces); break; case 6: oppAttkBitboard |= kingSquareBitboards[p]; break; } } kingMovement.AddMoveOptionsToMoveListOnlyCaptures(blackKingSquare, ~oppAttkBitboard & whitePieceBitboard); } public Move GetMoveOfString(string pMove) { int tSP, tEP; string[] tSpl = pMove.Split(','); if (Char.IsNumber(pMove[0])) { tSP = Convert.ToInt32(tSpl[0]); tEP = Convert.ToInt32(tSpl[1]); } else { tSP = SQUARES.NumberNotation(tSpl[0]); tEP = SQUARES.NumberNotation(tSpl[1]); } int tPT = pieceTypeArray[tSP]; bool tIC = ULONG_OPERATIONS.IsBitOne(allPieceBitboard, tEP), tIEP = enPassantSquare == tEP && tPT == 1; if (tSpl.Length == 3) return new Move(tSP, tEP, tPT, Convert.ToInt32(tSpl[2]), tIC); if (tIEP) return new Move(true, tSP, tEP, isWhiteToMove ? tEP - 8 : tEP + 8); if (tPT == 1 && Math.Abs(tSP - tEP) > 11) return new Move(tSP, tEP, 1, false, isWhiteToMove ? tSP + 8 : tSP - 8); if (tPT == 6 && (Math.Abs(tSP - tEP) == 2 || Math.Abs(tSP - tEP) == 3)) { if (isWhiteToMove) return tEP == 6 ? mWHITE_KING_ROCHADE : mWHITE_QUEEN_ROCHADE; return tEP == 62 ? mBLACK_KING_ROCHADE : mBLACK_QUEEN_ROCHADE; } return new Move(tSP, tEP, tPT, tIC); } public void PlainMakeMove(string pMoveName) { PlainMakeMove(GetMoveOfString(pMoveName)); } public void PlainMakeMove(Move pMove) { lastMadeMove = pMove; if (isWhiteToMove) WhiteMakeMove(pMove); else BlackMakeMove(pMove); debugFEN = CreateFenString(); } public void WhiteMakeMove(Move pMove) { int tEndPos = pMove.endPos, tStartPos = pMove.startPos, tPieceType = pMove.pieceType, tPTI = pieceTypeArray[tEndPos]; fiftyMoveRuleCounter++; whitePieceBitboard ^= pMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey ^= blackTurnHash ^ enPassantSquareHashes[enPassantSquare] ^ pieceHashesWhite[tStartPos, tPieceType] ^ pieceHashesWhite[tEndPos, tPieceType]; enPassantSquare = 65; isWhiteToMove = false; switch (pMove.moveTypeID) { case 0: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 1: fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 2: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 3: whiteKingSquare = tEndPos; if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 4: if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 5: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 6: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 7: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[whiteKingSquare = tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 8: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 9: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = pMove.enPassantOption]; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 11: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; whiteKingSquare = tEndPos; pieceTypeArray[pMove.rochadeEndPos] = 4; pieceTypeArray[pMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesWhite[pMove.rochadeStartPos, 4] ^ pieceHashesWhite[pMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 12: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[pMove.enPassantOption] = 0; zobristKey ^= pieceHashesBlack[pMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 13: fiftyMoveRuleCounter = 0; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; zobristKey ^= pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, pMove.promotionType]; break; case 14: fiftyMoveRuleCounter = 0; blackPieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, tPTI] ^ pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, pMove.promotionType]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; } moveHashList.Add(pMove.moveHash); if (pMove.isCapture || tPieceType == 1) { curSearchZobristKeyLine = Array.Empty<ulong>(); return; } ulong[] u = new ulong[(tPTI = curSearchZobristKeyLine.Length) + 1]; for (int i = tPTI; i-- > 0;) u[i] = curSearchZobristKeyLine[i]; u[tPTI] = zobristKey; curSearchZobristKeyLine = u; } public void BlackMakeMove(Move pMove) { int tEndPos = pMove.endPos, tStartPos = pMove.startPos, tPieceType = pMove.pieceType, tPTI = pieceTypeArray[tEndPos]; fiftyMoveRuleCounter++; blackPieceBitboard ^= pMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey ^= blackTurnHash ^ enPassantSquareHashes[enPassantSquare] ^ pieceHashesBlack[tStartPos, tPieceType] ^ pieceHashesBlack[tEndPos, tPieceType]; enPassantSquare = 65; isWhiteToMove = true; switch (pMove.moveTypeID) { case 0: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 1: fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 2: allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 3: blackKingSquare = tEndPos; if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 4: if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 5: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 6: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 7: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[blackKingSquare = tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 8: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 9: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = pMove.enPassantOption]; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 11: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; blackKingSquare = tEndPos; pieceTypeArray[pMove.rochadeEndPos] = 4; pieceTypeArray[pMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesBlack[pMove.rochadeStartPos, 4] ^ pieceHashesBlack[pMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 12: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[pMove.enPassantOption] = 0; zobristKey ^= pieceHashesWhite[pMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 13: fiftyMoveRuleCounter = 0; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, pMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; case 14: fiftyMoveRuleCounter = 0; whitePieceBitboard ^= pMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = pMove.promotionType; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } zobristKey ^= pieceHashesWhite[tEndPos, tPTI] ^ pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, pMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; break; } moveHashList.Add(pMove.moveHash); if (pMove.isCapture || tPieceType == 1) { curSearchZobristKeyLine = Array.Empty<ulong>(); return; } ulong[] u = new ulong[(tPTI = curSearchZobristKeyLine.Length) + 1]; for (int i = tPTI; i-- > 0;) u[i] = curSearchZobristKeyLine[i]; u[tPTI] = zobristKey; curSearchZobristKeyLine = u; } public void WhiteUndoMove(Move pMove) { } private const int WHITE_CHECKMATE_VAL = 100000, BLACK_CHECKMATE_VAL = -100000, CHECK_EXTENSION_LENGTH = -12, MAX_QUIESCENCE_TOTAL_LENGTH = -32; private readonly Move NULL_MOVE = new Move(0, 0, 0); private int curSearchDepth = 0, curSubSearchDepth = -1; public int MinimaxRoot(long pTime) { evalCount = 0; searches++; int baseLineLen = 0; long tTimestamp = globalTimer.ElapsedTicks + pTime; ClearHeuristics(); transpositionTable.Clear(); ulong[] tZobristKeyLine = Array.Empty<ulong>(); if (curSearchZobristKeyLine != null) { baseLineLen = curSearchZobristKeyLine.Length; tZobristKeyLine = new ulong[baseLineLen]; Array.Copy(curSearchZobristKeyLine, tZobristKeyLine, baseLineLen); } int perftScore, tattk = isWhiteToMove ? PreMinimaxCheckCheckWhite() : PreMinimaxCheckCheckBlack(), pDepth = 1; (string, int) bookMoveTuple = TLMDatabase.SearchForNextBookMove(moveHashList); if (bookMoveTuple.Item2 != 0) { int actualMoveHash = NuCRe.GetNumber(bookMoveTuple.Item1); List<Move> tMoves = new List<Move>(); GetLegalMoves(ref tMoves); int tL = tMoves.Count; for (int i = 0; i < tL; i++) { if (tMoves[i].moveHash == actualMoveHash) { if (debugSearchDepthResults) { SNAPSHOT_WRITLINE_REPLACEMENT("TLM_DB_Count: " + bookMoveTuple.Item2); SNAPSHOT_WRITLINE_REPLACEMENT(">> " + tMoves[i]); } transpositionTable.Add(zobristKey, new TranspositionEntry(tMoves[i], Array.Empty<int>())); return 0; } } } do { curSearchDepth = pDepth; curSubSearchDepth = pDepth - 1; ulong[] completeZobristHistory = new ulong[baseLineLen + pDepth - CHECK_EXTENSION_LENGTH + 1]; for (int i = 0; i < baseLineLen; i++) completeZobristHistory[i] = curSearchZobristKeyLine[i]; curSearchZobristKeyLine = completeZobristHistory; if (isWhiteToMove) { if (tattk == -1) perftScore = MinimaxWhite(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); else perftScore = MinimaxWhite(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); } else { if (tattk == -1) perftScore = MinimaxBlack(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); else perftScore = MinimaxBlack(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, pDepth, baseLineLen, tattk, NULL_MOVE); } if (debugSearchDepthResults && pTime != 1L) { int tNpS = Convert.ToInt32((double)evalCount * 10_000_000d /(double)(pTime - tTimestamp + globalTimer.ElapsedTicks)); int tSearchEval = perftScore; int timeForSearchSoFar = (int)((pTime - tTimestamp + globalTimer.ElapsedTicks) /10000d); Move tBestMove = transpositionTable[zobristKey].bestMove; SNAPSHOT_WRITLINE_REPLACEMENT((tSearchEval >= 0 ? "+": "") + tSearchEval); SNAPSHOT_WRITLINE_REPLACEMENT(" " + tBestMove + "  ["); SNAPSHOT_WRITLINE_REPLACEMENT("Depth = " + pDepth + ", "); SNAPSHOT_WRITLINE_REPLACEMENT("Evals = " + GetThreeDigitSeperatedInteger(evalCount) + ", "); SNAPSHOT_WRITLINE_REPLACEMENT("Time = " + GetThreeDigitSeperatedInteger(timeForSearchSoFar) + "ms, "); SNAPSHOT_WRITLINE_REPLACEMENT("NpS = " + GetThreeDigitSeperatedInteger(tNpS) + "]"); } pDepth++; } while (globalTimer.ElapsedTicks < tTimestamp && pDepth < 179); depths += pDepth - 1; BOT_MAIN.depthsSearched += pDepth - 1; BOT_MAIN.searchesFinished++; BOT_MAIN.evaluationsMade += evalCount; curSearchZobristKeyLine = tZobristKeyLine; return perftScore; } private int[] squareToRankArray = new int[64] { 0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1, 2,2,2,2,2,2,2,2, 3,3,3,3,3,3,3,3, 4,4,4,4,4,4,4,4, 5,5,5,5,5,5,5,5, 6,6,6,6,6,6,6,6, 7,7,7,7,7,7,7,7 }; private bool WhiteIsPositionTheSpecialCase(Move pLastMove, int pCheckingSquare) { if (pLastMove.isPromotion && pLastMove.isCapture && (pLastMove.promotionType == 4 || pLastMove.promotionType == 5)) { if(pLastMove.startPos % 8 == pCheckingSquare % 8 && pLastMove.startPos == whiteKingSquare + 8) return true; if (pCheckingSquare > -1 && squareToRankArray[pLastMove.startPos] == squareToRankArray[pCheckingSquare] && pLastMove.endPos == whiteKingSquare - 8) return true; } return false; } private bool BlackIsPositionTheSpecialCase(Move pLastMove, int pCheckingSquare) { if (pLastMove.isPromotion && pLastMove.isCapture && (pLastMove.promotionType == 4 || pLastMove.promotionType == 5)) { if (pLastMove.startPos % 8 == pCheckingSquare % 8 && pLastMove.startPos == blackKingSquare - 8) return true; if (pCheckingSquare > -1 && squareToRankArray[pLastMove.startPos] == squareToRankArray[pCheckingSquare] && pLastMove.endPos == blackKingSquare + 8) return true; } return false; } private int MinimaxWhite(int pPly, int pAlpha, int pBeta, int pDepth, int pRepetitionHistoryPly, int pCheckingSquare, Move pLastMove) { if (IsDrawByRepetition(pRepetitionHistoryPly - 4)) return 0; if ((pDepth <= 0 && pCheckingSquare == -1) || pDepth < CHECK_EXTENSION_LENGTH) return QuiescenceWhite(pPly, pAlpha, pBeta, pDepth - 1, pCheckingSquare, pLastMove); List<Move> moveOptionList = new List<Move>(); Move bestMove = NULL_MOVE; if (WhiteIsPositionTheSpecialCase(pLastMove, pCheckingSquare)) GetLegalWhiteMovesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalWhiteMoves(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tWhiteKingSquare = whiteKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1, curEval = BLACK_CHECKMATE_VAL - pDepth; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = true; double[] moveSortingArray = new double[molc]; int[] moveSortingArrayIndexes = new int[molc], thisSearchMoveSortingArrayForTransposEntry = new int[molc]; transpositionTable.TryGetValue(zobristKey, out TranspositionEntry transposEntry); if (transposEntry == null) { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; } } else { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove == transposEntry.bestMove) moveSortingArray[m] = BESTMOVE_SORT_VAL; else if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; if (transposEntry.moveGenOrderedEvalLength > m) moveSortingArray[m] -= transposEntry.moveGenOrderedEvals[m]; } } Array.Sort(moveSortingArray, moveSortingArrayIndexes); for (int m = 0; m < molc; m++) { int tActualIndex = moveSortingArrayIndexes[m]; Move curMove = moveOptionList[tActualIndex]; if (debugSortResults && pDepth == curSubSearchDepth) { SNAPSHOT_WRITLINE_REPLACEMENT(moveSortingArray[m] + " | "+ curMove); } int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; whitePieceBitboard = tWPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesWhite[tStartPos, tPieceType] ^ pieceHashesWhite[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 0: blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 1: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 2: blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 3: whiteKingSquare = tEndPos; if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; blackPieceBitboard = tBPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 4: blackPieceBitboard = tBPB; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 5: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[whiteKingSquare = tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = curMove.enPassantOption]; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 11: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; whiteKingSquare = tEndPos; blackPieceBitboard = tBPB; pieceTypeArray[curMove.rochadeEndPos] = 4; pieceTypeArray[curMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesWhite[curMove.rochadeStartPos, 4] ^ pieceHashesWhite[curMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | curMove.rochadeEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << curMove.rochadeEndPos)) tCheckPos = curMove.rochadeEndPos; break; case 12: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesBlack[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 13: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; zobristKey ^= pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, curMove.promotionType]; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; case 14: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, tPTI] ^ pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, curMove.promotionType]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } curSearchZobristKeyLine[pRepetitionHistoryPly] = zobristKey; debugMoveList[pPly] = curMove; int tEval = MinimaxBlack(pPly + 1, pAlpha, pBeta, pDepth - 1, pRepetitionHistoryPly + 1, tCheckPos, curMove); thisSearchMoveSortingArrayForTransposEntry[tActualIndex] = tEval; pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 3: whiteKingSquare = tWhiteKingSquare; break; case 7: whiteKingSquare = tWhiteKingSquare; break; case 10: enPassantSquare = 65; break; case 11: whiteKingSquare = tWhiteKingSquare; pieceTypeArray[curMove.rochadeStartPos] = 4; pieceTypeArray[curMove.rochadeEndPos] = 0; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 13: pieceTypeArray[tStartPos] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval > curEval) { bestMove = curMove; curEval = tEval; } if (pAlpha < curEval) pAlpha = curEval; if (curEval >= pBeta) { if (!curMove.isCapture) { killerMoveHeuristic[curMove.moveHash] = true; if (pDepth > 0) historyHeuristic[curMove.moveHash] += pDepth * pDepth; } break; } } isWhiteToMove = true; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; if (molc == 0 && pCheckingSquare == -1) curEval = 0; if (!transpositionTable.ContainsKey(zobristKey)) transpositionTable.Add(zobristKey, new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry)); else transpositionTable[zobristKey] = new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry); return curEval; } private int QuiescenceWhite(int pPly, int pAlpha, int pBeta, int pDepth, int pCheckingSquare, Move pLastMove) { int standPat = TexelEvaluate(); if (standPat >= pBeta || pDepth < MAX_QUIESCENCE_TOTAL_LENGTH) return pBeta; if (standPat > pAlpha) pAlpha = standPat; List<Move> moveOptionList = new List<Move>(); if (WhiteIsPositionTheSpecialCase(pLastMove, pCheckingSquare)) GetLegalWhiteCapturesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalWhiteCaptures(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tWhiteKingSquare = whiteKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = true; for (int m = 0; m < molc; m++) { Move curMove = moveOptionList[m]; int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; whitePieceBitboard = tWPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesWhite[tStartPos, tPieceType] ^ pieceHashesWhite[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 5: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = whiteCastleRightKingSide = false; fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[whiteKingSquare = tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tStartPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tStartPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesBlack[tEndPos, tPTI]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 12: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesBlack[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePawnAttackSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 14: fiftyMoveRuleCounter = 0; blackPieceBitboard = tBPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, tPTI] ^ pieceHashesWhite[tEndPos, 1] ^ pieceHashesWhite[tEndPos, curMove.promotionType]; if (blackCastleRightQueenSide && tEndPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tEndPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(whitePieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[blackKingSquare][squareConnectivesPrecalculationRayArray[tI = blackKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = blackKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (blackKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } debugMoveList[pPly] = curMove; int tEval = QuiescenceBlack(pPly + 1, pAlpha, pBeta, pDepth - 1, tCheckPos, curMove); pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 7: whiteKingSquare = tWhiteKingSquare; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval >= pBeta) return pBeta; if (pAlpha < tEval) pAlpha = tEval; } isWhiteToMove = true; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; return pAlpha; } private int MinimaxBlack(int pPly, int pAlpha, int pBeta, int pDepth, int pRepetitionHistoryPly, int pCheckingSquare, Move pLastMove) { if (IsDrawByRepetition(pRepetitionHistoryPly - 4)) return 0; if ((pDepth <= 0 && pCheckingSquare == -1) || pDepth < CHECK_EXTENSION_LENGTH) return QuiescenceBlack(pPly, pAlpha, pBeta, pDepth - 1, pCheckingSquare, pLastMove); List<Move> moveOptionList = new List<Move>(); Move bestMove = NULL_MOVE; if (BlackIsPositionTheSpecialCase(pLastMove, pCheckingSquare)) GetLegalBlackMovesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalBlackMoves(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tBlackKingSquare = blackKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1, curEval = WHITE_CHECKMATE_VAL + pDepth; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = false; double[] moveSortingArray = new double[molc]; int[] moveSortingArrayIndexes = new int[molc], thisSearchMoveSortingArrayForTransposEntry = new int[molc]; transpositionTable.TryGetValue(zobristKey, out TranspositionEntry transposEntry); if (transposEntry == null) { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; } } else { for (int m = 0; m < molc; m++) { moveSortingArrayIndexes[m] = m; Move curMove = moveOptionList[m]; if (curMove == transposEntry.bestMove) moveSortingArray[m] = BESTMOVE_SORT_VAL; else if (curMove.isCapture) moveSortingArray[m] = CAPTURE_SORT_VAL - MVVLVA_TABLE[pieceTypeArray[curMove.endPos], curMove.pieceType]; else if (killerMoveHeuristic[curMove.moveHash]) moveSortingArray[m] = KILLERMOVE_SORT_VAL; else moveSortingArray[m] = -historyHeuristic[curMove.moveHash]; if (transposEntry.moveGenOrderedEvalLength > m) moveSortingArray[m] -= transposEntry.moveGenOrderedEvals[m]; } } Array.Sort(moveSortingArray, moveSortingArrayIndexes); for (int m = 0; m < molc; m++) { int tActualIndex = moveSortingArrayIndexes[m]; Move curMove = moveOptionList[tActualIndex]; if (debugSortResults && pDepth == curSearchDepth) { SNAPSHOT_WRITLINE_REPLACEMENT("=== " + moveSortingArray[m] + " | "+ curMove); } int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; blackPieceBitboard = tBPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesBlack[tStartPos, tPieceType] ^ pieceHashesBlack[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 0: whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 1: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 2: whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 3: blackKingSquare = tEndPos; if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; whitePieceBitboard = tWPB; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 4: whitePieceBitboard = tWPB; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 5: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[blackKingSquare = tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 10: zobristKey ^= enPassantSquareHashes[enPassantSquare = curMove.enPassantOption]; whitePieceBitboard = tWPB; fiftyMoveRuleCounter = 0; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 11: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; blackKingSquare = tEndPos; whitePieceBitboard = tWPB; pieceTypeArray[curMove.rochadeEndPos] = 4; pieceTypeArray[curMove.rochadeStartPos] = 0; zobristKey ^= pieceHashesBlack[curMove.rochadeStartPos, 4] ^ pieceHashesBlack[curMove.rochadeEndPos, 4]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | curMove.rochadeEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << curMove.rochadeEndPos)) tCheckPos = curMove.rochadeEndPos; break; case 12: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesWhite[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 13: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, curMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; case 14: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } zobristKey ^= pieceHashesWhite[tEndPos, tPTI] ^ pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, curMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } curSearchZobristKeyLine[pRepetitionHistoryPly] = zobristKey; debugMoveList[pPly] = curMove; int tEval = MinimaxWhite(pPly + 1, pAlpha, pBeta, pDepth - 1, pRepetitionHistoryPly + 1, tCheckPos, curMove); thisSearchMoveSortingArrayForTransposEntry[tActualIndex] = tEval; pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 3: blackKingSquare = tBlackKingSquare; break; case 7: blackKingSquare = tBlackKingSquare; break; case 10: enPassantSquare = 65; break; case 11: blackKingSquare = tBlackKingSquare; pieceTypeArray[curMove.rochadeStartPos] = 4; pieceTypeArray[curMove.rochadeEndPos] = 0; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 13: pieceTypeArray[tStartPos] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval < curEval) { bestMove = curMove; curEval = tEval; } if (pBeta > curEval) pBeta = curEval; if (curEval <= pAlpha) { if (!curMove.isCapture) { killerMoveHeuristic[curMove.moveHash] = true; if (pDepth > 0) historyHeuristic[curMove.moveHash] += pDepth * pDepth; } break; } } isWhiteToMove = false; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; if (molc == 0 && pCheckingSquare == -1) curEval = 0; if (!transpositionTable.ContainsKey(zobristKey)) transpositionTable.Add(zobristKey, new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry)); else transpositionTable[zobristKey] = new TranspositionEntry(bestMove, thisSearchMoveSortingArrayForTransposEntry); return curEval; } private int QuiescenceBlack(int pPly, int pAlpha, int pBeta, int pDepth, int pCheckingSquare, Move pLastMove) { int standPat = TexelEvaluate(); if (standPat <= pAlpha || pDepth < MAX_QUIESCENCE_TOTAL_LENGTH) return pAlpha; if (standPat < pBeta) pBeta = standPat; List<Move> moveOptionList = new List<Move>(); if (BlackIsPositionTheSpecialCase(pLastMove, pCheckingSquare)) GetLegalBlackCapturesSpecialDoubleCheckCase(ref moveOptionList); else GetLegalBlackCaptures(pCheckingSquare, ref moveOptionList); int molc = moveOptionList.Count, tBlackKingSquare = blackKingSquare, tEPSquare = enPassantSquare, tFiftyMoveRuleCounter = fiftyMoveRuleCounter + 1; ulong tZobristKey = zobristKey ^ blackTurnHash ^ enPassantSquareHashes[tEPSquare]; bool tWKSCR = whiteCastleRightKingSide, tWQSCR = whiteCastleRightQueenSide, tBKSCR = blackCastleRightKingSide, tBQSCR = blackCastleRightQueenSide; ulong tAPB = allPieceBitboard, tBPB = blackPieceBitboard, tWPB = whitePieceBitboard; enPassantSquare = 65; isWhiteToMove = false; for (int m = 0; m < molc; m++) { Move curMove = moveOptionList[m]; int tPieceType = curMove.pieceType, tStartPos = curMove.startPos, tEndPos = curMove.endPos, tPTI = pieceTypeArray[tEndPos], tCheckPos = -1, tI, tPossibleAttackPiece; fiftyMoveRuleCounter = tFiftyMoveRuleCounter; blackPieceBitboard = tBPB ^ curMove.ownPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType; pieceTypeArray[tStartPos] = 0; zobristKey = tZobristKey ^ pieceHashesBlack[tStartPos, tPieceType] ^ pieceHashesBlack[tEndPos, tPieceType]; switch (curMove.moveTypeID) { case 5: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 6: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 7: if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightKingSide = blackCastleRightQueenSide = false; fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[blackKingSquare = tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 8: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (blackCastleRightQueenSide && tStartPos == 56) { zobristKey ^= blackQueenSideRochadeRightHash; blackCastleRightQueenSide = false; } else if (blackCastleRightKingSide && tStartPos == 63) { zobristKey ^= blackKingSideRochadeRightHash; blackCastleRightKingSide = false; } if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos] == 1 && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 9: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 12: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[curMove.enPassantOption] = 0; zobristKey ^= pieceHashesWhite[curMove.enPassantOption, 1]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPawnAttackSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | curMove.enPassantOption] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; break; case 14: fiftyMoveRuleCounter = 0; whitePieceBitboard = tWPB ^ curMove.oppPieceBitboardXOR; pieceTypeArray[tEndPos] = tPieceType = curMove.promotionType; zobristKey ^= pieceHashesWhite[tEndPos, tPTI]; if (whiteCastleRightQueenSide && tEndPos == 0) { zobristKey ^= whiteQueenSideRochadeRightHash; whiteCastleRightQueenSide = false; } else if (whiteCastleRightKingSide && tEndPos == 7) { zobristKey ^= whiteKingSideRochadeRightHash; whiteCastleRightKingSide = false; } zobristKey ^= pieceHashesWhite[tEndPos, tPTI] ^ pieceHashesBlack[tEndPos, 1] ^ pieceHashesBlack[tEndPos, curMove.promotionType]; allPieceBitboard = blackPieceBitboard | whitePieceBitboard; if (((int)(blackPieceBitboard >> (tPossibleAttackPiece = rayCollidingSquareCalculations[whiteKingSquare][squareConnectivesPrecalculationRayArray[tI = whiteKingSquare << 6 | tStartPos] & allPieceBitboard])) & 1) == 1 && pieceTypeAbilities[pieceTypeArray[tPossibleAttackPiece], squareConnectivesPrecalculationArray[tI]]) tCheckPos = tPossibleAttackPiece; else if (pieceTypeAbilities[tPieceType, squareConnectivesPrecalculationArray[tI = whiteKingSquare << 6 | tEndPos]] && (squareConnectivesPrecalculationLineArray[tI] & allPieceBitboard) == (1ul << tEndPos)) tCheckPos = tEndPos; else if (tPieceType == 2 && ((int)(knightSquareBitboards[tEndPos] >> (whiteKingSquare)) & 1) == 1) tCheckPos = tEndPos; break; } debugMoveList[pPly] = curMove; int tEval = QuiescenceWhite(pPly + 1, pAlpha, pBeta, pDepth - 1, tCheckPos, curMove); pieceTypeArray[tEndPos] = tPTI; pieceTypeArray[tStartPos] = tPieceType; whiteCastleRightKingSide = tWKSCR; whiteCastleRightQueenSide = tWQSCR; blackCastleRightKingSide = tBKSCR; blackCastleRightQueenSide = tBQSCR; switch (curMove.moveTypeID) { case 7: blackKingSquare = tBlackKingSquare; break; case 12: pieceTypeArray[curMove.enPassantOption] = 1; break; case 14: pieceTypeArray[tStartPos] = 1; break; } if (tEval <= pAlpha) return pAlpha; if (pBeta > tEval) pBeta = tEval; } isWhiteToMove = false; zobristKey = tZobristKey ^ blackTurnHash ^ enPassantSquareHashes[enPassantSquare = tEPSquare]; allPieceBitboard = tAPB; whitePieceBitboard = tWPB; blackPieceBitboard = tBPB; fiftyMoveRuleCounter = tFiftyMoveRuleCounter - 1; return pBeta; } private bool[] killerMoveHeuristic = new bool[262_144]; private int[] historyHeuristic = new int[262_144]; public void ClearHeuristics() { for (int i = 0; i < 262_144; i++) { killerMoveHeuristic[i] = false; historyHeuristic[i] = 0; } } private Dictionary<ulong, TranspositionEntry> transpositionTable = new Dictionary<ulong, TranspositionEntry>(); private int[] pieceEvals = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[,][] piecePositionEvals = new int[33, 14][]; private int evalCount = 0; private int Evaluate() { evalCount++; if (fiftyMoveRuleCounter > 99) return 0; int tEval = 0, tPT, pieceCount = ULONG_OPERATIONS.CountBits(allPieceBitboard); for (int p = 0; p < 64; p++) tEval += pieceEvals[tPT = pieceTypeArray[p] + 7 * ((int)(blackPieceBitboard >> p) & 1)] + piecePositionEvals[pieceCount, tPT][p]; return tEval; } public int GameState(bool pWhiteKingCouldBeAttacked) { if (IsDrawByRepetition(curSearchZobristKeyLine.Length - 5) || fiftyMoveRuleCounter > 99) return 0; int t; List<Move> tMoves = new List<Move>(); GetLegalMoves(ref tMoves); if (pWhiteKingCouldBeAttacked) { t = PreMinimaxCheckCheckWhite(); if (t == -1) return tMoves.Count == 0 ? 0 : 3; else if (tMoves.Count == 0) return -1; } else { t = PreMinimaxCheckCheckBlack(); if (t == -1) return tMoves.Count == 0 ? 0 : 3; else if (tMoves.Count == 0) return 1; } return 3; } private bool IsDrawByRepetition(int pPlyOfFirstPossibleRepeatedPosition) { int tC = 0; for (int i = pPlyOfFirstPossibleRepeatedPosition; i >= 0; i -= 2) { if (curSearchZobristKeyLine[i] == zobristKey) if (++tC == 2) return true; } return false; } private const int RELE_MAX_MOVE_COUNT_PER_GAME = 500; public double ReLePlayGame(int[,][] pEvalPositionValuesWhite, int[,][] pEvalPositionValuesBlack, long thinkingTimePerMove) { int[,][] processedValuesWhite = InitReLeAgent(pEvalPositionValuesWhite), processedValuesBlack = InitReLeAgent(pEvalPositionValuesBlack); int tGS, mc = 0; do { if (IsDrawByRepetition(curSearchZobristKeyLine.Length - 5)) return 0d; piecePositionEvals = isWhiteToMove ? processedValuesWhite : processedValuesBlack; MinimaxRoot(thinkingTimePerMove); if (transpositionTable.Count == 0) { SNAPSHOT_WRITLINE_REPLACEMENT("?!"); return 0d; } PlainMakeMove(transpositionTable[zobristKey].bestMove); tGS = GameState(isWhiteToMove); transpositionTable.Clear(); if (tGS != 3) break; } while (mc++ < RELE_MAX_MOVE_COUNT_PER_GAME); if (tGS == 3 || tGS == 0) return 0d; else if (tGS == 1) return 0.1d * (double)(RELE_MAX_MOVE_COUNT_PER_GAME - mc); return 0.1d * (double)(-RELE_MAX_MOVE_COUNT_PER_GAME + mc); } public int[,][] InitReLeAgent(int[,][] pEvalPositionValues) { return GetInterpolatedProcessedValues(pEvalPositionValues); } private int[,][] GetInterpolatedProcessedValues(int[,][] pEvalPositionValues) { int[,][] processedValues = new int[33, 14][]; for (int i = 0; i < 32; i++) { int ip1 = i + 1; processedValues[ip1, 7] = processedValues[ip1, 0] = new int[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; processedValues[ip1, 8] = SwapArrayViewingSide(processedValues[ip1, 1] = MultiplyArraysWithVal(pEvalPositionValues[0, 0], pEvalPositionValues[1, 0], pEvalPositionValues[2, 0], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 9] = SwapArrayViewingSide(processedValues[ip1, 2] = MultiplyArraysWithVal(pEvalPositionValues[0, 1], pEvalPositionValues[1, 1], pEvalPositionValues[2, 1], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 10] = SwapArrayViewingSide(processedValues[ip1, 3] = MultiplyArraysWithVal(pEvalPositionValues[0, 2], pEvalPositionValues[1, 2], pEvalPositionValues[2, 2], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 11] = SwapArrayViewingSide(processedValues[ip1, 4] = MultiplyArraysWithVal(pEvalPositionValues[0, 3], pEvalPositionValues[1, 3], pEvalPositionValues[2, 3], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 12] = SwapArrayViewingSide(processedValues[ip1, 5] = MultiplyArraysWithVal(pEvalPositionValues[0, 4], pEvalPositionValues[1, 4], pEvalPositionValues[2, 4], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 13] = SwapArrayViewingSide(processedValues[ip1, 6] = MultiplyArraysWithVal(pEvalPositionValues[0, 5], pEvalPositionValues[1, 5], pEvalPositionValues[2, 5], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); } return processedValues; } private double[,][] GetInterpolatedProcessedValues(double[,][] pEvalPositionValues) { double[,][] processedValues = new double[33, 14][]; for (int i = 0; i < 32; i++) { int ip1 = i + 1; processedValues[ip1, 7] = processedValues[ip1, 0] = new double[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; processedValues[ip1, 8] = SwapArrayViewingSide(processedValues[ip1, 1] = MultiplyArraysWithVal(pEvalPositionValues[0, 0], pEvalPositionValues[1, 0], pEvalPositionValues[2, 0], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 9] = SwapArrayViewingSide(processedValues[ip1, 2] = MultiplyArraysWithVal(pEvalPositionValues[0, 1], pEvalPositionValues[1, 1], pEvalPositionValues[2, 1], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 10] = SwapArrayViewingSide(processedValues[ip1, 3] = MultiplyArraysWithVal(pEvalPositionValues[0, 2], pEvalPositionValues[1, 2], pEvalPositionValues[2, 2], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 11] = SwapArrayViewingSide(processedValues[ip1, 4] = MultiplyArraysWithVal(pEvalPositionValues[0, 3], pEvalPositionValues[1, 3], pEvalPositionValues[2, 3], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 12] = SwapArrayViewingSide(processedValues[ip1, 5] = MultiplyArraysWithVal(pEvalPositionValues[0, 4], pEvalPositionValues[1, 4], pEvalPositionValues[2, 4], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); processedValues[ip1, 13] = SwapArrayViewingSide(processedValues[ip1, 6] = MultiplyArraysWithVal(pEvalPositionValues[0, 5], pEvalPositionValues[1, 5], pEvalPositionValues[2, 5], earlyGameMultipliers[ip1], middleGameMultipliers[ip1], lateGameMultipliers[ip1])); } return processedValues; } private double[] MultiplyArraysWithVal(double[] pArr1, double[] pArr2, double[] pArr3, double pVal1, double pVal2, double pVal3) { int tL = pArr1.Length; double[] rArr = new double[tL]; for (int i = 0; i < tL; i++) { rArr[i] = pArr1[i] * pVal1 + pArr2[i] * pVal2 + pArr3[i] * pVal3; } return rArr; } private int[] MultiplyArraysWithVal(int[] pArr1, int[] pArr2, int[] pArr3, double pVal1, double pVal2, double pVal3) { int tL = pArr1.Length; int[] rArr = new int[tL]; for (int i = 0; i < tL; i++) { rArr[i] = (int)(pArr1[i] * pVal1 + pArr2[i] * pVal2 + pArr3[i] * pVal3); } return rArr; } private int[] SwapArrayViewingSideAndNegate(int[] pArr) { return new int[64] { -pArr[56], -pArr[57], -pArr[58], -pArr[59], -pArr[60], -pArr[61], -pArr[62], -pArr[63], -pArr[48], -pArr[49], -pArr[50], -pArr[51], -pArr[52], -pArr[53], -pArr[54], -pArr[55], -pArr[40], -pArr[41], -pArr[42], -pArr[43], -pArr[44], -pArr[45], -pArr[46], -pArr[47], -pArr[32], -pArr[33], -pArr[34], -pArr[35], -pArr[36], -pArr[37], -pArr[38], -pArr[39], -pArr[24], -pArr[25], -pArr[26], -pArr[27], -pArr[28], -pArr[29], -pArr[30], -pArr[31], -pArr[16], -pArr[17], -pArr[18], -pArr[19], -pArr[20], -pArr[21], -pArr[22], -pArr[23], -pArr[8], -pArr[9], -pArr[10], -pArr[11], -pArr[12], -pArr[13], -pArr[14], -pArr[15], -pArr[0], -pArr[1], -pArr[2], -pArr[3], -pArr[4], -pArr[5], -pArr[6], -pArr[7] }; } private int[] SwapArrayViewingSide(int[] pArr) { return new int[64] { pArr[56], pArr[57], pArr[58], pArr[59], pArr[60], pArr[61], pArr[62], pArr[63], pArr[48], pArr[49], pArr[50], pArr[51], pArr[52], pArr[53], pArr[54], pArr[55], pArr[40], pArr[41], pArr[42], pArr[43], pArr[44], pArr[45], pArr[46], pArr[47], pArr[32], pArr[33], pArr[34], pArr[35], pArr[36], pArr[37], pArr[38], pArr[39], pArr[24], pArr[25], pArr[26], pArr[27], pArr[28], pArr[29], pArr[30], pArr[31], pArr[16], pArr[17], pArr[18], pArr[19], pArr[20], pArr[21], pArr[22], pArr[23], pArr[8], pArr[9], pArr[10], pArr[11], pArr[12], pArr[13], pArr[14], pArr[15], pArr[0], pArr[1], pArr[2], pArr[3], pArr[4], pArr[5], pArr[6], pArr[7] }; } private double[] SwapArrayViewingSide(double[] pArr) { return new double[64] { pArr[56], pArr[57], pArr[58], pArr[59], pArr[60], pArr[61], pArr[62], pArr[63], pArr[48], pArr[49], pArr[50], pArr[51], pArr[52], pArr[53], pArr[54], pArr[55], pArr[40], pArr[41], pArr[42], pArr[43], pArr[44], pArr[45], pArr[46], pArr[47], pArr[32], pArr[33], pArr[34], pArr[35], pArr[36], pArr[37], pArr[38], pArr[39], pArr[24], pArr[25], pArr[26], pArr[27], pArr[28], pArr[29], pArr[30], pArr[31], pArr[16], pArr[17], pArr[18], pArr[19], pArr[20], pArr[21], pArr[22], pArr[23], pArr[8], pArr[9], pArr[10], pArr[11], pArr[12], pArr[13], pArr[14], pArr[15], pArr[0], pArr[1], pArr[2], pArr[3], pArr[4], pArr[5], pArr[6], pArr[7] }; } private int[,][] texelTuningRuntimeVals = new int[33, 14][]; private int[,][] texelTuningVals = new int[3, 6][]; private int[,] texelTuningAdjustIterations = new int[6, 64]; private int[][] texelTuningRuntimePositionalValsV2EG = new int[14][]; private int[][] texelTuningRuntimePositionalValsV2LG = new int[14][]; private int[] texelPieceEvaluationsV2EG = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[] texelPieceEvaluationsV2LG = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[] texelKingSafetyR1EvaluationsEG = new int[9]; private int[] texelKingSafetyR2EvaluationsEG = new int[17]; private int[] texelKingSafetyR1EvaluationsLG = new int[9]; private int[] texelKingSafetyR2EvaluationsLG = new int[17]; private int[] texelKingSafetySREvaluationsPT1EG = new int[12]; private int[] texelKingSafetySREvaluationsPT2EG = new int[12]; private int[] texelKingSafetySREvaluationsPT3EG = new int[12]; private int[] texelKingSafetySREvaluationsPT4EG = new int[12]; private int[] texelKingSafetySREvaluationsPT5EG = new int[12]; private int[] texelKingSafetySREvaluationsPT6EG = new int[12]; private int[] texelKingSafetySREvaluationsPT1LG = new int[12]; private int[] texelKingSafetySREvaluationsPT2LG = new int[12]; private int[] texelKingSafetySREvaluationsPT3LG = new int[12]; private int[] texelKingSafetySREvaluationsPT4LG = new int[12]; private int[] texelKingSafetySREvaluationsPT5LG = new int[12]; private int[] texelKingSafetySREvaluationsPT6LG = new int[12]; private int[,] texelMobilityStraightEG = new int[14, 15], texelMobilityStraightLG = new int[14, 15]; private int[,] texelMobilityDiagonalEG = new int[14, 14], texelMobilityDiagonalLG = new int[14, 14]; private int[] texelPieceEvaluations = new int[14] { 0, 100, 300, 320, 500, 900, 0, 0, -100, -300, -320, -500, -900, 0 }; private int[] blackSidedSquares = new int[64] { 56, 57, 58, 59, 60, 61, 62, 63, 48, 49, 50, 51, 52, 53, 54, 55, 40, 41, 42, 43, 44, 45, 46, 47, 32, 33, 34, 35, 36, 37, 38, 39, 24, 25, 26, 27, 28, 29, 30, 31, 16, 17, 18, 19, 20, 21, 22, 23, 08, 09, 10, 11, 12, 13, 14, 15, 00, 01, 02, 03, 04, 05, 06, 07 }; private int[,] T_Pawns = new int[3, 64] { { 0, 0, 0, 0, 0, 0, 0, 0, 98, 134, 61, 95, 68, 126, 34, -11, -6, 7, 26, 31, 65, 56, 25, -20, -14, 13, 6, 21, 23, 12, 17, -23, -27, -2, -5, 12, 17, 6, 10, -25, -26, -4, -4, -10, 3, 3, 33, -12, -35, -1, -20, -23, -15, 24, 38, -22, 0, 0, 0, 0, 0, 0, 0, 0, } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { 0, 0, 0, 0, 0, 0, 0, 0, 178, 173, 158, 134, 147, 132, 165, 187, 94, 100, 85, 67, 56, 53, 82, 84, 32, 24, 13, 5, -2, 4, 17, 17, 13, 9, -3, -7, -7, -8, 3, -1, 4, 7, -6, 1, 0, -5, -1, -8, 13, 8, 8, 10, 13, 0, 2, -7, 0, 0, 0, 0, 0, 0, 0, 0, } }; private int[,] T_Knights = new int[3, 64] { { -167, -89, -34, -49, 61, -97, -15, -107, -73, -41, 72, 36, 23, 62, 7, -17, -47, 60, 37, 65, 84, 129, 73, 44, -9, 17, 19, 53, 37, 69, 18, 22, -13, 4, 16, 13, 28, 19, 21, -8, -23, -9, 12, 10, 19, 17, 25, -16, -29, -53, -12, -3, -1, 18, -14, -19, -105, -21, -58, -33, -17, -28, -19, -23 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -58, -38, -13, -28, -31, -27, -63, -99, -25, -8, -25, -2, -9, -25, -24, -52, -24, -20, 10, 9, -1, -9, -19, -41, -17, 3, 22, 22, 22, 11, 8, -18, -18, -6, 16, 25, 16, 17, 4, -18, -23, -3, -1, 15, 10, -3, -20, -22, -42, -20, -10, -5, -2, -20, -23, -44, -29, -51, -23, -15, -22, -18, -50, -64 } }; private int[,] T_Bishops = new int[3, 64] { { -29, 4, -82, -37, -25, -42, 7, -8, -26, 16, -18, -13, 30, 59, 18, -47, -16, 37, 43, 40, 35, 50, 37, -2, -4, 5, 19, 50, 37, 37, 7, -2, -6, 13, 13, 26, 34, 12, 10, 4, 0, 15, 15, 15, 14, 27, 18, 10, 4, 15, 16, 0, 7, 21, 33, 1, -33, -3, -14, -21, -13, -12, -39, -21 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -14, -21, -11, -8, -7, -9, -17, -24, -8, -4, 7, -12, -3, -13, -4, -14, 2, -8, 0, -1, -2, 6, 0, 4, -3, 9, 12, 9, 14, 10, 3, 2, -6, 3, 13, 19, 7, 10, -3, -9, -12, -3, 8, 10, 13, 3, -7, -15, -14, -18, -7, -1, 4, -9, -15, -27, -23, -9, -23, -5, -9, -16, -5, -17 } }; private int[,] T_Rooks = new int[3, 64] { { 32, 42, 32, 51, 63, 9, 31, 43, 27, 32, 58, 62, 80, 67, 26, 44, -5, 19, 26, 36, 17, 45, 61, 16, -24, -11, 7, 26, 24, 35, -8, -20, -36, -26, -12, -1, 9, -7, 6, -23, -45, -25, -16, -17, 3, 0, -5, -33, -44, -16, -20, -9, -1, 11, -6, -71, -19, -13, 1, 17, 16, 7, -37, -26 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { 13, 10, 18, 15, 12, 12, 8, 5, 11, 13, 13, 11, -3, 3, 8, 3, 7, 7, 7, 5, 4, -3, -5, -3, 4, 3, 13, 1, 2, 1, -1, 2, 3, 5, 8, 4, -5, -6, -8, -11, -4, 0, -5, -1, -7, -12, -8, -16, -6, -6, 0, 2, -9, -9, -11, -3, -9, 2, 3, -1, -5, -13, 4, -20 } }; private int[,] T_Queens = new int[3, 64] { { -28, 0, 29, 12, 59, 44, 43, 45, -24, -39, -5, 1, -16, 57, 28, 54, -13, -17, 7, 8, 29, 56, 47, 57, -27, -27, -16, -16, -1, 17, -2, 1, -9, -26, -9, -10, -2, -4, 3, -3, -14, 2, -11, -2, -5, 2, 14, 5, -35, -8, 11, 2, 8, 15, -3, 1, -1, -18, -9, 10, -15, -25, -31, -50 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -9, 22, 22, 27, 27, 19, 10, 20, -17, 20, 32, 41, 58, 25, 30, 0, -20, 6, 9, 49, 47, 35, 19, 9, 3, 22, 24, 45, 57, 40, 57, 36, -18, 28, 19, 47, 31, 34, 39, 23, -16, -27, 15, 6, 9, 17, 10, 5, -22, -23, -30, -16, -16, -23, -36, -32, -33, -28, -22, -43, -5, -32, -20, -41 } }; private int[,] T_Kings = new int[3, 64] { { -65, 23, 16, -15, -56, -34, 2, 13, 29, -1, -20, -7, -8, -4, -38, -29, -9, 24, 2, -16, -20, 6, 22, -22, -17, -20, -12, -27, -30, -25, -14, -36, -49, -1, -27, -39, -46, -44, -33, -51, -14, -14, -22, -46, -44, -30, -15, -27, 1, 7, -8, -64, -43, -16, 9, 8, -15, 36, 12, -54, 8, -28, 24, 14 } , { 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000 } , { -74, -35, -18, -18, -11, 15, 4, -17, -12, 17, 14, 17, 17, 38, 23, 11, 10, 17, 23, 15, 20, 45, 44, 13, -8, 22, 24, 27, 26, 33, 26, 3, -18, -4, 21, 24, 27, 23, 9, -11, -19, -3, 11, 21, 23, 16, 7, -9, -27, -11, 4, 13, 14, 4, -5, -17, -53, -34, -21, -11, -28, -14, -24, -43 } }; private int[] paramsLowerLimits = new int[5] { -10000, -10000, -10000, -10000, -10000 }; private int[] paramsUpperLimits = new int[5] { 10000, 10000, 10000, 10000, 10000 }; private List<TLM_ChessGame> threadDataset; private int threadFrom, threadTo; private int[] threadParams; private int customThreadID = 0; private ulong ulAllThreadIDsUnfinished = 0; private double lastCostVal = 0d; private double sumCostVals = 0d; private int costCalculations = 0; private readonly string[] TEXELPRINT_GAMEPARTS = new string[3] { "Early Game: ", "Mid Game: ", "Late Game: "}; private readonly string[] TEXELPRINT_PIECES = new string[6] { "Bauer: ", "Springer: ", "Lufer: ", "Turm: ", "Dame: ", "Knig: "}; private double[] earlyGameMultipliers = new double[33]; private double[] middleGameMultipliers = new double[33]; private double[] lateGameMultipliers = new double[33]; private int[] pieceTypeGameProgressImpact = new int[14] { 0, 0, 1, 1, 2, 4, 0, 0, 0, 1, 1, 2, 4, 0 }; private void PrecalculateMultipliers() { if (BOARD_MANAGER_ID == ENGINE_VALS.PARALLEL_BOARDS - 1) SNAPSHOT_WRITLINE_REPLACEMENT(); for (int i = 0; i < 25; i++) { earlyGameMultipliers[i] = EGMultiplierFunction(i); lateGameMultipliers[i] = LGMultiplierFunction(i); if (BOARD_MANAGER_ID == ENGINE_VALS.PARALLEL_BOARDS - 1) SNAPSHOT_WRITLINE_REPLACEMENT("[" + i + "] "+ earlyGameMultipliers[i] + " | "+ middleGameMultipliers[i] + " | "+ lateGameMultipliers[i]); } } private double MultiplierFunction(double pVal, double pXShift) { double d = Math.Exp(1d /6d * (pVal - pXShift)); return 5 * (d /Math.Pow(d + 1, 2d)); } private double EGMultiplierFunction(double pVal) { return Math.Clamp(1 /16d * (pVal - 4d), 0d, 1d); } private double LGMultiplierFunction(double pVal) { return Math.Clamp(1 /-16d * (pVal - 4d) + 1d, 0d, 1d); } private double EGMultiplierFunction2(double pVal) { return Math.Clamp(1 /32d * pVal, 0d, 1d); } private double LGMultiplierFunction2(double pVal) { return Math.Clamp(1 /-32d * pVal + 1d, 0d, 1d); } private void TuneWithTxtFile(string pTXTName) { List<TLM_ChessGame> gameDataset = new List<TLM_ChessGame>(); string tPath = PathManager.GetTXTPath(pTXTName); string[] tStrs = File.ReadAllLines(tPath); List<string> tGames = new List<string>(); foreach (string s in tStrs) if (s.Contains(';') && s.Replace(" ", "") != "") tGames.Add(s); foreach (string s in tGames) { TLM_ChessGame tGame = CGFF.GetGame(s); LoadFenString(tGame.startFen); foreach (int hMove in tGame.hashedMoves) { List<Move> moveOptionList = new List<Move>(); GetLegalMoves(ref moveOptionList); int tL = moveOptionList.Count; for (int j = 0; j < tL; j++) { Move tMove = moveOptionList[j]; if (tMove.moveHash == hMove) { tGame.actualMoves.Add(tMove); PlainMakeMove(tMove); tL = -1; break; } } if (tL != -1) break; } gameDataset.Add(tGame); } SNAPSHOT_WRITLINE_REPLACEMENT("[TLM TEXEL TUNER] " + tGames.Count + " Games Loaded In!"); BOT_MAIN.curTEXELPARAMS = new int[TEXEL_PARAMS]; BOT_MAIN.ParallelTexelTuning(gameDataset); } private void LoadBestTexelParamsIn() { int[] ttt = new int[778] { 72, 300, 484, 528, 904, 128, 272, 280, 504, 720, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -56, 88, -92, -200, 56, -40, -48, -148, -100, 96, -32, -100, 8, -28, -8, 32, -64, -200, 44, -184, 12, -8, 96, -200, -16, -104, -40, 40, 24, -134, -136, -8, -16, 80, -8, -32, 136, -120, -12, -136, -16, 20, -136, 68, 32, -200, 0, 88, -176, 128, -72, 128, 88, -200, 104, -200, 124, 40, 64, 84, 8, -124, -48, 128, 100, -36, -32, -32, -64, 200, -200, 200, 200, -200, 8, 156, -20, 76, 72, 200, 196, 200, 200, 200, -66, 8, 200, 200, -200, 200, -200, 200, 56, 200, -200, 200, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -200, -200, -28, 200, -200, -22, 200, 192, 172, 200, 12, 120, 12, -200, -200, 200, 18, -194, 200, -200, 46, -168, 52, 200, 176, 56, -56, 200, -40, 32, 8, 200, 70, -176, -112, 200, 168, -48, 192, 76, 192, -72, 136, 46, 64, -200, -24, -200, 172, -200, -200, 88, 24, 200, 112, -68, 200, 200, 168, -120, 200, -88, -12, 200, 76, 40, 56, 200, 200, 200, 64, -200, 138, -56, 200, -16, 96, 136, 200, -112, 200, 200, 200, 200, 101, -200, 176, 200, -200, 200, 120, -200, 54, -128, 200, -24, -200, 200, 200, -72, 200, 200, 200, 200, -200, -200, 176, -200, 80, 176, 200, -24, 112, -200, 200, 200, -200, -200, -200, 128, -200, 112, -200, -200, 200, -200, 16, -200, 16, -80, -200, 184, -8, 200, -32, -200, -176, -200, -56, 200, 56, 200, -104, -152, -200, 200, 32, 200, 112, 8, -24, 160, 92, -76, -120, -200, 64, -200, 200, -200, 32, 136, -140, -144, 24, 8, 16, 200, 132, 24, 40, -24, -62, -200, 200, -15, -8, -116, 148, 200, -76, 200, 200, -200, 96, -200, 8, 200, -148, -200, -200, 188, 200, 86, 64, 80, -180, -200, 64, 200, 200, 200, -200, -132, 184, -184, 200, -156, -136, -200, 200, -104, -184, 60, -200, -184, -32, 0, -169, 96, 200, 200, 200, 200, 200, 200, -200, -200, 200, -200, -200, 68, -200, -200, 200, 200, -200, 176, -200, 200, -56, 200, -200, 152, -200, -168, -46, -200, 200, -200, -200, 192, -200, 68, -200, -200, -16, 16, 4, 200, -168, 112, 176, -200, 92, -128, -200, 16, 34, 144, -68, 24, -40, -200, -64, 40, -128, 152, 48, -24, -200, -35, 200, -56, -88, 4, -96, 128, 200, -200, 200, -100, 200, -80, 32, -172, 200, -200, -40, -200, -78, 200, 96, -24, -26, 200, 80, -32, 200, -76, 200, 48, 200, -200, 16, -148, -200, -64, 32, -72, 120, -180, 200, 84, 200, 136, 200, 200, 200, 200, -52, 200, 72, 200, 200, -200, -64, 200, 200, -144, -136, 40, 200, -104, -8, 200, 88, -200, -173, -112, 200, -88, -40, 200, 32, -200, -200, 72, 200, 68, 200, -156, -200, -40, 128, 4, 144, -88, -200, 200, 174, -136, 200, -200, 184, -176, 200, -56, -200, 200, -200, -152, -200, 160, 200, -171, -96, -200, 88, 200, -62, 72, -200, -200, -200, 200, 194, -200, -200, -200, -140, 200, -32, 56, 88, 200, 200, 200, -53, -200, -38, -200, 84, -200, -200, 200, -8, 100, 3, -140, 38, 172, -48, 200, -20, -160, 80, -200, 200, -200, -200, 200, -200, -200, -56, -52, -72, -124, 80, 80, 88, -8, 104, -88, 104, 200, -24, -200, -8, -200, -80, 22, 164, 200, 152, 80, 104, -200, 88, -104, 200, 200, 25, 200, -112, -200, 56, -200, 200, 200, 100, -80, 176, 200, 200, 104, 200, 200, -200, -200, 24, 200, 200, 200, 200, -200, -200, -30, 200, 200, 200, 48, 200, 200, -76, -200, 200, -184, 200, 200, -200, -200, 174, 200, 108, 192, 128, 200, 80, 200, 200, 40, -200, -200, -48, -84, -88, 64, -24, -200, 8, -16, 160, -200, 176, -100, 200, 200, -200, -174, 48, -112, 72, 44, -136, -84, 44, -104, 64, -16, -96, 200, 64, -200, -200, 200, -200, 80, -200, 144, -200, 144, -192, 152, -104, 24, -200, 200, -200, -136, -8, -112, -200, -200, 200, 112, -200, 200, 48, 0, -200, 144, -200, -136, -48, 200, 200, -134, -200, -56, -200, -28, -192, -200, 200, 92, -200, 200, 134, 200, 200, 144, 200, -94, 200, 120, 200, 200, 200, 200, -200, -200, -200, 200, -200, 200, 200, -200, 200, 200, -197, 200, -200, 200, 197, 200, 200, 200, 0, 0, 200, -200, 200, 200, -200, -200, -200, 200, -200, -200, -200, 128, -200, -200, -200, -200, 0, -200, -200, -200 }; SetupTexelEvaluationParams(ttt); } private void SetupTexelEvaluationParams(int[] pParams) { int c = 10; for (int s = 0; s < 64; s++) { int pawnEG = T_Pawns[0, s], pawnLG = T_Pawns[2, s]; int knightEG = T_Knights[0, s], knightLG = T_Knights[2, s]; int bishopEG = T_Bishops[0, s], bishopLG = T_Bishops[2, s]; int rookEG = T_Rooks[0, s], rookLG = T_Rooks[2, s]; int queenEG = T_Queens[0, s], queenLG = T_Queens[2, s]; int kingEG = T_Kings[0, s], kingLG = T_Kings[2, s]; int bsSq = blackSidedSquares[s]; texelTuningRuntimePositionalValsV2EG[1][bsSq] = pawnEG; texelTuningRuntimePositionalValsV2LG[1][bsSq] = pawnLG; texelTuningRuntimePositionalValsV2EG[8][s] = -pawnEG; texelTuningRuntimePositionalValsV2LG[8][s] = -pawnLG; texelTuningRuntimePositionalValsV2EG[2][bsSq] = knightEG; texelTuningRuntimePositionalValsV2LG[2][bsSq] = knightLG; texelTuningRuntimePositionalValsV2EG[9][s] = -knightEG; texelTuningRuntimePositionalValsV2LG[9][s] = -knightLG; texelTuningRuntimePositionalValsV2EG[3][bsSq] = bishopEG; texelTuningRuntimePositionalValsV2LG[3][bsSq] = bishopLG; texelTuningRuntimePositionalValsV2EG[10][s] = -bishopEG; texelTuningRuntimePositionalValsV2LG[10][s] = -bishopLG; texelTuningRuntimePositionalValsV2EG[4][bsSq] = rookEG; texelTuningRuntimePositionalValsV2LG[4][bsSq] = rookLG; texelTuningRuntimePositionalValsV2EG[11][s] = -rookEG; texelTuningRuntimePositionalValsV2LG[11][s] = -rookLG; texelTuningRuntimePositionalValsV2EG[5][bsSq] = queenEG; texelTuningRuntimePositionalValsV2LG[5][bsSq] = queenLG; texelTuningRuntimePositionalValsV2EG[12][s] = -queenEG; texelTuningRuntimePositionalValsV2LG[12][s] = -queenLG; texelTuningRuntimePositionalValsV2EG[6][bsSq] = kingEG; texelTuningRuntimePositionalValsV2LG[6][bsSq] = kingLG; texelTuningRuntimePositionalValsV2EG[13][s] = -kingEG; texelTuningRuntimePositionalValsV2LG[13][s] = -kingLG; } return; for (int p = 2; p < 7; p++) { for (int a = 0; a < 15; a++) { if (a != 14) { texelMobilityDiagonalEG[p + 7, a] = -(texelMobilityDiagonalEG[p, a] = pParams[c++]); texelMobilityDiagonalLG[p + 7, a] = -(texelMobilityDiagonalLG[p, a] = pParams[c++]); } texelMobilityStraightEG[p + 7, a] = -(texelMobilityStraightEG[p, a] = pParams[c++]); texelMobilityStraightLG[p + 7, a] = -(texelMobilityStraightLG[p, a] = pParams[c++]); } } for (int i = 0; i < 12; i++) { texelKingSafetySREvaluationsPT1EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT2EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT3EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT4EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT5EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT6EG[i] = pParams[c++]; texelKingSafetySREvaluationsPT1LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT2LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT3LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT4LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT5LG[i] = pParams[c++]; texelKingSafetySREvaluationsPT6LG[i] = pParams[c++]; } } private void PrintDefinedTexelParams(int[] pParams) { int c = 0; for (int t = 0; t < 3; t++) { SNAPSHOT_WRITLINE_REPLACEMENT(TEXELPRINT_GAMEPARTS[t]); for (int p = 0; p < 6; p++) { SNAPSHOT_WRITLINE_REPLACEMENT(TEXELPRINT_PIECES[p]); texelTuningVals[t, p] = new int[64]; for (int s = 0; s < 64; s++) { if (s % 8 == 0 && s != 0) SNAPSHOT_WRITLINE_REPLACEMENT(); SNAPSHOT_WRITLINE_REPLACEMENT((texelTuningVals[t, p][s] = pParams[c++]) + ", "); } SNAPSHOT_WRITLINE_REPLACEMENT(); } } piecePositionEvals = GetInterpolatedProcessedValues(texelTuningVals); } public void TLMTuning(List<TLM_ChessGame> pDataset) { int tGameDataSetLen = pDataset.Count; int[,][] tRatio = new int[33, 6][]; int[,][] tTotalMoves = new int[33, 6][]; double[,][] tSummedRatios = new double[33, 6][]; double[,][] tSummedDataAmount = new double[33, 6][]; double[,][] tTuningResults = new double[33, 6][]; for (int t = 1; t < 33; t++) { for (int p = 0; p < 6; p++) { tRatio[t, p] = new int[64]; tTotalMoves[t, p] = new int[64]; tSummedRatios[t, p] = new double[64]; tSummedDataAmount[t, p] = new double[64]; tTuningResults[t, p] = new double[64]; } } for (int j = 0; j < tGameDataSetLen; j++) { TLM_ChessGame tGame = pDataset[j]; int tGR = tGame.gameResult - 1; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count - 5; for (int i = 0; i < tL; i++) { if (tGame.isMoveNonTactical[i]) { int tPieceAmount = ULONG_OPERATIONS.CountBits(allPieceBitboard); for (int s = 0; s < 64; s++) { int tPT = pieceTypeArray[s] - 1; if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, s)) { tTotalMoves[tPieceAmount, tPT][s]++; tRatio[tPieceAmount, tPT][s] += tGR; } else if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, s)) { int b = blackSidedSquares[s]; tTotalMoves[tPieceAmount, tPT][b]++; tRatio[tPieceAmount, tPT][b] += tGR; } } } PlainMakeMove(tGame.actualMoves[i]); } } double[,] allMultipliers = new double[33, 33]; for (int sh = 0; sh < 33; sh++) { for (int i = 0; i < 33; i++) { allMultipliers[sh, i] = MultiplierFunction(i, sh); } } for (int t = 1; t < 33; t++) { for (int p = 0; p < 6; p++) { for (int s = 0; s < 64; s++) { for (int t2 = 1; t2 < 33; t2++) { double cmult = allMultipliers[t, t2]; tSummedRatios[t, p][s] += tRatio[t2, p][s] * cmult; tSummedDataAmount[t, p][s] += tTotalMoves[t2, p][s] * cmult; } tTuningResults[t, p][s] = TTT(tSummedRatios[t, p][s], tSummedDataAmount[t, p][s]); } } } int c = 0; int[] tparams = new int[1152]; for (int t = 1; t < 33; t += 15) { if (t == 31) t = 32; SNAPSHOT_WRITLINE_REPLACEMENT("PieceCount = " + t + ": "); for (int p = 0; p < 6; p++) { SNAPSHOT_WRITLINE_REPLACEMENT(TEXELPRINT_PIECES[p]); for (int s = 0; s < 64; s++) { if (s % 8 == 0 && s != 0) SNAPSHOT_WRITLINE_REPLACEMENT(); SNAPSHOT_WRITLINE_REPLACEMENT((tparams[c++] = (int)(tTuningResults[t, p][s] * 100)).ToString().Replace(",", ".") + "("+ (int)tSummedDataAmount[t, p][s] + ")"+ ", "); } SNAPSHOT_WRITLINE_REPLACEMENT(); } } string tS = "PARAMS: {"; for (int i = 0; i < tparams.Length; i++) tS += tparams[i] + ","; tS = tS.Substring(0, tS.Length - 1) + "}\n"; SNAPSHOT_WRITLINE_REPLACEMENT(tS); TexelTuning(pDataset, tparams); } private double TTT(double d1, double d2) { if (d2 == 0) return 0; return d1 /d2; } public void TexelTuning(List<TLM_ChessGame> pDataset, int[] pCurBestParams) { Stopwatch sw = Stopwatch.StartNew(); string tPath = PathManager.GetTXTPath("OTHER/TEXEL_TUNING"); int paramCount = pCurBestParams.Length; double bestAvrgCost = CalculateAverageTexelCost(pDataset, pCurBestParams); SNAPSHOT_WRITLINE_REPLACEMENT("CUR PARAMS COST: " + bestAvrgCost); int packetSize = Math.Clamp(paramCount /ENGINE_VALS.CPU_CORES, 1, 100000); paramsLowerLimits = new int[paramCount]; paramsUpperLimits = new int[paramCount]; for (int i = 0; i < paramCount; i++) { int lim = i < 10 ? 100000 : 200; paramsLowerLimits[i] = -lim; paramsUpperLimits[i] = lim; } SNAPSHOT_WRITLINE_REPLACEMENT("PARAM-COUNT: " + paramCount); SNAPSHOT_WRITLINE_REPLACEMENT("PACKET-SIZE: " + packetSize); while (packetSize <= paramCount) { BOT_MAIN.TEXELfinished = 0; int lM = 0, tC = 0; ulong tUL = 0ul; for (int m = packetSize; lM < paramCount; m += packetSize) { if (m > paramCount) m = paramCount; tUL = ULONG_OPERATIONS.SetBitToOne(tUL, ++tC); lM = m; } tC = lM = 0; for (int m = packetSize; lM < paramCount; m += packetSize) { if (m > paramCount) m = paramCount; tC++; BOT_MAIN.boardManagers[tC].SetPlayTexelVals(pDataset, lM, m, pCurBestParams, paramsLowerLimits, paramsUpperLimits, tC, tUL); ThreadPool.QueueUserWorkItem(new WaitCallback(BOT_MAIN.boardManagers[tC].TexelTuningThreadedPackage)); lM = m; } packetSize = paramCount + 1; int tmod = 0; while (tC != BOT_MAIN.TEXELfinished) { if (++tmod % 20 == 0) { WriteTexelParamsToTXT(tPath, BOT_MAIN.curTEXELPARAMS); SNAPSHOT_WRITLINE_REPLACEMENT(CalculateAverageTexelCost(pDataset, BOT_MAIN.curTEXELPARAMS) + " | "+ BOT_MAIN.TEXELadjustmentsmade); SNAPSHOT_WRITLINE_REPLACEMENT(ULONG_OPERATIONS.GetBitVisualization(BOT_MAIN.TEXELfinishedwithoutimpovement)); } Thread.Sleep(100); } SNAPSHOT_WRITLINE_REPLACEMENT("One Thread Generation FINISHED! :) :) :)"); pCurBestParams = BOT_MAIN.curTEXELPARAMS; } sw.Stop(); WriteTexelParamsToTXT(tPath, BOT_MAIN.curTEXELPARAMS); SNAPSHOT_WRITLINE_REPLACEMENT("END COST: " + CalculateAverageTexelCost(pDataset, BOT_MAIN.curTEXELPARAMS)); SNAPSHOT_WRITLINE_REPLACEMENT(BOT_MAIN.TEXELadjustmentsmade); SNAPSHOT_WRITLINE_REPLACEMENT(sw.ElapsedMilliseconds); } public void TexelTuningThreadedPackage(object obj) { SNAPSHOT_WRITLINE_REPLACEMENT("Started CThreadID [" + customThreadID + "] which is handling Params ["+ threadFrom + "] - ["+ threadTo + "]"); bool firstIter = true; do { double bestAvrgCost = CalculateAverageTexelCost(threadDataset, threadParams); int adjust_val = firstIter ? 512 : 8; do { adjust_val /= 2; bool improvedAvrgCost = true; while (improvedAvrgCost) { improvedAvrgCost = false; for (int i = threadFrom; i < threadTo; i++) { bool improvedWithThisParam = true; int tadjustval = adjust_val; bool lastTimeMaximized = false, lastTimeMinimized = false; while (improvedWithThisParam) { improvedWithThisParam = false; int[] curParams = (int[])threadParams.Clone(); int paramBefore = curParams[i]; curParams[i] = Math.Clamp(paramBefore + adjust_val, paramsLowerLimits[i], paramsUpperLimits[i]); double curAvrgCost = CalculateAverageTexelCost(threadDataset, curParams); if (curAvrgCost < bestAvrgCost) { improvedAvrgCost = true; improvedWithThisParam = true; SNAPSHOT_WRITLINE_REPLACEMENT("Improved Param [" + i + "] at CThreadID ["+ customThreadID + "]: +"+ adjust_val + " ("+ GetDoublePrecentageString(bestAvrgCost - curAvrgCost) + ")"); bestAvrgCost = curAvrgCost; threadParams = curParams; BOT_MAIN.TEXELadjustmentsmade++; BOT_MAIN.TEXELfinishedwithoutimpovement = ulAllThreadIDsUnfinished; if (lastTimeMaximized) { adjust_val *= 4; lastTimeMaximized = false; } else lastTimeMaximized = true; lastTimeMinimized = false; } else { curParams[i] = Math.Clamp(paramBefore - adjust_val, paramsLowerLimits[i], paramsUpperLimits[i]); curAvrgCost = CalculateAverageTexelCost(threadDataset, curParams); if (curAvrgCost < bestAvrgCost) { improvedAvrgCost = true; improvedWithThisParam = true; SNAPSHOT_WRITLINE_REPLACEMENT("Improved Param [" + i + "] at CThreadID ["+ customThreadID + "]: -"+ adjust_val + " ("+ GetDoublePrecentageString(bestAvrgCost - curAvrgCost) + ")"); bestAvrgCost = curAvrgCost; threadParams = curParams; BOT_MAIN.TEXELadjustmentsmade++; BOT_MAIN.TEXELfinishedwithoutimpovement = ulAllThreadIDsUnfinished; if (lastTimeMinimized) { adjust_val *= 4; lastTimeMinimized = false; } else lastTimeMinimized = true; lastTimeMaximized = false; } } if (adjust_val != 1) adjust_val /= 2; for (int j = threadFrom; j < threadTo; j++) { BOT_MAIN.curTEXELPARAMS[j] = threadParams[j]; } threadParams = (int[])BOT_MAIN.curTEXELPARAMS.Clone(); bestAvrgCost = CalculateAverageTexelCost(threadDataset, threadParams); } adjust_val = tadjustval; } } } while (adjust_val != 1); BOT_MAIN.TEXELfinishedwithoutimpovement = ULONG_OPERATIONS.SetBitToZero(BOT_MAIN.TEXELfinishedwithoutimpovement, customThreadID); SNAPSHOT_WRITLINE_REPLACEMENT("FULLY FINISHED " + customThreadID + ". IMPROVEMENT THREAD PACKAGE CYCLE"); firstIter = false; } while (BOT_MAIN.TEXELfinishedwithoutimpovement != 0); BOT_MAIN.TEXELfinished++; } private void WriteTexelParamsToTXT(string pPath, int[] pParams) { try { string tS = "PARAMS: {"; for (int i = 0; i < pParams.Length; i++) tS += pParams[i] + ","; tS = tS.Substring(0, tS.Length - 1) + "}\n"; File.AppendAllText(pPath, tS); } catch { SNAPSHOT_WRITLINE_REPLACEMENT("Mal wieder TXT zu lange gebraucht um zu aktualisieren."); } } private double costSum = 0d; private int texelCostMovesEvaluated = 0; private double CalculateAverageTexelCost(List<TLM_ChessGame> tDataset, int[] pParams, bool pFullCost = true) { costSum = 0d; texelCostMovesEvaluated = 0; SetupTexelEvaluationParams(pParams); int tGameDataSetLen = tDataset.Count; int start = 0, end = tGameDataSetLen; if (!pFullCost) { end = (start = globalRandom.Next(0, end - 256)) + 256; } for (int j = start; j < end; j++) { TLM_ChessGame tGame = tDataset[j]; double tGR = tGame.gameResult; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count - 5; texelCostMovesEvaluated += tL; for (int i = 0; i < tL; i++) { costSum += TexelCost(tGR - TexelTuningSigmoid(TexelEvaluate())); PlainMakeMove(tGame.actualMoves[i]); } } return costSum /texelCostMovesEvaluated; } private double CalculateAverageTexelCostThreadedVersionLEGACYDOESNTWORK(List<TLM_ChessGame> tDataset, int[] pParams) { Stopwatch sw = Stopwatch.StartNew(); BOT_MAIN.TEXELcostSum = 0d; BOT_MAIN.TEXELfinished = 0; BOT_MAIN.TEXELcostMovesEvaluated = 0; int tGameDataSetLen = tDataset.Count; int gamesPerThread = tGameDataSetLen /ENGINE_VALS.CPU_CORES; for (int i = 0; i < ENGINE_VALS.CPU_CORES - 1; i++) { } for (int i = 0; i < ENGINE_VALS.CPU_CORES - 1; i++) { } while (BOT_MAIN.TEXELfinished != ENGINE_VALS.CPU_CORES) Thread.Sleep(1); sw.Stop(); return BOT_MAIN.TEXELcostSum /BOT_MAIN.TEXELcostMovesEvaluated; } public void SetPlayThroughVals(List<TLM_ChessGame> pDataset, int pFrom, int pTo) { threadDataset = pDataset; threadFrom = pFrom; threadTo = pTo; } public void SetPlayTexelVals(List<TLM_ChessGame> pDataset, int pFrom, int pTo, int[] pTexelParams, int[] pLowerLimits, int[] pUpperLimits, int pThreadID, ulong pUL) { threadDataset = pDataset; threadFrom = pFrom; threadTo = pTo; threadParams = pTexelParams; paramsLowerLimits = pLowerLimits; paramsUpperLimits = pUpperLimits; customThreadID = pThreadID; ulAllThreadIDsUnfinished = pUL; } public void PlayThroughSetOfGames(object obj) { SNAPSHOT_WRITLINE_REPLACEMENT(threadFrom + "->"+ threadTo); int sortedOut = 0; for (int j = threadFrom; j < threadTo; j++) { TLM_ChessGame tGame = threadDataset[j]; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count; for (int i = 0; i < tL; i++) { int tQuietEval = isWhiteToMove ? QuiescenceWhite(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, 0, PreMinimaxCheckCheckWhite(), NULL_MOVE) : QuiescenceBlack(0, BLACK_CHECKMATE_VAL - 100, WHITE_CHECKMATE_VAL + 100, 0, PreMinimaxCheckCheckBlack(), NULL_MOVE); bool tB; tGame.isMoveNonTactical.Add(tB = (Evaluate() == tQuietEval && i > 4)); if (!tB) sortedOut++; PlainMakeMove(tGame.actualMoves[i]); } } BOT_MAIN.TEXELsortedout += sortedOut; BOT_MAIN.TEXELfinished++; } public void CalculateAverageTexelCostThreadFunction(object obj) { SetupTexelEvaluationParams(threadParams); double d = 0d; for (int j = threadFrom; j < threadTo; j++) { TLM_ChessGame tGame = threadDataset[j]; double tGR = tGame.gameResult; LoadFenString(tGame.startFen); int tL = tGame.actualMoves.Count - 5; BOT_MAIN.TEXELcostMovesEvaluated += tL; for (int i = 0; i < tL; i++) { d += TexelCost(tGR - TexelTuningSigmoid(TexelEvaluate())); PlainMakeMove(tGame.actualMoves[i]); } } BOT_MAIN.TEXELcostSum += d; BOT_MAIN.TEXELfinished++; } private void ConsoleWriteLineTuneArray<T>(T[,][] pArr) { for (int j = 0; j < 3; j++) { SNAPSHOT_WRITLINE_REPLACEMENT("{"); for (int k = 0; k < 6; k++) { SNAPSHOT_WRITLINE_REPLACEMENT("{"); for (int s = 0; s < 64; s++) SNAPSHOT_WRITLINE_REPLACEMENT(pArr[j, k][s] + ", "); SNAPSHOT_WRITLINE_REPLACEMENT("\n}"); } SNAPSHOT_WRITLINE_REPLACEMENT("}"); } } private void Tune(string pGameCGFF, double pLearningRate) { TLM_ChessGame tGame = CGFF.GetGame(pGameCGFF); LoadFenString(tGame.startFen); double tDGameResult = tGame.gameResult; foreach (int hMove in tGame.hashedMoves) { Tune(tDGameResult, pLearningRate); List<Move> moveOptionList = new List<Move>(); GetLegalMoves(ref moveOptionList); int tL = moveOptionList.Count; for (int i = 0; i < tL; i++) { Move tMove = moveOptionList[i]; if (tMove.moveHash == hMove) { PlainMakeMove(tMove); tL = -1; break; } } if (tL != -1) break; } } private void Tune(double pGameResult, double pLearningRate) { int tPC = ULONG_OPERATIONS.CountBits(allPieceBitboard); double oneThroughPieceCount = 1d /tPC; double egMult = earlyGameMultipliers[tPC], mgMult = middleGameMultipliers[tPC], lgMult = lateGameMultipliers[tPC]; double tTexelResult = TexelEvaluateF(); double tSigmoidedTexelResult = TexelSigmoid(tTexelResult); double tDif = tSigmoidedTexelResult - pGameResult; double tM = oneThroughPieceCount * TexelCostDerivative(tDif) * TexelSigmoidDerivative(tTexelResult) * pLearningRate; sumCostVals += lastCostVal = TexelCost(tDif); costCalculations++; for (int i = 0; i < 64; i++) { if (ULONG_OPERATIONS.IsBitZero(allPieceBitboard, i)) continue; int tPT = pieceTypeArray[i] - 1, tI = i; if (ULONG_OPERATIONS.IsBitOne(blackPieceBitboard, i)) tI = blackSidedSquares[i]; texelTuningAdjustIterations[tPT, tI]++; } } private double TexelEvaluateF() { texelTuningRuntimeVals = GetInterpolatedProcessedValues(texelTuningVals); return TexelEvaluate(); } private int TexelEvaluate() { int tEvalEG = 0, tEvalLG = 0, tProgress = 0; for (int p = 0; p < 64; p++) { if (((int)(allPieceBitboard >> p) & 1) == 0) continue; int aPT = pieceTypeArray[p], tPT = aPT + 7 * ((int)(blackPieceBitboard >> p) & 1); tEvalEG += texelTuningRuntimePositionalValsV2EG[tPT][p] + texelPieceEvaluationsV2EG[tPT]; tEvalLG += texelTuningRuntimePositionalValsV2LG[tPT][p] + texelPieceEvaluationsV2LG[tPT]; tProgress += pieceTypeGameProgressImpact[tPT]; } if (tProgress > 24) tProgress = 24; return (int)(earlyGameMultipliers[tProgress] * tEvalEG + lateGameMultipliers[tProgress] * tEvalLG); } private const double TexelK = 0.2; private double TexelTuningSigmoid(double pVal) { return 2d /(1 + Math.Pow(10, -TexelK * pVal /400)); } private double TexelSigmoid(double pVal) { return 2d /(Math.Exp(-0.04d * pVal) + 1d); } private double TexelSigmoidDerivative(double pVal) { double d = Math.Exp(-0.04d * pVal); return 2d * d /(25d * (d + 1d) * (d + 1d)); } private double TexelCost(double pVal) { return pVal * pVal; } private double TexelCostDerivative(double pVal) { return 2 * pVal; } private char[] fenPieces = new char[7] { 'z', 'p', 'n', 'b', 'r', 'q', 'k' }; private string[] squareNames = new string[64] { "a1", "b1", "c1", "d1", "e1", "f1", "g1", "h1", "a2", "b2", "c2", "d2", "e2", "f2", "g2", "h2", "a3", "b3", "c3", "d3", "e3", "f3", "g3", "h3", "a4", "b4", "c4", "d4", "e4", "f4", "g4", "h4", "a5", "b5", "c5", "d5", "e5", "f5", "g5", "h5", "a6", "b6", "c6", "d6", "e6", "f6", "g6", "h6", "a7", "b7", "c7", "d7", "e7", "f7", "g7", "h7", "a8", "b8", "c8", "d8", "e8", "f8", "g8", "h8"}; public string CreateFenString() { string rFEN = ""; for (int i = 7; i >= 0; i--) { int t = 0; for (int j = 0; j < 8; j++) { int sq = i * 8 + j; if (pieceTypeArray[sq] != 0) { if (t != 0) rFEN += t; t = 0; } if (ULONG_OPERATIONS.IsBitOne(whitePieceBitboard, sq)) { switch (pieceTypeArray[sq]) { case 0: t++; SNAPSHOT_WRITLINE_REPLACEMENT("???"); break; case 1: rFEN += 'P'; break; case 2: rFEN += 'N'; break; case 3: rFEN += 'B'; break; case 4: rFEN += 'R'; break; case 5: rFEN += 'Q'; break; case 6: rFEN += 'K'; break; } } else { switch (pieceTypeArray[sq]) { case 0: t++; break; case 1: rFEN += 'p'; break; case 2: rFEN += 'n'; break; case 3: rFEN += 'b'; break; case 4: rFEN += 'r'; break; case 5: rFEN += 'q'; break; case 6: rFEN += 'k'; break; } } } if (t != 0) rFEN += t; if (i != 0) rFEN += "/"; } rFEN += (isWhiteToMove ? " w": " b"); rFEN += (whiteCastleRightKingSide ? " K": " "); rFEN += (whiteCastleRightQueenSide ? "Q": ""); rFEN += (blackCastleRightKingSide ? "k": ""); rFEN += (blackCastleRightQueenSide ? "q": ""); if (!whiteCastleRightKingSide && !whiteCastleRightQueenSide && !blackCastleRightKingSide && !blackCastleRightQueenSide) rFEN += "-"; if (enPassantSquare < 64) rFEN += " "+ squareNames[enPassantSquare] + " "; else rFEN += " - "; return rFEN + fiftyMoveRuleCounter + " "+ ((happenedHalfMoves - happenedHalfMoves % 2) /2); } public void LoadFenString(string fenStr) { debugFEN = fenStr; lastMadeMove = NULL_MOVE; zobristKey = 0ul; whitePieceBitboard = blackPieceBitboard = allPieceBitboard = 0ul; for (int i = 0; i < 64; i++) pieceTypeArray[i] = 0; string[] spaceSpl = fenStr.Split(' '); string[] rowSpl = spaceSpl[0].Split('/'); string epstr = spaceSpl[3]; if (epstr == "-") enPassantSquare = 65; else enPassantSquare = (epstr[0] - 'a') + 8 * (epstr[1] - '1'); isWhiteToMove = true; if (spaceSpl[1] == "b") isWhiteToMove = false; if (!isWhiteToMove) zobristKey ^= blackTurnHash; string crstr = spaceSpl[2]; whiteCastleRightKingSide = whiteCastleRightQueenSide = blackCastleRightKingSide = blackCastleRightQueenSide = false; int crStrL = crstr.Length; for (int i = 0; i < crStrL; i++) { switch (crstr[i]) { case 'K': whiteCastleRightKingSide = true; break; case 'Q': whiteCastleRightQueenSide = true; break; case 'k': blackCastleRightKingSide = true; break; case 'q': blackCastleRightQueenSide = true; break; } } fiftyMoveRuleCounter = Convert.ToInt32(spaceSpl[4]); happenedHalfMoves = Convert.ToInt32(spaceSpl[5]) * 2; if (!isWhiteToMove) happenedHalfMoves++; int tSq = 0; for (int i = rowSpl.Length; i-- > 0;) { string tStr = rowSpl[i]; int tStrLen = tStr.Length; for (int c = 0; c < tStrLen; c++) { char tChar = tStr[c]; if (Char.IsDigit(tChar)) tSq += tChar - '0'; else { bool tCol = Char.IsLower(tChar); if (tCol) blackPieceBitboard = ULONG_OPERATIONS.SetBitToOne(blackPieceBitboard, tSq); else whitePieceBitboard = ULONG_OPERATIONS.SetBitToOne(whitePieceBitboard, tSq); if (tChar == 'k') blackKingSquare = tSq; else if (tChar == 'K') whiteKingSquare = tSq; pieceTypeArray[tSq] = Array.IndexOf(fenPieces, Char.ToLower(tChar)); if (tCol) zobristKey ^= pieceHashesBlack[tSq, pieceTypeArray[tSq]]; else zobristKey ^= pieceHashesWhite[tSq, pieceTypeArray[tSq]]; tSq++; } } } if (whiteCastleRightKingSide) zobristKey ^= whiteKingSideRochadeRightHash; if (whiteCastleRightQueenSide) zobristKey ^= whiteQueenSideRochadeRightHash; if (blackCastleRightKingSide) zobristKey ^= blackKingSideRochadeRightHash; if (blackCastleRightQueenSide) zobristKey ^= blackQueenSideRochadeRightHash; zobristKey ^= enPassantSquareHashes[enPassantSquare]; allPieceBitboard = whitePieceBitboard | blackPieceBitboard; if (zobristKey == 16260251586586513106) moveHashList.Clear(); else { moveHashList.Clear(); moveHashList.Add(1); moveHashList.Add(2); moveHashList.Add(3); } } private ulong[,] pieceHashesWhite = new ulong[64, 7], pieceHashesBlack = new ulong[64, 7]; private ulong blackTurnHash, whiteKingSideRochadeRightHash, whiteQueenSideRochadeRightHash, blackKingSideRochadeRightHash, blackQueenSideRochadeRightHash; private ulong[] enPassantSquareHashes = new ulong[66]; private Dictionary<ulong, int> singleCheckCaseBackup = new Dictionary<ulong, int>(); private void InitZobrist() { Random rng = new Random(31415926); for (int sq = 0; sq < 64; sq++) { enPassantSquareHashes[sq] = ULONG_OPERATIONS.GetRandomULONG(rng); for (int it = 1; it < 7; it++) { pieceHashesWhite[sq, it] = ULONG_OPERATIONS.GetRandomULONG(rng); pieceHashesBlack[sq, it] = ULONG_OPERATIONS.GetRandomULONG(rng); } } blackTurnHash = ULONG_OPERATIONS.GetRandomULONG(rng); whiteKingSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); whiteQueenSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); blackKingSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); blackQueenSideRochadeRightHash = ULONG_OPERATIONS.GetRandomULONG(rng); } public void SetKnightMasks(ulong[] uls) { knightSquareBitboards = uls; } public void SetKingMasks(ulong[] uls) { kingSquareBitboards = uls; } private Move[,] whiteEnPassantMoves = new Move[64, 64]; private Move[,] blackEnPassantMoves = new Move[64, 64]; private bool[] epValidationArray = new bool[64] { false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true , true , true , true , true , true , true , true, true , true , true , true , true , true , true , true, true , true , true , true , true , true , true , true, true , true , true , true , true , true , true , true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false }; private ulong[] kingSafetyRing1 = new ulong[64], kingSafetyRing2 = new ulong[64]; private ulong[] kingSafetySpecialRingW = new ulong[64], kingSafetySpecialRingB = new ulong[64]; private ulong[] rowPrecalcs = new ulong[8], columnPrecalcs = new ulong[8]; const ulong columnUL = 0x101010101010101, rowUL = 0b11111111; private void PrecalculateKingSafetyBitboards() { for (int i = 0; i < 8; i++) { rowPrecalcs[i] = rowUL << (8 * i); columnPrecalcs[i] = columnUL << i; } for (int i = 0; i < 64; i++) { int tMod = i % 8; int tRow = (i - tMod) /8; ulong tULC = columnPrecalcs[tMod], tULR = rowPrecalcs[tRow]; ulong tULC2 = columnPrecalcs[tMod], tULR2 = rowPrecalcs[tRow]; if (tMod < 7) tULC |= columnPrecalcs[tMod + 1]; if (tMod > 0) tULC |= columnPrecalcs[tMod - 1]; if (tRow < 7) tULR |= rowPrecalcs[tRow + 1]; if (tRow > 0) tULR |= rowPrecalcs[tRow - 1]; if (tMod < 6) tULC2 |= columnPrecalcs[tMod + 2]; if (tMod > 1) tULC2 |= columnPrecalcs[tMod - 2]; if (tRow < 6) tULR2 |= rowPrecalcs[tRow + 2]; if (tRow > 1) tULR2 |= rowPrecalcs[tRow - 2]; tULR2 |= tULR; tULC2 |= tULC; kingSafetyRing1[i] = ULONG_OPERATIONS.SetBitToZero(tULR & tULC, i); kingSafetyRing2[i] = ULONG_OPERATIONS.SetBitsToZero(tULR2 & tULC2, i, i + 1, i - 1, i + 7, i + 8, i + 9, i - 7, i - 8, i - 9); } for (int i = 0; i < 64; i++) { if (i < 56) kingSafetySpecialRingW[i] = ULONG_OPERATIONS.SetBitToZero(kingSafetyRing1[i] | kingSafetyRing1[i + 8], i); else kingSafetySpecialRingW[i] = kingSafetyRing1[i]; if (i > 7) kingSafetySpecialRingB[i] = ULONG_OPERATIONS.SetBitToZero(kingSafetyRing1[i] | kingSafetyRing1[i - 8], i); else kingSafetySpecialRingB[i] = kingSafetyRing1[i]; } } private void PrecalculateEnPassantMoves() { for (int i = 0; i < 64; i++) { if (!epValidationArray[i]) continue; for (int j = 0; j < 64; j++) { if (i == j) continue; if (Math.Abs(i - j) > 9) continue; if (!epValidationArray[j]) continue; whiteEnPassantMoves[i, j] = new Move(false, i, j, j - 8); blackEnPassantMoves[i, j] = new Move(false, i, j, j + 8); } } } private void PawnAttackBitboards() { for (int sq = 0; sq < 64; sq++) { ulong u = 0ul; if (sq % 8 != 0) u = ULONG_OPERATIONS.SetBitToOne(u, sq + 7); if (sq % 8 != 7) u = ULONG_OPERATIONS.SetBitToOne(u, sq + 9); whitePawnAttackSquareBitboards[sq] = u; u = 0ul; if (sq % 8 != 0 && sq - 9 > -1) u = ULONG_OPERATIONS.SetBitToOne(u, sq - 9); if (sq % 8 != 7 && sq - 7 > -1) u = ULONG_OPERATIONS.SetBitToOne(u, sq - 7); blackPawnAttackSquareBitboards[sq] = u; } } private int[] squareConnectivesPrecalculationArray = new int[4096]; public int[] squareConnectivesCrossDirsPrecalculationArray { get; set; } = new int[4096]; private ulong[] squareConnectivesPrecalculationRayArray = new ulong[4096]; private ulong[] squareConnectivesPrecalculationLineArray = new ulong[4096]; private List<Dictionary<ulong, int>> rayCollidingSquareCalculations = new List<Dictionary<ulong, int>>(); private readonly int[] maxIntWithSpecifiedBitcount = new int[8] { 0, 0b1, 0b11, 0b111, 0b1111, 0b11111, 0b111111, 0b1111111 }; private List<ulong> differentRays = new List<ulong>(); private void SquareConnectivesPrecalculations() { for (int square = 0; square < 64; square++) { rayCollidingSquareCalculations.Add(new Dictionary<ulong, int>()); rayCollidingSquareCalculations[square].Add(0ul, square); for (int square2 = 0; square2 < 64; square2++) { if (square == square2) continue; int t = 0, t2 = 0, difSign = Math.Sign(square2 - square), itSq = square, g = 0; ulong tRay = 0ul, tExclRay = 0ul; List<int> tRayInts = new List<int>(); if (difSign == -1) g = 7; if (square % 8 == square2 % 8) { t2 = t = 1; while ((itSq += difSign * 8) < 64 && itSq > -1) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } } else if ((square - square % 8) == (square2 - square2 % 8)) { t = 1; t2 = -1; while ((itSq += difSign) % 8 != g && itSq > -1 && itSq < 64) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } } else { int dif = Math.Abs(square2 - square); if (dif % 7 == 0) { t = 2; t2 = 2; g = (difSign == 1) ? 7 : 0; while ((itSq += difSign * 7) % 8 != g && itSq < 64 && itSq > -1) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } if (ULONG_OPERATIONS.IsBitZero(tRay, square2)) { t2 = t = 0; tRay = 0ul; } } else if (dif % 9 == 0) { t = 2; t2 = -2; if (square == 0 && square2 == 63 || square == 63 && square2 == 0) SNAPSHOT_WRITLINE_REPLACEMENT("!"); while ((itSq += difSign * 9) % 8 != g && itSq < 64 && itSq > -1) { tRay = ULONG_OPERATIONS.SetBitToOne(tRay, itSq); tRayInts.Add(itSq); if (itSq == square2) { tExclRay = tRay; } } if (ULONG_OPERATIONS.IsBitZero(tRay, square2)) { t2 = t = 0; tRay = 0ul; } } } if (square == 0 && square2 == 63) { t2 = t = 2; tRayInts.Clear(); tExclRay = tRay = ULONG_OPERATIONS.SetBitsToOne(0ul, 9, 18, 27, 36, 45, 54, 63); tRayInts = new List<int>() { 9, 18, 27, 36, 45, 54, 63 }; } else if (square2 == 0 && square == 63) { t = 2; tRayInts.Clear(); t2 = -2; tExclRay = tRay = ULONG_OPERATIONS.SetBitsToOne(0ul, 0, 9, 18, 27, 36, 45, 54); tRayInts = new List<int>() { 54, 45, 36, 27, 18, 9, 0 }; } if (tRay != 0ul && !differentRays.Contains(tRay)) { differentRays.Add(tRay); int ccount, combI = maxIntWithSpecifiedBitcount[ccount = ULONG_OPERATIONS.CountBits(tRay)]; do { ulong curAllPieceBitboard = 0ul; int solution = square; for (int j = 0; j < ccount; j++) { if (((combI >> j) & 1) == 1) { curAllPieceBitboard = ULONG_OPERATIONS.SetBitToOne(curAllPieceBitboard, tRayInts[j]); if (solution == square) solution = tRayInts[j]; } } rayCollidingSquareCalculations[square].Add(curAllPieceBitboard, solution); } while (--combI != 0); } squareConnectivesPrecalculationArray[square << 6 | square2] = t; squareConnectivesPrecalculationRayArray[square << 6 | square2] = tRay; squareConnectivesCrossDirsPrecalculationArray[square << 6 | square2] = t2; if (t != 0) squareConnectivesPrecalculationLineArray[square << 6 | square2] = (square == 0 && square2 == 63 || square2 == 0 && square == 63) ? tExclRay : ULONG_OPERATIONS.SetBitToOne(tExclRay, square2); if (squareConnectivesPrecalculationLineArray[square << 6 | square2] == 0ul && ULONG_OPERATIONS.IsBitOne(knightSquareBitboards[square], square2)) squareConnectivesPrecalculationLineArray[square << 6 | square2] = 1ul << square2; } differentRays.Clear(); } } public void SNAPSHOT_WRITLINE_REPLACEMENT() { } public void SNAPSHOT_WRITLINE_REPLACEMENT(object pStr) { } private string GetDoublePrecentageString(double pVal) { return ((int)(pVal * 1_000_000) /10_000d) + "%"; } private string ReplaceAllULONGIsBitOne(string pCode) { const string METHOD_NAME = "ULONG_OPERATIONS.IsBitOne"; int METHOD_NAME_LEN = METHOD_NAME.Length, iterations = 0; int pIndex = pCode.IndexOf(METHOD_NAME); while (pIndex != -1 && ++iterations < 10_000) { List<int> paramIndexes = new List<int>(); int openedBracketCount = 1, closedBracketCount = 0, a = METHOD_NAME_LEN + pIndex; string tpCode = pCode.Substring(0, pIndex); paramIndexes.Add(a + 1); while (++a < pCode.Length) { switch (pCode[a]) { case '(': openedBracketCount++; break; case ')': if (++closedBracketCount == openedBracketCount) { pIndex = a; a = int.MaxValue - 5; } break; case ',': if (openedBracketCount - closedBracketCount == 1) paramIndexes.Add(a + 1); break; } } if (openedBracketCount == closedBracketCount && paramIndexes.Count == 2) { tpCode += "((int)("+ pCode.Substring(paramIndexes[0], paramIndexes[1] - paramIndexes[0] - 1) + (pCode[paramIndexes[1]] == ' ' ? " >> (": " >> (") + pCode.Substring(paramIndexes[1], pIndex - paramIndexes[1]) + ")) & 1) == 1"+ pCode.Substring(pIndex + 1, pCode.Length - pIndex - 1); } pIndex = (pCode = tpCode).IndexOf(METHOD_NAME); } SNAPSHOT_WRITLINE_REPLACEMENT(iterations + " ITERATIONS"); return pCode; } private string ReplaceAllULONGIsBitZero(string pCode) { const string METHOD_NAME = "ULONG_OPERATIONS.IsBitZero"; int METHOD_NAME_LEN = METHOD_NAME.Length, iterations = 0; int pIndex = pCode.IndexOf(METHOD_NAME); while (pIndex != -1 && ++iterations < 10_000) { List<int> paramIndexes = new List<int>(); int openedBracketCount = 1, closedBracketCount = 0, a = METHOD_NAME_LEN + pIndex; string tpCode = pCode.Substring(0, pIndex); paramIndexes.Add(a + 1); while (++a < pCode.Length) { switch (pCode[a]) { case '(': openedBracketCount++; break; case ')': if (++closedBracketCount == openedBracketCount) { pIndex = a; a = int.MaxValue - 5; } break; case ',': if (openedBracketCount - closedBracketCount == 1) paramIndexes.Add(a + 1); break; } } if (openedBracketCount == closedBracketCount && paramIndexes.Count == 2) { tpCode += "((int)("+ pCode.Substring(paramIndexes[0], paramIndexes[1] - paramIndexes[0] - 1) + (pCode[paramIndexes[1]] == ' ' ? " >>": " >> ") + pCode.Substring(paramIndexes[1], pIndex - paramIndexes[1]) + ") & 1) == 0"+ pCode.Substring(pIndex + 1, pCode.Length - pIndex - 1); } pIndex = (pCode = tpCode).IndexOf(METHOD_NAME); } SNAPSHOT_WRITLINE_REPLACEMENT(iterations + " ITERATIONS"); return pCode; } private string GetThreeDigitSeperatedInteger(int pInt) { string s = pInt.ToString(), r = s[0].ToString(); int t = s.Length % 3; for (int i = 1; i < s.Length; i++) { if (i % 3 == t) r += "."; r += s[i]; } s = ""; for (int i = 0; i < r.Length; i++) s += r[i]; return s; } public double GetAverageDepth() { return (double)depths /(double)searches; } }
